import { assert, ensure0x, messageId, } from '@hyperlane-xyz/utils';
import { BaseRadixAdapter } from '../../app/MultiProtocolApp.js';
import { ProviderType, } from '../../providers/ProviderType.js';
const MESSAGE_DISPATCH_EVENT_TYPE = 'DispatchEvent';
const MESSAGE_FIELD_KEY = 'message';
const MESSAGE_DESTINATION_FIELD_KEY = 'destination';
export class RadixCoreAdapter extends BaseRadixAdapter {
    chainName;
    multiProvider;
    addresses;
    constructor(chainName, multiProvider, addresses) {
        super(chainName, multiProvider, addresses);
        this.chainName = chainName;
        this.multiProvider = multiProvider;
        this.addresses = addresses;
    }
    extractMessageIds(sourceTx) {
        assert(sourceTx.type === ProviderType.Radix, `Unsupported provider type for RadixCoreAdapter ${sourceTx.type}`);
        const events = sourceTx.receipt.transaction.receipt?.events ?? [];
        if (events.length === 0) {
            return [];
        }
        const dispatchEvents = events.filter((e) => e.name === MESSAGE_DISPATCH_EVENT_TYPE);
        return dispatchEvents.map((event) => {
            const findField = (key) => (event.data?.fields ?? []).find((f) => f.field_name === key);
            const messageField = findField(MESSAGE_FIELD_KEY);
            const destField = findField(MESSAGE_DESTINATION_FIELD_KEY);
            assert(messageField, 'No message field found in dispatch event');
            assert(destField, 'No destination field found in dispatch event');
            return {
                messageId: ensure0x(messageId(ensure0x(messageField.hex))),
                destination: this.multiProvider.getChainName(destField.value),
            };
        });
    }
    async waitForMessageProcessed(messageId, destination, _delayMs, _maxAttempts) {
        const provider = this.multiProvider.getRadixProvider(destination);
        await provider.base.pollForCommit(messageId);
        return true;
    }
}
//# sourceMappingURL=RadixCoreAdapter.js.map