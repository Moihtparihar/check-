import { warpTypes } from '@hyperlane-xyz/cosmos-types';
import { assert, rootLogger } from '@hyperlane-xyz/utils';
import { CosmosNativeHookReader } from '../hook/CosmosNativeHookReader.js';
import { CosmosNativeIsmReader } from '../ism/CosmosNativeIsmReader.js';
import { RemoteRoutersSchema, } from '../router/types.js';
import { TokenType } from './config.js';
export class CosmosNativeWarpRouteReader {
    metadataManager;
    chain;
    cosmosProviderOrSigner;
    logger = rootLogger.child({
        module: 'CosmosNativeWarpRouteReader',
    });
    hookReader;
    ismReader;
    constructor(metadataManager, chain, cosmosProviderOrSigner) {
        this.metadataManager = metadataManager;
        this.chain = chain;
        this.cosmosProviderOrSigner = cosmosProviderOrSigner;
        this.hookReader = new CosmosNativeHookReader(metadataManager, cosmosProviderOrSigner);
        this.ismReader = new CosmosNativeIsmReader(metadataManager, cosmosProviderOrSigner);
    }
    /**
     * Derives the configuration for a Hyperlane ERC20 router contract at the given address.
     *
     * @param warpRouteAddress - The address of the Hyperlane ERC20 router contract.
     * @returns The configuration for the Hyperlane ERC20 router.
     *
     */
    async deriveWarpRouteConfig(warpRouteAddress) {
        // Derive the config type
        const type = await this.deriveTokenType(warpRouteAddress);
        const baseMetadata = await this.fetchMailboxClientConfig(warpRouteAddress);
        const tokenConfig = await this.fetchTokenConfig(type, warpRouteAddress);
        const remoteRouters = await this.fetchRemoteRouters(warpRouteAddress);
        const destinationGas = await this.fetchDestinationGas(warpRouteAddress);
        return {
            ...baseMetadata,
            ...tokenConfig,
            remoteRouters,
            destinationGas,
            type,
        };
    }
    /**
     * Derives the token type for a given Warp Route address using specific methods
     *
     * @param warpRouteAddress - The Warp Route address to derive the token type for.
     * @returns The derived token type, which can be one of: collateralVault, collateral, native, or synthetic.
     */
    async deriveTokenType(warpRouteAddress) {
        const { token } = await this.cosmosProviderOrSigner.query.warp.Token({
            id: warpRouteAddress,
        });
        if (!token) {
            throw new Error(`Failed to find token for address ${warpRouteAddress}`);
        }
        switch (token.token_type) {
            case warpTypes.HypTokenType.HYP_TOKEN_TYPE_COLLATERAL:
                return TokenType.collateral;
            case warpTypes.HypTokenType.HYP_TOKEN_TYPE_SYNTHETIC:
                return TokenType.synthetic;
            default:
                throw new Error(`Failed to determine token type for address ${warpRouteAddress}`);
        }
    }
    /**
     * Fetches the base metadata for a Warp Route contract.
     *
     * @param routerAddress - The address of the Warp Route contract.
     * @returns The base metadata for the Warp Route contract, including the mailbox, owner, hook, and ism.
     */
    async fetchMailboxClientConfig(routerAddress) {
        const { token } = await this.cosmosProviderOrSigner.query.warp.Token({
            id: routerAddress,
        });
        assert(token, `Failed to find token for address ${routerAddress}`);
        const config = {
            mailbox: token.origin_mailbox,
            owner: token.owner,
        };
        if (token.ism_id) {
            const derivedIsm = await this.ismReader.deriveIsmConfig(token.ism_id);
            config.interchainSecurityModule = derivedIsm;
        }
        return config;
    }
    /**
     * Fetches the metadata for a token address.
     *
     * @param warpRouteAddress - The address of the token.
     * @returns A partial ERC20 metadata object containing the token name, symbol, total supply, and decimals.
     * Throws if unsupported token type
     */
    async fetchTokenConfig(type, warpRouteAddress) {
        return {
            type,
            token: warpRouteAddress,
        };
    }
    async fetchRemoteRouters(warpRouteAddress) {
        const { remote_routers } = await this.cosmosProviderOrSigner.query.warp.RemoteRouters({
            id: warpRouteAddress,
        });
        const routers = {};
        for (const router of remote_routers) {
            routers[router.receiver_domain] = {
                address: router.receiver_contract,
            };
        }
        return RemoteRoutersSchema.parse(routers);
    }
    async fetchDestinationGas(warpRouteAddress) {
        const { remote_routers } = await this.cosmosProviderOrSigner.query.warp.RemoteRouters({
            id: warpRouteAddress,
        });
        return Object.fromEntries(remote_routers.map((routerConfig) => [
            routerConfig.receiver_domain,
            routerConfig.gas,
        ]));
    }
}
//# sourceMappingURL=CosmosNativeWarpRouteReader.js.map