import { Address } from '@hyperlane-xyz/utils';
import { ContractVerifier } from '../deploy/verify/ContractVerifier.js';
import { EvmHookReader } from '../hook/EvmHookReader.js';
import { EvmIsmReader } from '../ism/EvmIsmReader.js';
import { MultiProvider } from '../providers/MultiProvider.js';
import { EvmRouterReader } from '../router/EvmRouterReader.js';
import { DestinationGas } from '../router/types.js';
import { ChainName, ChainNameOrId, DeployedOwnableConfig } from '../types.js';
import { TokenType } from './config.js';
import { ContractVerificationStatus, DerivedTokenRouterConfig, HypTokenConfig, HypTokenRouterVirtualConfig, OwnerStatus, TokenMetadata, XERC20TokenMetadata } from './types.js';
export declare class EvmERC20WarpRouteReader extends EvmRouterReader {
    protected readonly multiProvider: MultiProvider;
    protected readonly chain: ChainNameOrId;
    protected readonly concurrency: number;
    protected readonly logger: import("pino").default.Logger<never>;
    protected readonly deriveTokenConfigMap: Record<TokenType, ((address: Address) => Promise<HypTokenConfig>) | null>;
    evmHookReader: EvmHookReader;
    evmIsmReader: EvmIsmReader;
    contractVerifier: ContractVerifier;
    constructor(multiProvider: MultiProvider, chain: ChainNameOrId, concurrency?: number, contractVerifier?: ContractVerifier);
    /**
     * Derives the configuration for a Hyperlane ERC20 router contract at the given address.
     *
     * @param warpRouteAddress - The address of the Hyperlane ERC20 router contract.
     * @returns The configuration for the Hyperlane ERC20 router.
     *
     */
    deriveWarpRouteConfig(warpRouteAddress: Address): Promise<DerivedTokenRouterConfig>;
    getContractVerificationStatus(chain: ChainName, address: Address): Promise<Record<string, ContractVerificationStatus>>;
    getOwnerStatus(chain: ChainName, address: Address): Promise<Record<string, OwnerStatus>>;
    deriveWarpRouteVirtualConfig(chain: ChainName, address: Address): Promise<HypTokenRouterVirtualConfig>;
    /**
     * Derives the token type for a given Warp Route address using specific methods
     *
     * @param warpRouteAddress - The Warp Route address to derive the token type for.
     * @returns The derived token type, which can be one of: collateralVault, collateral, native, or synthetic.
     */
    deriveTokenType(warpRouteAddress: Address): Promise<TokenType>;
    fetchXERC20Config(xERC20Address: Address, warpRouteAddress: Address): Promise<XERC20TokenMetadata>;
    /**
     * Fetches the metadata for a token address.
     *
     * @param warpRouteAddress - The address of the token.
     * @returns A partial ERC20 metadata object containing the token name, symbol, total supply, and decimals.
     * Throws if unsupported token type
     */
    fetchTokenConfig(type: TokenType, warpRouteAddress: Address): Promise<HypTokenConfig>;
    private deriveHypXERC20TokenConfig;
    private deriveHypXERC20LockboxTokenConfig;
    private deriveHypCollateralCctpTokenConfig;
    private deriveHypCollateralTokenConfig;
    private deriveHypCollateralFiatTokenConfig;
    private deriveHypCollateralVaultTokenConfig;
    private deriveHypCollateralVaultRebaseTokenConfig;
    private deriveHypSyntheticTokenConfig;
    private deriveHypNativeTokenConfig;
    private deriveOpL2TokenConfig;
    private deriveOpL1TokenConfig;
    private deriveHypSyntheticRebaseConfig;
    fetchERC20Metadata(tokenAddress: Address): Promise<TokenMetadata>;
    fetchPackageVersion(address: Address): Promise<string>;
    fetchProxyAdminConfig(tokenAddress: Address): Promise<DeployedOwnableConfig>;
    fetchDestinationGas(warpRouteAddress: Address): Promise<DestinationGas>;
}
//# sourceMappingURL=EvmERC20WarpRouteReader.d.ts.map