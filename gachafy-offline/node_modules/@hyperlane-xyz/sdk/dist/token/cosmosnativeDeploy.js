import { ProtocolType, assert, objFilter, objMap, rootLogger, } from '@hyperlane-xyz/utils';
import { TokenType, gasOverhead } from './config.js';
export class CosmosNativeDeployer {
    metadataManager;
    signersMap;
    logger;
    constructor(metadataManager, signersMap) {
        this.metadataManager = metadataManager;
        this.signersMap = signersMap;
        this.logger = rootLogger.child({ module: 'CosmosNativeDeployer' });
    }
    async deploy(configMap) {
        const resolvedConfigMap = objMap(configMap, (_, config) => ({
            gas: gasOverhead(config.type),
            ...config,
        }));
        const result = {};
        const configMapToDeploy = objFilter(resolvedConfigMap, (chain, config) => this.metadataManager.getProtocol(chain) === ProtocolType.CosmosNative &&
            !config.foreignDeployment);
        for (const chain of Object.keys(configMapToDeploy)) {
            assert(this.signersMap[chain], `No signer configured for ${chain}`);
            const config = configMapToDeploy[chain];
            assert(this.signersMap[chain], `No config configured for ${chain}`);
            this.logger.info(`Deploying ${config.type} token to Cosmos Native chain ${chain}`);
            switch (config.type) {
                case TokenType.collateral: {
                    result[chain] = await this.deployCollateralToken(chain, config.mailbox, config.token);
                    break;
                }
                case TokenType.synthetic: {
                    result[chain] = await this.deploySyntheticToken(chain, config.mailbox);
                    break;
                }
                default: {
                    throw new Error(`Token type ${config.type} not supported on chain ${chain}`);
                }
            }
            this.logger.info(`Successfully deployed contracts on ${chain}`);
        }
        return result;
    }
    async deployCollateralToken(chain, originMailbox, originDenom) {
        this.logger.info(`Deploying collateral token to ${chain}`);
        const { response } = await this.signersMap[chain].createCollateralToken({
            origin_mailbox: originMailbox,
            origin_denom: originDenom,
        });
        return response.id;
    }
    async deploySyntheticToken(chain, originMailbox) {
        this.logger.info(`Deploying synthetic token to ${chain}`);
        const { response } = await this.signersMap[chain].createSyntheticToken({
            origin_mailbox: originMailbox,
        });
        return response.id;
    }
}
//# sourceMappingURL=cosmosnativeDeploy.js.map