import { z } from 'zod';
export declare enum RebalancerStrategyOptions {
    Weighted = "weighted",
    MinAmount = "minAmount"
}
export declare const RebalancerWeightedChainConfigSchema: z.ZodObject<{
    weight: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
    tolerance: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
}, "strip", z.ZodTypeAny, {
    weight: bigint;
    tolerance: bigint;
}, {
    weight: string | number;
    tolerance: string | number;
}>;
export declare enum RebalancerMinAmountType {
    Absolute = "absolute",
    Relative = "relative"
}
export declare const RebalancerMinAmountConfigSchema: z.ZodObject<{
    min: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    target: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
    type: z.ZodNativeEnum<typeof RebalancerMinAmountType>;
}, "strip", z.ZodTypeAny, {
    type: RebalancerMinAmountType;
    min: string | number;
    target: string | number;
}, {
    type: RebalancerMinAmountType;
    min: string | number;
    target: string | number;
}>;
export declare const RebalancerBaseChainConfigSchema: z.ZodObject<{
    bridge: z.ZodString;
    bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
    bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
    bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
    override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
        bridge: z.ZodOptional<z.ZodString>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
        bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
        bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
    }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
        bridge: z.ZodOptional<z.ZodString>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
        bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
        bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
    }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
        bridge: z.ZodOptional<z.ZodString>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
        bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
        bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
    }, z.ZodTypeAny, "passthrough">>>>;
}, "strip", z.ZodTypeAny, {
    bridge: string;
    bridgeLockTime: number;
    bridgeMinAcceptedAmount?: string | number | undefined;
    bridgeIsWarp?: boolean | undefined;
    override?: Record<string, z.objectOutputType<{
        bridge: z.ZodOptional<z.ZodString>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
        bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
        bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
    }, z.ZodTypeAny, "passthrough">> | undefined;
}, {
    bridge: string;
    bridgeLockTime: number;
    bridgeMinAcceptedAmount?: string | number | undefined;
    bridgeIsWarp?: boolean | undefined;
    override?: Record<string, z.objectInputType<{
        bridge: z.ZodOptional<z.ZodString>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
        bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
        bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
    }, z.ZodTypeAny, "passthrough">> | undefined;
}>;
declare const WeightedStrategySchema: z.ZodObject<{
    rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.Weighted>;
    chains: z.ZodRecord<z.ZodString, z.ZodObject<{
        bridge: z.ZodString;
        override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">>>>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
        bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
        bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
        weighted: z.ZodObject<{
            weight: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
            tolerance: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
        }, "strip", z.ZodTypeAny, {
            weight: bigint;
            tolerance: bigint;
        }, {
            weight: string | number;
            tolerance: string | number;
        }>;
    }, "strip", z.ZodTypeAny, {
        bridge: string;
        weighted: {
            weight: bigint;
            tolerance: bigint;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }, {
        bridge: string;
        weighted: {
            weight: string | number;
            tolerance: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    chains: Record<string, {
        bridge: string;
        weighted: {
            weight: bigint;
            tolerance: bigint;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.Weighted;
}, {
    chains: Record<string, {
        bridge: string;
        weighted: {
            weight: string | number;
            tolerance: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.Weighted;
}>;
declare const MinAmountStrategySchema: z.ZodObject<{
    rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.MinAmount>;
    chains: z.ZodRecord<z.ZodString, z.ZodObject<{
        bridge: z.ZodString;
        override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">>>>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
        bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
        bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
        minAmount: z.ZodObject<{
            min: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
            target: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
            type: z.ZodNativeEnum<typeof RebalancerMinAmountType>;
        }, "strip", z.ZodTypeAny, {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        }, {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        }>;
    }, "strip", z.ZodTypeAny, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    chains: Record<string, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
}, {
    chains: Record<string, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
}>;
export type WeightedStrategy = z.infer<typeof WeightedStrategySchema>;
export type MinAmountStrategy = z.infer<typeof MinAmountStrategySchema>;
export type WeightedStrategyConfig = WeightedStrategy['chains'];
export type MinAmountStrategyConfig = MinAmountStrategy['chains'];
export declare const StrategyConfigSchema: z.ZodDiscriminatedUnion<"rebalanceStrategy", [z.ZodObject<{
    rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.Weighted>;
    chains: z.ZodRecord<z.ZodString, z.ZodObject<{
        bridge: z.ZodString;
        override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">>>>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
        bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
        bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
        weighted: z.ZodObject<{
            weight: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
            tolerance: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
        }, "strip", z.ZodTypeAny, {
            weight: bigint;
            tolerance: bigint;
        }, {
            weight: string | number;
            tolerance: string | number;
        }>;
    }, "strip", z.ZodTypeAny, {
        bridge: string;
        weighted: {
            weight: bigint;
            tolerance: bigint;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }, {
        bridge: string;
        weighted: {
            weight: string | number;
            tolerance: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    chains: Record<string, {
        bridge: string;
        weighted: {
            weight: bigint;
            tolerance: bigint;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.Weighted;
}, {
    chains: Record<string, {
        bridge: string;
        weighted: {
            weight: string | number;
            tolerance: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.Weighted;
}>, z.ZodObject<{
    rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.MinAmount>;
    chains: z.ZodRecord<z.ZodString, z.ZodObject<{
        bridge: z.ZodString;
        override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">>>>;
        bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
        bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
        bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
        minAmount: z.ZodObject<{
            min: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
            target: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
            type: z.ZodNativeEnum<typeof RebalancerMinAmountType>;
        }, "strip", z.ZodTypeAny, {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        }, {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        }>;
    }, "strip", z.ZodTypeAny, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>>;
}, "strip", z.ZodTypeAny, {
    chains: Record<string, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectOutputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
}, {
    chains: Record<string, {
        bridge: string;
        minAmount: {
            type: RebalancerMinAmountType;
            min: string | number;
            target: string | number;
        };
        bridgeLockTime: number;
        override?: Record<string, z.objectInputType<{
            bridge: z.ZodOptional<z.ZodString>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
            bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
            bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
        }, z.ZodTypeAny, "passthrough">> | undefined;
        bridgeMinAcceptedAmount?: string | number | undefined;
        bridgeIsWarp?: boolean | undefined;
    }>;
    rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
}>]>;
export declare const RebalancerConfigSchema: z.ZodEffects<z.ZodObject<{
    warpRouteId: z.ZodString;
    strategy: z.ZodDiscriminatedUnion<"rebalanceStrategy", [z.ZodObject<{
        rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.Weighted>;
        chains: z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodString;
            override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">>>>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
            bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
            bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
            weighted: z.ZodObject<{
                weight: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
                tolerance: z.ZodEffects<z.ZodUnion<[z.ZodString, z.ZodNumber]>, bigint, string | number>;
            }, "strip", z.ZodTypeAny, {
                weight: bigint;
                tolerance: bigint;
            }, {
                weight: string | number;
                tolerance: string | number;
            }>;
        }, "strip", z.ZodTypeAny, {
            bridge: string;
            weighted: {
                weight: bigint;
                tolerance: bigint;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }, {
            bridge: string;
            weighted: {
                weight: string | number;
                tolerance: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: bigint;
                tolerance: bigint;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    }, {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: string | number;
                tolerance: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    }>, z.ZodObject<{
        rebalanceStrategy: z.ZodLiteral<RebalancerStrategyOptions.MinAmount>;
        chains: z.ZodRecord<z.ZodString, z.ZodObject<{
            bridge: z.ZodString;
            override: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodObject<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, "passthrough", z.ZodTypeAny, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">>>>;
            bridgeMinAcceptedAmount: z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>;
            bridgeLockTime: z.ZodEffects<z.ZodNumber, number, number>;
            bridgeIsWarp: z.ZodOptional<z.ZodBoolean>;
            minAmount: z.ZodObject<{
                min: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
                target: z.ZodUnion<[z.ZodString, z.ZodNumber]>;
                type: z.ZodNativeEnum<typeof RebalancerMinAmountType>;
            }, "strip", z.ZodTypeAny, {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            }, {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            }>;
        }, "strip", z.ZodTypeAny, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>>;
    }, "strip", z.ZodTypeAny, {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    }, {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    }>]>;
}, "strip", z.ZodTypeAny, {
    warpRouteId: string;
    strategy: {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: bigint;
                tolerance: bigint;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    } | {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    };
}, {
    warpRouteId: string;
    strategy: {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: string | number;
                tolerance: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    } | {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    };
}>, {
    warpRouteId: string;
    strategy: {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: bigint;
                tolerance: bigint;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    } | {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectOutputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    };
}, {
    warpRouteId: string;
    strategy: {
        chains: Record<string, {
            bridge: string;
            weighted: {
                weight: string | number;
                tolerance: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.Weighted;
    } | {
        chains: Record<string, {
            bridge: string;
            minAmount: {
                type: RebalancerMinAmountType;
                min: string | number;
                target: string | number;
            };
            bridgeLockTime: number;
            override?: Record<string, z.objectInputType<{
                bridge: z.ZodOptional<z.ZodString>;
                bridgeMinAcceptedAmount: z.ZodOptional<z.ZodOptional<z.ZodUnion<[z.ZodString, z.ZodNumber]>>>;
                bridgeLockTime: z.ZodOptional<z.ZodEffects<z.ZodNumber, number, number>>;
                bridgeIsWarp: z.ZodOptional<z.ZodOptional<z.ZodBoolean>>;
            }, z.ZodTypeAny, "passthrough">> | undefined;
            bridgeMinAcceptedAmount?: string | number | undefined;
            bridgeIsWarp?: boolean | undefined;
        }>;
        rebalanceStrategy: RebalancerStrategyOptions.MinAmount;
    };
}>;
export type RebalancerWeightedChainConfig = z.infer<typeof RebalancerWeightedChainConfigSchema>;
export type RebalancerMinAmountChainConfig = z.infer<typeof RebalancerMinAmountConfigSchema>;
export type StrategyConfig = z.infer<typeof StrategyConfigSchema>;
export type RebalancerConfig = z.infer<typeof RebalancerConfigSchema>;
export type RebalancerConfigFileInput = z.input<typeof RebalancerConfigSchema>;
export {};
//# sourceMappingURL=types.d.ts.map