import { constants } from 'ethers';
import { MailboxClient__factory, Router__factory } from '@hyperlane-xyz/core';
import { eqAddress, rootLogger } from '@hyperlane-xyz/utils';
import { DEFAULT_CONTRACT_READ_CONCURRENCY } from '../consts/concurrency.js';
import { EvmHookReader } from '../hook/EvmHookReader.js';
import { EvmIsmReader } from '../ism/EvmIsmReader.js';
import { HyperlaneReader } from '../utils/HyperlaneReader.js';
import { RemoteRoutersSchema, } from './types.js';
export class EvmRouterReader extends HyperlaneReader {
    concurrency;
    logger = rootLogger.child({ module: 'EvmRouterReader' });
    evmHookReader;
    evmIsmReader;
    constructor(multiProvider, chain, concurrency = DEFAULT_CONTRACT_READ_CONCURRENCY) {
        super(multiProvider, chain);
        this.concurrency = concurrency;
        this.evmHookReader = new EvmHookReader(multiProvider, chain, concurrency);
        this.evmIsmReader = new EvmIsmReader(multiProvider, chain, concurrency);
    }
    async readRouterConfig(address) {
        const mailboxClientConfig = await this.fetchMailboxClientConfig(address);
        const remoteRouters = await this.fetchRemoteRouters(address);
        // proxyAdmin and foreignDeployment are not directly readable from a generic router
        // and depend on deployment context or specific router implementations.
        return {
            ...mailboxClientConfig,
            remoteRouters,
        };
    }
    async fetchMailboxClientConfig(routerAddress) {
        const mailboxClient = MailboxClient__factory.connect(routerAddress, this.provider);
        const [mailbox, owner, hookAddress, ismAddress] = await Promise.all([
            mailboxClient.mailbox(),
            mailboxClient.owner(),
            mailboxClient.hook(),
            mailboxClient.interchainSecurityModule(),
        ]);
        const derivedIsm = eqAddress(ismAddress, constants.AddressZero)
            ? constants.AddressZero
            : await this.evmIsmReader.deriveIsmConfig(ismAddress);
        const derivedHook = eqAddress(hookAddress, constants.AddressZero)
            ? constants.AddressZero
            : await this.evmHookReader.deriveHookConfig(hookAddress);
        return {
            owner,
            mailbox,
            hook: derivedHook,
            interchainSecurityModule: derivedIsm,
        };
    }
    async fetchRemoteRouters(routerAddress) {
        const router = Router__factory.connect(routerAddress, this.provider);
        const domains = await router.domains();
        const routers = Object.fromEntries(await Promise.all(domains.map(async (domain) => {
            return [domain, { address: await router.routers(domain) }];
        })));
        return RemoteRoutersSchema.parse(routers);
    }
}
//# sourceMappingURL=EvmRouterReader.js.map