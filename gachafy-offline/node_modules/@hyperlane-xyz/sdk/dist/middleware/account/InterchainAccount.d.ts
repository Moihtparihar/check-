import { PopulatedTransaction } from 'ethers';
import { z } from 'zod';
import { InterchainAccountRouter } from '@hyperlane-xyz/core';
import { Address, CallData } from '@hyperlane-xyz/utils';
import { HyperlaneAddressesMap, HyperlaneContracts, HyperlaneContractsMap } from '../../contracts/types.js';
import { MultiProvider } from '../../providers/MultiProvider.js';
import { RouterApp } from '../../router/RouterApps.js';
import { ChainMap, ChainName } from '../../types.js';
import { InterchainAccountFactories } from './contracts.js';
import { AccountConfig, GetCallRemoteSettings } from './types.js';
export declare class InterchainAccount extends RouterApp<InterchainAccountFactories> {
    knownAccounts: Record<Address, AccountConfig | undefined>;
    constructor(contractsMap: HyperlaneContractsMap<InterchainAccountFactories>, multiProvider: MultiProvider);
    remoteChains(chainName: string): Promise<ChainName[]>;
    router(contracts: HyperlaneContracts<InterchainAccountFactories>): InterchainAccountRouter;
    static fromAddressesMap(addressesMap: HyperlaneAddressesMap<any>, multiProvider: MultiProvider): InterchainAccount;
    getAccount(destinationChain: ChainName, config: AccountConfig): Promise<Address>;
    deployAccount(destinationChain: ChainName, config: AccountConfig): Promise<Address>;
    protected getOrDeployAccount(deployIfNotExists: boolean, destinationChain: ChainName, config: AccountConfig): Promise<Address>;
    getCallRemote({ chain, destination, innerCalls, config, hookMetadata, }: GetCallRemoteSettings): Promise<PopulatedTransaction>;
    callRemote({ chain, destination, innerCalls, config, hookMetadata, }: GetCallRemoteSettings): Promise<void>;
}
export declare function buildInterchainAccountApp(multiProvider: MultiProvider, chain: ChainName, config: AccountConfig, coreAddressesByChain: ChainMap<Record<string, string>>): Promise<InterchainAccount>;
export declare function deployInterchainAccount(multiProvider: MultiProvider, chain: ChainName, config: AccountConfig, coreAddressesByChain: ChainMap<Record<string, string>>): Promise<Address>;
export declare function encodeIcaCalls(calls: CallData[], salt: string): string;
export type RawCallData = {
    to: string;
    value?: string | number;
    data: string;
};
export declare function normalizeCalls(calls: RawCallData[]): CallData[];
export declare function commitmentFromIcaCalls(calls: CallData[], salt: string): string;
export declare const PostCallsSchema: z.ZodObject<{
    calls: z.ZodArray<z.ZodObject<{
        to: z.ZodString;
        data: z.ZodString;
        value: z.ZodOptional<z.ZodString>;
    }, "strip", z.ZodTypeAny, {
        data: string;
        to: string;
        value?: string | undefined;
    }, {
        data: string;
        to: string;
        value?: string | undefined;
    }>, "many">;
    relayers: z.ZodArray<z.ZodString, "many">;
    salt: z.ZodString;
    commitmentDispatchTx: z.ZodString;
    originDomain: z.ZodNumber;
}, "strip", z.ZodTypeAny, {
    calls: {
        data: string;
        to: string;
        value?: string | undefined;
    }[];
    relayers: string[];
    salt: string;
    commitmentDispatchTx: string;
    originDomain: number;
}, {
    calls: {
        data: string;
        to: string;
        value?: string | undefined;
    }[];
    relayers: string[];
    salt: string;
    commitmentDispatchTx: string;
    originDomain: number;
}>;
export type PostCallsType = z.infer<typeof PostCallsSchema>;
export declare function shareCallsWithPrivateRelayer(serverUrl: string, payload: PostCallsType): Promise<Response>;
//# sourceMappingURL=InterchainAccount.d.ts.map