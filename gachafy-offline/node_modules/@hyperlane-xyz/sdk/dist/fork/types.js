import { z } from 'zod';
import { objMap, objMerge } from '@hyperlane-xyz/utils';
import { ZHash } from '../metadata/customZodTypes.js';
export var EventAssertionType;
(function (EventAssertionType) {
    EventAssertionType["RAW_TOPIC"] = "rawTopic";
    EventAssertionType["TOPIC_SIGNATURE"] = "topicSignature";
})(EventAssertionType || (EventAssertionType = {}));
export const EventAssertionSchema = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(EventAssertionType.RAW_TOPIC),
        topic: ZHash,
        annotation: z.string().optional(),
    }),
    z.object({
        type: z.literal(EventAssertionType.TOPIC_SIGNATURE),
        signature: z.string(),
        args: z.array(z.string()).optional(),
        annotation: z.string().optional(),
    }),
]);
// Additional types can be added based on: https://github.com/ethers-io/ethers.js/blob/v5.7/packages/providers/src.ts/json-rpc-provider.ts#L55
export var RevertAssertionType;
(function (RevertAssertionType) {
    RevertAssertionType["ESTIMATE_GAS"] = "estimateGas";
})(RevertAssertionType || (RevertAssertionType = {}));
export const RevertAssertionSchema = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(RevertAssertionType.ESTIMATE_GAS),
        reason: z.string(),
        annotation: z.string().optional(),
    }),
]);
export var TransactionDataType;
(function (TransactionDataType) {
    TransactionDataType["RAW_CALLDATA"] = "rawCalldata";
    TransactionDataType["SIGNATURE"] = "signature";
})(TransactionDataType || (TransactionDataType = {}));
const TransactionDataSchema = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(TransactionDataType.RAW_CALLDATA),
        calldata: ZHash,
    }),
    z.object({
        type: z.literal(TransactionDataType.SIGNATURE),
        signature: z.string(),
        args: z.array(z.string()).default([]),
    }),
]);
export const ForkedChainTransactionConfigSchema = z.object({
    annotation: z.string().optional(),
    from: ZHash,
    data: TransactionDataSchema.optional(),
    value: z.string().optional(),
    to: ZHash.optional(),
    timeSkip: z.number().optional(),
    eventAssertions: z.array(EventAssertionSchema).default([]),
    revertAssertion: RevertAssertionSchema.optional(),
});
export const ForkedChainConfigSchema = z.object({
    impersonateAccounts: z.array(ZHash).default([]),
    transactions: z.array(ForkedChainTransactionConfigSchema).default([]),
});
export const ForkedChainConfigByChainSchema = z.record(ForkedChainConfigSchema);
export var TransactionConfigType;
(function (TransactionConfigType) {
    TransactionConfigType["RAW_TRANSACTION"] = "rawTransaction";
    TransactionConfigType["FILE"] = "file";
})(TransactionConfigType || (TransactionConfigType = {}));
export const RawForkedChainTransactionConfigSchema = z.discriminatedUnion('type', [
    z.object({
        type: z.literal(TransactionConfigType.RAW_TRANSACTION),
        transactions: z.array(ForkedChainTransactionConfigSchema),
    }),
    z.object({
        type: z.literal(TransactionConfigType.FILE),
        path: z.string(),
        defaultSender: ZHash,
        overrides: z
            .record(ForkedChainTransactionConfigSchema.partial())
            .default({}),
    }),
]);
export const RawForkedChainConfigSchema = z.object({
    impersonateAccounts: z.array(ZHash).default([]),
    transactions: z.array(RawForkedChainTransactionConfigSchema),
});
export const RawForkedChainConfigByChainSchema = z.record(RawForkedChainConfigSchema);
export const SafeTxFileSchema = z.object({
    version: z.string(),
    chainId: z.string(),
    transactions: z.array(ForkedChainTransactionConfigSchema.pick({
        value: true,
        to: true,
    }).extend({
        data: z.string().optional(),
    })),
});
function forkedChainTransactionsFromRaw(raw, fileReader) {
    const formatters = {
        [TransactionConfigType.FILE]: (config) => {
            const safeTxs = SafeTxFileSchema.parse(fileReader(config.path));
            const transactions = safeTxs.transactions.map((safeTx, idx) => {
                const overrides = config.overrides[idx] ?? {};
                const baseTx = {
                    from: config.defaultSender,
                    data: {
                        type: TransactionDataType.RAW_CALLDATA,
                        calldata: safeTx.data ?? '0x',
                    },
                    to: safeTx.to,
                    value: safeTx.value,
                    eventAssertions: [],
                };
                return objMerge(baseTx, overrides);
            });
            return transactions;
        },
        [TransactionConfigType.RAW_TRANSACTION]: (config) => config.transactions,
    };
    const formatter = formatters[raw.type];
    if (!formatter) {
        throw new Error(`Formatter not defined for parsing transaction of type "${raw.type}" for fork config`);
    }
    return formatter(raw);
}
function forkedChainConfigFromRaw(raw, fileReader) {
    const parsedRawConfig = RawForkedChainConfigSchema.parse(raw);
    const transactions = raw.transactions.flatMap((transactions) => forkedChainTransactionsFromRaw(transactions, fileReader));
    const transactionSenders = transactions.map((tx) => tx.from);
    const impersonateAccounts = Array.from(new Set([...transactionSenders, ...parsedRawConfig.impersonateAccounts]));
    const forkedChainConfig = {
        transactions,
        impersonateAccounts,
    };
    return ForkedChainConfigSchema.parse(forkedChainConfig);
}
export function forkedChainConfigByChainFromRaw(raw, fileReader) {
    const forkConfigByChain = objMap(raw, (_chain, config) => forkedChainConfigFromRaw(config, fileReader));
    return ForkedChainConfigByChainSchema.parse(forkConfigByChain);
}
//# sourceMappingURL=types.js.map