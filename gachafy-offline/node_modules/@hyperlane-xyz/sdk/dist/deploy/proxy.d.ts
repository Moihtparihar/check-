import { ethers } from 'ethers';
import { Provider as ZKSyncProvider } from 'zksync-ethers';
import { Address, ChainId } from '@hyperlane-xyz/utils';
import { AnnotatedEV5Transaction } from '../providers/ProviderType.js';
import { DeployedOwnableConfig } from '../types.js';
export type EthersLikeProvider = ethers.providers.Provider | ZKSyncProvider;
export type UpgradeConfig = {
    timelock: {
        delay: number;
        roles: {
            executor: Address;
            proposer: Address;
        };
    };
};
export declare function proxyImplementation(provider: EthersLikeProvider, proxy: Address): Promise<Address>;
export declare function isInitialized(provider: EthersLikeProvider, contract: Address): Promise<boolean>;
export declare function proxyAdmin(provider: EthersLikeProvider, proxy: Address): Promise<Address>;
export declare function proxyConstructorArgs<C extends ethers.Contract>(implementation: C, proxyAdmin: string, initializeArgs?: Parameters<C['initialize']>, initializeFnSignature?: string): [string, string, string];
export declare function isProxy(provider: EthersLikeProvider, proxy: Address): Promise<boolean>;
export declare function proxyAdminUpdateTxs(chainId: ChainId, proxyAddress: Address, actualConfig: Readonly<{
    owner: string;
    proxyAdmin?: DeployedOwnableConfig;
}>, expectedConfig: Readonly<{
    owner: string;
    proxyAdmin?: DeployedOwnableConfig;
}>): AnnotatedEV5Transaction[];
/**
 * Check if contract bytecode matches ProxyAdmin patterns
 * This is more efficient than function calls but less reliable
 * @param provider The provider to use
 * @param address The contract address
 * @returns true if the bytecode suggests it's a ProxyAdmin
 */
export declare function isProxyAdminFromBytecode(provider: EthersLikeProvider, address: Address): Promise<boolean>;
//# sourceMappingURL=proxy.d.ts.map