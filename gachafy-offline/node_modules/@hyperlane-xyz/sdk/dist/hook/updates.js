import { deepCopy, eqAddress } from '@hyperlane-xyz/utils';
import { EvmHookModule } from './EvmHookModule.js';
export async function getEvmHookUpdateTransactions(clientContractAddress, updateHookParams) {
    const { actualConfig: actualHookConfig, evmChainName, mailbox, proxyAdminAddress, expectedConfig, logger, hookAndIsmFactories, multiProvider, ccipContractCache, contractVerifier, } = updateHookParams;
    const hookModule = new EvmHookModule(multiProvider, {
        chain: evmChainName,
        config: actualHookConfig,
        addresses: {
            ...hookAndIsmFactories,
            mailbox,
            proxyAdmin: proxyAdminAddress,
            deployedHook: typeof actualHookConfig === 'string'
                ? actualHookConfig
                : actualHookConfig.address,
        },
    }, ccipContractCache, contractVerifier);
    // Get the current hook address before applying the txs to identify if
    // a new hook was deployed during the update process
    const { deployedHook: currentHookAddress } = hookModule.serialize();
    logger.info(`Comparing target Hook config with current one for ${evmChainName} chain`);
    const updateTransactions = await hookModule.update(deepCopy(expectedConfig));
    const { deployedHook: newHookAddress } = hookModule.serialize();
    // If a new Hook is deployed, push the tx to set the hook on the client contract
    if (!eqAddress(currentHookAddress, newHookAddress)) {
        updateTransactions.push({
            chainId: updateHookParams.multiProvider.getEvmChainId(updateHookParams.evmChainName),
            annotation: `Setting Hook ${newHookAddress} for contract at ${clientContractAddress} on chain ${evmChainName}`,
            to: clientContractAddress,
            data: updateHookParams.setHookFunctionCallEncoder(newHookAddress),
        });
    }
    return updateTransactions;
}
//# sourceMappingURL=updates.js.map