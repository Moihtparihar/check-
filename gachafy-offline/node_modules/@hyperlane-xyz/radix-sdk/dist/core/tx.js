import { assert } from '@hyperlane-xyz/utils';
export class RadixCoreTx {
    account;
    base;
    populate;
    signer;
    constructor(account, base, signer, populate) {
        this.account = account;
        this.base = base;
        this.signer = signer;
        this.populate = populate;
    }
    async transfer({ to_address, resource_address, amount, }) {
        const metadata = await this.base.getMetadata({
            resource: resource_address,
        });
        assert(metadata, `resource with address ${resource_address} does not exist`);
        const transactionManifest = await this.base.transfer({
            from_address: this.account.address,
            to_address,
            resource_address,
            amount,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async createMailbox({ domain_id }) {
        const transactionManifest = await this.populate.createMailbox({
            from_address: this.account.address,
            domain_id,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async createMerkleTreeHook({ mailbox }) {
        const transactionManifest = await this.populate.createMerkleTreeHook({
            from_address: this.account.address,
            mailbox,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async createMerkleRootMultisigIsm({ validators, threshold, }) {
        const transactionManifest = await this.populate.createMerkleRootMultisigIsm({
            from_address: this.account.address,
            validators,
            threshold,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async createMessageIdMultisigIsm({ validators, threshold, }) {
        const transactionManifest = await this.populate.createMessageIdMultisigIsm({
            from_address: this.account.address,
            validators,
            threshold,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async createRoutingIsm({ routes, }) {
        const transactionManifest = await this.populate.createRoutingIsm({
            from_address: this.account.address,
            routes,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async setRoutingIsmOwner({ ism, new_owner, }) {
        const transactionManifest = await this.populate.setRoutingIsmOwner({
            from_address: this.account.address,
            ism,
            new_owner,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async createNoopIsm() {
        const transactionManifest = await this.populate.createNoopIsm({
            from_address: this.account.address,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async createIgp({ denom }) {
        const transactionManifest = await this.populate.createIgp({
            from_address: this.account.address,
            denom,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async setIgpOwner({ igp, new_owner, }) {
        const transactionManifest = await this.populate.setIgpOwner({
            from_address: this.account.address,
            igp,
            new_owner,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async setDestinationGasConfig({ igp, destination_gas_config, }) {
        const transactionManifest = await this.populate.setDestinationGasConfig({
            from_address: this.account.address,
            igp,
            destination_gas_config,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async setMailboxOwner({ mailbox, new_owner, }) {
        const transactionManifest = await this.populate.setMailboxOwner({
            from_address: this.account.address,
            mailbox,
            new_owner,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async createValidatorAnnounce({ mailbox }) {
        const transactionManifest = await this.populate.createValidatorAnnounce({
            from_address: this.account.address,
            mailbox,
        });
        const intentHashTransactionId = await this.signer.signAndBroadcast(transactionManifest);
        return this.base.getNewComponent(intentHashTransactionId);
    }
    async setRequiredHook({ mailbox, hook, }) {
        const transactionManifest = await this.populate.setRequiredHook({
            from_address: this.account.address,
            mailbox,
            hook,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async setDefaultHook({ mailbox, hook, }) {
        const transactionManifest = await this.populate.setDefaultHook({
            from_address: this.account.address,
            mailbox,
            hook,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
    async setDefaultIsm({ mailbox, ism, }) {
        const transactionManifest = await this.populate.setDefaultIsm({
            from_address: this.account.address,
            mailbox,
            ism,
        });
        await this.signer.signAndBroadcast(transactionManifest);
    }
}
//# sourceMappingURL=tx.js.map