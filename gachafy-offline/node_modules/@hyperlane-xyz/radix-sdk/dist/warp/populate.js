import { address, decimal, enumeration, str, u8, u32, } from '@radixdlt/radix-engine-toolkit';
import { BigNumber } from 'bignumber.js';
import { assert, strip0x } from '@hyperlane-xyz/utils';
import { INSTRUCTIONS } from '../utils/types.js';
import { bytes } from '../utils/utils.js';
export class RadixWarpPopulate {
    gateway;
    base;
    query;
    packageAddress;
    constructor(gateway, base, query, packageAddress) {
        this.gateway = gateway;
        this.base = base;
        this.query = query;
        this.packageAddress = packageAddress;
    }
    createCollateralToken({ from_address, mailbox, origin_denom, }) {
        return this.base.createCallFunctionManifest(from_address, this.packageAddress, 'HypToken', INSTRUCTIONS.INSTANTIATE, [enumeration(0, address(origin_denom)), address(mailbox)]);
    }
    createSyntheticToken({ from_address, mailbox, name, symbol, description, divisibility, }) {
        return this.base.createCallFunctionManifest(from_address, this.packageAddress, 'HypToken', INSTRUCTIONS.INSTANTIATE, [
            enumeration(1, str(name), str(symbol), str(description), u8(divisibility)),
            address(mailbox),
        ]);
    }
    async setTokenOwner({ from_address, token, new_owner, }) {
        const details = await this.gateway.state.getEntityDetailsVaultAggregated(token);
        const resource = details.details.role_assignments.owner
            .rule.access_rule.proof_rule.requirement.resource;
        return this.base.transfer({
            from_address,
            to_address: new_owner,
            resource_address: resource,
            amount: '1',
        });
    }
    async setTokenIsm({ from_address, token, ism, }) {
        return this.base.createCallMethodManifestWithOwner(from_address, token, 'set_ism', [enumeration(1, address(ism))]);
    }
    async enrollRemoteRouter({ from_address, token, receiver_domain, receiver_address, gas, }) {
        return this.base.createCallMethodManifestWithOwner(from_address, token, 'enroll_remote_router', [u32(receiver_domain), bytes(strip0x(receiver_address)), decimal(gas)]);
    }
    async unenrollRemoteRouter({ from_address, token, receiver_domain, }) {
        return this.base.createCallMethodManifestWithOwner(from_address, token, 'unroll_remote_router', [u32(receiver_domain)]);
    }
    async remoteTransfer({ from_address, token, destination_domain, recipient, amount, max_fee, }) {
        const { origin_denom, divisibility } = await this.query.getToken({ token });
        const tokenAmount = new BigNumber(amount)
            .dividedBy(new BigNumber(10).pow(divisibility))
            .toFixed(divisibility);
        assert(origin_denom, `no origin_denom found on token ${token}`);
        return `
CALL_METHOD
    Address("${from_address}")
    "withdraw"
    Address("${origin_denom}")
    Decimal("${tokenAmount}")
;
CALL_METHOD
    Address("${from_address}")
    "withdraw"
    Address("${max_fee.denom}")
    Decimal("${max_fee.amount}")
;
TAKE_FROM_WORKTOP
    Address("${origin_denom}")
    Decimal("${tokenAmount}")
    Bucket("bucket1")
;
TAKE_FROM_WORKTOP
    Address("${max_fee.denom}")
    Decimal("${max_fee.amount}")
    Bucket("bucket2")
;
CALL_METHOD
    Address("${token}")
    "transfer_remote"
    ${destination_domain}u32
    Bytes("${recipient}")
    Bucket("bucket1")
    Array<Bucket>(
        Bucket("bucket2")
    )
    Enum<0u8>()
    Enum<0u8>()
;
CALL_METHOD
    Address("${from_address}")
    "try_deposit_batch_or_abort"
    Expression("ENTIRE_WORKTOP")
    Enum<0u8>()
;
`;
    }
}
//# sourceMappingURL=populate.js.map