import { LTSRadixEngineToolkit, ManifestBuilder, PrivateKey, RadixEngineToolkit, address, bucket, decimal, enumeration, expression, generateRandomNonce, } from '@radixdlt/radix-engine-toolkit';
import { BigNumber } from 'bignumber.js';
import { Decimal } from 'decimal.js';
import { utils } from 'ethers';
import { assert, retryAsync } from '@hyperlane-xyz/utils';
import { INSTRUCTIONS } from './types.js';
export class RadixBase {
    networkId;
    gateway;
    gasMultiplier;
    constructor(networkId, gateway, gasMultiplier) {
        this.networkId = networkId;
        this.gateway = gateway;
        this.gasMultiplier = gasMultiplier;
    }
    async getXrdAddress() {
        const knownAddresses = await LTSRadixEngineToolkit.Derive.knownAddresses(this.networkId);
        return knownAddresses.resources.xrdResource;
    }
    async isGatewayHealthy() {
        const status = await this.gateway.status.getCurrent();
        return status.ledger_state.state_version > 0;
    }
    async estimateTransactionFee({ transactionManifest, }) {
        const pk = new PrivateKey.Ed25519(new Uint8Array(utils.randomBytes(32)));
        const constructionMetadata = await this.gateway.transaction.innerClient.transactionConstruction();
        const manifest = typeof transactionManifest === 'string'
            ? transactionManifest
            : (await RadixEngineToolkit.Instructions.convert(transactionManifest.instructions, this.networkId, 'String')).value;
        const response = await this.gateway.transaction.innerClient.transactionPreview({
            transactionPreviewRequest: {
                manifest,
                nonce: generateRandomNonce(),
                signer_public_keys: [
                    {
                        key_type: 'EddsaEd25519',
                        key_hex: pk.publicKeyHex(),
                    },
                ],
                flags: {
                    use_free_credit: true,
                    // we have to enable this flag because the signer of the tx is a random pk
                    // this allows us to simulate txs for different addresses - even if we don't have accesse to their public key
                    assume_all_signature_proofs: true,
                },
                start_epoch_inclusive: constructionMetadata.ledger_state.epoch,
                end_epoch_exclusive: constructionMetadata.ledger_state.epoch + 2,
            },
        });
        assert(!response.receipt.error_message, `${response.receipt.error_message}`);
        const fee_summary = response.receipt.fee_summary;
        const costing_parameters = response.receipt
            .costing_parameters;
        const gasUnits = BigInt(fee_summary.execution_cost_units_consumed) +
            BigInt(fee_summary.finalization_cost_units_consumed);
        const fee = BigInt(new BigNumber(fee_summary.xrd_total_execution_cost)
            .plus(BigNumber(fee_summary.xrd_total_finalization_cost))
            .plus(BigNumber(fee_summary.xrd_total_storage_cost))
            .times(new BigNumber(10).exponentiatedBy(18))
            .toFixed(0));
        const gasPrice = (parseFloat(costing_parameters.execution_cost_unit_price) +
            parseFloat(costing_parameters.finalization_cost_unit_price)) *
            0.5; // average out the cost parameters to get a more accurate estimate
        return {
            gasUnits,
            fee,
            gasPrice,
        };
    }
    async getMetadata({ resource }) {
        const details = await this.gateway.state.getEntityDetailsVaultAggregated(resource);
        const result = {
            name: (details.metadata.items.find((i) => i.key === 'name')?.value
                .typed).value ?? '',
            symbol: (details.metadata.items.find((i) => i.key === 'symbol')?.value
                .typed).value ?? '',
            description: (details.metadata.items.find((i) => i.key === 'description')?.value
                .typed).value ?? '',
            divisibility: details.details.divisibility,
        };
        return result;
    }
    async getXrdMetadata() {
        const xrdAddress = await this.getXrdAddress();
        return this.getMetadata({ resource: xrdAddress });
    }
    async getBalance({ address, resource, }) {
        const details = await this.gateway.state.getEntityDetailsVaultAggregated(address);
        const fungibleResource = details.fungible_resources.items.find((r) => r.resource_address === resource);
        if (!fungibleResource) {
            return BigInt(0);
        }
        if (fungibleResource.vaults.items.length !== 1) {
            return BigInt(0);
        }
        const { divisibility } = await this.getMetadata({ resource });
        return BigInt(new BigNumber(fungibleResource.vaults.items[0].amount)
            .times(new BigNumber(10).exponentiatedBy(divisibility))
            .toFixed(0));
    }
    async getXrdBalance({ address, }) {
        const xrdAddress = await this.getXrdAddress();
        return this.getBalance({ address, resource: xrdAddress });
    }
    async getTotalSupply({ resource, }) {
        const details = await this.gateway.state.getEntityDetailsVaultAggregated(resource);
        const { divisibility } = await this.getMetadata({ resource });
        return BigInt(new BigNumber(details.details.total_supply)
            .times(new BigNumber(10).exponentiatedBy(divisibility))
            .toFixed(0));
    }
    async getXrdTotalSupply() {
        const xrdAddress = await this.getXrdAddress();
        return this.getTotalSupply({ resource: xrdAddress });
    }
    async pollForCommit(intentHashTransactionId) {
        const pollAttempts = 500;
        const pollDelayMs = 10000;
        for (let i = 0; i < pollAttempts; i++) {
            let statusOutput;
            try {
                statusOutput =
                    await this.gateway.transaction.innerClient.transactionStatus({
                        transactionStatusRequest: { intent_hash: intentHashTransactionId },
                    });
            }
            catch {
                await new Promise((resolve) => setTimeout(resolve, pollDelayMs));
                continue;
            }
            switch (statusOutput.intent_status) {
                case 'CommittedSuccess':
                    return;
                case 'CommittedFailure':
                    // You will typically wish to build a new transaction and try again.
                    throw new Error(`Transaction ${intentHashTransactionId} was not committed successfully - instead it resulted in: ${statusOutput.intent_status} with description: ${statusOutput.error_message}`);
                case 'CommitPendingOutcomeUnknown':
                    // We keep polling
                    if (i < pollAttempts) {
                        await new Promise((resolve) => setTimeout(resolve, pollDelayMs));
                    }
                    else {
                        throw new Error(`Transaction ${intentHashTransactionId} was not committed successfully within ${pollAttempts} poll attempts over ${pollAttempts * pollDelayMs}ms - instead it resulted in STATUS: ${statusOutput.intent_status} DESCRIPTION: ${statusOutput.intent_status_description}`);
                    }
            }
        }
    }
    async getNewComponent(transaction) {
        const transactionReceipt = await retryAsync(() => this.gateway.transaction.getCommittedDetails(transaction.id), 5, 5000);
        const receipt = transactionReceipt.transaction.receipt;
        assert(receipt, `found no receipt on transaction: ${transaction.id}`);
        const newGlobalGenericComponent = receipt.state_updates.new_global_entities.find((entity) => entity.entity_type === 'GlobalGenericComponent');
        assert(newGlobalGenericComponent, `found no newly created component on transaction: ${transaction.id}`);
        return newGlobalGenericComponent.entity_address;
    }
    async createCallFunctionManifest(from_address, package_address, blueprint_name, function_name, args) {
        const simulationManifest = new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [decimal(0)])
            .callFunction(package_address, blueprint_name, function_name, args)
            .callMethod(from_address, INSTRUCTIONS.TRY_DEPOSIT_BATCH_OR_ABORT, [
            expression('EntireWorktop'),
            enumeration(0),
        ])
            .build();
        const { fee } = await this.estimateTransactionFee({
            transactionManifest: simulationManifest,
        });
        return new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [
            decimal(new BigNumber(fee.toString())
                .times(this.gasMultiplier)
                .dividedBy(new BigNumber(10).exponentiatedBy(18))
                .toFixed()),
        ])
            .callFunction(package_address, blueprint_name, function_name, args)
            .callMethod(from_address, INSTRUCTIONS.TRY_DEPOSIT_BATCH_OR_ABORT, [
            expression('EntireWorktop'),
            enumeration(0),
        ])
            .build();
    }
    async createCallMethodManifestWithOwner(from_address, contract_address, method_name, args) {
        const details = await this.gateway.state.getEntityDetailsVaultAggregated(contract_address);
        const ownerResource = details.details.role_assignments
            .owner.rule.access_rule.proof_rule.requirement.resource;
        const simulationManifest = new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [decimal(0)])
            .callMethod(from_address, INSTRUCTIONS.CREATE_PROOF_OF_AMOUNT, [
            address(ownerResource),
            decimal(1),
        ])
            .callMethod(contract_address, method_name, args)
            .callMethod(from_address, INSTRUCTIONS.TRY_DEPOSIT_BATCH_OR_ABORT, [
            expression('EntireWorktop'),
            enumeration(0),
        ])
            .build();
        const { fee } = await this.estimateTransactionFee({
            transactionManifest: simulationManifest,
        });
        return new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [
            decimal(new BigNumber(fee.toString())
                .times(this.gasMultiplier)
                .dividedBy(new BigNumber(10).exponentiatedBy(18))
                .toFixed()),
        ])
            .callMethod(from_address, INSTRUCTIONS.CREATE_PROOF_OF_AMOUNT, [
            address(ownerResource),
            decimal(1),
        ])
            .callMethod(contract_address, method_name, args)
            .callMethod(from_address, INSTRUCTIONS.TRY_DEPOSIT_BATCH_OR_ABORT, [
            expression('EntireWorktop'),
            enumeration(0),
        ])
            .build();
    }
    async transfer({ from_address, to_address, resource_address, amount, }) {
        const simulationManifest = new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [decimal(0)])
            .callMethod(from_address, INSTRUCTIONS.WITHDRAW, [
            address(resource_address),
            decimal(amount),
        ])
            .takeFromWorktop(resource_address, new Decimal(amount), (builder, bucketId) => builder.callMethod(to_address, INSTRUCTIONS.TRY_DEPOSIT_OR_ABORT, [
            bucket(bucketId),
            enumeration(0),
        ]))
            .build();
        const { fee } = await this.estimateTransactionFee({
            transactionManifest: simulationManifest,
        });
        return new ManifestBuilder()
            .callMethod(from_address, INSTRUCTIONS.LOCK_FEE, [
            decimal(new BigNumber(fee.toString())
                .times(this.gasMultiplier)
                .dividedBy(new BigNumber(10).exponentiatedBy(18))
                .toFixed()),
        ])
            .callMethod(from_address, INSTRUCTIONS.WITHDRAW, [
            address(resource_address),
            decimal(amount),
        ])
            .takeFromWorktop(resource_address, new Decimal(amount), (builder, bucketId) => builder.callMethod(to_address, INSTRUCTIONS.TRY_DEPOSIT_OR_ABORT, [
            bucket(bucketId),
            enumeration(0),
        ]))
            .build();
    }
}
//# sourceMappingURL=base.js.map