import { RadixEngineToolkit, SimpleTransactionBuilder, TransactionBuilder, generateRandomNonce, } from '@radixdlt/radix-engine-toolkit';
export class RadixSigner {
    networkId;
    gateway;
    base;
    account;
    constructor(networkId, gateway, base, account) {
        this.networkId = networkId;
        this.gateway = gateway;
        this.base = base;
        this.account = account;
    }
    async signAndBroadcast(manifest) {
        // transaction builder from official example:
        // https://github.com/radixdlt/typescript-radix-engine-toolkit?tab=readme-ov-file#constructing-transactions
        const constructionMetadata = await this.gateway.transaction.innerClient.transactionConstruction();
        const transactionHeader = {
            networkId: this.networkId,
            startEpochInclusive: constructionMetadata.ledger_state.epoch,
            endEpochExclusive: constructionMetadata.ledger_state.epoch + 2,
            nonce: generateRandomNonce(),
            notaryPublicKey: this.account.publicKey,
            notaryIsSignatory: true,
            tipPercentage: 0,
        };
        const builder = await TransactionBuilder.new();
        const transaction = await builder
            .header(transactionHeader)
            .manifest(manifest)
            .sign(this.signIntent)
            .notarize(this.notarizeIntent);
        const compiledNotarizedTransaction = await RadixEngineToolkit.NotarizedTransaction.compile(transaction);
        const intentHashTransactionId = await RadixEngineToolkit.NotarizedTransaction.intentHash(transaction);
        await this.gateway.transaction.innerClient.transactionSubmit({
            transactionSubmitRequest: {
                notarized_transaction_hex: Buffer.from(compiledNotarizedTransaction).toString('hex'),
            },
        });
        await this.base.pollForCommit(intentHashTransactionId.id);
        return intentHashTransactionId;
    }
    async getTestnetXrd() {
        const constructionMetadata = await this.gateway.transaction.innerClient.transactionConstruction();
        const freeXrdForAccountTransaction = await SimpleTransactionBuilder.freeXrdFromFaucet({
            networkId: this.networkId,
            toAccount: this.account.address,
            validFromEpoch: constructionMetadata.ledger_state.epoch,
        });
        const intentHashTransactionId = freeXrdForAccountTransaction.transactionId.id;
        await this.gateway.transaction.innerClient.transactionSubmit({
            transactionSubmitRequest: {
                notarized_transaction_hex: freeXrdForAccountTransaction.toHex(),
            },
        });
        await this.base.pollForCommit(intentHashTransactionId);
        return intentHashTransactionId;
    }
    signIntent = (hashToSign) => {
        return this.account.privateKey.signToSignatureWithPublicKey(hashToSign);
    };
    notarizeIntent = (hashToSign) => {
        return this.account.privateKey.signToSignature(hashToSign);
    };
}
//# sourceMappingURL=signer.js.map