import { BigNumber } from 'bignumber.js';
import { ethers } from 'ethers';
/**
 * Convert the given Wei value to Ether value
 * @param value The value to convert.
 * @returns Converted value in string type.
 */
export declare function fromWei(value: BigNumber.Value | null | undefined, decimals?: number): string;
/**
 * Convert the given Wei value to Ether value,
 * round to set number of decimals with a minimum floor, configured per token
 * @param value The value to convert.
 * @param decimals
 * @returns Converted value in string type.
 */
export declare function fromWeiRounded(value: BigNumber.Value | null | undefined, decimals?: number, displayDecimals?: number): string;
/**
 * Convert the given value to Wei value
 * @param value The value to convert.
 * @returns Converted value in string type.
 */
export declare function toWei(value: BigNumber.Value | null | undefined, decimals?: number): string;
/**
 * Try to parse the given value into BigNumber.js BigNumber
 * @param value The value to parse.
 * @returns Parsed value in BigNumber.js BigNumber type.
 */
export declare function tryParseAmount(value: BigNumber.Value | null | undefined): BigNumber | null;
/**
 * Checks if an amount is equal of nearly equal to balance within a small margin of error
 * Necessary because amounts in the UI are often rounded
 * @param amount1 The amount to compare.
 * @param amount2 The amount to compare.
 * @returns true/false.
 */
export declare function eqAmountApproximate(amount1: BigNumber.Value, amount2: BigNumber.Value, maxDifference: BigNumber.Value): boolean;
/**
 * Converts a value with `fromDecimals` decimals to a value with `toDecimals` decimals.
 * Incurs a loss of precision when `fromDecimals` > `toDecimals`.
 * @param fromDecimals The number of decimals `value` has.
 * @param toDecimals The number of decimals to convert `value` to.
 * @param value The value to convert.
 * @returns `value` represented with `toDecimals` decimals in string type.
 */
export declare function convertDecimalsToIntegerString(fromDecimals: number, toDecimals: number, value: BigNumber.Value): string;
export declare function convertDecimals(fromDecimals: number, toDecimals: number, value: BigNumber.Value): BigNumber;
/**
 * Calculates the gas limit with a buffer added to the estimated gas.
 * @param estimatedGas The estimated gas for the transaction.
 * @param bufferPercent The percentage to add as a buffer (default: 10%).
 * @returns The calculated gas limit with the buffer added.
 */
export declare function addBufferToGasLimit(estimatedGas: ethers.BigNumber, bufferPercent?: number): ethers.BigNumber;
/**
 * Calculates the amount from the origin chain scaled to the destination chain
 * This calculation is in line with the FungibleTokenRouter contract _outboundAmount
 * and _inboundAmount functions
 * @param fromScale The origin scale number.
 * @param toScale The destination scale number.
 * @param amount The number to scale.
 * @param precisionFactor  Number used to get accurate conversion for smaller numbers.
 * Take into account the resulting amount will be have this precision factor multiplied into it.
 */
export declare function convertToScaledAmount({ amount, fromScale, toScale, precisionFactor, }: {
    fromScale?: number;
    toScale?: number;
    amount: bigint;
    precisionFactor: number;
}): bigint;
//# sourceMappingURL=amount.d.ts.map