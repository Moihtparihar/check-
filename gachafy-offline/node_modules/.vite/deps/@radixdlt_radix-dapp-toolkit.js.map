{
  "version": 3,
  "sources": ["../../base64-js/index.js", "../../ieee754/index.js", "../../buffer/index.js", "../../blakejs/util.js", "../../blakejs/blake2b.js", "../../blakejs/blake2s.js", "../../blakejs/index.js", "../../base64url/dist/pad-string.js", "../../base64url/dist/base64url.js", "../../base64url/index.js", "../../@radixdlt/radix-dapp-toolkit/dist/index.js", "../../rxjs/src/internal/util/isFunction.ts", "../../rxjs/src/internal/util/createErrorClass.ts", "../../rxjs/src/internal/util/UnsubscriptionError.ts", "../../rxjs/src/internal/util/arrRemove.ts", "../../rxjs/src/internal/Subscription.ts", "../../rxjs/src/internal/config.ts", "../../rxjs/src/internal/scheduler/timeoutProvider.ts", "../../rxjs/src/internal/util/reportUnhandledError.ts", "../../rxjs/src/internal/util/noop.ts", "../../rxjs/src/internal/NotificationFactories.ts", "../../rxjs/src/internal/util/errorContext.ts", "../../rxjs/src/internal/Subscriber.ts", "../../rxjs/src/internal/symbol/observable.ts", "../../rxjs/src/internal/util/identity.ts", "../../rxjs/src/internal/util/pipe.ts", "../../rxjs/src/internal/Observable.ts", "../../rxjs/src/internal/util/lift.ts", "../../rxjs/src/internal/operators/OperatorSubscriber.ts", "../../rxjs/src/internal/operators/refCount.ts", "../../rxjs/src/internal/observable/ConnectableObservable.ts", "../../rxjs/src/internal/scheduler/performanceTimestampProvider.ts", "../../rxjs/src/internal/scheduler/animationFrameProvider.ts", "../../rxjs/src/internal/observable/dom/animationFrames.ts", "../../rxjs/src/internal/util/ObjectUnsubscribedError.ts", "../../rxjs/src/internal/Subject.ts", "../../rxjs/src/internal/BehaviorSubject.ts", "../../rxjs/src/internal/scheduler/dateTimestampProvider.ts", "../../rxjs/src/internal/ReplaySubject.ts", "../../rxjs/src/internal/AsyncSubject.ts", "../../rxjs/src/internal/scheduler/Action.ts", "../../rxjs/src/internal/scheduler/intervalProvider.ts", "../../rxjs/src/internal/scheduler/AsyncAction.ts", "../../rxjs/src/internal/util/Immediate.ts", "../../rxjs/src/internal/scheduler/immediateProvider.ts", "../../rxjs/src/internal/scheduler/AsapAction.ts", "../../rxjs/src/internal/Scheduler.ts", "../../rxjs/src/internal/scheduler/AsyncScheduler.ts", "../../rxjs/src/internal/scheduler/AsapScheduler.ts", "../../rxjs/src/internal/scheduler/asap.ts", "../../rxjs/src/internal/scheduler/async.ts", "../../rxjs/src/internal/scheduler/QueueAction.ts", "../../rxjs/src/internal/scheduler/QueueScheduler.ts", "../../rxjs/src/internal/scheduler/queue.ts", "../../rxjs/src/internal/scheduler/AnimationFrameAction.ts", "../../rxjs/src/internal/scheduler/AnimationFrameScheduler.ts", "../../rxjs/src/internal/scheduler/animationFrame.ts", "../../rxjs/src/internal/scheduler/VirtualTimeScheduler.ts", "../../rxjs/src/internal/observable/empty.ts", "../../rxjs/src/internal/util/isScheduler.ts", "../../rxjs/src/internal/util/args.ts", "../../rxjs/src/internal/util/isArrayLike.ts", "../../rxjs/src/internal/util/isPromise.ts", "../../rxjs/src/internal/util/isInteropObservable.ts", "../../rxjs/src/internal/util/isAsyncIterable.ts", "../../rxjs/src/internal/util/throwUnobservableError.ts", "../../rxjs/src/internal/symbol/iterator.ts", "../../rxjs/src/internal/util/isIterable.ts", "../../rxjs/src/internal/util/isReadableStreamLike.ts", "../../rxjs/src/internal/observable/innerFrom.ts", "../../rxjs/src/internal/util/executeSchedule.ts", "../../rxjs/src/internal/operators/observeOn.ts", "../../rxjs/src/internal/operators/subscribeOn.ts", "../../rxjs/src/internal/scheduled/scheduleObservable.ts", "../../rxjs/src/internal/scheduled/schedulePromise.ts", "../../rxjs/src/internal/scheduled/scheduleArray.ts", "../../rxjs/src/internal/scheduled/scheduleIterable.ts", "../../rxjs/src/internal/scheduled/scheduleAsyncIterable.ts", "../../rxjs/src/internal/scheduled/scheduleReadableStreamLike.ts", "../../rxjs/src/internal/scheduled/scheduled.ts", "../../rxjs/src/internal/observable/from.ts", "../../rxjs/src/internal/observable/of.ts", "../../rxjs/src/internal/observable/throwError.ts", "../../rxjs/src/internal/Notification.ts", "../../rxjs/src/internal/util/EmptyError.ts", "../../rxjs/src/internal/firstValueFrom.ts", "../../rxjs/src/internal/util/ArgumentOutOfRangeError.ts", "../../rxjs/src/internal/util/NotFoundError.ts", "../../rxjs/src/internal/util/SequenceError.ts", "../../rxjs/src/internal/util/isDate.ts", "../../rxjs/src/internal/operators/timeout.ts", "../../rxjs/src/internal/operators/map.ts", "../../rxjs/src/internal/util/mapOneOrManyArgs.ts", "../../rxjs/src/internal/util/argsArgArrayOrObject.ts", "../../rxjs/src/internal/operators/mergeInternals.ts", "../../rxjs/src/internal/operators/mergeMap.ts", "../../rxjs/src/internal/operators/mergeAll.ts", "../../rxjs/src/internal/operators/concatAll.ts", "../../rxjs/src/internal/observable/concat.ts", "../../rxjs/src/internal/observable/fromEvent.ts", "../../rxjs/src/internal/observable/timer.ts", "../../rxjs/src/internal/observable/merge.ts", "../../rxjs/src/internal/observable/never.ts", "../../rxjs/src/internal/util/argsOrArgArray.ts", "../../rxjs/src/internal/operators/filter.ts", "../../rxjs/src/internal/observable/race.ts", "../../rxjs/src/internal/operators/concatMap.ts", "../../rxjs/src/internal/operators/defaultIfEmpty.ts", "../../rxjs/src/internal/operators/take.ts", "../../rxjs/src/internal/operators/ignoreElements.ts", "../../rxjs/src/internal/operators/mapTo.ts", "../../rxjs/src/internal/operators/delayWhen.ts", "../../rxjs/src/internal/operators/delay.ts", "../../rxjs/src/internal/operators/throwIfEmpty.ts", "../../rxjs/src/internal/operators/finalize.ts", "../../rxjs/src/internal/operators/first.ts", "../../rxjs/src/internal/operators/share.ts", "../../rxjs/src/internal/operators/shareReplay.ts", "../../rxjs/src/internal/operators/switchMap.ts", "../../rxjs/src/internal/operators/takeUntil.ts", "../../rxjs/src/internal/operators/tap.ts", "../../@noble/hashes/src/crypto.ts", "../../@noble/hashes/src/utils.ts", "../../@noble/hashes/src/_md.ts", "../../@noble/hashes/src/_u64.ts", "../../@noble/hashes/src/sha2.ts", "../../@noble/curves/src/utils.ts", "../../@noble/curves/src/abstract/modular.ts", "../../@noble/curves/src/abstract/curve.ts", "../../@noble/curves/src/abstract/edwards.ts", "../../@noble/curves/src/abstract/hash-to-curve.ts", "../../@noble/curves/src/abstract/montgomery.ts", "../../@noble/curves/src/ed25519.ts", "../../neverthrow/dist/index.es.js", "../../immer/src/utils/env.ts", "../../immer/src/utils/errors.ts", "../../immer/src/utils/common.ts", "../../immer/src/utils/plugins.ts", "../../immer/src/core/scope.ts", "../../immer/src/core/finalize.ts", "../../immer/src/core/proxy.ts", "../../immer/src/core/immerClass.ts", "../../immer/src/core/current.ts", "../../immer/src/plugins/patches.ts", "../../immer/src/plugins/mapset.ts", "../../immer/src/immer.ts", "../../valibot/dist/index.js", "../../uuid/dist/esm-browser/regex.js", "../../uuid/dist/esm-browser/validate.js", "../../uuid/dist/esm-browser/parse.js", "../../uuid/dist/esm-browser/stringify.js", "../../uuid/dist/esm-browser/rng.js", "../../uuid/dist/esm-browser/v35.js", "../../uuid/dist/esm-browser/md5.js", "../../uuid/dist/esm-browser/v3.js", "../../uuid/dist/esm-browser/native.js", "../../uuid/dist/esm-browser/v4.js", "../../uuid/dist/esm-browser/sha1.js", "../../uuid/dist/esm-browser/v5.js", "../../tslog/dist/esm/prettyLogStyles.js", "../../tslog/dist/esm/formatTemplate.js", "../../tslog/dist/esm/formatNumberAddZeros.js", "../../tslog/dist/esm/urlToObj.js", "../../tslog/dist/esm/runtime/browser/helper.jsonStringifyRecursive.js", "../../tslog/dist/esm/runtime/browser/util.inspect.polyfil.js", "../../tslog/dist/esm/runtime/browser/index.js", "../../tslog/dist/esm/BaseLogger.js", "../../tslog/dist/esm/index.js"],
  "sourcesContent": ["'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n", "/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n", "/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n", "const ERROR_MSG_INPUT = 'Input must be an string, Buffer or Uint8Array'\n\n// For convenience, let people hash a string, not just a Uint8Array\nfunction normalizeInput (input) {\n  let ret\n  if (input instanceof Uint8Array) {\n    ret = input\n  } else if (typeof input === 'string') {\n    const encoder = new TextEncoder()\n    ret = encoder.encode(input)\n  } else {\n    throw new Error(ERROR_MSG_INPUT)\n  }\n  return ret\n}\n\n// Converts a Uint8Array to a hexadecimal string\n// For example, toHex([255, 0, 255]) returns \"ff00ff\"\nfunction toHex (bytes) {\n  return Array.prototype.map\n    .call(bytes, function (n) {\n      return (n < 16 ? '0' : '') + n.toString(16)\n    })\n    .join('')\n}\n\n// Converts any value in [0...2^32-1] to an 8-character hex string\nfunction uint32ToHex (val) {\n  return (0x100000000 + val).toString(16).substring(1)\n}\n\n// For debugging: prints out hash state in the same format as the RFC\n// sample computation exactly, so that you can diff\nfunction debugPrint (label, arr, size) {\n  let msg = '\\n' + label + ' = '\n  for (let i = 0; i < arr.length; i += 2) {\n    if (size === 32) {\n      msg += uint32ToHex(arr[i]).toUpperCase()\n      msg += ' '\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n    } else if (size === 64) {\n      msg += uint32ToHex(arr[i + 1]).toUpperCase()\n      msg += uint32ToHex(arr[i]).toUpperCase()\n    } else throw new Error('Invalid size ' + size)\n    if (i % 6 === 4) {\n      msg += '\\n' + new Array(label.length + 4).join(' ')\n    } else if (i < arr.length - 2) {\n      msg += ' '\n    }\n  }\n  console.log(msg)\n}\n\n// For performance testing: generates N bytes of input, hashes M times\n// Measures and prints MB/second hash performance each time\nfunction testSpeed (hashFn, N, M) {\n  let startMs = new Date().getTime()\n\n  const input = new Uint8Array(N)\n  for (let i = 0; i < N; i++) {\n    input[i] = i % 256\n  }\n  const genMs = new Date().getTime()\n  console.log('Generated random input in ' + (genMs - startMs) + 'ms')\n  startMs = genMs\n\n  for (let i = 0; i < M; i++) {\n    const hashHex = hashFn(input)\n    const hashMs = new Date().getTime()\n    const ms = hashMs - startMs\n    startMs = hashMs\n    console.log('Hashed in ' + ms + 'ms: ' + hashHex.substring(0, 20) + '...')\n    console.log(\n      Math.round((N / (1 << 20) / (ms / 1000)) * 100) / 100 + ' MB PER SECOND'\n    )\n  }\n}\n\nmodule.exports = {\n  normalizeInput: normalizeInput,\n  toHex: toHex,\n  debugPrint: debugPrint,\n  testSpeed: testSpeed\n}\n", "// Blake2B in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nconst util = require('./util')\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += v[b,b+1]\n// v should be a Uint32Array\nfunction ADD64AA (v, a, b) {\n  const o0 = v[a] + v[b]\n  let o1 = v[a + 1] + v[b + 1]\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// 64-bit unsigned addition\n// Sets v[a,a+1] += b\n// b0 is the low 32 bits of b, b1 represents the high 32 bits\nfunction ADD64AC (v, a, b0, b1) {\n  let o0 = v[a] + b0\n  if (b0 < 0) {\n    o0 += 0x100000000\n  }\n  let o1 = v[a + 1] + b1\n  if (o0 >= 0x100000000) {\n    o1++\n  }\n  v[a] = o0\n  v[a + 1] = o1\n}\n\n// Little-endian byte access\nfunction B2B_GET32 (arr, i) {\n  return arr[i] ^ (arr[i + 1] << 8) ^ (arr[i + 2] << 16) ^ (arr[i + 3] << 24)\n}\n\n// G Mixing function\n// The ROTRs are inlined for speed\nfunction B2B_G (a, b, c, d, ix, iy) {\n  const x0 = m[ix]\n  const x1 = m[ix + 1]\n  const y0 = m[iy]\n  const y1 = m[iy + 1]\n\n  ADD64AA(v, a, b) // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s\n  ADD64AC(v, a, x0, x1) // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits\n  let xor0 = v[d] ^ v[a]\n  let xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = xor1\n  v[d + 1] = xor0\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor0 >>> 24) ^ (xor1 << 8)\n  v[b + 1] = (xor1 >>> 24) ^ (xor0 << 8)\n\n  ADD64AA(v, a, b)\n  ADD64AC(v, a, y0, y1)\n\n  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits\n  xor0 = v[d] ^ v[a]\n  xor1 = v[d + 1] ^ v[a + 1]\n  v[d] = (xor0 >>> 16) ^ (xor1 << 16)\n  v[d + 1] = (xor1 >>> 16) ^ (xor0 << 16)\n\n  ADD64AA(v, c, d)\n\n  // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits\n  xor0 = v[b] ^ v[c]\n  xor1 = v[b + 1] ^ v[c + 1]\n  v[b] = (xor1 >>> 31) ^ (xor0 << 1)\n  v[b + 1] = (xor0 >>> 31) ^ (xor1 << 1)\n}\n\n// Initialization Vector\nconst BLAKE2B_IV32 = new Uint32Array([\n  0xf3bcc908, 0x6a09e667, 0x84caa73b, 0xbb67ae85, 0xfe94f82b, 0x3c6ef372,\n  0x5f1d36f1, 0xa54ff53a, 0xade682d1, 0x510e527f, 0x2b3e6c1f, 0x9b05688c,\n  0xfb41bd6b, 0x1f83d9ab, 0x137e2179, 0x5be0cd19\n])\n\nconst SIGMA8 = [\n  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13,\n  6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1,\n  9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4,\n  10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5,\n  15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7,\n  14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2,\n  13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0,\n  1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6,\n  1, 12, 0, 2, 11, 7, 5, 3\n]\n\n// These are offsets into a uint64 buffer.\n// Multiply them all by 2 to make them offsets into a uint32 buffer,\n// because this is Javascript and we don't have uint64s\nconst SIGMA82 = new Uint8Array(\n  SIGMA8.map(function (x) {\n    return x * 2\n  })\n)\n\n// Compression function. 'last' flag indicates last block.\n// Note we're representing 16 uint64s as 32 uint32s\nconst v = new Uint32Array(32)\nconst m = new Uint32Array(32)\nfunction blake2bCompress (ctx, last) {\n  let i = 0\n\n  // init work variables\n  for (i = 0; i < 16; i++) {\n    v[i] = ctx.h[i]\n    v[i + 16] = BLAKE2B_IV32[i]\n  }\n\n  // low 64 bits of offset\n  v[24] = v[24] ^ ctx.t\n  v[25] = v[25] ^ (ctx.t / 0x100000000)\n  // high 64 bits not supported, offset may not be higher than 2**53-1\n\n  // last block flag set ?\n  if (last) {\n    v[28] = ~v[28]\n    v[29] = ~v[29]\n  }\n\n  // get little-endian words\n  for (i = 0; i < 32; i++) {\n    m[i] = B2B_GET32(ctx.b, 4 * i)\n  }\n\n  // twelve rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 64)\n  for (i = 0; i < 12; i++) {\n    // util.debugPrint('   (i=' + (i < 10 ? ' ' : '') + i + ') v[16]', v, 64)\n    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1])\n    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3])\n    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5])\n    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7])\n    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9])\n    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11])\n    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13])\n    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15])\n  }\n  // util.debugPrint('   (i=12) v[16]', v, 64)\n\n  for (i = 0; i < 16; i++) {\n    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16]\n  }\n  // util.debugPrint('h[8]', ctx.h, 64)\n}\n\n// reusable parameterBlock\nconst parameterBlock = new Uint8Array([\n  0,\n  0,\n  0,\n  0, //  0: outlen, keylen, fanout, depth\n  0,\n  0,\n  0,\n  0, //  4: leaf length, sequential mode\n  0,\n  0,\n  0,\n  0, //  8: node offset\n  0,\n  0,\n  0,\n  0, // 12: node offset\n  0,\n  0,\n  0,\n  0, // 16: node depth, inner length, rfu\n  0,\n  0,\n  0,\n  0, // 20: rfu\n  0,\n  0,\n  0,\n  0, // 24: rfu\n  0,\n  0,\n  0,\n  0, // 28: rfu\n  0,\n  0,\n  0,\n  0, // 32: salt\n  0,\n  0,\n  0,\n  0, // 36: salt\n  0,\n  0,\n  0,\n  0, // 40: salt\n  0,\n  0,\n  0,\n  0, // 44: salt\n  0,\n  0,\n  0,\n  0, // 48: personal\n  0,\n  0,\n  0,\n  0, // 52: personal\n  0,\n  0,\n  0,\n  0, // 56: personal\n  0,\n  0,\n  0,\n  0 // 60: personal\n])\n\n// Creates a BLAKE2b hashing context\n// Requires an output length between 1 and 64 bytes\n// Takes an optional Uint8Array key\n// Takes an optinal Uint8Array salt\n// Takes an optinal Uint8Array personal\nfunction blake2bInit (outlen, key, salt, personal) {\n  if (outlen === 0 || outlen > 64) {\n    throw new Error('Illegal output length, expected 0 < length <= 64')\n  }\n  if (key && key.length > 64) {\n    throw new Error('Illegal key, expected Uint8Array with 0 < length <= 64')\n  }\n  if (salt && salt.length !== 16) {\n    throw new Error('Illegal salt, expected Uint8Array with length is 16')\n  }\n  if (personal && personal.length !== 16) {\n    throw new Error('Illegal personal, expected Uint8Array with length is 16')\n  }\n\n  // state, 'param block'\n  const ctx = {\n    b: new Uint8Array(128),\n    h: new Uint32Array(16),\n    t: 0, // input count\n    c: 0, // pointer within buffer\n    outlen: outlen // output length in bytes\n  }\n\n  // initialize parameterBlock before usage\n  parameterBlock.fill(0)\n  parameterBlock[0] = outlen\n  if (key) parameterBlock[1] = key.length\n  parameterBlock[2] = 1 // fanout\n  parameterBlock[3] = 1 // depth\n  if (salt) parameterBlock.set(salt, 32)\n  if (personal) parameterBlock.set(personal, 48)\n\n  // initialize hash state\n  for (let i = 0; i < 16; i++) {\n    ctx.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameterBlock, i * 4)\n  }\n\n  // key the hash, if applicable\n  if (key) {\n    blake2bUpdate(ctx, key)\n    // at the end\n    ctx.c = 128\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2b streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2bUpdate (ctx, input) {\n  for (let i = 0; i < input.length; i++) {\n    if (ctx.c === 128) {\n      // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2bCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2b streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2bFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n\n  while (ctx.c < 128) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2bCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  const out = new Uint8Array(ctx.outlen)\n  for (let i = 0; i < ctx.outlen; i++) {\n    out[i] = ctx.h[i >> 2] >> (8 * (i & 3))\n  }\n  return out\n}\n\n// Computes the BLAKE2B hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n// - salt - optional salt bytes, string, Buffer or Uint8Array\n// - personal - optional personal bytes, string, Buffer or Uint8Array\nfunction blake2b (input, key, outlen, salt, personal) {\n  // preprocess inputs\n  outlen = outlen || 64\n  input = util.normalizeInput(input)\n  if (salt) {\n    salt = util.normalizeInput(salt)\n  }\n  if (personal) {\n    personal = util.normalizeInput(personal)\n  }\n\n  // do the math\n  const ctx = blake2bInit(outlen, key, salt, personal)\n  blake2bUpdate(ctx, input)\n  return blake2bFinal(ctx)\n}\n\n// Computes the BLAKE2B hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 64 bytes\n// - outlen - optional output length in bytes, default 64\n// - salt - optional salt bytes, string, Buffer or Uint8Array\n// - personal - optional personal bytes, string, Buffer or Uint8Array\nfunction blake2bHex (input, key, outlen, salt, personal) {\n  const output = blake2b(input, key, outlen, salt, personal)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2b: blake2b,\n  blake2bHex: blake2bHex,\n  blake2bInit: blake2bInit,\n  blake2bUpdate: blake2bUpdate,\n  blake2bFinal: blake2bFinal\n}\n", "// BLAKE2s hash function in pure Javascript\n// Adapted from the reference implementation in RFC7693\n// Ported to Javascript by DC - https://github.com/dcposch\n\nconst util = require('./util')\n\n// Little-endian byte access.\n// Expects a Uint8Array and an index\n// Returns the little-endian uint32 at v[i..i+3]\nfunction B2S_GET32 (v, i) {\n  return v[i] ^ (v[i + 1] << 8) ^ (v[i + 2] << 16) ^ (v[i + 3] << 24)\n}\n\n// Mixing function G.\nfunction B2S_G (a, b, c, d, x, y) {\n  v[a] = v[a] + v[b] + x\n  v[d] = ROTR32(v[d] ^ v[a], 16)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 12)\n  v[a] = v[a] + v[b] + y\n  v[d] = ROTR32(v[d] ^ v[a], 8)\n  v[c] = v[c] + v[d]\n  v[b] = ROTR32(v[b] ^ v[c], 7)\n}\n\n// 32-bit right rotation\n// x should be a uint32\n// y must be between 1 and 31, inclusive\nfunction ROTR32 (x, y) {\n  return (x >>> y) ^ (x << (32 - y))\n}\n\n// Initialization Vector.\nconst BLAKE2S_IV = new Uint32Array([\n  0x6a09e667,\n  0xbb67ae85,\n  0x3c6ef372,\n  0xa54ff53a,\n  0x510e527f,\n  0x9b05688c,\n  0x1f83d9ab,\n  0x5be0cd19\n])\n\nconst SIGMA = new Uint8Array([\n  0,\n  1,\n  2,\n  3,\n  4,\n  5,\n  6,\n  7,\n  8,\n  9,\n  10,\n  11,\n  12,\n  13,\n  14,\n  15,\n  14,\n  10,\n  4,\n  8,\n  9,\n  15,\n  13,\n  6,\n  1,\n  12,\n  0,\n  2,\n  11,\n  7,\n  5,\n  3,\n  11,\n  8,\n  12,\n  0,\n  5,\n  2,\n  15,\n  13,\n  10,\n  14,\n  3,\n  6,\n  7,\n  1,\n  9,\n  4,\n  7,\n  9,\n  3,\n  1,\n  13,\n  12,\n  11,\n  14,\n  2,\n  6,\n  5,\n  10,\n  4,\n  0,\n  15,\n  8,\n  9,\n  0,\n  5,\n  7,\n  2,\n  4,\n  10,\n  15,\n  14,\n  1,\n  11,\n  12,\n  6,\n  8,\n  3,\n  13,\n  2,\n  12,\n  6,\n  10,\n  0,\n  11,\n  8,\n  3,\n  4,\n  13,\n  7,\n  5,\n  15,\n  14,\n  1,\n  9,\n  12,\n  5,\n  1,\n  15,\n  14,\n  13,\n  4,\n  10,\n  0,\n  7,\n  6,\n  3,\n  9,\n  2,\n  8,\n  11,\n  13,\n  11,\n  7,\n  14,\n  12,\n  1,\n  3,\n  9,\n  5,\n  0,\n  15,\n  4,\n  8,\n  6,\n  2,\n  10,\n  6,\n  15,\n  14,\n  9,\n  11,\n  3,\n  0,\n  8,\n  12,\n  2,\n  13,\n  7,\n  1,\n  4,\n  10,\n  5,\n  10,\n  2,\n  8,\n  4,\n  7,\n  6,\n  1,\n  5,\n  15,\n  11,\n  9,\n  14,\n  3,\n  12,\n  13,\n  0\n])\n\n// Compression function. \"last\" flag indicates last block\nconst v = new Uint32Array(16)\nconst m = new Uint32Array(16)\nfunction blake2sCompress (ctx, last) {\n  let i = 0\n  for (i = 0; i < 8; i++) {\n    // init work variables\n    v[i] = ctx.h[i]\n    v[i + 8] = BLAKE2S_IV[i]\n  }\n\n  v[12] ^= ctx.t // low 32 bits of offset\n  v[13] ^= ctx.t / 0x100000000 // high 32 bits\n  if (last) {\n    // last block flag set ?\n    v[14] = ~v[14]\n  }\n\n  for (i = 0; i < 16; i++) {\n    // get little-endian words\n    m[i] = B2S_GET32(ctx.b, 4 * i)\n  }\n\n  // ten rounds of mixing\n  // uncomment the DebugPrint calls to log the computation\n  // and match the RFC sample documentation\n  // util.debugPrint('          m[16]', m, 32)\n  for (i = 0; i < 10; i++) {\n    // util.debugPrint('   (i=' + i + ')  v[16]', v, 32)\n    B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]])\n    B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]])\n    B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]])\n    B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]])\n    B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]])\n    B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]])\n    B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]])\n    B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]])\n  }\n  // util.debugPrint('   (i=10) v[16]', v, 32)\n\n  for (i = 0; i < 8; i++) {\n    ctx.h[i] ^= v[i] ^ v[i + 8]\n  }\n  // util.debugPrint('h[8]', ctx.h, 32)\n}\n\n// Creates a BLAKE2s hashing context\n// Requires an output length between 1 and 32 bytes\n// Takes an optional Uint8Array key\nfunction blake2sInit (outlen, key) {\n  if (!(outlen > 0 && outlen <= 32)) {\n    throw new Error('Incorrect output length, should be in [1, 32]')\n  }\n  const keylen = key ? key.length : 0\n  if (key && !(keylen > 0 && keylen <= 32)) {\n    throw new Error('Incorrect key length, should be in [1, 32]')\n  }\n\n  const ctx = {\n    h: new Uint32Array(BLAKE2S_IV), // hash state\n    b: new Uint8Array(64), // input block\n    c: 0, // pointer within block\n    t: 0, // input count\n    outlen: outlen // output length in bytes\n  }\n  ctx.h[0] ^= 0x01010000 ^ (keylen << 8) ^ outlen\n\n  if (keylen > 0) {\n    blake2sUpdate(ctx, key)\n    ctx.c = 64 // at the end\n  }\n\n  return ctx\n}\n\n// Updates a BLAKE2s streaming hash\n// Requires hash context and Uint8Array (byte array)\nfunction blake2sUpdate (ctx, input) {\n  for (let i = 0; i < input.length; i++) {\n    if (ctx.c === 64) {\n      // buffer full ?\n      ctx.t += ctx.c // add counters\n      blake2sCompress(ctx, false) // compress (not last)\n      ctx.c = 0 // counter to zero\n    }\n    ctx.b[ctx.c++] = input[i]\n  }\n}\n\n// Completes a BLAKE2s streaming hash\n// Returns a Uint8Array containing the message digest\nfunction blake2sFinal (ctx) {\n  ctx.t += ctx.c // mark last block offset\n  while (ctx.c < 64) {\n    // fill up with zeros\n    ctx.b[ctx.c++] = 0\n  }\n  blake2sCompress(ctx, true) // final block flag = 1\n\n  // little endian convert and store\n  const out = new Uint8Array(ctx.outlen)\n  for (let i = 0; i < ctx.outlen; i++) {\n    out[i] = (ctx.h[i >> 2] >> (8 * (i & 3))) & 0xff\n  }\n  return out\n}\n\n// Computes the BLAKE2S hash of a string or byte array, and returns a Uint8Array\n//\n// Returns a n-byte Uint8Array\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2s (input, key, outlen) {\n  // preprocess inputs\n  outlen = outlen || 32\n  input = util.normalizeInput(input)\n\n  // do the math\n  const ctx = blake2sInit(outlen, key)\n  blake2sUpdate(ctx, input)\n  return blake2sFinal(ctx)\n}\n\n// Computes the BLAKE2S hash of a string or byte array\n//\n// Returns an n-byte hash in hex, all lowercase\n//\n// Parameters:\n// - input - the input bytes, as a string, Buffer, or Uint8Array\n// - key - optional key Uint8Array, up to 32 bytes\n// - outlen - optional output length in bytes, default 64\nfunction blake2sHex (input, key, outlen) {\n  const output = blake2s(input, key, outlen)\n  return util.toHex(output)\n}\n\nmodule.exports = {\n  blake2s: blake2s,\n  blake2sHex: blake2sHex,\n  blake2sInit: blake2sInit,\n  blake2sUpdate: blake2sUpdate,\n  blake2sFinal: blake2sFinal\n}\n", "const b2b = require('./blake2b')\nconst b2s = require('./blake2s')\n\nmodule.exports = {\n  blake2b: b2b.blake2b,\n  blake2bHex: b2b.blake2bHex,\n  blake2bInit: b2b.blake2bInit,\n  blake2bUpdate: b2b.blake2bUpdate,\n  blake2bFinal: b2b.blake2bFinal,\n  blake2s: b2s.blake2s,\n  blake2sHex: b2s.blake2sHex,\n  blake2sInit: b2s.blake2sInit,\n  blake2sUpdate: b2s.blake2sUpdate,\n  blake2sFinal: b2s.blake2sFinal\n}\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction padString(input) {\n    var segmentLength = 4;\n    var stringLength = input.length;\n    var diff = stringLength % segmentLength;\n    if (!diff) {\n        return input;\n    }\n    var position = stringLength;\n    var padLength = segmentLength - diff;\n    var paddedStringLength = stringLength + padLength;\n    var buffer = Buffer.alloc(paddedStringLength);\n    buffer.write(input);\n    while (padLength--) {\n        buffer.write(\"=\", position++);\n    }\n    return buffer.toString();\n}\nexports.default = padString;\n", "\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar pad_string_1 = require(\"./pad-string\");\nfunction encode(input, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    if (Buffer.isBuffer(input)) {\n        return fromBase64(input.toString(\"base64\"));\n    }\n    return fromBase64(Buffer.from(input, encoding).toString(\"base64\"));\n}\n;\nfunction decode(base64url, encoding) {\n    if (encoding === void 0) { encoding = \"utf8\"; }\n    return Buffer.from(toBase64(base64url), \"base64\").toString(encoding);\n}\nfunction toBase64(base64url) {\n    base64url = base64url.toString();\n    return pad_string_1.default(base64url)\n        .replace(/\\-/g, \"+\")\n        .replace(/_/g, \"/\");\n}\nfunction fromBase64(base64) {\n    return base64\n        .replace(/=/g, \"\")\n        .replace(/\\+/g, \"-\")\n        .replace(/\\//g, \"_\");\n}\nfunction toBuffer(base64url) {\n    return Buffer.from(toBase64(base64url), \"base64\");\n}\nvar base64url = encode;\nbase64url.encode = encode;\nbase64url.decode = decode;\nbase64url.toBase64 = toBase64;\nbase64url.fromBase64 = fromBase64;\nbase64url.toBuffer = toBuffer;\nexports.default = base64url;\n", "module.exports = require('./dist/base64url').default;\nmodule.exports.default = module.exports;\n", "// src/polyfills.ts\nimport { Buffer as Buffer2 } from \"buffer\";\nvar polyfills_default = () => {\n  if (!globalThis.Buffer) globalThis.Buffer = Buffer2;\n};\n\n// src/modules/connect-button/connect-button.module.ts\nimport {\n  concatMap,\n  delay,\n  filter as filter7,\n  finalize,\n  first as first3,\n  fromEvent,\n  map as map6,\n  merge as merge3,\n  mergeMap as mergeMap2,\n  of as of3,\n  Subscription as Subscription7,\n  switchMap as switchMap6,\n  tap as tap4\n} from \"rxjs\";\n\n// src/modules/connect-button/subjects.ts\nimport { BehaviorSubject, ReplaySubject, Subject } from \"rxjs\";\nvar ConnectButtonSubjects = (input) => ({\n  onConnect: new Subject(),\n  onDisconnect: new Subject(),\n  onUpdateSharedAccounts: new Subject(),\n  connected: new ReplaySubject(1),\n  requestItems: new BehaviorSubject([]),\n  onCancelRequestItem: new Subject(),\n  onIgnoreTransactionItem: new Subject(),\n  accounts: new BehaviorSubject([]),\n  onShowPopover: new Subject(),\n  status: new BehaviorSubject(\"default\"),\n  loggedInTimestamp: new BehaviorSubject(\"\"),\n  isMobile: new BehaviorSubject(input.providers.environmentModule.isMobile()),\n  isWalletLinked: new BehaviorSubject(false),\n  showPopoverMenu: new BehaviorSubject(false),\n  isExtensionAvailable: new BehaviorSubject(false),\n  fullWidth: new BehaviorSubject(false),\n  activeTab: new BehaviorSubject(\"sharing\"),\n  mode: new BehaviorSubject(\"light\"),\n  theme: new BehaviorSubject(\"radix-blue\"),\n  avatarUrl: new BehaviorSubject(\"\"),\n  personaLabel: new BehaviorSubject(\"\"),\n  personaData: new BehaviorSubject([]),\n  dAppName: new BehaviorSubject(\"\"),\n  onLinkClick: new Subject()\n});\n\n// src/modules/wallet-request/crypto/curve25519.ts\nimport { x25519, ed25519 } from \"@noble/curves/ed25519\";\nimport { Buffer as Buffer3 } from \"buffer\";\nimport { err, ok } from \"neverthrow\";\n\n// ../../node_modules/@noble/hashes/esm/_assert.js\nfunction number(n) {\n  if (!Number.isSafeInteger(n) || n < 0)\n    throw new Error(`positive integer expected, not ${n}`);\n}\nfunction isBytes(a) {\n  return a instanceof Uint8Array || a != null && typeof a === \"object\" && a.constructor.name === \"Uint8Array\";\n}\nfunction bytes(b, ...lengths) {\n  if (!isBytes(b))\n    throw new Error(\"Uint8Array expected\");\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);\n}\nfunction hash(h) {\n  if (typeof h !== \"function\" || typeof h.create !== \"function\")\n    throw new Error(\"Hash should be wrapped by utils.wrapConstructor\");\n  number(h.outputLen);\n  number(h.blockLen);\n}\nfunction exists(instance, checkFinished = true) {\n  if (instance.destroyed)\n    throw new Error(\"Hash instance has been destroyed\");\n  if (checkFinished && instance.finished)\n    throw new Error(\"Hash#digest() has already been called\");\n}\nfunction output(out, instance) {\n  bytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error(`digestInto() expects output buffer of length at least ${min}`);\n  }\n}\n\n// ../../node_modules/@noble/hashes/esm/utils.js\nvar createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\nvar rotr = (word, shift) => word << 32 - shift | word >>> shift;\nvar isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;\nfunction utf8ToBytes(str) {\n  if (typeof str !== \"string\")\n    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);\n  return new Uint8Array(new TextEncoder().encode(str));\n}\nfunction toBytes(data) {\n  if (typeof data === \"string\")\n    data = utf8ToBytes(data);\n  bytes(data);\n  return data;\n}\nvar Hash = class {\n  // Safe version that clones internal state\n  clone() {\n    return this._cloneInto();\n  }\n};\nvar toStr = {}.toString;\nfunction wrapConstructor(hashCons) {\n  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\n// ../../node_modules/@noble/hashes/esm/hmac.js\nvar HMAC = class extends Hash {\n  constructor(hash2, _key) {\n    super();\n    this.finished = false;\n    this.destroyed = false;\n    hash(hash2);\n    const key = toBytes(_key);\n    this.iHash = hash2.create();\n    if (typeof this.iHash.update !== \"function\")\n      throw new Error(\"Expected instance of class which extends utils.Hash\");\n    this.blockLen = this.iHash.blockLen;\n    this.outputLen = this.iHash.outputLen;\n    const blockLen = this.blockLen;\n    const pad = new Uint8Array(blockLen);\n    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);\n    for (let i = 0; i < pad.length; i++)\n      pad[i] ^= 54;\n    this.iHash.update(pad);\n    this.oHash = hash2.create();\n    for (let i = 0; i < pad.length; i++)\n      pad[i] ^= 54 ^ 92;\n    this.oHash.update(pad);\n    pad.fill(0);\n  }\n  update(buf) {\n    exists(this);\n    this.iHash.update(buf);\n    return this;\n  }\n  digestInto(out) {\n    exists(this);\n    bytes(out, this.outputLen);\n    this.finished = true;\n    this.iHash.digestInto(out);\n    this.oHash.update(out);\n    this.oHash.digestInto(out);\n    this.destroy();\n  }\n  digest() {\n    const out = new Uint8Array(this.oHash.outputLen);\n    this.digestInto(out);\n    return out;\n  }\n  _cloneInto(to) {\n    to || (to = Object.create(Object.getPrototypeOf(this), {}));\n    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;\n    to = to;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    to.blockLen = blockLen;\n    to.outputLen = outputLen;\n    to.oHash = oHash._cloneInto(to.oHash);\n    to.iHash = iHash._cloneInto(to.iHash);\n    return to;\n  }\n  destroy() {\n    this.destroyed = true;\n    this.oHash.destroy();\n    this.iHash.destroy();\n  }\n};\nvar hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();\nhmac.create = (hash2, key) => new HMAC(hash2, key);\n\n// ../../node_modules/@noble/hashes/esm/hkdf.js\nfunction extract(hash2, ikm, salt) {\n  hash(hash2);\n  if (salt === void 0)\n    salt = new Uint8Array(hash2.outputLen);\n  return hmac(hash2, toBytes(salt), toBytes(ikm));\n}\nvar HKDF_COUNTER = /* @__PURE__ */ new Uint8Array([0]);\nvar EMPTY_BUFFER = /* @__PURE__ */ new Uint8Array();\nfunction expand(hash2, prk, info, length = 32) {\n  hash(hash2);\n  number(length);\n  if (length > 255 * hash2.outputLen)\n    throw new Error(\"Length should be <= 255*HashLen\");\n  const blocks = Math.ceil(length / hash2.outputLen);\n  if (info === void 0)\n    info = EMPTY_BUFFER;\n  const okm = new Uint8Array(blocks * hash2.outputLen);\n  const HMAC2 = hmac.create(hash2, prk);\n  const HMACTmp = HMAC2._cloneInto();\n  const T = new Uint8Array(HMAC2.outputLen);\n  for (let counter = 0; counter < blocks; counter++) {\n    HKDF_COUNTER[0] = counter + 1;\n    HMACTmp.update(counter === 0 ? EMPTY_BUFFER : T).update(info).update(HKDF_COUNTER).digestInto(T);\n    okm.set(T, hash2.outputLen * counter);\n    HMAC2._cloneInto(HMACTmp);\n  }\n  HMAC2.destroy();\n  HMACTmp.destroy();\n  T.fill(0);\n  HKDF_COUNTER.fill(0);\n  return okm.slice(0, length);\n}\nvar hkdf = (hash2, ikm, salt, info, length) => expand(hash2, extract(hash2, ikm, salt), info, length);\n\n// ../../node_modules/@noble/hashes/esm/_md.js\nfunction setBigUint64(view, byteOffset, value, isLE2) {\n  if (typeof view.setBigUint64 === \"function\")\n    return view.setBigUint64(byteOffset, value, isLE2);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(4294967295);\n  const wh = Number(value >> _32n & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE2 ? 4 : 0;\n  const l = isLE2 ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE2);\n  view.setUint32(byteOffset + l, wl, isLE2);\n}\nvar Chi = (a, b, c) => a & b ^ ~a & c;\nvar Maj = (a, b, c) => a & b ^ a & c ^ b & c;\nvar HashMD = class extends Hash {\n  constructor(blockLen, outputLen, padOffset, isLE2) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE2;\n    this.finished = false;\n    this.length = 0;\n    this.pos = 0;\n    this.destroyed = false;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data) {\n    exists(this);\n    const { view, buffer, blockLen } = this;\n    data = toBytes(data);\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen)\n          this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out) {\n    exists(this);\n    output(out, this);\n    this.finished = true;\n    const { buffer, view, blockLen, isLE: isLE2 } = this;\n    let { pos } = this;\n    buffer[pos++] = 128;\n    this.buffer.subarray(pos).fill(0);\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    for (let i = pos; i < blockLen; i++)\n      buffer[i] = 0;\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    if (len % 4)\n      throw new Error(\"_sha2: outputLen should be aligned to 32bit\");\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length)\n      throw new Error(\"_sha2: outputLen bigger than state\");\n    for (let i = 0; i < outLen; i++)\n      oview.setUint32(4 * i, state[i], isLE2);\n  }\n  digest() {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to) {\n    to || (to = new this.constructor());\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.length = length;\n    to.pos = pos;\n    to.finished = finished;\n    to.destroyed = destroyed;\n    if (length % blockLen)\n      to.buffer.set(buffer);\n    return to;\n  }\n};\n\n// ../../node_modules/@noble/hashes/esm/sha256.js\nvar SHA256_K = /* @__PURE__ */ new Uint32Array([\n  1116352408,\n  1899447441,\n  3049323471,\n  3921009573,\n  961987163,\n  1508970993,\n  2453635748,\n  2870763221,\n  3624381080,\n  310598401,\n  607225278,\n  1426881987,\n  1925078388,\n  2162078206,\n  2614888103,\n  3248222580,\n  3835390401,\n  4022224774,\n  264347078,\n  604807628,\n  770255983,\n  1249150122,\n  1555081692,\n  1996064986,\n  2554220882,\n  2821834349,\n  2952996808,\n  3210313671,\n  3336571891,\n  3584528711,\n  113926993,\n  338241895,\n  666307205,\n  773529912,\n  1294757372,\n  1396182291,\n  1695183700,\n  1986661051,\n  2177026350,\n  2456956037,\n  2730485921,\n  2820302411,\n  3259730800,\n  3345764771,\n  3516065817,\n  3600352804,\n  4094571909,\n  275423344,\n  430227734,\n  506948616,\n  659060556,\n  883997877,\n  958139571,\n  1322822218,\n  1537002063,\n  1747873779,\n  1955562222,\n  2024104815,\n  2227730452,\n  2361852424,\n  2428436474,\n  2756734187,\n  3204031479,\n  3329325298\n]);\nvar SHA256_IV = /* @__PURE__ */ new Uint32Array([\n  1779033703,\n  3144134277,\n  1013904242,\n  2773480762,\n  1359893119,\n  2600822924,\n  528734635,\n  1541459225\n]);\nvar SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nvar SHA256 = class extends HashMD {\n  constructor() {\n    super(64, 32, 8, false);\n    this.A = SHA256_IV[0] | 0;\n    this.B = SHA256_IV[1] | 0;\n    this.C = SHA256_IV[2] | 0;\n    this.D = SHA256_IV[3] | 0;\n    this.E = SHA256_IV[4] | 0;\n    this.F = SHA256_IV[5] | 0;\n    this.G = SHA256_IV[6] | 0;\n    this.H = SHA256_IV[7] | 0;\n  }\n  get() {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  set(A, B, C, D, E, F, G, H) {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  process(view, offset) {\n    for (let i = 0; i < 16; i++, offset += 4)\n      SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;\n      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;\n    }\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = sigma0 + Maj(A, B, C) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = D + T1 | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = T1 + T2 | 0;\n    }\n    A = A + this.A | 0;\n    B = B + this.B | 0;\n    C = C + this.C | 0;\n    D = D + this.D | 0;\n    E = E + this.E | 0;\n    F = F + this.F | 0;\n    G = G + this.G | 0;\n    H = H + this.H | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  roundClean() {\n    SHA256_W.fill(0);\n  }\n  destroy() {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    this.buffer.fill(0);\n  }\n};\nvar sha256 = /* @__PURE__ */ wrapConstructor(() => new SHA256());\n\n// src/modules/wallet-request/crypto/curve25519.ts\nvar toHex = (input) => Buffer3.from(input).toString(\"hex\");\nvar Curve25519 = (privateKeyHex = toHex(x25519.utils.randomPrivateKey())) => {\n  const getPrivateKey = () => privateKeyHex;\n  const x25519Api = {\n    getPublicKey: () => toHex(x25519.getPublicKey(privateKeyHex)),\n    calculateSharedSecret: (publicKeyHex, dAppDefinitionAddress) => {\n      try {\n        const sharedSecret = x25519.getSharedSecret(privateKeyHex, publicKeyHex);\n        const derived = hkdf(\n          sha256,\n          sharedSecret,\n          Buffer3.from(dAppDefinitionAddress, \"utf-8\"),\n          \"RCfM\",\n          32\n        );\n        return ok(toHex(derived));\n      } catch (error) {\n        return err(error);\n      }\n    }\n  };\n  const ed25519Api = {\n    getPublicKey: () => toHex(ed25519.getPublicKey(privateKeyHex)),\n    sign: (messageHex) => {\n      try {\n        return ok(toHex(ed25519.sign(messageHex, privateKeyHex)));\n      } catch (error) {\n        return err(error);\n      }\n    }\n  };\n  return {\n    getPrivateKey,\n    x25519: x25519Api,\n    ed25519: ed25519Api\n  };\n};\n\n// src/modules/wallet-request/crypto/blake2b.ts\nimport { err as err2, ok as ok2 } from \"neverthrow\";\nimport blake from \"blakejs\";\nimport { Buffer as Buffer4 } from \"buffer\";\nvar bufferToArrayBuffer = (buffer) => {\n  const arrayBuffer = new ArrayBuffer(buffer.length);\n  const view = new Uint8Array(arrayBuffer);\n  for (let i = 0; i < buffer.length; ++i) {\n    view[i] = buffer[i];\n  }\n  return arrayBuffer;\n};\nvar bufferToUnit8Array = (buffer) => new Uint8Array(bufferToArrayBuffer(buffer));\nvar blake2b = (input) => {\n  try {\n    return ok2(blake.blake2bHex(bufferToUnit8Array(input), void 0, 32)).map(\n      (hex) => Buffer4.from(hex, \"hex\")\n    );\n  } catch (error) {\n    return err2(error);\n  }\n};\n\n// src/modules/wallet-request/data-request/builders/accounts.ts\nimport { produce } from \"immer\";\nimport { boolean as boolean2, object as object2, optional as optional2 } from \"valibot\";\n\n// src/schemas/index.ts\nimport {\n  array,\n  boolean,\n  literal,\n  number as number2,\n  object,\n  optional,\n  minValue,\n  string,\n  union,\n  check,\n  pipe\n} from \"valibot\";\nvar Account = object({\n  address: string(),\n  label: string(),\n  appearanceId: number2()\n});\nvar Proof = object({\n  publicKey: string(),\n  signature: string(),\n  curve: union([literal(\"curve25519\"), literal(\"secp256k1\")])\n});\nvar AccountProof = object({\n  accountAddress: string(),\n  proof: Proof\n});\nvar PersonaProof = object({\n  identityAddress: string(),\n  proof: Proof\n});\nvar ProofOfOwnershipRequestItem = object({\n  challenge: string(),\n  identityAddress: optional(string()),\n  accountAddresses: optional(array(string()))\n});\nvar ProofOfOwnershipResponseItem = object({\n  challenge: string(),\n  proofs: array(union([AccountProof, PersonaProof]))\n});\nvar Persona = object({ identityAddress: string(), label: string() });\nvar personaDataFullNameVariant = {\n  western: \"western\",\n  eastern: \"eastern\"\n};\nvar PersonaDataNameVariant = union([\n  literal(personaDataFullNameVariant.eastern),\n  literal(personaDataFullNameVariant.western)\n]);\nvar PersonaDataName = object({\n  variant: PersonaDataNameVariant,\n  familyName: string(),\n  nickname: string(),\n  givenNames: string()\n});\nvar NumberOfValues = object({\n  quantifier: union([literal(\"exactly\"), literal(\"atLeast\")]),\n  quantity: pipe(number2(), minValue(0, \"The number must be at least 0.\"))\n});\nvar AccountsRequestItem = object({\n  challenge: optional(string()),\n  numberOfAccounts: NumberOfValues\n});\nvar AccountsRequestResponseItem = pipe(\n  object({\n    accounts: array(Account),\n    challenge: optional(string()),\n    proofs: optional(array(AccountProof))\n  }),\n  check((data) => {\n    if (data.challenge || data?.proofs) {\n      return !!(data.challenge && data?.proofs?.length);\n    }\n    return true;\n  }, \"missing challenge or proofs\")\n);\nvar PersonaDataRequestItem = object({\n  isRequestingName: optional(boolean()),\n  numberOfRequestedEmailAddresses: optional(NumberOfValues),\n  numberOfRequestedPhoneNumbers: optional(NumberOfValues)\n});\nvar PersonaDataRequestResponseItem = object({\n  name: optional(PersonaDataName),\n  emailAddresses: optional(array(string())),\n  phoneNumbers: optional(array(string()))\n});\nvar ResetRequestItem = object({\n  accounts: boolean(),\n  personaData: boolean()\n});\nvar LoginRequestResponseItem = pipe(\n  object({\n    persona: Persona,\n    challenge: optional(string()),\n    proof: optional(Proof)\n  }),\n  check((data) => {\n    if (data.challenge || data.proof) {\n      return !!(data.challenge && data.proof);\n    }\n    return true;\n  }, \"missing challenge or proof\")\n);\nvar WalletUnauthorizedRequestItems = object({\n  discriminator: literal(\"unauthorizedRequest\"),\n  oneTimeAccounts: optional(AccountsRequestItem),\n  oneTimePersonaData: optional(PersonaDataRequestItem)\n});\nvar AuthUsePersonaRequestItem = object({\n  discriminator: literal(\"usePersona\"),\n  identityAddress: string()\n});\nvar AuthLoginWithoutChallengeRequestItem = object({\n  discriminator: literal(\"loginWithoutChallenge\")\n});\nvar AuthLoginWithChallengeRequestItem = object({\n  discriminator: literal(\"loginWithChallenge\"),\n  challenge: string()\n});\nvar AuthLoginRequestItem = union([\n  AuthLoginWithoutChallengeRequestItem,\n  AuthLoginWithChallengeRequestItem\n]);\nvar AuthRequestItem = union([\n  AuthUsePersonaRequestItem,\n  AuthLoginRequestItem\n]);\nvar WalletAuthorizedRequestItems = object({\n  discriminator: literal(\"authorizedRequest\"),\n  auth: AuthRequestItem,\n  reset: optional(ResetRequestItem),\n  proofOfOwnership: optional(ProofOfOwnershipRequestItem),\n  oneTimeAccounts: optional(AccountsRequestItem),\n  ongoingAccounts: optional(AccountsRequestItem),\n  oneTimePersonaData: optional(PersonaDataRequestItem),\n  ongoingPersonaData: optional(PersonaDataRequestItem)\n});\nvar WalletRequestItems = union([\n  WalletUnauthorizedRequestItems,\n  WalletAuthorizedRequestItems\n]);\nvar SendTransactionItem = object({\n  transactionManifest: string(),\n  version: number2(),\n  blobs: optional(array(string())),\n  message: optional(string())\n});\nvar WalletTransactionItems = object({\n  discriminator: literal(\"transaction\"),\n  send: SendTransactionItem\n});\nvar SendTransactionResponseItem = object({\n  transactionIntentHash: string()\n});\nvar WalletTransactionResponseItems = object({\n  discriminator: literal(\"transaction\"),\n  send: SendTransactionResponseItem\n});\nvar CancelRequest = object({\n  discriminator: literal(\"cancelRequest\")\n});\nvar ExpireAtTime = object({\n  discriminator: literal(\"expireAtTime\"),\n  unixTimestampSeconds: number2()\n});\nvar ExpireAfterDelay = object({\n  discriminator: literal(\"expireAfterDelay\"),\n  expireAfterSeconds: number2()\n});\nvar SubintentRequestItem = object({\n  discriminator: literal(\"subintent\"),\n  /**\n   * Version of the message interface\n   */\n  version: number2(),\n  /**\n   * Version of the Transaction Manifest\n   */\n  manifestVersion: number2(),\n  subintentManifest: string(),\n  blobs: optional(array(string())),\n  message: optional(string()),\n  expiration: union([ExpireAtTime, ExpireAfterDelay])\n});\nvar SubintentResponseItem = object({\n  expirationTimestamp: number2(),\n  subintentHash: string(),\n  signedPartialTransaction: string()\n});\nvar WalletPreAuthorizationItems = object({\n  discriminator: literal(\"preAuthorizationRequest\"),\n  request: optional(SubintentRequestItem)\n});\nvar WalletInteractionItems = union([\n  WalletRequestItems,\n  WalletTransactionItems,\n  CancelRequest,\n  WalletPreAuthorizationItems\n]);\nvar Metadata = object({\n  version: literal(2),\n  networkId: number2(),\n  dAppDefinitionAddress: string(),\n  origin: string()\n});\nvar WalletInteraction = object({\n  interactionId: string(),\n  metadata: Metadata,\n  items: WalletInteractionItems\n});\nvar WalletUnauthorizedRequestResponseItems = object({\n  discriminator: literal(\"unauthorizedRequest\"),\n  oneTimeAccounts: optional(AccountsRequestResponseItem),\n  oneTimePersonaData: optional(PersonaDataRequestResponseItem)\n});\nvar AuthLoginWithoutChallengeRequestResponseItem = object({\n  discriminator: literal(\"loginWithoutChallenge\"),\n  persona: Persona\n});\nvar AuthLoginWithChallengeRequestResponseItem = object({\n  discriminator: literal(\"loginWithChallenge\"),\n  persona: Persona,\n  challenge: string(),\n  proof: Proof\n});\nvar WalletPreAuthorizationResponseItems = object({\n  discriminator: literal(\"preAuthorizationResponse\"),\n  response: optional(SubintentResponseItem)\n});\nvar AuthLoginRequestResponseItem = union([\n  AuthLoginWithoutChallengeRequestResponseItem,\n  AuthLoginWithChallengeRequestResponseItem\n]);\nvar AuthUsePersonaRequestResponseItem = object({\n  discriminator: literal(\"usePersona\"),\n  persona: Persona\n});\nvar AuthRequestResponseItem = union([\n  AuthUsePersonaRequestResponseItem,\n  AuthLoginRequestResponseItem\n]);\nvar WalletAuthorizedRequestResponseItems = object({\n  discriminator: literal(\"authorizedRequest\"),\n  auth: AuthRequestResponseItem,\n  proofOfOwnership: optional(ProofOfOwnershipResponseItem),\n  oneTimeAccounts: optional(AccountsRequestResponseItem),\n  ongoingAccounts: optional(AccountsRequestResponseItem),\n  oneTimePersonaData: optional(PersonaDataRequestResponseItem),\n  ongoingPersonaData: optional(PersonaDataRequestResponseItem)\n});\nvar WalletRequestResponseItems = union([\n  WalletUnauthorizedRequestResponseItems,\n  WalletAuthorizedRequestResponseItems\n]);\nvar WalletInteractionResponseItems = union([\n  WalletRequestResponseItems,\n  WalletTransactionResponseItems,\n  WalletPreAuthorizationResponseItems\n]);\nvar WalletInteractionSuccessResponse = object({\n  discriminator: literal(\"success\"),\n  interactionId: string(),\n  items: WalletInteractionResponseItems\n});\nvar WalletInteractionFailureResponse = object({\n  discriminator: literal(\"failure\"),\n  interactionId: string(),\n  error: string(),\n  message: optional(string())\n});\nvar WalletInteractionResponse = union([\n  WalletInteractionSuccessResponse,\n  WalletInteractionFailureResponse\n]);\nvar extensionInteractionDiscriminator = {\n  extensionStatus: \"extensionStatus\",\n  openPopup: \"openPopup\",\n  cancelWalletInteraction: \"cancelWalletInteraction\",\n  walletInteraction: \"walletInteraction\"\n};\nvar StatusExtensionInteraction = object({\n  interactionId: string(),\n  discriminator: literal(extensionInteractionDiscriminator.extensionStatus)\n});\nvar OpenPopupExtensionInteraction = object({\n  interactionId: string(),\n  discriminator: literal(extensionInteractionDiscriminator.openPopup)\n});\nvar WalletInteractionExtensionInteraction = object({\n  interactionId: string(),\n  discriminator: literal(extensionInteractionDiscriminator.walletInteraction),\n  interaction: WalletInteraction,\n  sessionId: optional(string())\n});\nvar CancelWalletInteractionExtensionInteraction = object({\n  interactionId: string(),\n  discriminator: literal(\n    extensionInteractionDiscriminator.cancelWalletInteraction\n  ),\n  metadata: Metadata\n});\nvar ExtensionInteraction = union([\n  StatusExtensionInteraction,\n  OpenPopupExtensionInteraction,\n  WalletInteractionExtensionInteraction,\n  CancelWalletInteractionExtensionInteraction\n]);\nvar messageLifeCycleEventType = {\n  extensionStatus: \"extensionStatus\",\n  receivedByExtension: \"receivedByExtension\",\n  receivedByWallet: \"receivedByWallet\",\n  requestCancelSuccess: \"requestCancelSuccess\",\n  requestCancelFail: \"requestCancelFail\"\n};\nvar MessageLifeCycleExtensionStatusEvent = object({\n  eventType: literal(messageLifeCycleEventType.extensionStatus),\n  interactionId: string(),\n  isWalletLinked: boolean(),\n  isExtensionAvailable: boolean(),\n  canHandleSessions: optional(boolean())\n});\nvar MessageLifeCycleEvent = object({\n  eventType: union([\n    literal(messageLifeCycleEventType.extensionStatus),\n    literal(messageLifeCycleEventType.receivedByExtension),\n    literal(messageLifeCycleEventType.receivedByWallet),\n    literal(messageLifeCycleEventType.requestCancelSuccess),\n    literal(messageLifeCycleEventType.requestCancelFail)\n  ]),\n  interactionId: string()\n});\nvar IncomingMessage = union([\n  MessageLifeCycleEvent,\n  WalletInteractionResponse\n]);\nvar eventType = {\n  outgoingMessage: \"radix#chromeExtension#send\",\n  incomingMessage: \"radix#chromeExtension#receive\"\n};\nvar Offer = literal(\"offer\");\nvar Answer = literal(\"answer\");\nvar IceCandidate = literal(\"iceCandidate\");\nvar IceCandidates = literal(\"iceCandidates\");\nvar Types = union([Offer, Answer, IceCandidate, IceCandidates]);\nvar Sources = union([literal(\"wallet\"), literal(\"extension\")]);\nvar SignalingServerMessage = object({\n  requestId: string(),\n  targetClientId: string(),\n  encryptedPayload: string(),\n  source: optional(Sources),\n  // redundant, to be removed\n  connectionId: optional(string())\n  // redundant, to be removed\n});\nvar AnswerIO = object({\n  ...SignalingServerMessage.entries,\n  method: Answer,\n  payload: object({\n    sdp: string()\n  })\n});\nvar OfferIO = object({\n  ...SignalingServerMessage.entries,\n  method: Offer,\n  payload: object({\n    sdp: string()\n  })\n});\nvar IceCandidatePayloadIO = object({\n  candidate: string(),\n  sdpMid: string(),\n  sdpMLineIndex: number2()\n});\nvar IceCandidateIO = object({\n  ...SignalingServerMessage.entries,\n  method: IceCandidate,\n  payload: IceCandidatePayloadIO\n});\nvar IceCandidatesIO = object({\n  ...SignalingServerMessage.entries,\n  method: IceCandidates,\n  payload: array(IceCandidatePayloadIO)\n});\n\n// src/modules/wallet-request/data-request/builders/accounts.ts\nvar AccountsDataRequestSchema = object2({\n  numberOfAccounts: NumberOfValues,\n  withProof: optional2(boolean2()),\n  reset: optional2(boolean2())\n});\nvar accounts = () => {\n  const defaultValue = {\n    numberOfAccounts: { quantifier: \"atLeast\", quantity: 1 }\n  };\n  let data = produce(defaultValue, () => {\n  });\n  const atLeast = (n) => {\n    data = produce(data, (draft) => {\n      draft.numberOfAccounts.quantifier = \"atLeast\";\n      draft.numberOfAccounts.quantity = n;\n    });\n    return methods;\n  };\n  const exactly = (n) => {\n    data = produce(data, (draft) => {\n      draft.numberOfAccounts.quantifier = \"exactly\";\n      draft.numberOfAccounts.quantity = n;\n    });\n    return methods;\n  };\n  const reset = (value = true) => {\n    data = produce(data, (draft) => {\n      draft.reset = value;\n    });\n    return methods;\n  };\n  const withProof = (value = true) => {\n    data = produce(data, (draft) => {\n      draft.withProof = value;\n    });\n    return methods;\n  };\n  const _toObject = () => ({\n    accounts: data\n  });\n  const methods = {\n    atLeast,\n    exactly,\n    withProof,\n    reset,\n    _toObject\n  };\n  return methods;\n};\n\n// src/modules/wallet-request/data-request/builders/persona.ts\nimport { produce as produce2 } from \"immer\";\nimport { boolean as boolean3, object as object3, optional as optional3 } from \"valibot\";\nvar schema = object3({\n  withProof: optional3(boolean3())\n});\nvar persona = (initialData = {\n  withProof: false\n}) => {\n  let data = produce2(initialData, () => {\n  });\n  const withProof = (value = true) => {\n    data = produce2(data, (draft) => {\n      draft.withProof = value;\n    });\n    return methods;\n  };\n  const _toObject = () => ({\n    persona: data\n  });\n  const methods = {\n    withProof,\n    _toObject\n  };\n  return methods;\n};\n\n// src/modules/wallet-request/data-request/builders/persona-data.ts\nimport { produce as produce3 } from \"immer\";\nimport { boolean as boolean4, object as object4, partial } from \"valibot\";\nvar PersonaDataRequestSchema = partial(\n  object4({\n    fullName: boolean4(),\n    emailAddresses: NumberOfValues,\n    phoneNumbers: NumberOfValues,\n    reset: boolean4()\n  })\n);\nvar personaData = (initialData = {}) => {\n  let data = produce3(initialData, () => {\n  });\n  const fullName = (value = true) => {\n    data = produce3(data, (draft) => {\n      draft.fullName = value;\n    });\n    return methods;\n  };\n  const createNumberOfValuesOptions = (key) => ({\n    atLeast: (n) => {\n      data = produce3(data, (draft) => {\n        draft[key] = { quantifier: \"atLeast\", quantity: n };\n      });\n      return methods;\n    },\n    exactly: (n) => {\n      data = produce3(data, (draft) => {\n        draft[key] = { quantifier: \"exactly\", quantity: n };\n      });\n      return methods;\n    }\n  });\n  const emailAddresses = (value = true) => {\n    const options = createNumberOfValuesOptions(\"emailAddresses\");\n    options.exactly(value ? 1 : 0);\n    return methods;\n  };\n  const phoneNumbers = (value = true) => {\n    const options = createNumberOfValuesOptions(\"phoneNumbers\");\n    options.exactly(value ? 1 : 0);\n    return methods;\n  };\n  const reset = (value = true) => {\n    data = produce3(data, (draft) => {\n      draft.reset = value;\n    });\n    return methods;\n  };\n  const _toObject = () => ({\n    personaData: data\n  });\n  const methods = {\n    fullName,\n    emailAddresses,\n    phoneNumbers,\n    reset,\n    _toObject\n  };\n  return methods;\n};\n\n// src/modules/wallet-request/data-request/builders/proof-of-ownership.ts\nimport { produce as produce4 } from \"immer\";\nimport { object as object5, string as string2, array as array2, optional as optional4 } from \"valibot\";\nvar schema2 = object5({\n  accountAddresses: optional4(array2(string2())),\n  identityAddress: optional4(string2())\n});\nvar proofOfOwnership = (initialData = {}) => {\n  let data = produce4(initialData, () => {\n  });\n  const accounts2 = (value) => {\n    data = produce4(data, (draft) => {\n      draft.accountAddresses = value;\n    });\n    return methods;\n  };\n  const identity = (value) => {\n    data = produce4(data, (draft) => {\n      draft.identityAddress = value;\n    });\n    return methods;\n  };\n  const _toObject = () => ({\n    proofOfOwnership: data\n  });\n  const methods = {\n    accounts: accounts2,\n    identity,\n    _toObject\n  };\n  return methods;\n};\n\n// src/modules/wallet-request/data-request/builders/index.ts\nvar config = (data) => {\n  const _toObject = () => ({ ...data });\n  const methods = {\n    _toObject\n  };\n  return methods;\n};\nvar DataRequestBuilder = {\n  accounts,\n  personaData,\n  persona,\n  config\n};\nvar OneTimeDataRequestBuilder = {\n  accounts,\n  personaData,\n  proofOfOwnership\n};\n\n// src/helpers/is-deep-equal.ts\nvar isDeepEqual = (a, b) => {\n  const values = [null, void 0, false, true];\n  if (values.includes(a) || values.includes(b) || typeof a === \"number\" || typeof b === \"number\") {\n    return Object.is(a, b);\n  }\n  const aKeys = Object.keys(a);\n  const bKeys = Object.keys(b);\n  if (aKeys.length !== bKeys.length) return false;\n  for (const key of aKeys) {\n    const value1 = a[key];\n    const value2 = b[key];\n    const isObjects = isObject(value1) && isObject(value2);\n    if (isObjects && !isDeepEqual(value1, value2) || !isObjects && value1 !== value2) {\n      return false;\n    }\n  }\n  return true;\n};\nvar isObject = (x) => {\n  return x != null && typeof x === \"object\";\n};\n\n// src/modules/wallet-request/data-request/helpers/can-data-request-be-resolved-by-rdt-state.ts\nvar canDataRequestBeResolvedByRdtState = (dataRequest, state) => {\n  if (dataRequest.discriminator === \"authorizedRequest\") {\n    const isReset = dataRequest.reset?.accounts || dataRequest.reset?.personaData;\n    const isOneTimeRequest = !!(dataRequest.oneTimeAccounts || dataRequest.oneTimePersonaData);\n    const isChallengeRequest = dataRequest.auth.discriminator === \"loginWithChallenge\" || !!dataRequest.oneTimeAccounts?.challenge || !!dataRequest.ongoingAccounts?.challenge;\n    if (isReset || isOneTimeRequest || isChallengeRequest) return false;\n    let rdtStateSatisfiesRequest = false;\n    if (dataRequest.ongoingAccounts) {\n      const { quantifier, quantity } = dataRequest.ongoingAccounts.numberOfAccounts;\n      rdtStateSatisfiesRequest = state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantifier === quantifier && state.sharedData?.ongoingAccounts?.numberOfAccounts?.quantity === quantity;\n    }\n    if (dataRequest.ongoingPersonaData) {\n      rdtStateSatisfiesRequest = isDeepEqual(\n        dataRequest.ongoingPersonaData,\n        state.sharedData?.ongoingPersonaData\n      );\n    }\n    return rdtStateSatisfiesRequest;\n  }\n  return false;\n};\n\n// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts\nimport { produce as produce6 } from \"immer\";\n\n// src/modules/wallet-request/data-request/transformations/rdt-to-wallet.ts\nimport { produce as produce5 } from \"immer\";\nimport { ok as ok3 } from \"neverthrow\";\nimport { boolean as boolean5, object as object6, string as string3, optional as optional5, array as array3 } from \"valibot\";\nvar TransformRdtDataRequestToWalletRequestInput = object6({\n  proofOfOwnership: optional5(\n    object6({\n      challenge: optional5(string3()),\n      accountAddresses: optional5(array3(string3())),\n      identityAddress: optional5(string3())\n    })\n  ),\n  accounts: optional5(\n    object6({\n      numberOfAccounts: NumberOfValues,\n      reset: boolean5(),\n      oneTime: boolean5(),\n      challenge: optional5(string3())\n    })\n  ),\n  personaData: optional5(\n    object6({\n      fullName: optional5(boolean5()),\n      phoneNumbers: optional5(NumberOfValues),\n      emailAddresses: optional5(NumberOfValues),\n      reset: boolean5(),\n      oneTime: optional5(boolean5())\n    })\n  ),\n  persona: optional5(\n    object6({\n      identityAddress: optional5(string3()),\n      label: optional5(string3()),\n      challenge: optional5(string3())\n    })\n  )\n});\nvar isAuthorized = (input) => {\n  const { persona: persona2, accounts: accounts2, personaData: personaData2, proofOfOwnership: proofOfOwnership2 } = input;\n  const isPersonaLogin = !!persona2;\n  const shouldResetData = accounts2?.reset || personaData2?.reset;\n  const isOngoingAccountsRequest = accounts2 && !accounts2?.oneTime;\n  const isOngoingPersonaDataRequest = personaData2 && !personaData2?.oneTime;\n  const isAuthorizedRequest = !!(shouldResetData || isOngoingAccountsRequest || isOngoingPersonaDataRequest || isPersonaLogin || proofOfOwnership2);\n  return isAuthorizedRequest;\n};\nvar createLoginRequestItem = (input) => {\n  if (input.persona?.challenge) {\n    return {\n      discriminator: \"loginWithChallenge\",\n      challenge: input.persona.challenge\n    };\n  }\n  if (input.persona?.identityAddress) {\n    return {\n      discriminator: \"usePersona\",\n      identityAddress: input.persona?.identityAddress\n    };\n  }\n  return {\n    discriminator: \"loginWithoutChallenge\"\n  };\n};\nvar withAccountRequestItem = (input) => (requestItems) => {\n  const updatedRequestItems = { ...requestItems };\n  const { accounts: accounts2 } = input;\n  if (accounts2) {\n    const data = {\n      challenge: accounts2.challenge,\n      numberOfAccounts: accounts2.numberOfAccounts\n    };\n    const isOngoingRequest = updatedRequestItems.discriminator === \"authorizedRequest\" && !input.accounts?.oneTime;\n    const isConnectOngoingRequest = updatedRequestItems.discriminator === \"authorizedRequest\";\n    if (input.accounts?.oneTime) {\n      updatedRequestItems[\"oneTimeAccounts\"] = data;\n    } else if (isOngoingRequest || isConnectOngoingRequest) {\n      updatedRequestItems[\"ongoingAccounts\"] = data;\n    }\n  }\n  return updatedRequestItems;\n};\nvar withProofOfOwnershipRequestItem = (input) => (requestItems) => {\n  const updatedRequestItems = { ...requestItems };\n  if (input.proofOfOwnership) {\n    const { challenge, accountAddresses, identityAddress } = input.proofOfOwnership;\n    if (challenge && updatedRequestItems.discriminator === \"authorizedRequest\") {\n      updatedRequestItems[\"proofOfOwnership\"] = {\n        challenge\n      };\n      if (accountAddresses) {\n        updatedRequestItems[\"proofOfOwnership\"].accountAddresses = accountAddresses;\n      }\n      if (identityAddress) {\n        updatedRequestItems[\"proofOfOwnership\"].identityAddress = identityAddress;\n      }\n    }\n  }\n  return updatedRequestItems;\n};\nvar withPersonaDataRequestItem = (input) => (requestItems) => {\n  const updatedRequestItems = { ...requestItems };\n  if (input.personaData) {\n    const {\n      fullName: isRequestingName,\n      phoneNumbers: numberOfRequestedPhoneNumbers,\n      emailAddresses: numberOfRequestedEmailAddresses\n    } = input.personaData;\n    if (input.personaData?.oneTime) {\n      updatedRequestItems[\"oneTimePersonaData\"] = {\n        isRequestingName,\n        numberOfRequestedPhoneNumbers,\n        numberOfRequestedEmailAddresses\n      };\n    }\n    const isOngoingRequest = updatedRequestItems.discriminator === \"authorizedRequest\" && !input.personaData?.oneTime;\n    const isConnectOngoingRequest = updatedRequestItems.discriminator === \"authorizedRequest\";\n    if (isOngoingRequest || isConnectOngoingRequest) {\n      updatedRequestItems[\"ongoingPersonaData\"] = {\n        isRequestingName,\n        numberOfRequestedPhoneNumbers,\n        numberOfRequestedEmailAddresses\n      };\n    }\n  }\n  return updatedRequestItems;\n};\nvar withResetRequestItem = (input) => (requestItems) => {\n  const { accounts: accounts2, personaData: personaData2 } = input;\n  return {\n    ...requestItems,\n    reset: { accounts: !!accounts2?.reset, personaData: !!personaData2?.reset }\n  };\n};\nvar createUnauthorizedRequestItems = (input) => ok3({\n  discriminator: \"unauthorizedRequest\"\n}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withProofOfOwnershipRequestItem(input));\nvar createAuthorizedRequestItems = (input) => ok3({\n  discriminator: \"authorizedRequest\",\n  auth: createLoginRequestItem(input)\n}).map(withAccountRequestItem(input)).map(withPersonaDataRequestItem(input)).map(withResetRequestItem(input)).map(withProofOfOwnershipRequestItem(input));\nvar transformConnectRequest = (isConnect, input) => ok3(\n  isConnect ? produce5(input, (draft) => {\n    if (draft.accounts) {\n      draft.accounts.oneTime = false;\n      draft.accounts.reset = false;\n    }\n    if (draft.personaData) {\n      draft.personaData.oneTime = false;\n      draft.personaData.reset = false;\n    }\n  }) : input\n);\nvar transformRdtDataRequestToWalletRequest = (isConnect, input) => transformConnectRequest(isConnect, input).andThen(\n  (transformed) => isAuthorized(transformed) ? createAuthorizedRequestItems(transformed) : createUnauthorizedRequestItems(transformed)\n);\n\n// src/modules/wallet-request/data-request/helpers/to-wallet-request.ts\nvar toWalletRequest = ({\n  dataRequestState,\n  isConnect,\n  challenge,\n  oneTime,\n  walletData\n}) => transformRdtDataRequestToWalletRequest(\n  isConnect,\n  produce6({}, (draft) => {\n    if (dataRequestState.proofOfOwnership) {\n      draft.proofOfOwnership = {\n        ...dataRequestState.proofOfOwnership,\n        challenge\n      };\n    }\n    if (dataRequestState.accounts) {\n      draft.accounts = {\n        numberOfAccounts: dataRequestState.accounts.numberOfAccounts || {\n          quantifier: \"atLeast\",\n          quantity: 1\n        },\n        oneTime,\n        reset: !!dataRequestState.accounts.reset,\n        challenge: dataRequestState.accounts.withProof ? challenge : void 0\n      };\n    }\n    if (dataRequestState.personaData)\n      draft.personaData = {\n        ...dataRequestState.personaData,\n        reset: !!dataRequestState.personaData.reset,\n        oneTime\n      };\n    if (!oneTime || dataRequestState.proofOfOwnership) {\n      const persona2 = walletData.persona;\n      if (walletData.persona) draft.persona = persona2;\n      if (dataRequestState.persona?.withProof)\n        draft.persona = { ...draft.persona ?? {}, challenge };\n      if (Object.values(dataRequestState).length === 0)\n        draft.persona = { challenge: void 0 };\n    }\n  })\n);\n\n// src/modules/wallet-request/data-request/transformations/shared-data.ts\nimport { produce as produce7 } from \"immer\";\nvar transformWalletRequestToSharedData = (walletInteraction, sharedData) => {\n  const { items: walletDataRequest } = walletInteraction;\n  if (walletDataRequest.discriminator === \"authorizedRequest\")\n    return produce7({}, (draft) => {\n      draft.persona = { proof: false };\n      if (walletDataRequest.auth.discriminator === \"loginWithChallenge\")\n        draft.persona.proof = !!walletDataRequest.auth.challenge;\n      if (walletDataRequest.ongoingAccounts) {\n        draft.ongoingAccounts = {\n          proof: !!walletDataRequest.ongoingAccounts.challenge,\n          numberOfAccounts: walletDataRequest.ongoingAccounts.numberOfAccounts\n        };\n      }\n      if (walletDataRequest.ongoingPersonaData) {\n        draft.ongoingPersonaData = walletDataRequest.ongoingPersonaData;\n      }\n    });\n  return sharedData;\n};\nvar transformSharedDataToDataRequestState = (sharedData) => produce7({}, (draft) => {\n  if (sharedData.ongoingAccounts) {\n    draft.accounts = {\n      numberOfAccounts: sharedData.ongoingAccounts.numberOfAccounts,\n      withProof: sharedData.ongoingAccounts.proof,\n      reset: true\n    };\n  }\n  if (sharedData.ongoingPersonaData) {\n    draft.personaData = {\n      fullName: sharedData.ongoingPersonaData.isRequestingName,\n      phoneNumbers: sharedData.ongoingPersonaData.numberOfRequestedPhoneNumbers,\n      emailAddresses: sharedData.ongoingPersonaData.numberOfRequestedEmailAddresses,\n      reset: false\n    };\n  }\n  if (sharedData.persona) {\n    draft.persona = {\n      withProof: false\n    };\n  }\n});\n\n// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts\nimport { produce as produce8 } from \"immer\";\nimport { okAsync as okAsync2 } from \"neverthrow\";\n\n// src/modules/state/state.module.ts\nimport { BehaviorSubject as BehaviorSubject2, Subscription, filter } from \"rxjs\";\n\n// src/modules/state/types.ts\nimport {\n  array as array4,\n  boolean as boolean6,\n  optional as optional6,\n  literal as literal2,\n  object as object7,\n  variant,\n  string as string4\n} from \"valibot\";\nvar proofType = {\n  persona: \"persona\",\n  account: \"account\"\n};\nvar SignedChallengePersona = object7({\n  challenge: string4(),\n  proof: Proof,\n  address: string4(),\n  type: literal2(proofType.persona)\n});\nvar SignedChallengeAccount = object7({\n  challenge: string4(),\n  proof: Proof,\n  address: string4(),\n  type: literal2(proofType.account)\n});\nvar SignedChallenge = variant(\"type\", [\n  SignedChallengePersona,\n  SignedChallengeAccount\n]);\nvar WalletDataPersonaDataFullName = object7({\n  entry: literal2(\"fullName\"),\n  fields: PersonaDataName\n});\nvar WalletDataPersonaDataEmailAddresses = object7({\n  entry: literal2(\"emailAddresses\"),\n  fields: array4(string4())\n});\nvar WalletDataPersonaDataPhoneNumbersAddresses = object7({\n  entry: literal2(\"phoneNumbers\"),\n  fields: array4(string4())\n});\nvar WalletDataPersonaData = variant(\"entry\", [\n  WalletDataPersonaDataFullName,\n  WalletDataPersonaDataEmailAddresses,\n  WalletDataPersonaDataPhoneNumbersAddresses\n]);\nvar WalletData = object7({\n  accounts: array4(Account),\n  personaData: array4(WalletDataPersonaData),\n  persona: optional6(Persona),\n  proofs: array4(SignedChallenge)\n});\nvar SharedData = object7({\n  persona: optional6(object7({ proof: boolean6() })),\n  ongoingAccounts: optional6(\n    object7({\n      numberOfAccounts: optional6(NumberOfValues),\n      proof: boolean6()\n    })\n  ),\n  ongoingPersonaData: optional6(PersonaDataRequestItem)\n});\nvar RdtState = object7({\n  loggedInTimestamp: string4(),\n  walletData: WalletData,\n  sharedData: SharedData\n});\nvar walletDataDefault = {\n  accounts: [],\n  personaData: [],\n  proofs: [],\n  persona: void 0\n};\n\n// src/modules/state/state.module.ts\nimport { ok as ok4, okAsync } from \"neverthrow\";\nvar StateModule = (input) => {\n  const logger = input?.logger?.getSubLogger({ name: \"StateModule\" });\n  const storageModule = input.providers.storageModule;\n  const subscriptions = new Subscription();\n  const setState = (state) => storageModule.setState(state);\n  const getState = () => storageModule.getState().orElse(() => okAsync(defaultState)).andThen((state) => state ? ok4(state) : ok4(defaultState));\n  const patchState = (state) => getState().andThen(\n    (oldState) => setState({ ...oldState, ...state })\n  );\n  const defaultState = {\n    walletData: walletDataDefault,\n    loggedInTimestamp: \"\",\n    sharedData: {}\n  };\n  const resetState = () => storageModule.setState(defaultState).map(() => {\n    emitWalletData();\n  });\n  const initializeState = () => getState().map(() => emitWalletData()).orElse(() => resetState());\n  initializeState();\n  const walletDataSubject = new BehaviorSubject2(\n    void 0\n  );\n  const emitWalletData = () => {\n    storageModule.getState().map((state) => {\n      walletDataSubject.next(state?.walletData);\n    });\n  };\n  const walletData$ = walletDataSubject.asObservable().pipe(filter((walletData) => !!walletData));\n  return {\n    setState,\n    patchState,\n    getState,\n    walletData$,\n    emitWalletData,\n    getWalletData: () => walletDataSubject.value,\n    reset: resetState,\n    storage$: storageModule.storage$,\n    destroy: () => {\n      subscriptions.unsubscribe();\n    }\n  };\n};\n\n// src/modules/wallet-request/data-request/transformations/wallet-to-rdt.ts\nvar withAccounts = (input) => (walletData) => {\n  let accounts2 = [];\n  if (input.discriminator === \"authorizedRequest\") {\n    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];\n    const ongoingAccounts = input.ongoingAccounts?.accounts ?? [];\n    accounts2 = [...oneTimeAccounts, ...ongoingAccounts];\n  } else if (input.discriminator === \"unauthorizedRequest\") {\n    const oneTimeAccounts = input.oneTimeAccounts?.accounts ?? [];\n    accounts2 = oneTimeAccounts;\n  }\n  return produce8(walletData, (draft) => {\n    draft.accounts = accounts2;\n  });\n};\nvar withPersonaDataEntries = (input) => {\n  const entries = [];\n  if (input.name) {\n    entries.push({\n      entry: \"fullName\",\n      fields: input.name\n    });\n  }\n  if (input.emailAddresses)\n    entries.push({\n      entry: \"emailAddresses\",\n      fields: input.emailAddresses\n    });\n  if (input.phoneNumbers)\n    entries.push({\n      entry: \"phoneNumbers\",\n      fields: input.phoneNumbers\n    });\n  return entries;\n};\nvar convertOwnershipProofsToSignedChallenge = (challenge, proofs) => {\n  return proofs.map((proof) => {\n    const type = \"identityAddress\" in proof ? proofType.persona : proofType.account;\n    const address = \"identityAddress\" in proof ? proof.identityAddress : proof.accountAddress;\n    return {\n      type,\n      challenge,\n      address,\n      proof: proof.proof\n    };\n  });\n};\nvar withPersonaData = (input) => (walletData) => produce8(walletData, (draft) => {\n  if (input.discriminator === \"authorizedRequest\") {\n    if (input.oneTimePersonaData)\n      draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);\n    if (input.ongoingPersonaData)\n      draft.personaData = withPersonaDataEntries(input.ongoingPersonaData);\n  } else if (input.discriminator === \"unauthorizedRequest\" && input.oneTimePersonaData)\n    draft.personaData = withPersonaDataEntries(input.oneTimePersonaData);\n});\nvar withPersona = (input) => (walletData) => produce8(walletData, (draft) => {\n  if (input.discriminator === \"authorizedRequest\")\n    draft.persona = input.auth?.persona;\n});\nvar withProofs = (input) => (walletData) => produce8(walletData, (draft) => {\n  draft.proofs = [];\n  if (input.discriminator === \"authorizedRequest\") {\n    if (input.auth.discriminator === \"loginWithChallenge\")\n      draft.proofs.push({\n        challenge: input.auth.challenge,\n        proof: input.auth.proof,\n        address: input.auth.persona.identityAddress,\n        type: proofType.persona\n      });\n    if (input.ongoingAccounts?.challenge && input.ongoingAccounts.proofs?.length) {\n      const challenge = input.ongoingAccounts.challenge;\n      const accountProofs = input.ongoingAccounts.proofs.map(\n        ({ accountAddress, proof }) => ({\n          proof,\n          address: accountAddress,\n          challenge,\n          type: proofType.account\n        })\n      );\n      draft.proofs.push(...accountProofs);\n    }\n    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {\n      const challenge = input.oneTimeAccounts.challenge;\n      const accountProofs = input.oneTimeAccounts.proofs.map(\n        ({ accountAddress, proof }) => ({\n          proof,\n          address: accountAddress,\n          challenge,\n          type: proofType.account\n        })\n      );\n      draft.proofs.push(...accountProofs);\n    }\n    if (input.proofOfOwnership) {\n      draft.proofs.push(\n        ...convertOwnershipProofsToSignedChallenge(\n          input.proofOfOwnership.challenge,\n          input.proofOfOwnership.proofs\n        )\n      );\n    }\n  }\n  if (input.discriminator === \"unauthorizedRequest\") {\n    if (input.oneTimeAccounts?.challenge && input.oneTimeAccounts.proofs?.length) {\n      const challenge = input.oneTimeAccounts.challenge;\n      const accountProofs = input.oneTimeAccounts.proofs.map(\n        ({ accountAddress, proof }) => ({\n          proof,\n          address: accountAddress,\n          challenge,\n          type: proofType.account\n        })\n      );\n      draft.proofs.push(...accountProofs);\n    }\n  }\n});\nvar transformWalletResponseToRdtWalletData = (response) => okAsync2({\n  accounts: [],\n  personaData: [],\n  proofs: [],\n  persona: void 0\n}).map(withAccounts(response)).map(withPersonaData(response)).map(withPersona(response)).map(withProofs(response));\n\n// src/modules/wallet-request/data-request/transformations/wallet-data-to-connect-button.ts\nvar transformWalletDataToConnectButton = (walletData) => {\n  const accounts2 = walletData.accounts ?? [];\n  const personaLabel = walletData?.persona?.label ?? \"\";\n  const connected = !!walletData?.persona;\n  const personaData2 = walletData?.personaData?.map((item) => {\n    if (item.entry === \"fullName\") {\n      const { variant: variant2, givenNames, familyName, nickname } = item.fields;\n      const value = variant2 === \"western\" ? `${givenNames}${nickname ? ` \"${nickname}\" ` : \" \"}${familyName}` : `${familyName}${nickname ? ` \"${nickname}\" ` : \" \"}${givenNames}`;\n      return {\n        value,\n        field: \"fullName\"\n      };\n    } else if (item.entry === \"emailAddresses\") {\n      return {\n        // currently only one email address is supported\n        value: item.fields[0],\n        field: \"emailAddress\"\n      };\n    } else if (item.entry === \"phoneNumbers\") {\n      return {\n        // currently only one phone number is supported\n        value: item.fields[0],\n        field: \"phoneNumber\"\n      };\n    }\n    return;\n  }).filter(\n    (item) => !!item && !!item.value?.trim()\n  );\n  return { accounts: accounts2, personaLabel, connected, personaData: personaData2 };\n};\n\n// src/modules/wallet-request/data-request/data-request-state.module.ts\nimport { BehaviorSubject as BehaviorSubject3 } from \"rxjs\";\nimport { produce as produce9 } from \"immer\";\nvar DataRequestStateModule = (initialState) => {\n  const state = new BehaviorSubject3(initialState);\n  const reset = () => state.next(initialState);\n  const update = (input) => state.next(input);\n  const getState = () => state.getValue();\n  const toDataRequestState = (...items) => items.filter((item) => typeof item._toObject === \"function\").reduce(\n    (acc, item) => ({\n      ...acc,\n      ...item._toObject()\n    }),\n    {}\n  );\n  const setState = (...items) => {\n    if (items.length === 0) reset();\n    else {\n      update(toDataRequestState(...items));\n    }\n  };\n  const patchState = (...items) => {\n    if (items.length === 0) return;\n    update({ ...getState(), ...toDataRequestState(...items) });\n  };\n  const removeState = (...keys) => {\n    update(\n      produce9(getState(), (draft) => {\n        keys.forEach((key) => {\n          delete draft[key];\n        });\n      })\n    );\n  };\n  return {\n    reset,\n    setState,\n    getState,\n    patchState,\n    removeState,\n    toDataRequestState,\n    state$: state.asObservable()\n  };\n};\n\n// src/modules/wallet-request/identity/identity.module.ts\nimport { err as err3, ok as ok5, okAsync as okAsync3 } from \"neverthrow\";\n\n// src/modules/wallet-request/crypto/create-signature-message.ts\nimport { Buffer as Buffer5 } from \"buffer\";\nvar createSignatureMessage = ({\n  interactionId,\n  dAppDefinitionAddress,\n  origin,\n  logger\n}) => {\n  const prefix = \"C\";\n  const prefixBuffer = Buffer5.from(\"C\", \"ascii\");\n  const lengthOfDappDefAddress = dAppDefinitionAddress.length;\n  const lengthOfDappDefAddressBuffer = Buffer5.from(\n    lengthOfDappDefAddress.toString(16),\n    \"hex\"\n  );\n  const dappDefAddressBuffer = Buffer5.from(dAppDefinitionAddress, \"utf-8\");\n  const originBuffer = Buffer5.from(origin, \"utf-8\");\n  const interactionIdBuffer = Buffer5.from(interactionId, \"utf-8\");\n  const messageBuffer = Buffer5.concat([\n    prefixBuffer,\n    interactionIdBuffer,\n    lengthOfDappDefAddressBuffer,\n    dappDefAddressBuffer,\n    originBuffer\n  ]);\n  const blake2bHash = blake2b(messageBuffer).map((hash2) => {\n    logger?.debug({\n      method: \"createSignatureMessage\",\n      messagePartsRaw: [\n        prefix,\n        interactionId,\n        lengthOfDappDefAddress,\n        dAppDefinitionAddress,\n        origin\n      ],\n      messageParts: [\n        prefixBuffer.toString(\"hex\"),\n        interactionIdBuffer.toString(\"hex\"),\n        lengthOfDappDefAddressBuffer.toString(\"hex\"),\n        dappDefAddressBuffer.toString(\"hex\"),\n        originBuffer.toString(\"hex\")\n      ],\n      message: messageBuffer.toString(\"hex\"),\n      blake2bHash: hash2.toString(\"hex\")\n    });\n    return Buffer5.from(hash2).toString(\"hex\");\n  }).mapErr((jsError) => ({ reason: \"couldNotHashMessage\", jsError }));\n  return blake2bHash;\n};\n\n// src/modules/wallet-request/identity/identity.module.ts\nvar IdentityKind = {\n  dApp: \"dApp\"\n};\nvar IdentityModule = (input) => {\n  const { storageModule, KeyPairModule } = input.providers;\n  const keyPairFromSecret = (input2) => ok5(KeyPairModule(input2));\n  const getIdentity = (kind) => storageModule.getItemById(kind).andThen(\n    (identity) => identity ? keyPairFromSecret(identity.secret) : okAsync3(void 0)\n  );\n  const createIdentity = (kind) => ok5(KeyPairModule()).asyncAndThen(\n    (keyPair) => storageModule.setItems({\n      [kind]: {\n        secret: keyPair.getPrivateKey(),\n        createdAt: Date.now()\n      }\n    }).map(() => keyPair)\n  );\n  const getOrCreateIdentity = (kind) => getIdentity(kind).andThen((keyPair) => keyPair ? okAsync3(keyPair) : createIdentity(kind)).mapErr((error) => ({\n    reason: \"couldNotGetOrCreateIdentity\",\n    jsError: error\n  }));\n  const deriveSharedSecret = (kind, publicKey) => getIdentity(kind).mapErr(() => ({ reason: \"couldNotDeriveSharedSecret\" })).andThen(\n    (identity) => identity ? identity.x25519.calculateSharedSecret(publicKey, input.dAppDefinitionAddress).mapErr(() => ({\n      reason: \"FailedToDeriveSharedSecret\"\n    })) : err3({ reason: \"DappIdentityNotFound\" })\n  );\n  const createSignature = ({\n    kind,\n    interactionId,\n    dAppDefinitionAddress,\n    origin\n  }) => getOrCreateIdentity(kind).andThen(\n    (identity) => createSignatureMessage({\n      interactionId,\n      dAppDefinitionAddress,\n      origin,\n      logger: input.logger\n    }).andThen(\n      (message) => identity.ed25519.sign(message).map((signature) => ({\n        signature,\n        publicKey: identity.x25519.getPublicKey(),\n        identity: identity.ed25519.getPublicKey()\n      })).mapErr((error) => ({\n        reason: \"couldNotSignMessage\",\n        jsError: error\n      }))\n    )\n  );\n  return {\n    get: (kind) => getOrCreateIdentity(kind),\n    deriveSharedSecret,\n    createSignature\n  };\n};\n\n// ../common/src/index.ts\nvar RequestStatus = {\n  fail: \"fail\",\n  ignored: \"ignored\",\n  pending: \"pending\",\n  success: \"success\",\n  timedOut: \"timedOut\",\n  cancelled: \"cancelled\",\n  /**\n   * Pending commit status is for preauthorization which was signed but not yet successfully committed to the network\n   */\n  pendingCommit: \"pendingCommit\"\n};\n\n// src/modules/wallet-request/request-items/request-item.module.ts\nimport { Subscription as Subscription2, filter as filter2, map, switchMap } from \"rxjs\";\n\n// src/error.ts\nvar ErrorType = {\n  rejectedByUser: \"rejectedByUser\",\n  missingExtension: \"missingExtension\",\n  canceledByUser: \"canceledByUser\",\n  walletRequestValidation: \"walletRequestValidation\",\n  walletResponseValidation: \"walletResponseValidation\",\n  wrongNetwork: \"wrongNetwork\",\n  failedToPrepareTransaction: \"failedToPrepareTransaction\",\n  failedToCompileTransaction: \"failedToCompileTransaction\",\n  failedToSignTransaction: \"failedToSignTransaction\",\n  failedToSubmitTransaction: \"failedToSubmitTransaction\",\n  failedToPollSubmittedTransaction: \"failedToPollSubmittedTransaction\",\n  submittedTransactionWasDuplicate: \"submittedTransactionWasDuplicate\",\n  submittedTransactionHasFailedTransactionStatus: \"submittedTransactionHasFailedTransactionStatus\",\n  submittedTransactionHasRejectedTransactionStatus: \"submittedTransactionHasRejectedTransactionStatus\",\n  failedToFindAccountWithEnoughFundsToLockFee: \"failedToFindAccountWithEnoughFundsToLockFee\",\n  wrongAccountType: \"wrongAccountType\",\n  unknownWebsite: \"unknownWebsite\",\n  radixJsonNotFound: \"radixJsonNotFound\",\n  unknownDappDefinitionAddress: \"unknownDappDefinitionAddress\",\n  invalidPersona: \"invalidPersona\"\n};\nvar defaultErrorMessage = (/* @__PURE__ */ new Map()).set(ErrorType.missingExtension, \"extension could not be found\").set(ErrorType.rejectedByUser, \"user rejected request\").set(ErrorType.canceledByUser, \"user has canceled the request\");\nvar SdkError = (error, interactionId, message, jsError) => ({\n  error,\n  interactionId,\n  message: message || defaultErrorMessage.get(error) || \"\",\n  jsError\n});\n\n// src/modules/wallet-request/request-items/request-item.module.ts\nimport { errAsync } from \"neverthrow\";\nvar RequestItemModule = (input) => {\n  const logger = input?.logger?.getSubLogger({ name: \"RequestItemModule\" });\n  const subscriptions = new Subscription2();\n  const storageModule = input.providers.storageModule;\n  const signals = /* @__PURE__ */ new Map();\n  const createItem = ({\n    type,\n    walletInteraction,\n    isOneTimeRequest\n  }) => ({\n    type,\n    status: \"pending\",\n    createdAt: Date.now(),\n    interactionId: walletInteraction.interactionId,\n    showCancel: true,\n    walletInteraction,\n    isOneTimeRequest\n  });\n  const add = (value, onSignal) => {\n    const item = createItem(value);\n    logger?.debug({\n      method: \"addRequestItem\",\n      item\n    });\n    if (onSignal) {\n      signals.set(item.interactionId, onSignal);\n    }\n    return storageModule.setItems({ [item.interactionId]: item }).map(() => item);\n  };\n  const getAndRemoveSignal = (interactionId) => {\n    if (signals.has(interactionId)) {\n      const signal = signals.get(interactionId);\n      signals.delete(interactionId);\n      return signal;\n    }\n  };\n  const patch = (id, partialValue) => {\n    logger?.debug({\n      method: \"patchRequestItemStatus\",\n      item: { id, ...partialValue }\n    });\n    return storageModule.patchItem(id, partialValue);\n  };\n  const cancel = (id) => {\n    logger?.debug({ method: \"cancelRequestItem\", id });\n    return patch(id, { status: \"fail\", error: ErrorType.canceledByUser });\n  };\n  const isWalletInteractionRequired = (status) => [RequestStatus.pending, RequestStatus.pendingCommit].includes(\n    status\n  );\n  const updateStatus = ({\n    id,\n    status,\n    error,\n    transactionIntentHash,\n    metadata = {},\n    walletData,\n    walletResponse\n  }) => {\n    return storageModule.getItemById(id).mapErr(() => ({ reason: \"couldNotReadFromStore\" })).andThen((item) => {\n      if (item) {\n        if (status === RequestStatus.ignored && signals.has(id)) {\n          signals.delete(id);\n        }\n        if (status === RequestStatus.success) {\n          const signal = getAndRemoveSignal(id);\n          signal?.(metadata?.parentTransactionIntentHash);\n        }\n        const updated = {\n          ...item,\n          walletData,\n          transactionIntentHash,\n          error,\n          walletResponse,\n          status: item.status === RequestStatus.ignored ? item.status : status,\n          metadata: item.metadata ? { ...item.metadata, ...metadata } : metadata\n        };\n        if (!isWalletInteractionRequired(updated.status)) {\n          delete updated.walletInteraction;\n        }\n        logger?.debug({ method: \"updateRequestItemStatus\", updated });\n        return storageModule.setItems({ [id]: updated }).mapErr(() => ({ reason: \"couldNotWriteToStore\" }));\n      }\n      return errAsync({ reason: \"itemNotFound\" });\n    });\n  };\n  const getPendingCommit = () => storageModule.getItemList().map(\n    (items) => items.filter((item) => item.status === RequestStatus.pendingCommit)\n  );\n  const getPending = () => storageModule.getItemList().map((items) => items.filter((item) => item.status === \"pending\"));\n  const requests$ = storageModule.storage$.pipe(\n    switchMap(() => storageModule.getItemList()),\n    map((result) => {\n      if (result.isOk()) return result.value;\n    }),\n    filter2((items) => !!items)\n  );\n  return {\n    add,\n    cancel,\n    updateStatus,\n    patch,\n    getAndRemoveSignal,\n    getById: (id) => storageModule.getItemById(id),\n    getPendingCommit,\n    getPending,\n    requests$,\n    clear: storageModule.clear,\n    destroy: () => {\n      subscriptions.unsubscribe();\n    }\n  };\n};\n\n// src/modules/wallet-request/session/session.module.ts\nimport { okAsync as okAsync4 } from \"neverthrow\";\nimport { v4 as uuidV4 } from \"uuid\";\nvar SessionModule = (input) => {\n  const storageModule = input.providers.storageModule;\n  const getSession = () => storageModule.getItemList().mapErr((error) => ({\n    reason: \"couldNotReadSessionFromStore\",\n    jsError: error\n  })).map((sessions) => sessions[0]);\n  const getSessionById = (sessionId) => storageModule.getItemById(sessionId).mapErr((error) => ({ reason: \"couldNotGetSessionById\", jsError: error }));\n  const createSession = () => {\n    const sessionId = uuidV4();\n    const newSession = {\n      sessionId,\n      createdAt: Date.now()\n    };\n    return storageModule.setItems({ [sessionId]: newSession }).map(() => newSession).mapErr((error) => ({ reason: \"couldNotCreateSession\", jsError: error }));\n  };\n  const patchSession = (sessionId, value) => storageModule.patchItem(sessionId, value).mapErr((error) => ({ reason: \"couldNotPatchSession\", jsError: error }));\n  const getCurrentSession = () => getSession().andThen(\n    (session) => session ? okAsync4(session) : createSession()\n  );\n  return {\n    getCurrentSession,\n    getSession,\n    store: storageModule,\n    getSessionById,\n    patchSession\n  };\n};\n\n// src/modules/wallet-request/transport/connector-extension/subjects.ts\nimport { Subject as Subject2 } from \"rxjs\";\nvar ConnectorExtensionSubjects = () => ({\n  outgoingMessageSubject: new Subject2(),\n  incomingMessageSubject: new Subject2(),\n  responseSubject: new Subject2(),\n  messageLifeCycleEventSubject: new Subject2()\n});\n\n// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts\nimport { ResultAsync as ResultAsync6, err as err7, ok as ok9, okAsync as okAsync6 } from \"neverthrow\";\nimport {\n  Subject as Subject4,\n  Subscription as Subscription3,\n  filter as filter3,\n  first,\n  firstValueFrom as firstValueFrom2,\n  from,\n  map as map3,\n  merge as merge2,\n  mergeMap,\n  of as of2,\n  race,\n  share,\n  shareReplay,\n  switchMap as switchMap3,\n  takeUntil,\n  tap,\n  timer as timer2\n} from \"rxjs\";\n\n// src/helpers/exponential-backoff.ts\nimport { err as err4, ok as ok6 } from \"neverthrow\";\nimport { map as map2, merge, of, Subject as Subject3, switchMap as switchMap2, timer } from \"rxjs\";\nvar ExponentialBackoff = ({\n  maxDelayTime = 1e4,\n  multiplier = 2,\n  timeout,\n  interval = 2e3\n} = {}) => {\n  const trigger = new Subject3();\n  const stop = new Subject3();\n  let numberOfRetries = 0;\n  const backoff$ = merge(\n    of(0),\n    trigger.pipe(\n      map2(() => {\n        numberOfRetries = numberOfRetries + 1;\n        return numberOfRetries;\n      })\n    )\n  ).pipe(\n    switchMap2((numberOfRetries2) => {\n      const delayTime = numberOfRetries2 * interval * multiplier;\n      const delay2 = delayTime > maxDelayTime ? maxDelayTime : delayTime;\n      return timer(delay2).pipe(map2(() => ok6(numberOfRetries2)));\n    })\n  );\n  const withBackoffAndTimeout$ = merge(\n    stop.asObservable().pipe(map2(() => err4({ error: \"stopped\" }))),\n    timeout ? merge(\n      backoff$,\n      timer(timeout).pipe(map2(() => err4({ error: \"timeout\" })))\n    ) : backoff$\n  );\n  return {\n    trigger,\n    withBackoff$: withBackoffAndTimeout$,\n    stop: () => stop.next()\n  };\n};\n\n// src/helpers/fetch-wrapper.ts\nimport { ResultAsync as ResultAsync4, errAsync as errAsync2, okAsync as okAsync5 } from \"neverthrow\";\n\n// src/helpers/parse-json.ts\nimport { err as err5, ok as ok7 } from \"neverthrow\";\nvar parseJSON = (text) => {\n  try {\n    return ok7(JSON.parse(text));\n  } catch (error) {\n    return err5(error);\n  }\n};\n\n// src/helpers/fetch-wrapper.ts\nvar typedError = (error) => error;\nvar resolveFetch = (fetchable) => ResultAsync4.fromPromise(fetchable, typedError).mapErr((error) => ({\n  reason: \"FailedToFetch\",\n  error,\n  status: 0\n}));\nvar fetchWrapper = (fetchable) => resolveFetch(fetchable).andThen(\n  (response) => ResultAsync4.fromPromise(response.text(), typedError).andThen((text) => text ? parseJSON(text) : okAsync5(text)).mapErr((error) => ({\n    status: response.status,\n    reason: \"FailedToParseResponseToJson\",\n    error\n  })).andThen(\n    (data) => response.ok ? okAsync5({\n      status: response.status,\n      data\n    }) : errAsync2({\n      status: response.status,\n      reason: \"RequestStatusNotOk\",\n      data\n    })\n  )\n);\n\n// src/helpers/logger.ts\nimport { Logger as TsLogger } from \"tslog\";\nvar Logger = (minLevel) => new TsLogger({\n  minLevel: minLevel ?? 2,\n  prettyLogTemplate: \"{{hh}}:{{MM}}:{{ss}}:{{ms}}\t{{name}}\t{{logLevelName}}\t\"\n});\n\n// src/helpers/stringify.ts\nimport { err as err6, ok as ok8 } from \"neverthrow\";\nvar stringify = (input) => {\n  try {\n    return ok8(JSON.stringify(input));\n  } catch (error) {\n    return err6(error);\n  }\n};\n\n// src/helpers/remove-undefined.ts\nvar removeUndefined = (input) => stringify(input).andThen(parseJSON);\n\n// src/helpers/typed-error.ts\nvar typedError2 = (error) => error;\n\n// src/helpers/unwrap-observable.ts\nimport { ResultAsync as ResultAsync5 } from \"neverthrow\";\nimport { firstValueFrom } from \"rxjs\";\nvar unwrapObservable = (input) => ResultAsync5.fromPromise(\n  firstValueFrom(input),\n  (error) => error\n).andThen((result) => result);\n\n// src/helpers/validate-wallet-response.ts\nimport { Result as Result3 } from \"neverthrow\";\nimport { parse } from \"valibot\";\nvar validateWalletResponse = (walletResponse) => {\n  const fn = Result3.fromThrowable(\n    (_) => parse(WalletInteractionResponse, _),\n    (error) => error\n  );\n  return fn(walletResponse).mapErr(\n    (response) => SdkError(\n      \"walletResponseValidation\",\n      walletResponse?.interactionId,\n      \"Invalid input\",\n      response\n    )\n  );\n};\n\n// src/helpers/generate-rola-challenge.ts\nvar generateRolaChallenge = () => [...globalThis.crypto.getRandomValues(new Uint8Array(32))].map((x) => x.toString(16).padStart(2, \"0\")).join(\"\");\n\n// src/helpers/validate-rola-challenge.ts\nvar validateRolaChallenge = (challenge) => typeof challenge === \"string\" && /^[0-9a-f]{64}$/i.test(challenge);\n\n// src/helpers/parse-signed-challenge.ts\nimport { safeParse } from \"valibot\";\nvar parseSignedChallenge = (value) => safeParse(SignedChallenge, value);\n\n// src/modules/wallet-request/transport/connector-extension/connector-extension.module.ts\nimport { v4 as uuidV42 } from \"uuid\";\nvar ConnectorExtensionModule = (input) => {\n  let isExtensionHandlingSessions = false;\n  const logger = input?.logger?.getSubLogger({\n    name: \"ConnectorExtensionModule\"\n  });\n  const subjects = input?.subjects ?? ConnectorExtensionSubjects();\n  const subscription = new Subscription3();\n  const extensionDetectionTime = input?.extensionDetectionTime ?? 200;\n  const requestResolverModule = input.providers.requestResolverModule;\n  const storage = input.providers.storageModule.getPartition(\"connectorExtension\");\n  subscription.add(\n    subjects.incomingMessageSubject.pipe(\n      tap((message) => {\n        logger?.debug({\n          method: \"incomingMessageSubject\",\n          message\n        });\n        if (\"eventType\" in message) {\n          subjects.messageLifeCycleEventSubject.next(message);\n        } else {\n          subjects.responseSubject.next(message);\n        }\n      })\n    ).subscribe()\n  );\n  subscription.add(\n    subjects.responseSubject.pipe(\n      mergeMap(\n        (walletResponse) => from(requestResolverModule.addWalletResponses([walletResponse]))\n      )\n    ).subscribe()\n  );\n  subscription.add(\n    subjects.outgoingMessageSubject.pipe(\n      tap((payload) => {\n        logger?.debug({\n          method: \"outgoingMessageSubject\",\n          payload\n        });\n        input.providers.environmentModule.globalThis.dispatchEvent(\n          new CustomEvent(eventType.outgoingMessage, {\n            detail: payload\n          })\n        );\n      })\n    ).subscribe()\n  );\n  const wrapOutgoingInteraction = (interaction) => {\n    if (!isExtensionHandlingSessions) {\n      return okAsync6(interaction);\n    }\n    return storage.getState().andThen((state) => {\n      const isAuthorizedRequest = interaction.items.discriminator === \"authorizedRequest\";\n      const sessionId = isAuthorizedRequest ? state?.sessionId || uuidV42() : state?.sessionId;\n      const wrappedRequest = {\n        interactionId: interaction.interactionId,\n        interaction,\n        sessionId,\n        discriminator: \"walletInteraction\"\n      };\n      return isAuthorizedRequest ? storage.setState({ sessionId }).map(() => wrappedRequest) : okAsync6(wrappedRequest);\n    });\n  };\n  const handleIncomingMessage = (event) => {\n    const message = event.detail;\n    subjects.incomingMessageSubject.next(message);\n  };\n  addEventListener(eventType.incomingMessage, handleIncomingMessage);\n  const sendWalletInteraction = (walletInteraction, callbackFns) => {\n    const cancelRequestSubject = new Subject4();\n    const maybeResolved$ = from(\n      requestResolverModule.getWalletResponseById(\n        walletInteraction.interactionId\n      )\n    ).pipe(filter3((result) => result.isOk() && !!result.value));\n    const walletResponse$ = subjects.responseSubject.pipe(\n      filter3(\n        (response) => response.interactionId === walletInteraction.interactionId\n      ),\n      map3((walletResponse) => ok9(walletResponse))\n    );\n    const cancelResponse$ = subjects.messageLifeCycleEventSubject.pipe(\n      filter3(\n        ({ interactionId, eventType: eventType2 }) => walletInteraction.interactionId === interactionId && [\"requestCancelSuccess\", \"requestCancelFail\"].includes(eventType2)\n      ),\n      map3((message) => {\n        const error = SdkError(\"canceledByUser\", message.interactionId);\n        logger?.debug(`\\u{1F535}\\u2B06\\uFE0F\\u274C walletRequestCanceled`, error);\n        return message;\n      })\n    );\n    const sendCancelRequest = () => {\n      subjects.outgoingMessageSubject.next({\n        interactionId: walletInteraction.interactionId,\n        metadata: walletInteraction.metadata,\n        ...isExtensionHandlingSessions ? { discriminator: \"cancelWalletInteraction\" } : { items: { discriminator: \"cancelRequest\" } }\n      });\n      setTimeout(() => {\n        cancelRequestSubject.next(\n          err7(SdkError(\"canceledByUser\", walletInteraction.interactionId))\n        );\n      });\n      return ResultAsync6.fromSafePromise(\n        firstValueFrom2(\n          merge2(\n            walletResponse$.pipe(map3(() => \"requestCancelFail\")),\n            cancelResponse$.pipe(map3(({ eventType: eventType2 }) => eventType2))\n          )\n        )\n      );\n    };\n    if (callbackFns.requestControl)\n      callbackFns.requestControl({\n        cancelRequest: () => sendCancelRequest().andThen(\n          (eventType2) => eventType2 === \"requestCancelSuccess\" ? ok9(\"requestCancelSuccess\") : err7(\"requestCancelFail\")\n        ),\n        getRequest: () => walletInteraction\n      });\n    const walletResponseOrCancelRequest$ = merge2(\n      maybeResolved$,\n      walletResponse$,\n      cancelRequestSubject\n    ).pipe(first());\n    const messageLifeCycleEvent$ = subjects.messageLifeCycleEventSubject.pipe(\n      filter3(\n        ({ interactionId }) => walletInteraction.interactionId === interactionId\n      ),\n      tap((event) => {\n        if (callbackFns.eventCallback)\n          callbackFns.eventCallback(event.eventType);\n      }),\n      takeUntil(walletResponse$),\n      share()\n    );\n    const messageEventSubscription = messageLifeCycleEvent$.subscribe();\n    const missingExtensionError$ = timer2(extensionDetectionTime).pipe(\n      map3(\n        () => err7(SdkError(\"missingExtension\", walletInteraction.interactionId))\n      )\n    );\n    const extensionMissingError$ = merge2(\n      missingExtensionError$,\n      messageLifeCycleEvent$\n    ).pipe(\n      first(),\n      filter3((value) => !(\"eventType\" in value))\n    );\n    const sendWalletRequest$ = extensionStatus$.pipe(\n      filter3((status) => status.isExtensionAvailable),\n      switchMap3(() => of2(wrapOutgoingInteraction(walletInteraction))),\n      tap((result) => {\n        result.map((message) => {\n          subjects.outgoingMessageSubject.next(message);\n        });\n      }),\n      filter3((_) => false)\n    );\n    return unwrapObservable(\n      merge2(\n        walletResponseOrCancelRequest$,\n        extensionMissingError$,\n        sendWalletRequest$\n      ).pipe(\n        tap(() => {\n          messageEventSubscription.unsubscribe();\n        })\n      )\n    );\n  };\n  const extensionStatusEvent$ = subjects.messageLifeCycleEventSubject.pipe(\n    filter3(\n      (event) => event.eventType === \"extensionStatus\"\n    )\n  );\n  const extensionStatus$ = of2(true).pipe(\n    tap(() => {\n      subjects.outgoingMessageSubject.next({\n        interactionId: uuidV42(),\n        discriminator: \"extensionStatus\"\n      });\n    }),\n    switchMap3(\n      () => race(\n        extensionStatusEvent$,\n        merge2(\n          extensionStatusEvent$,\n          timer2(extensionDetectionTime).pipe(\n            map3(\n              () => ({\n                eventType: \"extensionStatus\",\n                isWalletLinked: false,\n                isExtensionAvailable: false,\n                canHandleSessions: false\n              })\n            )\n          )\n        )\n      )\n    ),\n    tap((event) => {\n      isExtensionHandlingSessions = event.canHandleSessions || false;\n    }),\n    shareReplay(1)\n  );\n  return {\n    id: \"connector-extension\",\n    isSupported: () => !input.providers.environmentModule.isMobile(),\n    send: sendWalletInteraction,\n    isAvailable$: extensionStatus$.pipe(\n      map3(({ isExtensionAvailable }) => isExtensionAvailable)\n    ),\n    isLinked$: extensionStatus$.pipe(\n      map3(({ isWalletLinked }) => isWalletLinked)\n    ),\n    showQrCode: () => {\n      input.providers.environmentModule.globalThis.dispatchEvent(\n        new CustomEvent(eventType.outgoingMessage, {\n          detail: { discriminator: \"openPopup\" }\n        })\n      );\n    },\n    disconnect: () => {\n      storage.clear();\n    },\n    destroy: () => {\n      subscription.unsubscribe();\n      removeEventListener(eventType.incomingMessage, handleIncomingMessage);\n    }\n  };\n};\n\n// src/modules/wallet-request/transport/radix-connect-relay/deep-link.module.ts\nimport { errAsync as errAsync3, okAsync as okAsync7 } from \"neverthrow\";\nvar DeepLinkModule = (input) => {\n  const { walletUrl } = input;\n  const logger = input?.logger?.getSubLogger({ name: \"DeepLinkModule\" });\n  const isTelegramMiniApp = input.providers.environmentModule.isTMA();\n  const deepLinkToWallet = (values) => {\n    const outboundUrl = new URL(walletUrl);\n    Object.entries(values).forEach(([key, value]) => {\n      outboundUrl.searchParams.append(key, value);\n    });\n    logger?.debug({\n      method: \"deepLinkToWallet\",\n      data: { ...values }\n    });\n    if (input.providers.environmentModule.isMobile()) {\n      const deepLink = outboundUrl.toString();\n      if (isTelegramMiniApp)\n        input.providers.environmentModule.globalThis.open(deepLink, \"_blank\");\n      else if (input.providers.environmentModule.globalThis.location?.href)\n        input.providers.environmentModule.globalThis.location.href = deepLink;\n      return okAsync7(void 0);\n    }\n    return errAsync3(SdkError(\"UnhandledEnvironment\", \"\"));\n  };\n  return {\n    deepLinkToWallet\n  };\n};\n\n// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts\nimport { ResultAsync as ResultAsync8, errAsync as errAsync4 } from \"neverthrow\";\nimport { Subscription as Subscription4 } from \"rxjs\";\n\n// src/modules/wallet-request/encryption/helpers/buffer-reader.ts\nimport { err as err8, ok as ok10 } from \"neverthrow\";\nimport { Buffer as Buffer6 } from \"buffer\";\nvar createBufferReader = (buffer) => {\n  let offset = 0;\n  let bytesLeftToRead = buffer.length;\n  const readNextBuffer = (byteCount) => {\n    if (byteCount < 0) return err8(Error(`'byteCount' must not be negative`));\n    if (byteCount === 0) {\n      return ok10(Buffer6.alloc(0));\n    }\n    if (offset + byteCount > buffer.length)\n      return err8(Error(`Out of buffer's boundary`));\n    const bufToReturn = Buffer6.alloc(byteCount);\n    buffer.copy(bufToReturn, 0, offset, offset + byteCount);\n    if (bufToReturn.length !== byteCount) {\n      return err8(Error(`Incorrect length of newly read buffer...`));\n    }\n    offset += byteCount;\n    bytesLeftToRead -= byteCount;\n    return ok10(bufToReturn);\n  };\n  const finishedParsing = () => {\n    if (bytesLeftToRead < 0) {\n      return err8(Error(`Incorrect implementation, read too many bytes.`));\n    }\n    return ok10(bytesLeftToRead === 0);\n  };\n  return {\n    readNextBuffer,\n    finishedParsing,\n    remainingBytes: () => finishedParsing().andThen((finished) => {\n      if (finished) return ok10(Buffer6.alloc(0));\n      const leftBuf = Buffer6.alloc(bytesLeftToRead);\n      buffer.copy(leftBuf, 0, offset);\n      return ok10(leftBuf);\n    })\n  };\n};\nvar readBuffer = (buffer) => createBufferReader(buffer).readNextBuffer;\n\n// src/modules/wallet-request/encryption/helpers/sealbox.ts\nimport { Buffer as Buffer7 } from \"buffer\";\nimport { Result as Result5 } from \"neverthrow\";\nvar transformBufferToSealbox = (buffer) => {\n  const readNextBuffer = readBuffer(buffer);\n  const nonceLength = 12;\n  const authTagLength = 16;\n  return Result5.combine([\n    readNextBuffer(nonceLength),\n    readNextBuffer(buffer.length - nonceLength - authTagLength),\n    readNextBuffer(authTagLength)\n  ]).map(([iv, ciphertext, authTag]) => ({\n    iv,\n    ciphertext,\n    authTag,\n    combined: Buffer7.concat([iv, ciphertext, authTag]),\n    ciphertextAndAuthTag: Buffer7.concat([ciphertext, authTag])\n  }));\n};\n\n// src/modules/wallet-request/encryption/encryption.module.ts\nimport { ResultAsync as ResultAsync7 } from \"neverthrow\";\nimport { Buffer as Buffer8 } from \"buffer\";\nvar EncryptionModule = () => {\n  const cryptoDecrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(\n    crypto.subtle.decrypt({ name: \"AES-GCM\", iv }, encryptionKey, data),\n    typedError2\n  ).map(Buffer8.from);\n  const cryptoEncrypt = (data, encryptionKey, iv) => ResultAsync7.fromPromise(\n    crypto.subtle.encrypt(\n      {\n        name: \"AES-GCM\",\n        iv\n      },\n      encryptionKey,\n      data\n    ),\n    typedError2\n  ).map(Buffer8.from);\n  const getKey = (encryptionKey) => ResultAsync7.fromPromise(\n    crypto.subtle.importKey(\n      \"raw\",\n      encryptionKey,\n      {\n        name: \"AES-GCM\",\n        length: 256\n      },\n      false,\n      [\"encrypt\", \"decrypt\"]\n    ),\n    typedError2\n  );\n  const decrypt = (data, encryptionKey, iv) => getKey(encryptionKey).andThen(\n    (cryptoKey) => cryptoDecrypt(data, cryptoKey, iv)\n  );\n  const encrypt = (data, encryptionKey, iv = createIV()) => getKey(encryptionKey).andThen((cryptoKey) => cryptoEncrypt(data, cryptoKey, iv)).map((ciphertext) => ({\n    combined: Buffer8.concat([iv, ciphertext]),\n    iv,\n    ciphertext\n  }));\n  const createIV = () => Buffer8.from(crypto.getRandomValues(new Uint8Array(12)));\n  return { encrypt, decrypt, createIV };\n};\n\n// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay-api.service.ts\nvar RadixConnectRelayApiService = (input) => {\n  const baseUrl = input.baseUrl;\n  const logger = input.logger?.getSubLogger({ name: \"RadixConnectRelayApi\" });\n  const callApi = (body) => {\n    logger?.debug({ method: `callApi.${body.method}`, body });\n    return fetchWrapper(\n      fetch(baseUrl, {\n        method: \"POST\",\n        body: JSON.stringify(body)\n      })\n    ).map((response) => {\n      logger?.debug({\n        method: `callApi.${body.method}.success`,\n        response\n      });\n      return response;\n    }).mapErr((error) => {\n      logger?.debug({\n        method: `callApi.${body.method}.error`,\n        error\n      });\n      return SdkError(\n        \"RadixConnectRelayRequestFailed\",\n        body.interactionId ?? \"\"\n      );\n    });\n  };\n  const getResponses = (sessionId) => callApi({\n    method: \"getResponses\",\n    sessionId\n  }).map((value) => value.data);\n  return {\n    getResponses\n  };\n};\n\n// src/modules/wallet-request/transport/radix-connect-relay/helpers/base64url.ts\nimport base64url from \"base64url\";\nvar base64urlEncode = (value) => base64url.encode(Buffer.from(JSON.stringify(value)));\n\n// src/modules/wallet-request/transport/radix-connect-relay/radix-connect-relay.module.ts\nvar RadixConnectRelayModule = (input) => {\n  const logger = input.logger?.getSubLogger({ name: \"RadixConnectRelayModule\" });\n  const { baseUrl, providers, walletUrl } = input;\n  const { storageModule, requestResolverModule } = providers;\n  const encryptionModule = providers?.encryptionModule ?? EncryptionModule();\n  const deepLinkModule = providers?.deepLinkModule ?? DeepLinkModule({\n    logger,\n    walletUrl,\n    providers: {\n      environmentModule: input.providers.environmentModule\n    }\n  });\n  const identityModule = providers?.identityModule ?? IdentityModule({\n    logger,\n    dAppDefinitionAddress: input.dAppDefinitionAddress,\n    providers: {\n      storageModule: storageModule.getPartition(\"identities\"),\n      KeyPairModule: Curve25519\n    }\n  });\n  const sessionModule = providers?.sessionModule ?? SessionModule({\n    providers: {\n      storageModule: storageModule.getPartition(\"sessions\")\n    }\n  });\n  const radixConnectRelayApiService = RadixConnectRelayApiService({\n    baseUrl: `${baseUrl}/api/v1`,\n    logger\n  });\n  const subscriptions = new Subscription4();\n  const wait = (timer3 = 1500) => new Promise((resolve) => setTimeout(resolve, timer3));\n  const decryptWalletResponse = (walletResponse) => {\n    if (\"error\" in walletResponse) {\n      return errAsync4({ reason: walletResponse.error });\n    }\n    return identityModule.get(\"dApp\").andThen(\n      (dAppIdentity) => dAppIdentity.x25519.calculateSharedSecret(\n        walletResponse.publicKey,\n        input.dAppDefinitionAddress\n      ).mapErr(() => ({ reason: \"FailedToDeriveSharedSecret\" })).asyncAndThen(\n        (sharedSecret) => decryptWalletResponseData(sharedSecret, walletResponse.data)\n      )\n    );\n  };\n  const checkRelayLoop = async () => {\n    await requestResolverModule.getPendingRequestIds().andThen(\n      () => sessionModule.getCurrentSession().map((session) => session.sessionId).andThen(radixConnectRelayApiService.getResponses).andThen(\n        (responses) => ResultAsync8.combine(responses.map(decryptWalletResponse))\n      ).andThen(requestResolverModule.addWalletResponses)\n    );\n    await wait();\n    checkRelayLoop();\n  };\n  if (input.providers.environmentModule.isMobile()) {\n    checkRelayLoop();\n  }\n  const sendWalletInteractionRequest = ({\n    session,\n    walletInteraction,\n    signature,\n    publicKey,\n    identity\n  }) => requestResolverModule.getPendingRequestById(walletInteraction.interactionId).andThen(\n    () => requestResolverModule.markRequestAsSent(\n      walletInteraction.interactionId\n    )\n  ).andThen(\n    () => deepLinkModule.deepLinkToWallet({\n      sessionId: session.sessionId,\n      request: base64urlEncode(walletInteraction),\n      signature,\n      publicKey,\n      identity,\n      origin: walletInteraction.metadata.origin,\n      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress\n    })\n  ).mapErr(\n    () => SdkError(\"FailedToSendDappRequest\", walletInteraction.interactionId)\n  );\n  const sendToWallet = (walletInteraction, callbackFns) => ResultAsync8.combine([\n    sessionModule.getCurrentSession().mapErr(\n      (error) => SdkError(error.reason, walletInteraction.interactionId)\n    ),\n    identityModule.get(\"dApp\").mapErr(\n      (error) => SdkError(error.reason, walletInteraction.interactionId)\n    )\n  ]).andThen(\n    ([session, dAppIdentity]) => identityModule.createSignature({\n      dAppDefinitionAddress: walletInteraction.metadata.dAppDefinitionAddress,\n      interactionId: walletInteraction.interactionId,\n      origin: walletInteraction.metadata.origin,\n      kind: \"dApp\"\n    }).mapErr(\n      (error) => SdkError(error.reason, walletInteraction.interactionId)\n    ).andThen(\n      ({ signature }) => sendWalletInteractionRequest({\n        session,\n        walletInteraction,\n        signature,\n        identity: dAppIdentity.ed25519.getPublicKey(),\n        publicKey: dAppIdentity.x25519.getPublicKey()\n      })\n    ).andThen(\n      () => requestResolverModule.waitForWalletResponse(\n        walletInteraction.interactionId\n      )\n    ).map((requestItem) => requestItem.walletResponse)\n  );\n  const decryptWalletResponseData = (sharedSecretHex, value) => transformBufferToSealbox(Buffer.from(value, \"hex\")).asyncAndThen(\n    ({ ciphertextAndAuthTag, iv }) => encryptionModule.decrypt(\n      ciphertextAndAuthTag,\n      Buffer.from(sharedSecretHex, \"hex\"),\n      iv\n    )\n  ).andThen(\n    (decrypted) => parseJSON(decrypted.toString(\"utf-8\"))\n  ).mapErr((error) => ({\n    reason: \"FailedToDecryptWalletResponseData\",\n    jsError: error\n  }));\n  return {\n    id: \"radix-connect-relay\",\n    isSupported: () => input.providers.environmentModule.isMobile(),\n    send: sendToWallet,\n    disconnect: () => {\n    },\n    destroy: () => {\n      subscriptions.unsubscribe();\n    }\n  };\n};\n\n// src/modules/wallet-request/wallet-request-sdk.ts\nimport { ResultAsync as ResultAsync9, err as err9, errAsync as errAsync5, ok as ok11, okAsync as okAsync8 } from \"neverthrow\";\nimport { parse as parse2 } from \"valibot\";\nimport { v4 as uuidV43 } from \"uuid\";\nvar WalletRequestSdk = (input) => {\n  const metadata = {\n    version: 2,\n    dAppDefinitionAddress: input.dAppDefinitionAddress,\n    networkId: input.networkId,\n    origin: input.origin || input.providers.environmentModule.globalThis?.location?.origin || \"\"\n  };\n  const interactionIdFactory = input.providers.interactionIdFactory ?? uuidV43;\n  parse2(Metadata, metadata);\n  const logger = input?.logger?.getSubLogger({ name: \"WalletSdk\" });\n  const availableTransports = input.providers.transports;\n  const requestInterceptorDefault = async (walletInteraction) => walletInteraction;\n  const requestInterceptor = input.requestInterceptor ?? requestInterceptorDefault;\n  logger?.debug({ metadata });\n  const createWalletInteraction = (items, interactionId = interactionIdFactory()) => ({\n    items,\n    interactionId,\n    metadata\n  });\n  const withInterceptor = (payload) => ResultAsync9.fromPromise(\n    requestInterceptor(payload),\n    (error) => SdkError(\"requestInterceptorError\", payload.interactionId, error.message)\n  );\n  const getTransport = (interactionId) => {\n    const transport = availableTransports.find(\n      (transport2) => transport2.isSupported()\n    );\n    return transport ? ok11(transport) : err9({\n      error: \"SupportedTransportNotFound\",\n      interactionId,\n      message: \"No supported transport found\"\n    });\n  };\n  const sendInteraction = ({\n    interactionId = uuidV43(),\n    items\n  }, callbackFns = {}) => withInterceptor({\n    items,\n    interactionId,\n    metadata\n  }).andThen(\n    (walletInteraction) => getTransport(walletInteraction.interactionId).asyncAndThen(\n      (transport) => transport.send(walletInteraction, callbackFns)\n    ).andThen(\n      (response) => response.discriminator === \"failure\" ? errAsync5(response) : okAsync8(response)\n    )\n  );\n  return {\n    sendInteraction,\n    createWalletInteraction,\n    getTransport\n  };\n};\n\n// src/modules/wallet-request/wallet-request.ts\nimport {\n  Subject as Subject6,\n  Subscription as Subscription6,\n  filter as filter6,\n  firstValueFrom as firstValueFrom5,\n  map as map5,\n  switchMap as switchMap5,\n  tap as tap3\n} from \"rxjs\";\nimport { ResultAsync as ResultAsync14, err as err16, ok as ok14, okAsync as okAsync14 } from \"neverthrow\";\n\n// src/modules/wallet-request/request-resolver/request-resolver.module.ts\nimport { err as err10, ok as ok12, okAsync as okAsync9, Result as Result7, ResultAsync as ResultAsync10 } from \"neverthrow\";\nimport { filter as filter4, firstValueFrom as firstValueFrom3, map as map4 } from \"rxjs\";\nvar RequestResolverModule = (input) => {\n  const WAIT_TIME = 1e3;\n  const { providers } = input;\n  const { requestItemModule, storageModule, resolvers } = providers;\n  const logger = input.logger?.getSubLogger({ name: \"RequestResolverModule\" });\n  let shouldRun = true;\n  const walletResponses = storageModule.getPartition(\"walletResponses\");\n  const getPendingRequests = () => requestItemModule.getPending().orElse((error) => {\n    logger?.error({ method: \"getPendingRequests\", error });\n    return ok12([]);\n  }).andThen(\n    (pendingItems) => pendingItems.length === 0 ? err10(\"PendingItemsNotFound\") : ok12(pendingItems)\n  );\n  const getPendingRequestById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError(\"FailedToGetPendingItems\", interactionId)).andThen(\n    (pendingItem) => pendingItem?.status === \"pending\" ? ok12(pendingItem) : err10(SdkError(\"PendingItemNotFound\", interactionId))\n  );\n  const getWalletResponseById = (interactionId) => requestItemModule.getById(interactionId).mapErr(() => SdkError(\"FailedToGetWalletResponse\", interactionId)).map((item) => item?.walletResponse);\n  const markRequestAsSent = (interactionId) => requestItemModule.patch(interactionId, { sentToWallet: true });\n  const addWalletResponses = (responses) => Result7.combine(responses.map(validateWalletResponse)).asyncAndThen(\n    () => walletResponses.setItems(\n      responses.reduce(\n        (acc, response) => {\n          acc[response.interactionId] = response;\n          return acc;\n        },\n        {}\n      )\n    )\n  ).mapErr((error) => logger?.error({ method: \"addWalletResponses\", error }));\n  const toRequestItemMap = (items) => items.reduce(\n    (acc, item) => ({ ...acc, [item.interactionId]: item }),\n    {}\n  );\n  const matchRequestItemToResponses = (requestItems) => {\n    const ids = Object.keys(requestItems);\n    return walletResponses.getItemList().map(\n      (responses) => responses.filter((response) => ids.includes(response.interactionId))\n    ).andThen(\n      (responses) => responses.length ? ok12(responses) : err10(\"WalletResponsesNotFound\")\n    ).map(\n      (responses) => responses.map((response) => ({\n        walletInteractionResponse: response,\n        requestItem: requestItems[response.interactionId]\n      }))\n    );\n  };\n  const resolveRequests = (unresolvedRequests) => ResultAsync10.combine(unresolvedRequests.map(resolveRequest)).map(\n    () => unresolvedRequests\n  );\n  const cleanup = (requestItems) => {\n    return okAsync9(void 0);\n  };\n  const resolveRequest = ({\n    requestItem,\n    walletInteractionResponse\n  }) => {\n    const { walletInteraction } = requestItem;\n    return ResultAsync10.combine(\n      resolvers.map(\n        (resolver) => resolver({ walletInteraction, walletInteractionResponse, requestItem })\n      )\n    );\n  };\n  const waitForWalletResponse = (interactionId) => ResultAsync10.fromSafePromise(\n    firstValueFrom3(\n      requestItemModule.requests$.pipe(\n        filter4(\n          (items) => items.some(\n            (item) => item.interactionId === interactionId && item.status !== \"pending\"\n          )\n        ),\n        map4(\n          (items) => items.find((item) => item.interactionId === interactionId)\n        )\n      )\n    )\n  );\n  const requestResolverLoop = async () => {\n    await getPendingRequests().map(toRequestItemMap).andThen(matchRequestItemToResponses).andThen(resolveRequests).map(\n      (unresolvedRequests) => unresolvedRequests.map((item) => item.requestItem)\n    ).andThen(cleanup);\n    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));\n    if (shouldRun) requestResolverLoop();\n  };\n  requestResolverLoop();\n  return {\n    waitForWalletResponse,\n    getPendingRequestById,\n    getPendingRequestIds: () => getPendingRequests().map(\n      (items) => items.map((item) => item.interactionId)\n    ),\n    markRequestAsSent,\n    addWalletResponses,\n    getWalletResponseById,\n    destroy: () => {\n      shouldRun = false;\n    }\n  };\n};\n\n// src/modules/wallet-request/request-resolver/resolvers/data-response.ts\nimport { err as err11, okAsync as okAsync10 } from \"neverthrow\";\nvar matchResponse = (input) => {\n  if (input.discriminator === \"success\") {\n    if (input.items.discriminator === \"authorizedRequest\" || input.items.discriminator === \"unauthorizedRequest\") {\n      return input.items;\n    }\n  }\n};\nvar useDataRequestController = (getDataRequestController, interactionId) => (walletData) => {\n  const maybeDataRequestController = getDataRequestController();\n  if (!maybeDataRequestController) return okAsync10(walletData);\n  return maybeDataRequestController(walletData).map(() => walletData).mapErr((error) => SdkError(error.error, interactionId, error.message));\n};\nvar handleAuthorizedRequestResponse = ({\n  requestItem,\n  walletInteraction,\n  walletData,\n  stateModule\n}) => stateModule.getState().andThen(\n  (state) => stateModule.setState({\n    loggedInTimestamp: requestItem.type === \"loginRequest\" ? Date.now().toString() : state.loggedInTimestamp,\n    walletData,\n    sharedData: transformWalletRequestToSharedData(\n      walletInteraction,\n      state.sharedData\n    )\n  }).andTee(() => stateModule.emitWalletData())\n).orElse(\n  () => err11(SdkError(\"FailedToUpdateRdtState\", walletInteraction.interactionId))\n);\nvar dataResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse, requestItem }) => {\n  const dataResponse = matchResponse(walletInteractionResponse);\n  if (!dataResponse) return okAsync10(void 0);\n  const { requestItemModule, getDataRequestController, stateModule } = dependencies;\n  const { interactionId } = walletInteraction;\n  return transformWalletResponseToRdtWalletData(dataResponse).andThen(\n    useDataRequestController(getDataRequestController, interactionId)\n  ).andThen(\n    (walletData) => dataResponse.discriminator === \"authorizedRequest\" ? handleAuthorizedRequestResponse({\n      requestItem,\n      walletInteraction,\n      walletData,\n      stateModule\n    }).map(() => walletData) : okAsync10(walletData)\n  ).andThen(\n    (walletData) => requestItemModule.updateStatus({\n      id: walletInteraction.interactionId,\n      status: \"success\",\n      walletData,\n      walletResponse: walletInteractionResponse\n    }).mapErr(\n      (error) => SdkError(error.reason, walletInteraction.interactionId)\n    )\n  ).andTee(() => dependencies.updateConnectButtonStatus(\"success\")).orElse((error) => {\n    dependencies.updateConnectButtonStatus(\"fail\");\n    return err11(error);\n  }).map(() => void 0);\n};\n\n// src/modules/wallet-request/request-resolver/resolvers/failed-response.ts\nimport { err as err12, okAsync as okAsync11 } from \"neverthrow\";\nvar matchResponse2 = (input) => {\n  if (input.discriminator === \"failure\") {\n    return input;\n  }\n};\nvar failedResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {\n  const failedResponse = matchResponse2(walletInteractionResponse);\n  if (!failedResponse) return okAsync11(void 0);\n  const { interactionId } = walletInteraction;\n  const { requestItemModule } = dependencies;\n  return requestItemModule.updateStatus({\n    id: interactionId,\n    status: \"fail\",\n    walletResponse: walletInteractionResponse\n  }).orElse((error) => {\n    dependencies.updateConnectButtonStatus(\"fail\");\n    return err12(SdkError(error.reason, interactionId));\n  }).andTee(() => dependencies.updateConnectButtonStatus(\"fail\")).map(() => void 0);\n};\n\n// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts\nimport { err as err14, okAsync as okAsync12 } from \"neverthrow\";\n\n// src/modules/gateway/types.ts\nvar TransactionStatus = {\n  Unknown: \"Unknown\",\n  CommittedSuccess: \"CommittedSuccess\",\n  CommittedFailure: \"CommittedFailure\",\n  Pending: \"Pending\",\n  Rejected: \"Rejected\"\n};\nvar RadixNetwork = {\n  Mainnet: 1,\n  Stokenet: 2,\n  Gilganet: 32,\n  Enkinet: 33,\n  Hammunet: 34,\n  Nergalnet: 35,\n  Mardunet: 36,\n  Dumunet: 37\n};\nvar RadixNetworkConfig = {\n  Mainnet: {\n    networkName: \"Mainnet\",\n    networkId: RadixNetwork.Mainnet,\n    gatewayUrl: \"https://mainnet.radixdlt.com\",\n    dashboardUrl: \"https://dashboard.radixdlt.com\"\n  },\n  Stokenet: {\n    networkName: \"Stokenet\",\n    networkId: RadixNetwork.Stokenet,\n    gatewayUrl: \"https://babylon-stokenet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://stokenet-dashboard.radixdlt.com\"\n  },\n  Mardunet: {\n    networkName: \"Mardunet\",\n    networkId: RadixNetwork.Mardunet,\n    gatewayUrl: \"https://mardunet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://mardunet-dashboard.rdx-works-main.extratools.works\"\n  },\n  Gilganet: {\n    networkName: \"Gilganet\",\n    networkId: RadixNetwork.Gilganet,\n    gatewayUrl: \"https://gilganet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://gilganet-dashboard.rdx-works-main.extratools.works\"\n  },\n  Enkinet: {\n    networkName: \"Enkinet\",\n    networkId: RadixNetwork.Enkinet,\n    gatewayUrl: \"https://enkinet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://enkinet-dashboard.rdx-works-main.extratools.works\"\n  },\n  Hammunet: {\n    networkName: \"Hammunet\",\n    networkId: RadixNetwork.Hammunet,\n    gatewayUrl: \"https://hammunet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://hammunet-dashboard.rdx-works-main.extratools.works\"\n  },\n  Dumunet: {\n    networkName: \"Dumunet\",\n    networkId: RadixNetwork.Dumunet,\n    gatewayUrl: \"https://dumunet-gateway.radixdlt.com\",\n    dashboardUrl: \"https://dumunet-dashboard.rdx-works-main.extratools.works\"\n  }\n};\nvar RadixNetworkConfigById = Object.values(RadixNetworkConfig).reduce(\n  (prev, config2) => {\n    prev[config2.networkId] = config2;\n    return prev;\n  },\n  {}\n);\n\n// src/modules/gateway/helpers/generate-gateway-api-config.ts\nvar generateGatewayApiConfig = ({\n  networkId,\n  dAppDefinitionAddress,\n  gatewayBaseUrl,\n  applicationName,\n  applicationVersion\n}) => ({\n  basePath: gatewayBaseUrl ?? RadixNetworkConfigById[networkId].gatewayUrl,\n  applicationName: applicationName ?? \"Unknown\",\n  applicationVersion: applicationVersion ?? \"Unknown\",\n  applicationDappDefinitionAddress: dAppDefinitionAddress\n});\n\n// src/version.ts\nvar __VERSION__ = \"2.2.1\";\n\n// src/modules/gateway/gateway.service.ts\nvar GatewayApiService = ({\n  basePath,\n  applicationName,\n  applicationVersion,\n  applicationDappDefinitionAddress\n}) => {\n  const fetchWithHeaders = (url, body) => fetchWrapper(\n    fetch(`${basePath}${url}`, {\n      method: \"POST\",\n      body: JSON.stringify(body),\n      headers: {\n        \"Content-Type\": \"application/json\",\n        \"RDX-Client-Name\": \"@radixdlt/radix-dapp-toolkit\",\n        \"RDX-Client-Version\": __VERSION__,\n        \"RDX-App-Name\": applicationName,\n        \"RDX-App-Version\": applicationVersion,\n        \"RDX-App-Dapp-Definition\": applicationDappDefinitionAddress\n      }\n    })\n  ).map((response) => response.data);\n  const getTransactionStatus = (transactionIntentHash) => fetchWithHeaders(\"/transaction/status\", {\n    intent_hash: transactionIntentHash\n  });\n  const getSubintentStatus = (subintentHash) => fetchWithHeaders(\"/transaction/subintent-status\", {\n    subintent_hash: subintentHash\n  });\n  const getEntityMetadataPage = (address) => fetchWithHeaders(\"/state/entity/page/metadata\", { address });\n  return {\n    getSubintentStatus,\n    getTransactionStatus,\n    getEntityMetadataPage\n  };\n};\n\n// src/modules/gateway/gateway.module.ts\nimport { ResultAsync as ResultAsync12, err as err13, ok as ok13 } from \"neverthrow\";\nimport { filter as filter5, first as first2, firstValueFrom as firstValueFrom4, switchMap as switchMap4 } from \"rxjs\";\nvar GatewayModule = (input) => {\n  const logger = input.logger?.getSubLogger({ name: \"GatewayModule\" });\n  const gatewayApi = input?.providers?.gatewayApiService ?? GatewayApiService(input.clientConfig);\n  const poll = (hash2, apiCall, exponentialBackoff) => {\n    return ResultAsync12.fromPromise(\n      firstValueFrom4(\n        exponentialBackoff.withBackoff$.pipe(\n          switchMap4((result) => {\n            if (result.isErr())\n              return [\n                err13(\n                  SdkError(\"failedToPoll\", \"\", void 0, {\n                    error: result.error,\n                    context: \"GatewayModule.poll.retry.withBackoff$\",\n                    hash: hash2\n                  })\n                )\n              ];\n            logger?.debug(`Polling ${hash2} retry #${result.value + 1}`);\n            return apiCall().orElse((response) => {\n              if (response.reason === \"FailedToFetch\") {\n                logger?.debug({\n                  error: response,\n                  context: \"unexpected error, retrying\"\n                });\n                exponentialBackoff.trigger.next();\n                return ok13(void 0);\n              }\n              logger?.debug(response);\n              return err13(\n                SdkError(\"failedToPoll\", \"\", void 0, {\n                  error: response,\n                  hash: hash2,\n                  context: \"GatewayModule.poll\"\n                })\n              );\n            });\n          }),\n          filter5(\n            (result) => result.isOk() && !!result.value || result.isErr()\n          ),\n          first2()\n        )\n      ),\n      (error) => error\n    ).andThen((result) => result);\n  };\n  const pollTransactionStatus = (transactionIntentHash) => {\n    const exponentialBackoff = ExponentialBackoff(input.retryConfig);\n    return poll(\n      transactionIntentHash,\n      () => gatewayApi.getTransactionStatus(transactionIntentHash).map(({ status }) => {\n        const completedStatus = /* @__PURE__ */ new Set([\n          \"CommittedSuccess\",\n          \"CommittedFailure\",\n          \"Rejected\"\n        ]);\n        if (completedStatus.has(status)) return status;\n        exponentialBackoff.trigger.next();\n        return;\n      }),\n      exponentialBackoff\n    );\n  };\n  const pollSubintentStatus = (subintentHash, expirationTimestamp) => {\n    const exponentialBackoff = ExponentialBackoff({\n      ...input.retryConfig,\n      maxDelayTime: 6e4,\n      timeout: new Date(expirationTimestamp * 1e3)\n    });\n    return {\n      stop: exponentialBackoff.stop,\n      result: poll(\n        subintentHash,\n        () => gatewayApi.getSubintentStatus(subintentHash).map(\n          ({ subintent_status, finalized_at_transaction_intent_hash }) => {\n            if (subintent_status === \"CommittedSuccess\") {\n              return {\n                subintentStatus: subintent_status,\n                transactionIntentHash: finalized_at_transaction_intent_hash\n              };\n            }\n            exponentialBackoff.trigger.next();\n            return;\n          }\n        ),\n        exponentialBackoff\n      )\n    };\n  };\n  return {\n    pollSubintentStatus,\n    pollTransactionStatus,\n    gatewayApi,\n    configuration: input.clientConfig\n  };\n};\n\n// src/modules/wallet-request/request-resolver/resolvers/send-transaction-response.ts\nvar matchResponse3 = (input) => {\n  if (input.discriminator === \"success\" && input.items.discriminator === \"transaction\") {\n    return input.items;\n  }\n};\nvar determineFailedTransaction = (status) => {\n  const failedTransactionStatus = [\n    TransactionStatus.Rejected,\n    TransactionStatus.CommittedFailure\n  ];\n  return failedTransactionStatus.includes(status);\n};\nvar sendTransactionResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {\n  const transactionResponse = matchResponse3(walletInteractionResponse);\n  if (!transactionResponse) return okAsync12(void 0);\n  const { gatewayModule, requestItemModule, updateConnectButtonStatus } = dependencies;\n  const { interactionId } = walletInteraction;\n  const {\n    send: { transactionIntentHash }\n  } = transactionResponse;\n  return requestItemModule.getById(interactionId).mapErr(() => SdkError(\"FailedToGetItemWithInteractionId\", interactionId)).andTee(\n    () => requestItemModule.getAndRemoveSignal(interactionId)?.(\n      transactionIntentHash\n    )\n  ).andThen(() => gatewayModule.pollTransactionStatus(transactionIntentHash)).andThen((status) => {\n    const isFailedTransaction = determineFailedTransaction(status);\n    const requestItemStatus = isFailedTransaction ? \"fail\" : \"success\";\n    return requestItemModule.updateStatus({\n      id: interactionId,\n      status: requestItemStatus,\n      transactionIntentHash,\n      metadata: { transactionStatus: status },\n      walletResponse: walletInteractionResponse\n    }).orElse((error) => err14(SdkError(error.reason, interactionId))).andThen(() => {\n      updateConnectButtonStatus(requestItemStatus);\n      return okAsync12(void 0);\n    }).orElse((error) => {\n      updateConnectButtonStatus(\"fail\");\n      return err14(error);\n    });\n  }).map(() => void 0);\n};\n\n// src/modules/wallet-request/request-resolver/resolvers/pre-authorization-response.ts\nimport { err as err15, okAsync as okAsync13 } from \"neverthrow\";\nvar matchResponse4 = (input) => {\n  if (input.discriminator === \"success\" && input.items.discriminator === \"preAuthorizationResponse\") {\n    return input.items.response;\n  }\n};\nvar preAuthorizationResponseResolver = (dependencies) => ({ walletInteraction, walletInteractionResponse }) => {\n  const response = matchResponse4(walletInteractionResponse);\n  if (!response) return okAsync13(void 0);\n  const { signedPartialTransaction, expirationTimestamp, subintentHash } = response;\n  const { interactionId } = walletInteraction;\n  const { requestItemModule } = dependencies;\n  return requestItemModule.updateStatus({\n    id: interactionId,\n    status: RequestStatus.pendingCommit,\n    transactionIntentHash: subintentHash,\n    walletResponse: walletInteractionResponse,\n    metadata: {\n      signedPartialTransaction,\n      expirationTimestamp,\n      subintentHash\n    }\n  }).orElse((error) => {\n    dependencies.updateConnectButtonStatus(\"fail\");\n    return err15(SdkError(error.reason, interactionId));\n  }).andTee(() => dependencies.updateConnectButtonStatus(\"success\")).map(() => void 0);\n};\n\n// src/modules/wallet-request/pre-authorization-request/preauthorization-polling-module.ts\nimport { ResultAsync as ResultAsync13 } from \"neverthrow\";\nimport { Subscription as Subscription5, tap as tap2 } from \"rxjs\";\nvar PreauthorizationPollingModule = (input) => {\n  const logger = input?.logger?.getSubLogger({\n    name: \"PreauthorizationPolling\"\n  });\n  const {\n    providers: { requestItemModule, ignoreTransactionSubject }\n  } = input;\n  let shouldRun = true;\n  const WAIT_TIME = 1e3;\n  const activePolling = /* @__PURE__ */ new Map();\n  const subscriptions = new Subscription5();\n  subscriptions.add(\n    ignoreTransactionSubject.pipe(\n      tap2((id) => {\n        if (activePolling.has(id)) {\n          activePolling.get(id)?.stop();\n          activePolling.delete(id);\n        }\n      })\n    ).subscribe()\n  );\n  const preauthorizationPollingLoop = async () => {\n    await requestItemModule.getPendingCommit().andThen((lookedUpItems) => {\n      const timedOutItems = [];\n      const lookupItems = [];\n      lookedUpItems.forEach((item) => {\n        if (Number(item.metadata?.expirationTimestamp) * 1e3 < Date.now()) {\n          timedOutItems.push(item);\n        } else {\n          lookupItems.push(item);\n        }\n      });\n      lookupItems.forEach((item) => {\n        if (!activePolling.has(item.interactionId)) {\n          const polling = input.providers.gatewayModule.pollSubintentStatus(\n            item.transactionIntentHash,\n            item.metadata?.expirationTimestamp\n          );\n          activePolling.set(item.interactionId, polling);\n          polling.result.andTee(\n            (result) => requestItemModule.updateStatus({\n              id: item.interactionId,\n              status: RequestStatus.success,\n              metadata: {\n                parentTransactionIntentHash: result.transactionIntentHash\n              }\n            })\n          ).mapErr(() => {\n            activePolling.delete(item.interactionId);\n          });\n        }\n      });\n      return ResultAsync13.combine(\n        timedOutItems.map((item) => {\n          if (activePolling.has(item.interactionId)) {\n            activePolling.get(item.interactionId)?.stop();\n            activePolling.delete(item.interactionId);\n          }\n          return requestItemModule.updateStatus({\n            id: item.interactionId,\n            status: RequestStatus.timedOut\n          });\n        })\n      );\n    });\n    await new Promise((resolve) => setTimeout(resolve, WAIT_TIME));\n    if (shouldRun) preauthorizationPollingLoop();\n  };\n  preauthorizationPollingLoop();\n  return {\n    destroy: () => {\n      shouldRun = false;\n      subscriptions.unsubscribe();\n    }\n  };\n};\n\n// src/modules/wallet-request/wallet-request.ts\nvar WalletRequestModule = (input) => {\n  const logger = input.logger?.getSubLogger({ name: \"WalletRequestModule\" });\n  const useCache = input.useCache;\n  const networkId = input.networkId;\n  const cancelRequestSubject = new Subject6();\n  const ignoreTransactionSubject = new Subject6();\n  const interactionStatusChangeSubject = new Subject6();\n  const gatewayModule = input.providers.gatewayModule;\n  const dAppDefinitionAddress = input.dAppDefinitionAddress;\n  const stateModule = input.providers.stateModule;\n  const storageModule = input.providers.storageModule;\n  const dataRequestStateModule = input.providers.dataRequestStateModule ?? DataRequestStateModule({});\n  const requestItemModule = input.providers.requestItemModule ?? RequestItemModule({\n    logger,\n    providers: {\n      gatewayModule,\n      storageModule: storageModule.getPartition(\"requests\")\n    }\n  });\n  const preauthorizationPollingModule = input.providers.preauthorizationPollingModule ?? PreauthorizationPollingModule({\n    logger,\n    providers: {\n      gatewayModule,\n      requestItemModule,\n      ignoreTransactionSubject\n    }\n  });\n  const updateConnectButtonStatus = (status) => {\n    interactionStatusChangeSubject.next(status);\n  };\n  const requestResolverModule = input.providers.requestResolverModule ?? RequestResolverModule({\n    logger,\n    providers: {\n      storageModule,\n      requestItemModule,\n      resolvers: [\n        sendTransactionResponseResolver({\n          gatewayModule,\n          requestItemModule,\n          updateConnectButtonStatus\n        }),\n        preAuthorizationResponseResolver({\n          requestItemModule,\n          updateConnectButtonStatus\n        }),\n        failedResponseResolver({\n          requestItemModule,\n          updateConnectButtonStatus\n        }),\n        dataResponseResolver({\n          requestItemModule,\n          getDataRequestController: () => dataRequestControl,\n          stateModule,\n          updateConnectButtonStatus\n        })\n      ]\n    }\n  });\n  const transports = input.providers.transports ?? [\n    ConnectorExtensionModule({\n      logger,\n      providers: {\n        storageModule,\n        requestResolverModule,\n        environmentModule: input.providers.environmentModule\n      }\n    }),\n    RadixConnectRelayModule({\n      logger,\n      walletUrl: \"radixWallet://connect\",\n      baseUrl: \"https://radix-connect-relay.radixdlt.com\",\n      dAppDefinitionAddress: input.dAppDefinitionAddress,\n      providers: {\n        storageModule,\n        requestResolverModule,\n        environmentModule: input.providers.environmentModule\n      }\n    })\n  ];\n  const walletRequestSdk = input.providers.walletRequestSdk ?? WalletRequestSdk({\n    logger,\n    networkId,\n    origin: input.origin,\n    dAppDefinitionAddress,\n    requestInterceptor: input.requestInterceptor,\n    providers: {\n      transports,\n      environmentModule: input.providers.environmentModule\n    }\n  });\n  const cancelRequestControl = (id) => {\n    const messageLifeCycleEvent = new Subject6();\n    return {\n      eventCallback: (event) => {\n        messageLifeCycleEvent.next(event);\n      },\n      requestControl: ({ cancelRequest: cancelRequest2, getRequest }) => {\n        firstValueFrom5(\n          messageLifeCycleEvent.pipe(\n            filter6((event) => event === \"receivedByWallet\"),\n            map5(() => getRequest()),\n            tap3((request) => {\n              if ([\"transaction\", \"preAuthorizationRequest\"].includes(\n                request.items.discriminator\n              ))\n                requestItemModule.patch(id, { showCancel: false });\n            })\n          )\n        );\n        firstValueFrom5(\n          cancelRequestSubject.pipe(\n            filter6((requestItemId) => requestItemId === id),\n            switchMap5(\n              () => requestItemModule.cancel(id).andThen(() => cancelRequest2())\n            )\n          )\n        );\n        firstValueFrom5(\n          ignoreTransactionSubject.pipe(\n            filter6((requestItemId) => requestItemId === id),\n            switchMap5(\n              () => requestItemModule.updateStatus({\n                id,\n                status: \"ignored\"\n              }).andThen(() => cancelRequest2())\n            )\n          )\n        );\n      }\n    };\n  };\n  let challengeGeneratorFn = () => Promise.resolve(\"\");\n  let connectResponseCallback;\n  let dataRequestControl;\n  const isChallengeNeeded = (dataRequestState) => dataRequestState.accounts?.withProof || dataRequestState.persona?.withProof || dataRequestState.proofOfOwnership;\n  const getChallenge = (dataRequestState) => {\n    if (!isChallengeNeeded(dataRequestState)) return okAsync14(void 0);\n    return ResultAsync14.fromPromise(\n      challengeGeneratorFn(),\n      () => SdkError(\"ChallengeGeneratorError\", \"\", \"failed to generate challenge\")\n    ).andThen(\n      (challenge) => validateRolaChallenge(challenge) ? ok14(challenge) : err16(SdkError(\"ChallengeValidationError\", \"\", \"challenge is invalid\"))\n    );\n  };\n  const provideConnectResponseCallback = (fn) => {\n    connectResponseCallback = (result) => fn(result);\n  };\n  const provideDataRequestControl = (fn) => {\n    dataRequestControl = (walletData) => ResultAsync14.fromPromise(fn(walletData), () => ({\n      error: \"LoginRejectedByDapp\",\n      message: \"Login rejected by dApp\"\n    }));\n  };\n  const sendRequestAndAwaitResponse = (walletInteraction) => {\n    updateConnectButtonStatus(\"pending\");\n    return ResultAsync14.combine([\n      walletRequestSdk.sendInteraction(\n        walletInteraction,\n        cancelRequestControl(walletInteraction.interactionId)\n      ),\n      requestResolverModule.waitForWalletResponse(\n        walletInteraction.interactionId\n      )\n    ]).map(([_, response]) => response);\n  };\n  const sendOneTimeRequest = (...items) => sendRequest({\n    dataRequestState: dataRequestStateModule.toDataRequestState(...items),\n    isConnect: false,\n    oneTime: true\n  });\n  const sendDataRequest = (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction).andThen((response) => {\n    logger?.debug({ method: \"sendDataRequest.successResponse\", response });\n    return ok14(response.walletData);\n  }).mapErr((error) => {\n    logger?.debug({ method: \"sendDataRequest.errorResponse\", error });\n    return error;\n  });\n  const getRdtState = () => stateModule.getState().mapErr(() => SdkError(\"FailedToReadRdtState\", \"\"));\n  const addNewRequest = (type, walletInteraction, isOneTimeRequest, signal) => requestItemModule.add(\n    {\n      type,\n      walletInteraction,\n      isOneTimeRequest\n    },\n    signal\n  ).mapErr(\n    ({ message }) => SdkError(\n      \"FailedToCreateRequestItem\",\n      walletInteraction.interactionId,\n      message\n    )\n  );\n  const sendPreAuthorizationRequest = (value) => {\n    const walletInteraction = walletRequestSdk.createWalletInteraction({\n      discriminator: \"preAuthorizationRequest\",\n      request: value.toRequestItem()\n    });\n    return addNewRequest(\n      \"preAuthorizationRequest\",\n      walletInteraction,\n      false,\n      value.getOnSubmittedSuccessFn?.()\n    ).andThen(() => sendRequestAndAwaitResponse(walletInteraction)).map(\n      (requestItem) => ({\n        ...requestItem.metadata\n      })\n    );\n  };\n  const sendRequest = ({\n    isConnect,\n    oneTime,\n    dataRequestState\n  }) => ResultAsync14.combine([\n    getChallenge(dataRequestState),\n    getRdtState()\n  ]).andThen(\n    ([challenge, state]) => toWalletRequest({\n      dataRequestState,\n      isConnect,\n      oneTime,\n      challenge,\n      walletData: state.walletData\n    }).mapErr(() => SdkError(\"FailedToTransformWalletRequest\", \"\")).asyncAndThen((walletDataRequest) => {\n      const walletInteraction = walletRequestSdk.createWalletInteraction(walletDataRequest);\n      if (canDataRequestBeResolvedByRdtState(walletDataRequest, state) && useCache)\n        return okAsync14(state.walletData);\n      const isLoginRequest = !state.walletData.persona && walletDataRequest.discriminator === \"authorizedRequest\";\n      const isProofOfOwnershipRequest = walletDataRequest.discriminator === \"authorizedRequest\" && !!walletDataRequest.proofOfOwnership;\n      const requestType = isLoginRequest ? \"loginRequest\" : isProofOfOwnershipRequest ? \"proofRequest\" : \"dataRequest\";\n      return addNewRequest(requestType, walletInteraction, oneTime).andThen(\n        () => sendDataRequest(walletInteraction)\n      );\n    })\n  );\n  const setRequestDataState = (...items) => {\n    dataRequestStateModule.setState(...items);\n    return {\n      sendRequest: () => sendRequest({\n        dataRequestState: dataRequestStateModule.getState(),\n        isConnect: false,\n        oneTime: false\n      })\n    };\n  };\n  const updateSharedAccounts = () => stateModule.getState().mapErr((err18) => {\n    logger?.error(err18);\n    return {\n      error: \"FailedToReadRdtState\",\n      message: \"failed to read rdt state\",\n      jsError: err18\n    };\n  }).andThen(\n    (state) => sendRequest({\n      dataRequestState: transformSharedDataToDataRequestState(\n        state.sharedData\n      ),\n      isConnect: false,\n      oneTime: false\n    })\n  );\n  const subscriptions = new Subscription6();\n  const sendTransaction = (value) => {\n    const createTransactionRequest = () => {\n      const walletInteraction = walletRequestSdk.createWalletInteraction({\n        discriminator: \"transaction\",\n        send: {\n          blobs: value.blobs,\n          transactionManifest: value.transactionManifest,\n          message: value.message,\n          version: value.version ?? 1\n        }\n      });\n      return requestItemModule.add(\n        {\n          type: \"sendTransaction\",\n          walletInteraction,\n          isOneTimeRequest: false\n        },\n        value.onTransactionId\n      ).mapErr(\n        () => SdkError(\"FailedToAddRequestItem\", walletInteraction.interactionId)\n      ).map(() => walletInteraction);\n    };\n    return createTransactionRequest().andThen(\n      (walletInteraction) => sendRequestAndAwaitResponse(walletInteraction)\n    ).andThen(({ status, transactionIntentHash, metadata, interactionId }) => {\n      const output2 = {\n        transactionIntentHash,\n        status: metadata.transactionStatus\n      };\n      return status === \"success\" ? ok14(output2) : err16(SdkError(output2.status, interactionId));\n    });\n  };\n  const getTransport = () => transports.find((transport) => transport.isSupported());\n  const getPendingRequests = () => requestItemModule.getPending();\n  const cancelRequest = (id) => {\n    cancelRequestSubject.next(id);\n    requestItemModule.cancel(id);\n    interactionStatusChangeSubject.next(\"fail\");\n    updateConnectButtonStatus(\"fail\");\n  };\n  const ignoreTransaction = (id) => {\n    ignoreTransactionSubject.next(id);\n    requestItemModule.updateStatus({\n      id,\n      status: \"ignored\"\n    });\n    interactionStatusChangeSubject.next(\"fail\");\n  };\n  const provideChallengeGenerator = (fn) => {\n    challengeGeneratorFn = fn;\n  };\n  const disconnect = () => {\n    requestItemModule.getPending().map((items) => {\n      items.forEach((item) => {\n        if (item.showCancel) cancelRequestSubject.next(item.interactionId);\n      });\n    });\n    stateModule.reset();\n    requestItemModule.clear();\n    transports.forEach((transport) => transport?.disconnect());\n  };\n  const destroy = () => {\n    stateModule.destroy();\n    requestItemModule.destroy();\n    requestResolverModule.destroy();\n    preauthorizationPollingModule.destroy();\n    input.providers.transports?.forEach((transport) => transport.destroy());\n    subscriptions.unsubscribe();\n  };\n  return {\n    sendRequest: (input2) => sendRequest({\n      isConnect: input2.isConnect,\n      oneTime: input2.oneTime,\n      dataRequestState: dataRequestStateModule.getState()\n    }).andThen((response) => {\n      if (connectResponseCallback) connectResponseCallback(ok14(response));\n      return ok14(response);\n    }).orElse((error) => {\n      if (connectResponseCallback) connectResponseCallback(err16(error));\n      return err16(error);\n    }),\n    sendTransaction,\n    sendPreAuthorizationRequest,\n    cancelRequest,\n    ignoreTransaction,\n    requestItemModule,\n    provideChallengeGenerator,\n    provideDataRequestControl,\n    provideConnectResponseCallback,\n    sendOneTimeRequest,\n    setRequestDataState,\n    getPendingRequests,\n    getTransport,\n    updateSharedAccounts,\n    dataRequestStateModule,\n    interactionStatusChange$: interactionStatusChangeSubject.asObservable(),\n    requestItems$: requestItemModule.requests$,\n    disconnect,\n    destroy\n  };\n};\n\n// src/modules/wallet-request/pre-authorization-request/subintent-builder.ts\nvar SubintentRequestBuilder = () => {\n  let state = {\n    discriminator: \"subintent\",\n    version: 1,\n    manifestVersion: 2\n  };\n  let onSubmittedSuccessFn;\n  const onSubmittedSuccess = (callback) => {\n    onSubmittedSuccessFn = callback;\n    return api;\n  };\n  const setExpiration = (type, value) => {\n    state.expiration = type === \"atTime\" ? {\n      discriminator: \"expireAtTime\",\n      unixTimestampSeconds: value\n    } : {\n      discriminator: \"expireAfterDelay\",\n      expireAfterSeconds: value\n    };\n    return api;\n  };\n  const addBlobs = (...blobs) => {\n    state.blobs = blobs;\n    return api;\n  };\n  const message = (message2) => {\n    state.message = message2;\n    return api;\n  };\n  const manifest = (value) => {\n    state.subintentManifest = value;\n    return { setExpiration };\n  };\n  const toRequestItem = () => state;\n  const rawConfig = (rawConfig2) => {\n    state = { ...rawConfig2, discriminator: \"subintent\" };\n    return { toRequestItem };\n  };\n  const api = {\n    addBlobs,\n    message,\n    toRequestItem,\n    onSubmittedSuccess,\n    getOnSubmittedSuccessFn: () => onSubmittedSuccessFn\n  };\n  return { manifest, rawConfig };\n};\n\n// src/modules/connect-button/connect-button-noop.module.ts\nimport { NEVER } from \"rxjs\";\nvar ConnectButtonNoopModule = () => {\n  return {\n    status$: NEVER,\n    onConnect$: NEVER,\n    onDisconnect$: NEVER,\n    onUpdateSharedAccounts$: NEVER,\n    onShowPopover$: NEVER,\n    onCancelRequestItem$: NEVER,\n    onLinkClick$: NEVER,\n    setStatus: () => {\n    },\n    setMode: () => {\n    },\n    setTheme: () => {\n    },\n    setActiveTab: () => {\n    },\n    setIsMobile: () => {\n    },\n    setIsWalletLinked: () => {\n    },\n    setIsExtensionAvailable: () => {\n    },\n    setConnected: () => {\n    },\n    setLoggedInTimestamp: () => {\n    },\n    setRequestItems: () => {\n    },\n    setAccounts: () => {\n    },\n    setPersonaData: () => {\n    },\n    setPersonaLabel: () => {\n    },\n    setDappName: () => {\n    },\n    destroy: () => {\n    },\n    disconnect: () => {\n    }\n  };\n};\n\n// src/modules/connect-button/connect-button.module.ts\nvar ConnectButtonModule = (input) => {\n  if (!input.providers.environmentModule.isBrowser()) {\n    return ConnectButtonNoopModule();\n  }\n  import(\"./connect-button-CHA436HC.js\");\n  const logger = input?.logger?.getSubLogger({ name: \"ConnectButtonModule\" });\n  const subjects = input.subjects || ConnectButtonSubjects({\n    providers: { environmentModule: input.providers.environmentModule }\n  });\n  const dAppDefinitionAddress = input.dAppDefinitionAddress;\n  const { baseUrl, accountsPath, transactionPath, subintentPath } = input.explorer ?? {\n    baseUrl: RadixNetworkConfigById[input.networkId].dashboardUrl,\n    transactionPath: \"/transaction/\",\n    subintentPath: \"/subintent/\",\n    accountsPath: \"/account/\"\n  };\n  const stateModule = input.providers.stateModule;\n  const gatewayModule = input.providers.gatewayModule;\n  const walletRequestModule = input.providers.walletRequestModule;\n  const onConnectDefault = (done) => {\n    done();\n  };\n  const onConnect = input.onConnect || onConnectDefault;\n  const transport = walletRequestModule.getTransport();\n  const getConnectButtonElement = () => document.querySelector(\"radix-connect-button\");\n  const subscriptions = new Subscription7();\n  const onConnectButtonRender$ = fromEvent(input.providers.environmentModule.globalThis, \"onConnectButtonRender\");\n  subscriptions.add(\n    onConnectButtonRender$.pipe(\n      map6(() => getConnectButtonElement()),\n      filter7((element) => !!element),\n      switchMap6((connectButtonElement) => {\n        logger?.debug({ observable: `onConnectButtonRender$` });\n        const onConnect$ = fromEvent(connectButtonElement, \"onConnect\").pipe(\n          tap4(() => {\n            onConnect((value) => subjects.onConnect.next(value));\n          })\n        );\n        const onDisconnect$ = fromEvent(\n          connectButtonElement,\n          \"onDisconnect\"\n        ).pipe(tap4(() => subjects.onDisconnect.next()));\n        const onLinkClick$ = fromEvent(connectButtonElement, \"onLinkClick\").pipe(\n          tap4((ev) => {\n            subjects.onLinkClick.next(ev.detail);\n          })\n        );\n        const onDestroy$ = fromEvent(connectButtonElement, \"onDestroy\").pipe(\n          map6(() => {\n            logger?.debug({ observable: `onDestroy$` });\n            return true;\n          })\n        );\n        const onCancelRequestItem$ = fromEvent(\n          connectButtonElement,\n          \"onCancelRequestItem\"\n        ).pipe(\n          tap4((event) => {\n            const id = event.detail.id;\n            logger?.debug({ method: \"onCancelRequestItem\", id });\n            subjects.onCancelRequestItem.next(id);\n          })\n        );\n        const onIgnoreTransactionItem$ = fromEvent(\n          connectButtonElement,\n          \"onIgnoreTransactionItem\"\n        ).pipe(\n          tap4((event) => {\n            const id = event.detail.id;\n            logger?.debug({\n              method: \"onIgnoreTransactionItem\",\n              id\n            });\n            subjects.onIgnoreTransactionItem.next(id);\n          })\n        );\n        const onUpdateSharedAccounts$ = fromEvent(\n          connectButtonElement,\n          \"onUpdateSharedAccounts\"\n        ).pipe(\n          tap4(() => {\n            logger?.debug(`onUpdateSharedAccounts`);\n            subjects.onUpdateSharedAccounts.next();\n          })\n        );\n        const onShowPopover$ = fromEvent(\n          connectButtonElement,\n          \"onShowPopover\"\n        ).pipe(tap4(() => subjects.onShowPopover.next()));\n        const isWalletLinked$ = subjects.isWalletLinked.pipe(\n          tap4((value) => connectButtonElement.isWalletLinked = value)\n        );\n        const isExtensionAvailable$ = subjects.isExtensionAvailable.pipe(\n          tap4((value) => connectButtonElement.isExtensionAvailable = value)\n        );\n        const status$ = subjects.status.pipe(\n          tap4((value) => connectButtonElement.status = value)\n        );\n        const mode$ = subjects.mode.pipe(\n          tap4((value) => connectButtonElement.mode = value)\n        );\n        const connected$ = subjects.connected.pipe(\n          tap4((value) => connectButtonElement.connected = value)\n        );\n        const isMobile$ = subjects.isMobile.pipe(\n          tap4((value) => connectButtonElement.isMobile = value)\n        );\n        const loggedInTimestamp$ = subjects.loggedInTimestamp.pipe(\n          tap4((value) => connectButtonElement.loggedInTimestamp = value)\n        );\n        const activeTab$ = subjects.activeTab.pipe(\n          tap4((value) => connectButtonElement.activeTab = value)\n        );\n        const requestItems$ = subjects.requestItems.pipe(\n          tap4((items) => connectButtonElement.requestItems = items)\n        );\n        const showPopoverMenu$ = subjects.showPopoverMenu.pipe(\n          tap4((value) => {\n            value ? connectButtonElement.setAttribute(\"showPopoverMenu\", \"true\") : connectButtonElement.removeAttribute(\"showPopoverMenu\");\n          })\n        );\n        const accounts$ = subjects.accounts.pipe(\n          tap4((items) => connectButtonElement.accounts = items)\n        );\n        const personaData$ = subjects.personaData.pipe(\n          tap4((items) => connectButtonElement.personaData = items)\n        );\n        const personaLabel$ = subjects.personaLabel.pipe(\n          tap4((items) => connectButtonElement.personaLabel = items)\n        );\n        const dAppName$ = subjects.dAppName.pipe(\n          tap4((value) => connectButtonElement.dAppName = value)\n        );\n        const theme$ = subjects.theme.pipe(\n          tap4((value) => connectButtonElement.theme = value)\n        );\n        const connectButtonEvents$ = merge3(\n          onConnect$,\n          status$,\n          theme$,\n          mode$,\n          connected$,\n          showPopoverMenu$,\n          requestItems$,\n          loggedInTimestamp$,\n          isMobile$,\n          activeTab$,\n          isWalletLinked$,\n          isExtensionAvailable$,\n          onDisconnect$,\n          onCancelRequestItem$,\n          onIgnoreTransactionItem$,\n          accounts$,\n          personaData$,\n          personaLabel$,\n          onUpdateSharedAccounts$,\n          onShowPopover$,\n          dAppName$,\n          onLinkClick$\n        ).pipe(map6(() => false));\n        return merge3(connectButtonEvents$, onDestroy$).pipe(\n          filter7((shouldDestroy) => !!shouldDestroy),\n          first3(),\n          finalize(() => {\n            logger?.debug({ observable: `onConnectButtonRender$.finalize` });\n          })\n        );\n      })\n    ).subscribe()\n  );\n  subscriptions.add(\n    (transport && transport.isAvailable$ || of3(true)).pipe(tap4((value) => subjects.isExtensionAvailable.next(value))).subscribe()\n  );\n  subscriptions.add(\n    (transport && transport.isLinked$ || of3(true)).pipe(tap4((value) => subjects.isWalletLinked.next(value))).subscribe()\n  );\n  subscriptions.add(\n    subjects.onLinkClick.pipe(\n      tap4(({ type, data }) => {\n        if ([\"account\", \"transaction\", \"subintent\"].includes(type)) {\n          if (!baseUrl || !window) return;\n          const url = `${baseUrl}${type === \"transaction\" ? transactionPath : type === \"subintent\" ? subintentPath : accountsPath}${data}`;\n          window.open(url);\n        } else if (type === \"setupGuide\")\n          window.open(\"https://wallet.radixdlt.com\");\n        else if (type === \"getWallet\") {\n          window.open(\"https://app.radixdlt.com/qr-code\");\n        } else if (type === \"showQrCode\" && transport?.showQrCode)\n          transport.showQrCode();\n      })\n    ).subscribe()\n  );\n  const connectButtonApi = {\n    status$: subjects.status.asObservable(),\n    onConnect$: subjects.onConnect.asObservable(),\n    onDisconnect$: subjects.onDisconnect.asObservable(),\n    onShowPopover$: subjects.onShowPopover.asObservable(),\n    onUpdateSharedAccounts$: subjects.onUpdateSharedAccounts.asObservable(),\n    onCancelRequestItem$: subjects.onCancelRequestItem.asObservable(),\n    onIgnoreTransactionItem$: subjects.onIgnoreTransactionItem.asObservable(),\n    onLinkClick$: subjects.onLinkClick.asObservable(),\n    setTheme: (value) => subjects.theme.next(value),\n    setMode: (value) => subjects.mode.next(value),\n    setActiveTab: (value) => subjects.activeTab.next(value),\n    setIsMobile: (value) => subjects.isMobile.next(value),\n    setIsWalletLinked: (value) => subjects.isWalletLinked.next(value),\n    setIsExtensionAvailable: (value) => subjects.isExtensionAvailable.next(value),\n    setLoggedInTimestamp: (value) => subjects.loggedInTimestamp.next(value),\n    setConnected: (value) => subjects.connected.next(value),\n    setShowPopoverMenu: (value) => subjects.showPopoverMenu.next(value),\n    setRequestItems: (items) => subjects.requestItems.next(items),\n    setAccounts: (accounts2) => subjects.accounts.next(accounts2),\n    setPersonaData: (personaData2) => subjects.personaData.next(personaData2),\n    setPersonaLabel: (personaLabel) => subjects.personaLabel.next(personaLabel),\n    setDappName: (dAppName) => subjects.dAppName.next(dAppName),\n    disconnect: () => {\n      subjects.connected.next(false);\n      subjects.status.next(\"default\");\n    },\n    destroy: () => {\n      subscriptions.unsubscribe();\n    }\n  };\n  const setPropsFromState = () => stateModule.getState().map((state) => {\n    const { personaData: personaData2, accounts: accounts2, personaLabel, connected } = transformWalletDataToConnectButton(state.walletData);\n    connectButtonApi.setLoggedInTimestamp(state.loggedInTimestamp);\n    connectButtonApi.setAccounts(accounts2);\n    connectButtonApi.setPersonaData(personaData2);\n    connectButtonApi.setPersonaLabel(personaLabel);\n    connectButtonApi.setConnected(connected);\n  });\n  subscriptions.add(\n    stateModule.storage$.pipe(switchMap6(() => setPropsFromState())).subscribe()\n  );\n  subscriptions.add(\n    subjects.onCancelRequestItem.pipe(\n      tap4((value) => {\n        walletRequestModule.cancelRequest(value);\n      })\n    ).subscribe()\n  );\n  subscriptions.add(\n    subjects.onIgnoreTransactionItem.pipe(\n      tap4((value) => {\n        walletRequestModule.ignoreTransaction(value);\n      })\n    ).subscribe()\n  );\n  subscriptions.add(\n    walletRequestModule.requestItems$.pipe(\n      tap4((items) => {\n        connectButtonApi.setRequestItems([...items].reverse());\n      })\n    ).subscribe()\n  );\n  subscriptions.add(\n    subjects.onShowPopover.pipe(\n      tap4(() => {\n        walletRequestModule.getPendingRequests().map((pendingRequests) => {\n          if (pendingRequests.length > 0) {\n            subjects.activeTab.next(\"requests\");\n          }\n        });\n      })\n    ).subscribe()\n  );\n  subscriptions.add(\n    subjects.onConnect.pipe(\n      switchMap6(\n        () => stateModule.reset().andThen(\n          () => walletRequestModule.sendRequest({\n            isConnect: true,\n            oneTime: false\n          })\n        ).map(\n          () => input.providers.environmentModule.isMobile() && subjects.showPopoverMenu.next(false)\n        )\n      )\n    ).subscribe()\n  );\n  subscriptions.add(\n    subjects.onUpdateSharedAccounts.pipe(switchMap6(() => walletRequestModule.updateSharedAccounts())).subscribe()\n  );\n  subscriptions.add(\n    subjects.onDisconnect.pipe(\n      tap4(() => {\n        subjects.connected.next(false);\n        subjects.status.next(\"default\");\n        walletRequestModule.disconnect();\n        if (input.onDisconnect) input.onDisconnect();\n      })\n    ).subscribe()\n  );\n  const setPendingOrDefault = () => walletRequestModule.getPendingRequests().andTee(\n    (items) => subjects.status.next(items.length ? \"pending\" : \"default\")\n  );\n  subscriptions.add(\n    walletRequestModule.interactionStatusChange$.pipe(\n      mergeMap2(\n        (newStatus) => of3(\n          subjects.status.next(\n            newStatus === \"success\" ? \"success\" : newStatus === \"fail\" ? \"error\" : \"pending\"\n          )\n        ).pipe(\n          delay(2e3),\n          concatMap(() => setPendingOrDefault())\n        )\n      )\n    ).subscribe()\n  );\n  setPendingOrDefault();\n  if (dAppDefinitionAddress) {\n    gatewayModule.gatewayApi.getEntityMetadataPage(dAppDefinitionAddress).map(\n      (details) => details?.items.find((item) => item.key === \"name\")?.value?.typed?.value\n    ).map((dAppName) => {\n      subjects.dAppName.next(dAppName ?? \"Unnamed dApp\");\n    });\n  }\n  return connectButtonApi;\n};\n\n// src/modules/connect-button/types.ts\nvar ConnectButtonStatus = {\n  pending: \"pending\",\n  success: \"success\",\n  default: \"default\",\n  error: \"error\"\n};\n\n// src/modules/environment/environment.module.ts\nvar EnvironmentModule = () => {\n  const isMobile = (userAgent) => {\n    const ua = userAgent.toLowerCase();\n    return /(mobi|ipod|phone|blackberry|opera mini|fennec|minimo|symbian|psp|nintendo ds|archos|skyfire|puffin|blazer|bolt|gobrowser|iris|maemo|semc|teashark|uzard|ipad|tablet|(android(?!.*mobile))|(windows(?!.*phone)(.*touch))|kindle|playbook|silk|(puffin(?!.*(IP|AP|WP))))/.test(\n      ua\n    );\n  };\n  const getNavigator = () => {\n    return typeof navigator !== \"undefined\" ? navigator : void 0;\n  };\n  const isTMA = () => Object.keys(globalThis?.Telegram?.WebView?.initParams || {}).length > 0;\n  return {\n    get globalThis() {\n      return globalThis;\n    },\n    isMobile: (userAgent) => {\n      return isMobile(userAgent ?? getNavigator()?.userAgent ?? \"\");\n    },\n    isTMA,\n    isBrowser: () => ![typeof window, typeof document].includes(\"undefined\")\n  };\n};\n\n// src/modules/storage/local-storage.module.ts\nimport { err as err17, ok as ok15, Result as Result8, ResultAsync as ResultAsync15 } from \"neverthrow\";\nimport { filter as filter8, fromEvent as fromEvent2, map as map7, merge as merge4, mergeMap as mergeMap3, of as of4 } from \"rxjs\";\nvar LocalStorageModule = (storageKey, {\n  providers\n}) => {\n  const _window = providers.environmentModule.globalThis;\n  const getDataAsync = () => new Promise((resolve, reject) => {\n    try {\n      resolve(localStorage.getItem(storageKey));\n    } catch (error) {\n      reject(error);\n    }\n  });\n  const setDataAsync = (value) => new Promise((resolve, reject) => {\n    try {\n      localStorage.setItem(storageKey, value);\n      resolve();\n    } catch (error) {\n      reject(error);\n    }\n  });\n  const getItems = () => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen(\n    (data) => data ? parseJSON(data) : ok15({})\n  );\n  const getState = () => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen(\n    (data) => data ? parseJSON(data) : ok15(void 0)\n  );\n  const getItemById = (id) => ResultAsync15.fromPromise(getDataAsync(), typedError2).andThen((data) => data ? parseJSON(data) : ok15(void 0)).map((items) => items ? items[id] : void 0);\n  const removeItemById = (id) => getItems().andThen((items) => {\n    const { [id]: _, ...newItems } = items;\n    return stringify(newItems).asyncAndThen((serialized) => {\n      const result = ResultAsync15.fromPromise(\n        setDataAsync(serialized),\n        typedError2\n      ).map(() => {\n        _window.dispatchEvent(\n          new StorageEvent(\"storage\", {\n            key: storageKey,\n            oldValue: JSON.stringify(items),\n            newValue: serialized\n          })\n        );\n      });\n      return result;\n    });\n  });\n  const patchItem = (id, patch) => getItemById(id).andThen((item) => {\n    return item ? setItems({ [id]: { ...item, ...patch } }) : err17(new Error(\"Item not found\"));\n  });\n  const setItems = (item) => getItems().andThen(\n    (data) => stringify({ ...data, ...item }).asyncAndThen((serialized) => {\n      const result = ResultAsync15.fromPromise(\n        setDataAsync(serialized),\n        typedError2\n      ).map(() => {\n        _window.dispatchEvent(\n          new StorageEvent(\"storage\", {\n            key: storageKey,\n            oldValue: JSON.stringify(data),\n            newValue: serialized\n          })\n        );\n      });\n      return result;\n    })\n  );\n  const getItemList = () => getItems().map(Object.values);\n  const setState = (newValue) => getState().andThen(\n    (oldValue) => stringify({ ...oldValue ?? {}, ...newValue }).asyncAndThen(\n      (serialized) => {\n        const result = ResultAsync15.fromPromise(\n          setDataAsync(serialized),\n          typedError2\n        ).map(() => {\n          _window.dispatchEvent(\n            new StorageEvent(\"storage\", {\n              key: storageKey,\n              oldValue: JSON.stringify(oldValue),\n              newValue: serialized\n            })\n          );\n        });\n        return result;\n      }\n    )\n  );\n  const patchState = (newValue) => getState().mapErr(() => ({ reason: \"FailedToReadFromLocalStorage\" })).andThen(\n    (oldState) => oldState ? setState({ ...oldState, ...newValue }).mapErr(() => ({\n      reason: \"FailedToWriteToLocalStorage\"\n    })) : err17({ reason: \"PatchingStateFailed\" })\n  );\n  const getPartition = (partitionKey) => LocalStorageModule(`${storageKey}:${partitionKey}`, { providers });\n  const storage$ = merge4(\n    fromEvent2(providers.environmentModule.globalThis, \"storage\"),\n    of4({ key: storageKey, newValue: null, oldValue: null })\n  ).pipe(\n    filter8((item) => item.key === storageKey),\n    mergeMap3((event) => {\n      const { key, newValue, oldValue } = event;\n      if (!key) return [];\n      const [rdt, accountDefinition, networkId, partition] = key.split(\":\");\n      if (rdt === \"rdt\" && accountDefinition && networkId) {\n        const oldValueResult = oldValue ? parseJSON(oldValue) : ok15(void 0);\n        const newValueResult = newValue ? parseJSON(newValue) : ok15(void 0);\n        return [\n          Result8.combine([oldValueResult, newValueResult]).map(\n            ([oldValue2, newValue2]) => ({\n              key,\n              partition,\n              newValue: newValue2,\n              oldValue: oldValue2\n            })\n          )\n        ];\n      }\n      return [];\n    }),\n    filter8((result) => result.isOk()),\n    map7(({ value }) => value)\n  );\n  const clear = () => ResultAsync15.fromPromise(\n    new Promise((resolve) => resolve(localStorage.removeItem(storageKey))),\n    typedError2\n  );\n  return {\n    getItems,\n    getItemById,\n    removeItemById,\n    patchItem,\n    setItems,\n    getItemList,\n    getPartition,\n    setState,\n    getState,\n    patchState,\n    clear,\n    storage$\n  };\n};\n\n// src/radix-dapp-toolkit.ts\npolyfills_default();\nvar RadixDappToolkit = (options) => {\n  const dAppDefinitionAddress = options.dAppDefinitionAddress ?? options.applicationDappDefinitionAddress;\n  const {\n    networkId,\n    providers,\n    logger,\n    onDisconnect,\n    gatewayBaseUrl,\n    applicationName,\n    applicationVersion,\n    useCache = true\n  } = options || {};\n  const environmentModule = providers?.environmentModule ?? EnvironmentModule();\n  const storageModule = providers?.storageModule ?? LocalStorageModule(`rdt:${dAppDefinitionAddress}:${networkId}`, {\n    providers: {\n      environmentModule\n    }\n  });\n  const stateModule = providers?.stateModule ?? StateModule({\n    logger,\n    providers: {\n      storageModule: storageModule.getPartition(\"state\")\n    }\n  });\n  const gatewayModule = providers?.gatewayModule ?? GatewayModule({\n    logger,\n    clientConfig: generateGatewayApiConfig({\n      networkId,\n      dAppDefinitionAddress,\n      gatewayBaseUrl,\n      applicationName,\n      applicationVersion\n    })\n  });\n  const walletRequestModule = providers?.walletRequestModule ?? WalletRequestModule({\n    logger,\n    useCache,\n    networkId,\n    dAppDefinitionAddress,\n    requestInterceptor: options.requestInterceptor,\n    providers: {\n      stateModule,\n      storageModule,\n      gatewayModule,\n      environmentModule\n    }\n  });\n  const connectButtonModule = providers?.connectButtonModule ?? ConnectButtonModule({\n    logger,\n    networkId,\n    explorer: options.explorer,\n    onDisconnect,\n    dAppDefinitionAddress,\n    providers: {\n      stateModule,\n      environmentModule,\n      walletRequestModule,\n      gatewayModule\n    }\n  });\n  return {\n    walletApi: {\n      setRequestData: walletRequestModule.setRequestDataState,\n      sendRequest: () => walletRequestModule.sendRequest({\n        isConnect: false,\n        oneTime: false\n      }),\n      provideChallengeGenerator: (fn) => walletRequestModule.provideChallengeGenerator(fn),\n      dataRequestControl: (fn) => {\n        walletRequestModule.provideDataRequestControl(fn);\n      },\n      provideConnectResponseCallback: walletRequestModule.provideConnectResponseCallback,\n      updateSharedAccounts: () => walletRequestModule.updateSharedAccounts(),\n      sendOneTimeRequest: walletRequestModule.sendOneTimeRequest,\n      sendPreAuthorizationRequest: walletRequestModule.sendPreAuthorizationRequest,\n      sendTransaction: (input) => walletRequestModule.sendTransaction(input),\n      walletData$: stateModule.walletData$,\n      getWalletData: stateModule.getWalletData\n    },\n    buttonApi: {\n      setTheme: connectButtonModule.setTheme,\n      setMode: connectButtonModule.setMode,\n      status$: connectButtonModule.status$\n    },\n    gatewayApi: {\n      clientConfig: gatewayModule.configuration\n    },\n    disconnect: () => {\n      walletRequestModule.disconnect();\n      connectButtonModule.disconnect();\n      if (onDisconnect) onDisconnect();\n    },\n    destroy: () => {\n      stateModule.destroy();\n      walletRequestModule.destroy();\n      connectButtonModule.destroy();\n    }\n  };\n};\nexport {\n  Account,\n  AccountProof,\n  AccountsRequestItem,\n  AccountsRequestResponseItem,\n  AnswerIO,\n  AuthLoginRequestItem,\n  AuthLoginRequestResponseItem,\n  AuthLoginWithChallengeRequestItem,\n  AuthLoginWithChallengeRequestResponseItem,\n  AuthLoginWithoutChallengeRequestItem,\n  AuthLoginWithoutChallengeRequestResponseItem,\n  AuthRequestItem,\n  AuthRequestResponseItem,\n  AuthUsePersonaRequestItem,\n  CancelRequest,\n  CancelWalletInteractionExtensionInteraction,\n  ConnectButtonModule,\n  ConnectButtonStatus,\n  ConnectButtonSubjects,\n  ConnectorExtensionModule,\n  ConnectorExtensionSubjects,\n  Curve25519,\n  DataRequestBuilder,\n  DataRequestStateModule,\n  DeepLinkModule,\n  EnvironmentModule,\n  ExpireAfterDelay,\n  ExpireAtTime,\n  ExponentialBackoff,\n  ExtensionInteraction,\n  GatewayApiService,\n  GatewayModule,\n  IceCandidateIO,\n  IceCandidatePayloadIO,\n  IceCandidatesIO,\n  IdentityKind,\n  IdentityModule,\n  LocalStorageModule,\n  Logger,\n  LoginRequestResponseItem,\n  MessageLifeCycleEvent,\n  MessageLifeCycleExtensionStatusEvent,\n  Metadata,\n  NumberOfValues,\n  OfferIO,\n  OneTimeDataRequestBuilder,\n  OpenPopupExtensionInteraction,\n  Persona,\n  PersonaDataName,\n  PersonaDataNameVariant,\n  PersonaDataRequestItem,\n  PersonaDataRequestResponseItem,\n  PersonaProof,\n  Proof,\n  ProofOfOwnershipRequestItem,\n  ProofOfOwnershipResponseItem,\n  RadixConnectRelayModule,\n  RadixDappToolkit,\n  RadixNetwork,\n  RadixNetworkConfig,\n  RadixNetworkConfigById,\n  RdtState,\n  RequestItemModule,\n  ResetRequestItem,\n  SendTransactionItem,\n  SendTransactionResponseItem,\n  SessionModule,\n  SharedData,\n  SignalingServerMessage,\n  SignedChallenge,\n  SignedChallengeAccount,\n  SignedChallengePersona,\n  Sources,\n  StateModule,\n  StatusExtensionInteraction,\n  SubintentRequestBuilder,\n  SubintentRequestItem,\n  SubintentResponseItem,\n  TransactionStatus,\n  TransformRdtDataRequestToWalletRequestInput,\n  WalletAuthorizedRequestItems,\n  WalletAuthorizedRequestResponseItems,\n  WalletData,\n  WalletDataPersonaData,\n  WalletDataPersonaDataEmailAddresses,\n  WalletDataPersonaDataFullName,\n  WalletDataPersonaDataPhoneNumbersAddresses,\n  WalletInteraction,\n  WalletInteractionExtensionInteraction,\n  WalletInteractionFailureResponse,\n  WalletInteractionItems,\n  WalletInteractionResponse,\n  WalletInteractionSuccessResponse,\n  WalletPreAuthorizationItems,\n  WalletPreAuthorizationResponseItems,\n  WalletRequestItems,\n  WalletRequestModule,\n  WalletRequestResponseItems,\n  WalletRequestSdk,\n  WalletTransactionItems,\n  WalletUnauthorizedRequestItems,\n  blake2b,\n  canDataRequestBeResolvedByRdtState,\n  config,\n  eventType,\n  extensionInteractionDiscriminator,\n  fetchWrapper,\n  generateGatewayApiConfig,\n  generateRolaChallenge,\n  messageLifeCycleEventType,\n  parseJSON,\n  parseSignedChallenge,\n  personaDataFullNameVariant,\n  proofType,\n  removeUndefined,\n  stringify,\n  toWalletRequest,\n  transformRdtDataRequestToWalletRequest,\n  transformSharedDataToDataRequestState,\n  transformWalletDataToConnectButton,\n  transformWalletRequestToSharedData,\n  transformWalletResponseToRdtWalletData,\n  typedError2 as typedError,\n  unwrapObservable,\n  validateRolaChallenge,\n  validateWalletResponse,\n  walletDataDefault\n};\n/*! Bundled license information:\n\n@noble/hashes/esm/utils.js:\n  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)\n*/\n", "/**\n * Returns true if the object is a function.\n * @param value The value to check\n */\nexport function isFunction(value: any): value is (...args: any[]) => any {\n  return typeof value === 'function';\n}\n", "/**\n * Used to create Error subclasses until the community moves away from ES5.\n *\n * This is because compiling from TypeScript down to ES5 has issues with subclassing Errors\n * as well as other built-in types: https://github.com/Microsoft/TypeScript/issues/12123\n *\n * @param createImpl A factory function to create the actual constructor implementation. The returned\n * function should be a named function that calls `_super` internally.\n */\nexport function createErrorClass<T>(createImpl: (_super: any) => any): T {\n  const _super = (instance: any) => {\n    Error.call(instance);\n    instance.stack = new Error().stack;\n  };\n\n  const ctorFunc = createImpl(_super);\n  ctorFunc.prototype = Object.create(Error.prototype);\n  ctorFunc.prototype.constructor = ctorFunc;\n  return ctorFunc;\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface UnsubscriptionError extends Error {\n  readonly errors: any[];\n}\n\nexport interface UnsubscriptionErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (errors: any[]): UnsubscriptionError;\n}\n\n/**\n * An error thrown when one or more errors have occurred during the\n * `unsubscribe` of a {@link Subscription}.\n */\nexport const UnsubscriptionError: UnsubscriptionErrorCtor = createErrorClass(\n  (_super) =>\n    function UnsubscriptionErrorImpl(this: any, errors: (Error | string)[]) {\n      _super(this);\n      this.message = errors\n        ? `${errors.length} errors occurred during unsubscription:\n${errors.map((err, i) => `${i + 1}) ${err.toString()}`).join('\\n  ')}`\n        : '';\n      this.name = 'UnsubscriptionError';\n      this.errors = errors;\n    }\n);\n", "/**\n * Removes an item from an array, mutating it.\n * @param arr The array to remove the item from\n * @param item The item to remove\n */\nexport function arrRemove<T>(arr: T[] | undefined | null, item: T) {\n  if (arr) {\n    const index = arr.indexOf(item);\n    0 <= index && arr.splice(index, 1);\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { UnsubscriptionError } from './util/UnsubscriptionError';\nimport { SubscriptionLike, TeardownLogic, Unsubscribable } from './types';\nimport { arrRemove } from './util/arrRemove';\n\n/**\n * Represents a disposable resource, such as the execution of an Observable. A\n * Subscription has one important method, `unsubscribe`, that takes no argument\n * and just disposes the resource held by the subscription.\n *\n * Additionally, subscriptions may be grouped together through the `add()`\n * method, which will attach a child Subscription to the current Subscription.\n * When a Subscription is unsubscribed, all its children (and its grandchildren)\n * will be unsubscribed as well.\n */\nexport class Subscription implements SubscriptionLike {\n  public static EMPTY = (() => {\n    const empty = new Subscription();\n    empty.closed = true;\n    return empty;\n  })();\n\n  /**\n   * A flag to indicate whether this Subscription has already been unsubscribed.\n   */\n  public closed = false;\n\n  private _parentage: Subscription[] | Subscription | null = null;\n\n  /**\n   * The list of registered finalizers to execute upon unsubscription. Adding and removing from this\n   * list occurs in the {@link #add} and {@link #remove} methods.\n   */\n  private _finalizers: Exclude<TeardownLogic, void>[] | null = null;\n\n  /**\n   * @param initialTeardown A function executed first as part of the finalization\n   * process that is kicked off when {@link #unsubscribe} is called.\n   */\n  constructor(private initialTeardown?: () => void) {}\n\n  /**\n   * Disposes the resources held by the subscription. May, for instance, cancel\n   * an ongoing Observable execution or cancel any other type of work that\n   * started when the Subscription was created.\n   */\n  unsubscribe(): void {\n    let errors: any[] | undefined;\n\n    if (!this.closed) {\n      this.closed = true;\n\n      // Remove this from it's parents.\n      const { _parentage } = this;\n      if (_parentage) {\n        this._parentage = null;\n        if (Array.isArray(_parentage)) {\n          for (const parent of _parentage) {\n            parent.remove(this);\n          }\n        } else {\n          _parentage.remove(this);\n        }\n      }\n\n      const { initialTeardown: initialFinalizer } = this;\n      if (isFunction(initialFinalizer)) {\n        try {\n          initialFinalizer();\n        } catch (e) {\n          errors = e instanceof UnsubscriptionError ? e.errors : [e];\n        }\n      }\n\n      const { _finalizers } = this;\n      if (_finalizers) {\n        this._finalizers = null;\n        for (const finalizer of _finalizers) {\n          try {\n            execFinalizer(finalizer);\n          } catch (err) {\n            errors = errors ?? [];\n            if (err instanceof UnsubscriptionError) {\n              errors = [...errors, ...err.errors];\n            } else {\n              errors.push(err);\n            }\n          }\n        }\n      }\n\n      if (errors) {\n        throw new UnsubscriptionError(errors);\n      }\n    }\n  }\n\n  /**\n   * Adds a finalizer to this subscription, so that finalization will be unsubscribed/called\n   * when this subscription is unsubscribed. If this subscription is already {@link #closed},\n   * because it has already been unsubscribed, then whatever finalizer is passed to it\n   * will automatically be executed (unless the finalizer itself is also a closed subscription).\n   *\n   * Closed Subscriptions cannot be added as finalizers to any subscription. Adding a closed\n   * subscription to a any subscription will result in no operation. (A noop).\n   *\n   * Adding a subscription to itself, or adding `null` or `undefined` will not perform any\n   * operation at all. (A noop).\n   *\n   * `Subscription` instances that are added to this instance will automatically remove themselves\n   * if they are unsubscribed. Functions and {@link Unsubscribable} objects that you wish to remove\n   * will need to be removed manually with {@link #remove}\n   *\n   * @param teardown The finalization logic to add to this subscription.\n   */\n  add(teardown: TeardownLogic): void {\n    // Only add the finalizer if it's not undefined\n    // and don't add a subscription to itself.\n    if (teardown && teardown !== this) {\n      if (this.closed) {\n        // If this subscription is already closed,\n        // execute whatever finalizer is handed to it automatically.\n        execFinalizer(teardown);\n      } else {\n        if (teardown instanceof Subscription) {\n          // We don't add closed subscriptions, and we don't add the same subscription\n          // twice. Subscription unsubscribe is idempotent.\n          if (teardown.closed || teardown._hasParent(this)) {\n            return;\n          }\n          teardown._addParent(this);\n        }\n        (this._finalizers = this._finalizers ?? []).push(teardown);\n      }\n    }\n  }\n\n  /**\n   * Checks to see if a this subscription already has a particular parent.\n   * This will signal that this subscription has already been added to the parent in question.\n   * @param parent the parent to check for\n   */\n  private _hasParent(parent: Subscription) {\n    const { _parentage } = this;\n    return _parentage === parent || (Array.isArray(_parentage) && _parentage.includes(parent));\n  }\n\n  /**\n   * Adds a parent to this subscription so it can be removed from the parent if it\n   * unsubscribes on it's own.\n   *\n   * NOTE: THIS ASSUMES THAT {@link _hasParent} HAS ALREADY BEEN CHECKED.\n   * @param parent The parent subscription to add\n   */\n  private _addParent(parent: Subscription) {\n    const { _parentage } = this;\n    this._parentage = Array.isArray(_parentage) ? (_parentage.push(parent), _parentage) : _parentage ? [_parentage, parent] : parent;\n  }\n\n  /**\n   * Called on a child when it is removed via {@link #remove}.\n   * @param parent The parent to remove\n   */\n  private _removeParent(parent: Subscription) {\n    const { _parentage } = this;\n    if (_parentage === parent) {\n      this._parentage = null;\n    } else if (Array.isArray(_parentage)) {\n      arrRemove(_parentage, parent);\n    }\n  }\n\n  /**\n   * Removes a finalizer from this subscription that was previously added with the {@link #add} method.\n   *\n   * Note that `Subscription` instances, when unsubscribed, will automatically remove themselves\n   * from every other `Subscription` they have been added to. This means that using the `remove` method\n   * is not a common thing and should be used thoughtfully.\n   *\n   * If you add the same finalizer instance of a function or an unsubscribable object to a `Subscription` instance\n   * more than once, you will need to call `remove` the same number of times to remove all instances.\n   *\n   * All finalizer instances are removed to free up memory upon unsubscription.\n   *\n   * @param teardown The finalizer to remove from this subscription\n   */\n  remove(teardown: Exclude<TeardownLogic, void>): void {\n    const { _finalizers } = this;\n    _finalizers && arrRemove(_finalizers, teardown);\n\n    if (teardown instanceof Subscription) {\n      teardown._removeParent(this);\n    }\n  }\n}\n\nexport const EMPTY_SUBSCRIPTION = Subscription.EMPTY;\n\nexport function isSubscription(value: any): value is Subscription {\n  return (\n    value instanceof Subscription ||\n    (value && 'closed' in value && isFunction(value.remove) && isFunction(value.add) && isFunction(value.unsubscribe))\n  );\n}\n\nfunction execFinalizer(finalizer: Unsubscribable | (() => void)) {\n  if (isFunction(finalizer)) {\n    finalizer();\n  } else {\n    finalizer.unsubscribe();\n  }\n}\n", "import { Subscriber } from './Subscriber';\nimport { ObservableNotification } from './types';\n\n/**\n * The {@link GlobalConfig} object for RxJS. It is used to configure things\n * like how to react on unhandled errors.\n */\nexport const config: GlobalConfig = {\n  onUnhandledError: null,\n  onStoppedNotification: null,\n  Promise: undefined,\n  useDeprecatedSynchronousErrorHandling: false,\n  useDeprecatedNextContext: false,\n};\n\n/**\n * The global configuration object for RxJS, used to configure things\n * like how to react on unhandled errors. Accessible via {@link config}\n * object.\n */\nexport interface GlobalConfig {\n  /**\n   * A registration point for unhandled errors from RxJS. These are errors that\n   * cannot were not handled by consuming code in the usual subscription path. For\n   * example, if you have this configured, and you subscribe to an observable without\n   * providing an error handler, errors from that subscription will end up here. This\n   * will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onUnhandledError: ((err: any) => void) | null;\n\n  /**\n   * A registration point for notifications that cannot be sent to subscribers because they\n   * have completed, errored or have been explicitly unsubscribed. By default, next, complete\n   * and error notifications sent to stopped subscribers are noops. However, sometimes callers\n   * might want a different behavior. For example, with sources that attempt to report errors\n   * to stopped subscribers, a caller can configure RxJS to throw an unhandled error instead.\n   * This will _always_ be called asynchronously on another job in the runtime. This is because\n   * we do not want errors thrown in this user-configured handler to interfere with the\n   * behavior of the library.\n   */\n  onStoppedNotification: ((notification: ObservableNotification<any>, subscriber: Subscriber<any>) => void) | null;\n\n  /**\n   * The promise constructor used by default for {@link Observable#toPromise toPromise} and {@link Observable#forEach forEach}\n   * methods.\n   *\n   * @deprecated As of version 8, RxJS will no longer support this sort of injection of a\n   * Promise constructor. If you need a Promise implementation other than native promises,\n   * please polyfill/patch Promise as you see appropriate. Will be removed in v8.\n   */\n  Promise?: PromiseConstructorLike;\n\n  /**\n   * If true, turns on synchronous error rethrowing, which is a deprecated behavior\n   * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe\n   * call in a try/catch block. It also enables producer interference, a nasty bug\n   * where a multicast can be broken for all observers by a downstream consumer with\n   * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BUY TIME\n   * FOR MIGRATION REASONS.\n   *\n   * @deprecated As of version 8, RxJS will no longer support synchronous throwing\n   * of unhandled errors. All errors will be thrown on a separate call stack to prevent bad\n   * behaviors described above. Will be removed in v8.\n   */\n  useDeprecatedSynchronousErrorHandling: boolean;\n\n  /**\n   * If true, enables an as-of-yet undocumented feature from v5: The ability to access\n   * `unsubscribe()` via `this` context in `next` functions created in observers passed\n   * to `subscribe`.\n   *\n   * This is being removed because the performance was severely problematic, and it could also cause\n   * issues when types other than POJOs are passed to subscribe as subscribers, as they will likely have\n   * their `this` context overwritten.\n   *\n   * @deprecated As of version 8, RxJS will no longer support altering the\n   * context of next functions provided as part of an observer to Subscribe. Instead,\n   * you will have access to a subscription or a signal or token that will allow you to do things like\n   * unsubscribe and test closed status. Will be removed in v8.\n   */\n  useDeprecatedNextContext: boolean;\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetTimeoutFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearTimeoutFunction = (handle: TimerHandle) => void;\n\ninterface TimeoutProvider {\n  setTimeout: SetTimeoutFunction;\n  clearTimeout: ClearTimeoutFunction;\n  delegate:\n    | {\n        setTimeout: SetTimeoutFunction;\n        clearTimeout: ClearTimeoutFunction;\n      }\n    | undefined;\n}\n\nexport const timeoutProvider: TimeoutProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setTimeout(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = timeoutProvider;\n    if (delegate?.setTimeout) {\n      return delegate.setTimeout(handler, timeout, ...args);\n    }\n    return setTimeout(handler, timeout, ...args);\n  },\n  clearTimeout(handle) {\n    const { delegate } = timeoutProvider;\n    return (delegate?.clearTimeout || clearTimeout)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { config } from '../config';\nimport { timeoutProvider } from '../scheduler/timeoutProvider';\n\n/**\n * Handles an error on another job either with the user-configured {@link onUnhandledError},\n * or by throwing it on that new job so it can be picked up by `window.onerror`, `process.on('error')`, etc.\n *\n * This should be called whenever there is an error that is out-of-band with the subscription\n * or when an error hits a terminal boundary of the subscription and no error handler was provided.\n *\n * @param err the error to report\n */\nexport function reportUnhandledError(err: any) {\n  timeoutProvider.setTimeout(() => {\n    const { onUnhandledError } = config;\n    if (onUnhandledError) {\n      // Execute the user-configured error handler.\n      onUnhandledError(err);\n    } else {\n      // Throw so it is picked up by the runtime's uncaught error mechanism.\n      throw err;\n    }\n  });\n}\n", "/* tslint:disable:no-empty */\nexport function noop() { }\n", "import { CompleteNotification, NextNotification, ErrorNotification } from './types';\n\n/**\n * A completion object optimized for memory use and created to be the\n * same \"shape\" as other notifications in v8.\n * @internal\n */\nexport const COMPLETE_NOTIFICATION = (() => createNotification('C', undefined, undefined) as CompleteNotification)();\n\n/**\n * Internal use only. Creates an optimized error notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function errorNotification(error: any): ErrorNotification {\n  return createNotification('E', undefined, error) as any;\n}\n\n/**\n * Internal use only. Creates an optimized next notification that is the same \"shape\"\n * as other notifications.\n * @internal\n */\nexport function nextNotification<T>(value: T) {\n  return createNotification('N', value, undefined) as NextNotification<T>;\n}\n\n/**\n * Ensures that all notifications created internally have the same \"shape\" in v8.\n *\n * TODO: This is only exported to support a crazy legacy test in `groupBy`.\n * @internal\n */\nexport function createNotification(kind: 'N' | 'E' | 'C', value: any, error: any) {\n  return {\n    kind,\n    value,\n    error,\n  };\n}\n", "import { config } from '../config';\n\nlet context: { errorThrown: boolean; error: any } | null = null;\n\n/**\n * Handles dealing with errors for super-gross mode. Creates a context, in which\n * any synchronously thrown errors will be passed to {@link captureError}. Which\n * will record the error such that it will be rethrown after the call back is complete.\n * TODO: Remove in v8\n * @param cb An immediately executed function.\n */\nexport function errorContext(cb: () => void) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    const isRoot = !context;\n    if (isRoot) {\n      context = { errorThrown: false, error: null };\n    }\n    cb();\n    if (isRoot) {\n      const { errorThrown, error } = context!;\n      context = null;\n      if (errorThrown) {\n        throw error;\n      }\n    }\n  } else {\n    // This is the general non-deprecated path for everyone that\n    // isn't crazy enough to use super-gross mode (useDeprecatedSynchronousErrorHandling)\n    cb();\n  }\n}\n\n/**\n * Captures errors only in super-gross mode.\n * @param err the error to capture\n */\nexport function captureError(err: any) {\n  if (config.useDeprecatedSynchronousErrorHandling && context) {\n    context.errorThrown = true;\n    context.error = err;\n  }\n}\n", "import { isFunction } from './util/isFunction';\nimport { Observer, ObservableNotification } from './types';\nimport { isSubscription, Subscription } from './Subscription';\nimport { config } from './config';\nimport { reportUnhandledError } from './util/reportUnhandledError';\nimport { noop } from './util/noop';\nimport { nextNotification, errorNotification, COMPLETE_NOTIFICATION } from './NotificationFactories';\nimport { timeoutProvider } from './scheduler/timeoutProvider';\nimport { captureError } from './util/errorContext';\n\n/**\n * Implements the {@link Observer} interface and extends the\n * {@link Subscription} class. While the {@link Observer} is the public API for\n * consuming the values of an {@link Observable}, all Observers get converted to\n * a Subscriber, in order to provide Subscription-like capabilities such as\n * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for\n * implementing operators, but it is rarely used as a public API.\n */\nexport class Subscriber<T> extends Subscription implements Observer<T> {\n  /**\n   * A static factory for a Subscriber, given a (potentially partial) definition\n   * of an Observer.\n   * @param next The `next` callback of an Observer.\n   * @param error The `error` callback of an\n   * Observer.\n   * @param complete The `complete` callback of an\n   * Observer.\n   * @return A Subscriber wrapping the (partially defined)\n   * Observer represented by the given arguments.\n   * @deprecated Do not use. Will be removed in v8. There is no replacement for this\n   * method, and there is no reason to be creating instances of `Subscriber` directly.\n   * If you have a specific use case, please file an issue.\n   */\n  static create<T>(next?: (x?: T) => void, error?: (e?: any) => void, complete?: () => void): Subscriber<T> {\n    return new SafeSubscriber(next, error, complete);\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected isStopped: boolean = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  protected destination: Subscriber<any> | Observer<any>; // this `any` is the escape hatch to erase extra type param (e.g. R)\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * There is no reason to directly create an instance of Subscriber. This type is exported for typings reasons.\n   */\n  constructor(destination?: Subscriber<any> | Observer<any>) {\n    super();\n    if (destination) {\n      this.destination = destination;\n      // Automatically chain subscriptions together here.\n      // if destination is a Subscription, then it is a Subscriber.\n      if (isSubscription(destination)) {\n        destination.add(this);\n      }\n    } else {\n      this.destination = EMPTY_OBSERVER;\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `next` from\n   * the Observable, with a value. The Observable may call this method 0 or more\n   * times.\n   * @param value The `next` value.\n   */\n  next(value: T): void {\n    if (this.isStopped) {\n      handleStoppedNotification(nextNotification(value), this);\n    } else {\n      this._next(value!);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive notifications of type `error` from\n   * the Observable, with an attached `Error`. Notifies the Observer that\n   * the Observable has experienced an error condition.\n   * @param err The `error` exception.\n   */\n  error(err?: any): void {\n    if (this.isStopped) {\n      handleStoppedNotification(errorNotification(err), this);\n    } else {\n      this.isStopped = true;\n      this._error(err);\n    }\n  }\n\n  /**\n   * The {@link Observer} callback to receive a valueless notification of type\n   * `complete` from the Observable. Notifies the Observer that the Observable\n   * has finished sending push-based notifications.\n   */\n  complete(): void {\n    if (this.isStopped) {\n      handleStoppedNotification(COMPLETE_NOTIFICATION, this);\n    } else {\n      this.isStopped = true;\n      this._complete();\n    }\n  }\n\n  unsubscribe(): void {\n    if (!this.closed) {\n      this.isStopped = true;\n      super.unsubscribe();\n      this.destination = null!;\n    }\n  }\n\n  protected _next(value: T): void {\n    this.destination.next(value);\n  }\n\n  protected _error(err: any): void {\n    try {\n      this.destination.error(err);\n    } finally {\n      this.unsubscribe();\n    }\n  }\n\n  protected _complete(): void {\n    try {\n      this.destination.complete();\n    } finally {\n      this.unsubscribe();\n    }\n  }\n}\n\n/**\n * This bind is captured here because we want to be able to have\n * compatibility with monoid libraries that tend to use a method named\n * `bind`. In particular, a library called Monio requires this.\n */\nconst _bind = Function.prototype.bind;\n\nfunction bind<Fn extends (...args: any[]) => any>(fn: Fn, thisArg: any): Fn {\n  return _bind.call(fn, thisArg);\n}\n\n/**\n * Internal optimization only, DO NOT EXPOSE.\n * @internal\n */\nclass ConsumerObserver<T> implements Observer<T> {\n  constructor(private partialObserver: Partial<Observer<T>>) {}\n\n  next(value: T): void {\n    const { partialObserver } = this;\n    if (partialObserver.next) {\n      try {\n        partialObserver.next(value);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n\n  error(err: any): void {\n    const { partialObserver } = this;\n    if (partialObserver.error) {\n      try {\n        partialObserver.error(err);\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    } else {\n      handleUnhandledError(err);\n    }\n  }\n\n  complete(): void {\n    const { partialObserver } = this;\n    if (partialObserver.complete) {\n      try {\n        partialObserver.complete();\n      } catch (error) {\n        handleUnhandledError(error);\n      }\n    }\n  }\n}\n\nexport class SafeSubscriber<T> extends Subscriber<T> {\n  constructor(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((e?: any) => void) | null,\n    complete?: (() => void) | null\n  ) {\n    super();\n\n    let partialObserver: Partial<Observer<T>>;\n    if (isFunction(observerOrNext) || !observerOrNext) {\n      // The first argument is a function, not an observer. The next\n      // two arguments *could* be observers, or they could be empty.\n      partialObserver = {\n        next: (observerOrNext ?? undefined) as ((value: T) => void) | undefined,\n        error: error ?? undefined,\n        complete: complete ?? undefined,\n      };\n    } else {\n      // The first argument is a partial observer.\n      let context: any;\n      if (this && config.useDeprecatedNextContext) {\n        // This is a deprecated path that made `this.unsubscribe()` available in\n        // next handler functions passed to subscribe. This only exists behind a flag\n        // now, as it is *very* slow.\n        context = Object.create(observerOrNext);\n        context.unsubscribe = () => this.unsubscribe();\n        partialObserver = {\n          next: observerOrNext.next && bind(observerOrNext.next, context),\n          error: observerOrNext.error && bind(observerOrNext.error, context),\n          complete: observerOrNext.complete && bind(observerOrNext.complete, context),\n        };\n      } else {\n        // The \"normal\" path. Just use the partial observer directly.\n        partialObserver = observerOrNext;\n      }\n    }\n\n    // Wrap the partial observer to ensure it's a full observer, and\n    // make sure proper error handling is accounted for.\n    this.destination = new ConsumerObserver(partialObserver);\n  }\n}\n\nfunction handleUnhandledError(error: any) {\n  if (config.useDeprecatedSynchronousErrorHandling) {\n    captureError(error);\n  } else {\n    // Ideal path, we report this as an unhandled error,\n    // which is thrown on a new call stack.\n    reportUnhandledError(error);\n  }\n}\n\n/**\n * An error handler used when no error handler was supplied\n * to the SafeSubscriber -- meaning no error handler was supplied\n * do the `subscribe` call on our observable.\n * @param err The error to handle\n */\nfunction defaultErrorHandler(err: any) {\n  throw err;\n}\n\n/**\n * A handler for notifications that cannot be sent to a stopped subscriber.\n * @param notification The notification being sent.\n * @param subscriber The stopped subscriber.\n */\nfunction handleStoppedNotification(notification: ObservableNotification<any>, subscriber: Subscriber<any>) {\n  const { onStoppedNotification } = config;\n  onStoppedNotification && timeoutProvider.setTimeout(() => onStoppedNotification(notification, subscriber));\n}\n\n/**\n * The observer used as a stub for subscriptions where the user did not\n * pass any arguments to `subscribe`. Comes with the default error handling\n * behavior.\n */\nexport const EMPTY_OBSERVER: Readonly<Observer<any>> & { closed: true } = {\n  closed: true,\n  next: noop,\n  error: defaultErrorHandler,\n  complete: noop,\n};\n", "/**\n * Symbol.observable or a string \"@@observable\". Used for interop\n *\n * @deprecated We will no longer be exporting this symbol in upcoming versions of RxJS.\n * Instead polyfill and use Symbol.observable directly *or* use https://www.npmjs.com/package/symbol-observable\n */\nexport const observable: string | symbol = (() => (typeof Symbol === 'function' && Symbol.observable) || '@@observable')();\n", "/**\n * This function takes one parameter and just returns it. Simply put,\n * this is like `<T>(x: T): T => x`.\n *\n * ## Examples\n *\n * This is useful in some cases when using things like `mergeMap`\n *\n * ```ts\n * import { interval, take, map, range, mergeMap, identity } from 'rxjs';\n *\n * const source$ = interval(1000).pipe(take(5));\n *\n * const result$ = source$.pipe(\n *   map(i => range(i)),\n *   mergeMap(identity) // same as mergeMap(x => x)\n * );\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * Or when you want to selectively apply an operator\n *\n * ```ts\n * import { interval, take, identity } from 'rxjs';\n *\n * const shouldLimit = () => Math.random() < 0.5;\n *\n * const source$ = interval(1000);\n *\n * const result$ = source$.pipe(shouldLimit() ? take(5) : identity);\n *\n * result$.subscribe({\n *   next: console.log\n * });\n * ```\n *\n * @param x Any value that is returned by this function\n * @returns The value passed as the first parameter to this function\n */\nexport function identity<T>(x: T): T {\n  return x;\n}\n", "import { identity } from './identity';\nimport { UnaryFunction } from '../types';\n\nexport function pipe(): typeof identity;\nexport function pipe<T, A>(fn1: UnaryFunction<T, A>): UnaryFunction<T, A>;\nexport function pipe<T, A, B>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>): UnaryFunction<T, B>;\nexport function pipe<T, A, B, C>(fn1: UnaryFunction<T, A>, fn2: UnaryFunction<A, B>, fn3: UnaryFunction<B, C>): UnaryFunction<T, C>;\nexport function pipe<T, A, B, C, D>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>\n): UnaryFunction<T, D>;\nexport function pipe<T, A, B, C, D, E>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>\n): UnaryFunction<T, E>;\nexport function pipe<T, A, B, C, D, E, F>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>\n): UnaryFunction<T, F>;\nexport function pipe<T, A, B, C, D, E, F, G>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>\n): UnaryFunction<T, G>;\nexport function pipe<T, A, B, C, D, E, F, G, H>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>\n): UnaryFunction<T, H>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>\n): UnaryFunction<T, I>;\nexport function pipe<T, A, B, C, D, E, F, G, H, I>(\n  fn1: UnaryFunction<T, A>,\n  fn2: UnaryFunction<A, B>,\n  fn3: UnaryFunction<B, C>,\n  fn4: UnaryFunction<C, D>,\n  fn5: UnaryFunction<D, E>,\n  fn6: UnaryFunction<E, F>,\n  fn7: UnaryFunction<F, G>,\n  fn8: UnaryFunction<G, H>,\n  fn9: UnaryFunction<H, I>,\n  ...fns: UnaryFunction<any, any>[]\n): UnaryFunction<T, unknown>;\n\n/**\n * pipe() can be called on one or more functions, each of which can take one argument (\"UnaryFunction\")\n * and uses it to return a value.\n * It returns a function that takes one argument, passes it to the first UnaryFunction, and then\n * passes the result to the next one, passes that result to the next one, and so on.  \n */\nexport function pipe(...fns: Array<UnaryFunction<any, any>>): UnaryFunction<any, any> {\n  return pipeFromArray(fns);\n}\n\n/** @internal */\nexport function pipeFromArray<T, R>(fns: Array<UnaryFunction<T, R>>): UnaryFunction<T, R> {\n  if (fns.length === 0) {\n    return identity as UnaryFunction<any, any>;\n  }\n\n  if (fns.length === 1) {\n    return fns[0];\n  }\n\n  return function piped(input: T): R {\n    return fns.reduce((prev: any, fn: UnaryFunction<T, R>) => fn(prev), input as any);\n  };\n}\n", "import { Operator } from './Operator';\nimport { SafeSubscriber, Subscriber } from './Subscriber';\nimport { isSubscription, Subscription } from './Subscription';\nimport { TeardownLogic, OperatorFunction, Subscribable, Observer } from './types';\nimport { observable as Symbol_observable } from './symbol/observable';\nimport { pipeFromArray } from './util/pipe';\nimport { config } from './config';\nimport { isFunction } from './util/isFunction';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A representation of any set of values over any amount of time. This is the most basic building block\n * of RxJS.\n */\nexport class Observable<T> implements Subscribable<T> {\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  source: Observable<any> | undefined;\n\n  /**\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  operator: Operator<any, T> | undefined;\n\n  /**\n   * @param subscribe The function that is called when the Observable is\n   * initially subscribed to. This function is given a Subscriber, to which new values\n   * can be `next`ed, or an `error` method can be called to raise an error, or\n   * `complete` can be called to notify of a successful completion.\n   */\n  constructor(subscribe?: (this: Observable<T>, subscriber: Subscriber<T>) => TeardownLogic) {\n    if (subscribe) {\n      this._subscribe = subscribe;\n    }\n  }\n\n  // HACK: Since TypeScript inherits static properties too, we have to\n  // fight against TypeScript here so Subject can have a different static create signature\n  /**\n   * Creates a new Observable by calling the Observable constructor\n   * @param subscribe the subscriber function to be passed to the Observable constructor\n   * @return A new observable.\n   * @deprecated Use `new Observable()` instead. Will be removed in v8.\n   */\n  static create: (...args: any[]) => any = <T>(subscribe?: (subscriber: Subscriber<T>) => TeardownLogic) => {\n    return new Observable<T>(subscribe);\n  };\n\n  /**\n   * Creates a new Observable, with this Observable instance as the source, and the passed\n   * operator defined as the new observable's operator.\n   * @param operator the operator defining the operation to take on the observable\n   * @return A new observable with the Operator applied.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   * If you have implemented an operator using `lift`, it is recommended that you create an\n   * operator by simply returning `new Observable()` directly. See \"Creating new operators from\n   * scratch\" section here: https://rxjs.dev/guide/operators\n   */\n  lift<R>(operator?: Operator<T, R>): Observable<R> {\n    const observable = new Observable<R>();\n    observable.source = this;\n    observable.operator = operator;\n    return observable;\n  }\n\n  subscribe(observerOrNext?: Partial<Observer<T>> | ((value: T) => void)): Subscription;\n  /** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\n  subscribe(next?: ((value: T) => void) | null, error?: ((error: any) => void) | null, complete?: (() => void) | null): Subscription;\n  /**\n   * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.\n   *\n   * <span class=\"informal\">Use it when you have all these Observables, but still nothing is happening.</span>\n   *\n   * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It\n   * might be for example a function that you passed to Observable's constructor, but most of the time it is\n   * a library implementation, which defines what will be emitted by an Observable, and when it be will emitted. This means\n   * that calling `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often\n   * the thought.\n   *\n   * Apart from starting the execution of an Observable, this method allows you to listen for values\n   * that an Observable emits, as well as for when it completes or errors. You can achieve this in two\n   * of the following ways.\n   *\n   * The first way is creating an object that implements {@link Observer} interface. It should have methods\n   * defined by that interface, but note that it should be just a regular JavaScript object, which you can create\n   * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular, do\n   * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also\n   * that your object does not have to implement all methods. If you find yourself creating a method that doesn't\n   * do anything, you can simply omit it. Note however, if the `error` method is not provided and an error happens,\n   * it will be thrown asynchronously. Errors thrown asynchronously cannot be caught using `try`/`catch`. Instead,\n   * use the {@link onUnhandledError} configuration option or use a runtime handler (like `window.onerror` or\n   * `process.on('error)`) to be notified of unhandled errors. Because of this, it's recommended that you provide\n   * an `error` method to avoid missing thrown errors.\n   *\n   * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.\n   * This means you can provide three functions as arguments to `subscribe`, where the first function is equivalent\n   * of a `next` method, the second of an `error` method and the third of a `complete` method. Just as in case of an Observer,\n   * if you do not need to listen for something, you can omit a function by passing `undefined` or `null`,\n   * since `subscribe` recognizes these functions by where they were placed in function call. When it comes\n   * to the `error` function, as with an Observer, if not provided, errors emitted by an Observable will be thrown asynchronously.\n   *\n   * You can, however, subscribe with no parameters at all. This may be the case where you're not interested in terminal events\n   * and you also handled emissions internally by using operators (e.g. using `tap`).\n   *\n   * Whichever style of calling `subscribe` you use, in both cases it returns a Subscription object.\n   * This object allows you to call `unsubscribe` on it, which in turn will stop the work that an Observable does and will clean\n   * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback\n   * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.\n   *\n   * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.\n   * It is an Observable itself that decides when these functions will be called. For example {@link of}\n   * by default emits all its values synchronously. Always check documentation for how given Observable\n   * will behave when subscribed and if its default behavior can be modified with a `scheduler`.\n   *\n   * #### Examples\n   *\n   * Subscribe with an {@link guide/observer Observer}\n   *\n   * ```ts\n   * import { of } from 'rxjs';\n   *\n   * const sumObserver = {\n   *   sum: 0,\n   *   next(value) {\n   *     console.log('Adding: ' + value);\n   *     this.sum = this.sum + value;\n   *   },\n   *   error() {\n   *     // We actually could just remove this method,\n   *     // since we do not really care about errors right now.\n   *   },\n   *   complete() {\n   *     console.log('Sum equals: ' + this.sum);\n   *   }\n   * };\n   *\n   * of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.\n   *   .subscribe(sumObserver);\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Subscribe with functions ({@link deprecations/subscribe-arguments deprecated})\n   *\n   * ```ts\n   * import { of } from 'rxjs'\n   *\n   * let sum = 0;\n   *\n   * of(1, 2, 3).subscribe(\n   *   value => {\n   *     console.log('Adding: ' + value);\n   *     sum = sum + value;\n   *   },\n   *   undefined,\n   *   () => console.log('Sum equals: ' + sum)\n   * );\n   *\n   * // Logs:\n   * // 'Adding: 1'\n   * // 'Adding: 2'\n   * // 'Adding: 3'\n   * // 'Sum equals: 6'\n   * ```\n   *\n   * Cancel a subscription\n   *\n   * ```ts\n   * import { interval } from 'rxjs';\n   *\n   * const subscription = interval(1000).subscribe({\n   *   next(num) {\n   *     console.log(num)\n   *   },\n   *   complete() {\n   *     // Will not be called, even when cancelling subscription.\n   *     console.log('completed!');\n   *   }\n   * });\n   *\n   * setTimeout(() => {\n   *   subscription.unsubscribe();\n   *   console.log('unsubscribed!');\n   * }, 2500);\n   *\n   * // Logs:\n   * // 0 after 1s\n   * // 1 after 2s\n   * // 'unsubscribed!' after 2.5s\n   * ```\n   *\n   * @param observerOrNext Either an {@link Observer} with some or all callback methods,\n   * or the `next` handler that is called for each value emitted from the subscribed Observable.\n   * @param error A handler for a terminal event resulting from an error. If no error handler is provided,\n   * the error will be thrown asynchronously as unhandled.\n   * @param complete A handler for a terminal event resulting from successful completion.\n   * @return A subscription reference to the registered handlers.\n   */\n  subscribe(\n    observerOrNext?: Partial<Observer<T>> | ((value: T) => void) | null,\n    error?: ((error: any) => void) | null,\n    complete?: (() => void) | null\n  ): Subscription {\n    const subscriber = isSubscriber(observerOrNext) ? observerOrNext : new SafeSubscriber(observerOrNext, error, complete);\n\n    errorContext(() => {\n      const { operator, source } = this;\n      subscriber.add(\n        operator\n          ? // We're dealing with a subscription in the\n            // operator chain to one of our lifted operators.\n            operator.call(subscriber, source)\n          : source\n          ? // If `source` has a value, but `operator` does not, something that\n            // had intimate knowledge of our API, like our `Subject`, must have\n            // set it. We're going to just call `_subscribe` directly.\n            this._subscribe(subscriber)\n          : // In all other cases, we're likely wrapping a user-provided initializer\n            // function, so we need to catch errors and handle them appropriately.\n            this._trySubscribe(subscriber)\n      );\n    });\n\n    return subscriber;\n  }\n\n  /** @internal */\n  protected _trySubscribe(sink: Subscriber<T>): TeardownLogic {\n    try {\n      return this._subscribe(sink);\n    } catch (err) {\n      // We don't need to return anything in this case,\n      // because it's just going to try to `add()` to a subscription\n      // above.\n      sink.error(err);\n    }\n  }\n\n  /**\n   * Used as a NON-CANCELLABLE means of subscribing to an observable, for use with\n   * APIs that expect promises, like `async/await`. You cannot unsubscribe from this.\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * #### Example\n   *\n   * ```ts\n   * import { interval, take } from 'rxjs';\n   *\n   * const source$ = interval(1000).pipe(take(4));\n   *\n   * async function getTotal() {\n   *   let total = 0;\n   *\n   *   await source$.forEach(value => {\n   *     total += value;\n   *     console.log('observable -> ' + value);\n   *   });\n   *\n   *   return total;\n   * }\n   *\n   * getTotal().then(\n   *   total => console.log('Total: ' + total)\n   * );\n   *\n   * // Expected:\n   * // 'observable -> 0'\n   * // 'observable -> 1'\n   * // 'observable -> 2'\n   * // 'observable -> 3'\n   * // 'Total: 6'\n   * ```\n   *\n   * @param next A handler for each value emitted by the observable.\n   * @return A promise that either resolves on observable completion or\n   * rejects with the handled error.\n   */\n  forEach(next: (value: T) => void): Promise<void>;\n\n  /**\n   * @param next a handler for each value emitted by the observable\n   * @param promiseCtor a constructor function used to instantiate the Promise\n   * @return a promise that either resolves on observable completion or\n   *  rejects with the handled error\n   * @deprecated Passing a Promise constructor will no longer be available\n   * in upcoming versions of RxJS. This is because it adds weight to the library, for very\n   * little benefit. If you need this functionality, it is recommended that you either\n   * polyfill Promise, or you create an adapter to convert the returned native promise\n   * to whatever promise implementation you wanted. Will be removed in v8.\n   */\n  forEach(next: (value: T) => void, promiseCtor: PromiseConstructorLike): Promise<void>;\n\n  forEach(next: (value: T) => void, promiseCtor?: PromiseConstructorLike): Promise<void> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor<void>((resolve, reject) => {\n      const subscriber = new SafeSubscriber<T>({\n        next: (value) => {\n          try {\n            next(value);\n          } catch (err) {\n            reject(err);\n            subscriber.unsubscribe();\n          }\n        },\n        error: reject,\n        complete: resolve,\n      });\n      this.subscribe(subscriber);\n    }) as Promise<void>;\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<any>): TeardownLogic {\n    return this.source?.subscribe(subscriber);\n  }\n\n  /**\n   * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable\n   * @return This instance of the observable.\n   */\n  [Symbol_observable]() {\n    return this;\n  }\n\n  /* tslint:disable:max-line-length */\n  pipe(): Observable<T>;\n  pipe<A>(op1: OperatorFunction<T, A>): Observable<A>;\n  pipe<A, B>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>): Observable<B>;\n  pipe<A, B, C>(op1: OperatorFunction<T, A>, op2: OperatorFunction<A, B>, op3: OperatorFunction<B, C>): Observable<C>;\n  pipe<A, B, C, D>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>\n  ): Observable<D>;\n  pipe<A, B, C, D, E>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>\n  ): Observable<E>;\n  pipe<A, B, C, D, E, F>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>\n  ): Observable<F>;\n  pipe<A, B, C, D, E, F, G>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>\n  ): Observable<G>;\n  pipe<A, B, C, D, E, F, G, H>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>\n  ): Observable<H>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>\n  ): Observable<I>;\n  pipe<A, B, C, D, E, F, G, H, I>(\n    op1: OperatorFunction<T, A>,\n    op2: OperatorFunction<A, B>,\n    op3: OperatorFunction<B, C>,\n    op4: OperatorFunction<C, D>,\n    op5: OperatorFunction<D, E>,\n    op6: OperatorFunction<E, F>,\n    op7: OperatorFunction<F, G>,\n    op8: OperatorFunction<G, H>,\n    op9: OperatorFunction<H, I>,\n    ...operations: OperatorFunction<any, any>[]\n  ): Observable<unknown>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Used to stitch together functional operators into a chain.\n   *\n   * ## Example\n   *\n   * ```ts\n   * import { interval, filter, map, scan } from 'rxjs';\n   *\n   * interval(1000)\n   *   .pipe(\n   *     filter(x => x % 2 === 0),\n   *     map(x => x + x),\n   *     scan((acc, x) => acc + x)\n   *   )\n   *   .subscribe(x => console.log(x));\n   * ```\n   *\n   * @return The Observable result of all the operators having been called\n   * in the order they were passed in.\n   */\n  pipe(...operations: OperatorFunction<any, any>[]): Observable<any> {\n    return pipeFromArray(operations)(this);\n  }\n\n  /* tslint:disable:max-line-length */\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: typeof Promise): Promise<T | undefined>;\n  /** @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise */\n  toPromise(PromiseCtor: PromiseConstructorLike): Promise<T | undefined>;\n  /* tslint:enable:max-line-length */\n\n  /**\n   * Subscribe to this Observable and get a Promise resolving on\n   * `complete` with the last emission (if any).\n   *\n   * **WARNING**: Only use this with observables you *know* will complete. If the source\n   * observable does not complete, you will end up with a promise that is hung up, and\n   * potentially all of the state of an async function hanging out in memory. To avoid\n   * this situation, look into adding something like {@link timeout}, {@link take},\n   * {@link takeWhile}, or {@link takeUntil} amongst others.\n   *\n   * @param [promiseCtor] a constructor function used to instantiate\n   * the Promise\n   * @return A Promise that resolves with the last value emit, or\n   * rejects on an error. If there were no emissions, Promise\n   * resolves with undefined.\n   * @deprecated Replaced with {@link firstValueFrom} and {@link lastValueFrom}. Will be removed in v8. Details: https://rxjs.dev/deprecations/to-promise\n   */\n  toPromise(promiseCtor?: PromiseConstructorLike): Promise<T | undefined> {\n    promiseCtor = getPromiseCtor(promiseCtor);\n\n    return new promiseCtor((resolve, reject) => {\n      let value: T | undefined;\n      this.subscribe(\n        (x: T) => (value = x),\n        (err: any) => reject(err),\n        () => resolve(value)\n      );\n    }) as Promise<T | undefined>;\n  }\n}\n\n/**\n * Decides between a passed promise constructor from consuming code,\n * A default configured promise constructor, and the native promise\n * constructor and returns it. If nothing can be found, it will throw\n * an error.\n * @param promiseCtor The optional promise constructor to passed by consuming code\n */\nfunction getPromiseCtor(promiseCtor: PromiseConstructorLike | undefined) {\n  return promiseCtor ?? config.Promise ?? Promise;\n}\n\nfunction isObserver<T>(value: any): value is Observer<T> {\n  return value && isFunction(value.next) && isFunction(value.error) && isFunction(value.complete);\n}\n\nfunction isSubscriber<T>(value: any): value is Subscriber<T> {\n  return (value && value instanceof Subscriber) || (isObserver(value) && isSubscription(value));\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { OperatorFunction } from '../types';\nimport { isFunction } from './isFunction';\n\n/**\n * Used to determine if an object is an Observable with a lift function.\n */\nexport function hasLift(source: any): source is { lift: InstanceType<typeof Observable>['lift'] } {\n  return isFunction(source?.lift);\n}\n\n/**\n * Creates an `OperatorFunction`. Used to define operators throughout the library in a concise way.\n * @param init The logic to connect the liftedSource to the subscriber at the moment of subscription.\n */\nexport function operate<T, R>(\n  init: (liftedSource: Observable<T>, subscriber: Subscriber<R>) => (() => void) | void\n): OperatorFunction<T, R> {\n  return (source: Observable<T>) => {\n    if (hasLift(source)) {\n      return source.lift(function (this: Subscriber<R>, liftedSource: Observable<T>) {\n        try {\n          return init(liftedSource, this);\n        } catch (err) {\n          this.error(err);\n        }\n      });\n    }\n    throw new TypeError('Unable to lift unknown Observable type');\n  };\n}\n", "import { Subscriber } from '../Subscriber';\n\n/**\n * Creates an instance of an `OperatorSubscriber`.\n * @param destination The downstream subscriber.\n * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n * and send to the `destination` error handler.\n * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n * this handler are sent to the `destination` error handler.\n * @param onFinalize Additional teardown logic here. This will only be called on teardown if the\n * subscriber itself is not already closed. This is called after all other teardown logic is executed.\n */\nexport function createOperatorSubscriber<T>(\n  destination: Subscriber<any>,\n  onNext?: (value: T) => void,\n  onComplete?: () => void,\n  onError?: (err: any) => void,\n  onFinalize?: () => void\n): Subscriber<T> {\n  return new OperatorSubscriber(destination, onNext, onComplete, onError, onFinalize);\n}\n\n/**\n * A generic helper for allowing operators to be created with a Subscriber and\n * use closures to capture necessary state from the operator function itself.\n */\nexport class OperatorSubscriber<T> extends Subscriber<T> {\n  /**\n   * Creates an instance of an `OperatorSubscriber`.\n   * @param destination The downstream subscriber.\n   * @param onNext Handles next values, only called if this subscriber is not stopped or closed. Any\n   * error that occurs in this function is caught and sent to the `error` method of this subscriber.\n   * @param onError Handles errors from the subscription, any errors that occur in this handler are caught\n   * and send to the `destination` error handler.\n   * @param onComplete Handles completion notification from the subscription. Any errors that occur in\n   * this handler are sent to the `destination` error handler.\n   * @param onFinalize Additional finalization logic here. This will only be called on finalization if the\n   * subscriber itself is not already closed. This is called after all other finalization logic is executed.\n   * @param shouldUnsubscribe An optional check to see if an unsubscribe call should truly unsubscribe.\n   * NOTE: This currently **ONLY** exists to support the strange behavior of {@link groupBy}, where unsubscription\n   * to the resulting observable does not actually disconnect from the source if there are active subscriptions\n   * to any grouped observable. (DO NOT EXPOSE OR USE EXTERNALLY!!!)\n   */\n  constructor(\n    destination: Subscriber<any>,\n    onNext?: (value: T) => void,\n    onComplete?: () => void,\n    onError?: (err: any) => void,\n    private onFinalize?: () => void,\n    private shouldUnsubscribe?: () => boolean\n  ) {\n    // It's important - for performance reasons - that all of this class's\n    // members are initialized and that they are always initialized in the same\n    // order. This will ensure that all OperatorSubscriber instances have the\n    // same hidden class in V8. This, in turn, will help keep the number of\n    // hidden classes involved in property accesses within the base class as\n    // low as possible. If the number of hidden classes involved exceeds four,\n    // the property accesses will become megamorphic and performance penalties\n    // will be incurred - i.e. inline caches won't be used.\n    //\n    // The reasons for ensuring all instances have the same hidden class are\n    // further discussed in this blog post from Benedikt Meurer:\n    // https://benediktmeurer.de/2018/03/23/impact-of-polymorphism-on-component-based-frameworks-like-react/\n    super(destination);\n    this._next = onNext\n      ? function (this: OperatorSubscriber<T>, value: T) {\n          try {\n            onNext(value);\n          } catch (err) {\n            destination.error(err);\n          }\n        }\n      : super._next;\n    this._error = onError\n      ? function (this: OperatorSubscriber<T>, err: any) {\n          try {\n            onError(err);\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._error;\n    this._complete = onComplete\n      ? function (this: OperatorSubscriber<T>) {\n          try {\n            onComplete();\n          } catch (err) {\n            // Send any errors that occur down stream.\n            destination.error(err);\n          } finally {\n            // Ensure finalization.\n            this.unsubscribe();\n          }\n        }\n      : super._complete;\n  }\n\n  unsubscribe() {\n    if (!this.shouldUnsubscribe || this.shouldUnsubscribe()) {\n      const { closed } = this;\n      super.unsubscribe();\n      // Execute additional teardown if we have any and we didn't already do so.\n      !closed && this.onFinalize?.();\n    }\n  }\n}\n", "import { ConnectableObservable } from '../observable/ConnectableObservable';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Make a {@link ConnectableObservable} behave like a ordinary observable and automates the way\n * you can connect to it.\n *\n * Internally it counts the subscriptions to the observable and subscribes (only once) to the source if\n * the number of subscriptions is larger than 0. If the number of subscriptions is smaller than 1, it\n * unsubscribes from the source. This way you can make sure that everything before the *published*\n * refCount has only a single subscription independently of the number of subscribers to the target\n * observable.\n *\n * Note that using the {@link share} operator is exactly the same as using the `multicast(() => new Subject())` operator\n * (making the observable hot) and the *refCount* operator in a sequence.\n *\n * ![](refCount.png)\n *\n * ## Example\n *\n * In the following example there are two intervals turned into connectable observables\n * by using the *publish* operator. The first one uses the *refCount* operator, the\n * second one does not use it. You will notice that a connectable observable does nothing\n * until you call its connect function.\n *\n * ```ts\n * import { interval, tap, publish, refCount } from 'rxjs';\n *\n * // Turn the interval observable into a ConnectableObservable (hot)\n * const refCountInterval = interval(400).pipe(\n *   tap(num => console.log(`refCount ${ num }`)),\n *   publish(),\n *   refCount()\n * );\n *\n * const publishedInterval = interval(400).pipe(\n *   tap(num => console.log(`publish ${ num }`)),\n *   publish()\n * );\n *\n * refCountInterval.subscribe();\n * refCountInterval.subscribe();\n * // 'refCount 0' -----> 'refCount 1' -----> etc\n * // All subscriptions will receive the same value and the tap (and\n * // every other operator) before the `publish` operator will be executed\n * // only once per event independently of the number of subscriptions.\n *\n * publishedInterval.subscribe();\n * // Nothing happens until you call .connect() on the observable.\n * ```\n *\n * @return A function that returns an Observable that automates the connection\n * to ConnectableObservable.\n * @see {@link ConnectableObservable}\n * @see {@link share}\n * @see {@link publish}\n * @deprecated Replaced with the {@link share} operator. How `share` is used\n * will depend on the connectable observable you created just prior to the\n * `refCount` operator.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport function refCount<T>(): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let connection: Subscription | null = null;\n\n    (source as any)._refCount++;\n\n    const refCounter = createOperatorSubscriber(subscriber, undefined, undefined, undefined, () => {\n      if (!source || (source as any)._refCount <= 0 || 0 < --(source as any)._refCount) {\n        connection = null;\n        return;\n      }\n\n      ///\n      // Compare the local RefCountSubscriber's connection Subscription to the\n      // connection Subscription on the shared ConnectableObservable. In cases\n      // where the ConnectableObservable source synchronously emits values, and\n      // the RefCountSubscriber's downstream Observers synchronously unsubscribe,\n      // execution continues to here before the RefCountOperator has a chance to\n      // supply the RefCountSubscriber with the shared connection Subscription.\n      // For example:\n      // ```\n      // range(0, 10).pipe(\n      //   publish(),\n      //   refCount(),\n      //   take(5),\n      // )\n      // .subscribe();\n      // ```\n      // In order to account for this case, RefCountSubscriber should only dispose\n      // the ConnectableObservable's shared connection Subscription if the\n      // connection Subscription exists, *and* either:\n      //   a. RefCountSubscriber doesn't have a reference to the shared connection\n      //      Subscription yet, or,\n      //   b. RefCountSubscriber's connection Subscription reference is identical\n      //      to the shared connection Subscription\n      ///\n\n      const sharedConnection = (source as any)._connection;\n      const conn = connection;\n      connection = null;\n\n      if (sharedConnection && (!conn || sharedConnection === conn)) {\n        sharedConnection.unsubscribe();\n      }\n\n      subscriber.unsubscribe();\n    });\n\n    source.subscribe(refCounter);\n\n    if (!refCounter.closed) {\n      connection = (source as ConnectableObservable<T>).connect();\n    }\n  });\n}\n", "import { Subject } from '../Subject';\nimport { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { refCount as higherOrderRefCount } from '../operators/refCount';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { hasLift } from '../util/lift';\n\n/**\n * @class ConnectableObservable<T>\n * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n * If you are using the `refCount` method of `ConnectableObservable`, use the {@link share} operator\n * instead.\n * Details: https://rxjs.dev/deprecations/multicasting\n */\nexport class ConnectableObservable<T> extends Observable<T> {\n  protected _subject: Subject<T> | null = null;\n  protected _refCount: number = 0;\n  protected _connection: Subscription | null = null;\n\n  /**\n   * @param source The source observable\n   * @param subjectFactory The factory that creates the subject used internally.\n   * @deprecated Will be removed in v8. Use {@link connectable} to create a connectable observable.\n   * `new ConnectableObservable(source, factory)` is equivalent to\n   * `connectable(source, { connector: factory })`.\n   * When the `refCount()` method is needed, the {@link share} operator should be used instead:\n   * `new ConnectableObservable(source, factory).refCount()` is equivalent to\n   * `source.pipe(share({ connector: factory }))`.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  constructor(public source: Observable<T>, protected subjectFactory: () => Subject<T>) {\n    super();\n    // If we have lift, monkey patch that here. This is done so custom observable\n    // types will compose through multicast. Otherwise the resulting observable would\n    // simply be an instance of `ConnectableObservable`.\n    if (hasLift(source)) {\n      this.lift = source.lift;\n    }\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>) {\n    return this.getSubject().subscribe(subscriber);\n  }\n\n  protected getSubject(): Subject<T> {\n    const subject = this._subject;\n    if (!subject || subject.isStopped) {\n      this._subject = this.subjectFactory();\n    }\n    return this._subject!;\n  }\n\n  protected _teardown() {\n    this._refCount = 0;\n    const { _connection } = this;\n    this._subject = this._connection = null;\n    _connection?.unsubscribe();\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use {@link connectable} instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  connect(): Subscription {\n    let connection = this._connection;\n    if (!connection) {\n      connection = this._connection = new Subscription();\n      const subject = this.getSubject();\n      connection.add(\n        this.source.subscribe(\n          createOperatorSubscriber(\n            subject as any,\n            undefined,\n            () => {\n              this._teardown();\n              subject.complete();\n            },\n            (err) => {\n              this._teardown();\n              subject.error(err);\n            },\n            () => this._teardown()\n          )\n        )\n      );\n\n      if (connection.closed) {\n        this._connection = null;\n        connection = Subscription.EMPTY;\n      }\n    }\n    return connection;\n  }\n\n  /**\n   * @deprecated {@link ConnectableObservable} will be removed in v8. Use the {@link share} operator instead.\n   * Details: https://rxjs.dev/deprecations/multicasting\n   */\n  refCount(): Observable<T> {\n    return higherOrderRefCount()(this) as Observable<T>;\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface PerformanceTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const performanceTimestampProvider: PerformanceTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (performanceTimestampProvider.delegate || performance).now();\n  },\n  delegate: undefined,\n};\n", "import { Subscription } from '../Subscription';\n\ninterface AnimationFrameProvider {\n  schedule(callback: FrameRequestCallback): Subscription;\n  requestAnimationFrame: typeof requestAnimationFrame;\n  cancelAnimationFrame: typeof cancelAnimationFrame;\n  delegate:\n    | {\n        requestAnimationFrame: typeof requestAnimationFrame;\n        cancelAnimationFrame: typeof cancelAnimationFrame;\n      }\n    | undefined;\n}\n\nexport const animationFrameProvider: AnimationFrameProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  schedule(callback) {\n    let request = requestAnimationFrame;\n    let cancel: typeof cancelAnimationFrame | undefined = cancelAnimationFrame;\n    const { delegate } = animationFrameProvider;\n    if (delegate) {\n      request = delegate.requestAnimationFrame;\n      cancel = delegate.cancelAnimationFrame;\n    }\n    const handle = request((timestamp) => {\n      // Clear the cancel function. The request has been fulfilled, so\n      // attempting to cancel the request upon unsubscription would be\n      // pointless.\n      cancel = undefined;\n      callback(timestamp);\n    });\n    return new Subscription(() => cancel?.(handle));\n  },\n  requestAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.requestAnimationFrame || requestAnimationFrame)(...args);\n  },\n  cancelAnimationFrame(...args) {\n    const { delegate } = animationFrameProvider;\n    return (delegate?.cancelAnimationFrame || cancelAnimationFrame)(...args);\n  },\n  delegate: undefined,\n};\n", "import { Observable } from '../../Observable';\nimport { TimestampProvider } from '../../types';\nimport { performanceTimestampProvider } from '../../scheduler/performanceTimestampProvider';\nimport { animationFrameProvider } from '../../scheduler/animationFrameProvider';\n\n/**\n * An observable of animation frames\n *\n * Emits the amount of time elapsed since subscription and the timestamp on each animation frame.\n * Defaults to milliseconds provided to the requestAnimationFrame's callback. Does not end on its own.\n *\n * Every subscription will start a separate animation loop. Since animation frames are always scheduled\n * by the browser to occur directly before a repaint, scheduling more than one animation frame synchronously\n * should not be much different or have more overhead than looping over an array of events during\n * a single animation frame. However, if for some reason the developer would like to ensure the\n * execution of animation-related handlers are all executed during the same task by the engine,\n * the `share` operator can be used.\n *\n * This is useful for setting up animations with RxJS.\n *\n * ## Examples\n *\n * Tweening a div to move it on the screen\n *\n * ```ts\n * import { animationFrames, map, takeWhile, endWith } from 'rxjs';\n *\n * function tween(start: number, end: number, duration: number) {\n *   const diff = end - start;\n *   return animationFrames().pipe(\n *     // Figure out what percentage of time has passed\n *     map(({ elapsed }) => elapsed / duration),\n *     // Take the vector while less than 100%\n *     takeWhile(v => v < 1),\n *     // Finish with 100%\n *     endWith(1),\n *     // Calculate the distance traveled between start and end\n *     map(v => v * diff + start)\n *   );\n * }\n *\n * // Setup a div for us to move around\n * const div = document.createElement('div');\n * document.body.appendChild(div);\n * div.style.position = 'absolute';\n * div.style.width = '40px';\n * div.style.height = '40px';\n * div.style.backgroundColor = 'lime';\n * div.style.transform = 'translate3d(10px, 0, 0)';\n *\n * tween(10, 200, 4000).subscribe(x => {\n *   div.style.transform = `translate3d(${ x }px, 0, 0)`;\n * });\n * ```\n *\n * Providing a custom timestamp provider\n *\n * ```ts\n * import { animationFrames, TimestampProvider } from 'rxjs';\n *\n * // A custom timestamp provider\n * let now = 0;\n * const customTSProvider: TimestampProvider = {\n *   now() { return now++; }\n * };\n *\n * const source$ = animationFrames(customTSProvider);\n *\n * // Log increasing numbers 0...1...2... on every animation frame.\n * source$.subscribe(({ elapsed }) => console.log(elapsed));\n * ```\n *\n * @param timestampProvider An object with a `now` method that provides a numeric timestamp\n */\nexport function animationFrames(timestampProvider?: TimestampProvider) {\n  return timestampProvider ? animationFramesFactory(timestampProvider) : DEFAULT_ANIMATION_FRAMES;\n}\n\n/**\n * Does the work of creating the observable for `animationFrames`.\n * @param timestampProvider The timestamp provider to use to create the observable\n */\nfunction animationFramesFactory(timestampProvider?: TimestampProvider) {\n  return new Observable<{ timestamp: number; elapsed: number }>((subscriber) => {\n    // If no timestamp provider is specified, use performance.now() - as it\n    // will return timestamps 'compatible' with those passed to the run\n    // callback and won't be affected by NTP adjustments, etc.\n    const provider = timestampProvider || performanceTimestampProvider;\n\n    // Capture the start time upon subscription, as the run callback can remain\n    // queued for a considerable period of time and the elapsed time should\n    // represent the time elapsed since subscription - not the time since the\n    // first rendered animation frame.\n    const start = provider.now();\n\n    let id = 0;\n    const run = () => {\n      if (!subscriber.closed) {\n        id = animationFrameProvider.requestAnimationFrame((timestamp: DOMHighResTimeStamp | number) => {\n          id = 0;\n          // Use the provider's timestamp to calculate the elapsed time. Note that\n          // this means - if the caller hasn't passed a provider - that\n          // performance.now() will be used instead of the timestamp that was\n          // passed to the run callback. The reason for this is that the timestamp\n          // passed to the callback can be earlier than the start time, as it\n          // represents the time at which the browser decided it would render any\n          // queued frames - and that time can be earlier the captured start time.\n          const now = provider.now();\n          subscriber.next({\n            timestamp: timestampProvider ? now : timestamp,\n            elapsed: now - start,\n          });\n          run();\n        });\n      }\n    };\n\n    run();\n\n    return () => {\n      if (id) {\n        animationFrameProvider.cancelAnimationFrame(id);\n      }\n    };\n  });\n}\n\n/**\n * In the common case, where the timestamp provided by the rAF API is used,\n * we use this shared observable to reduce overhead.\n */\nconst DEFAULT_ANIMATION_FRAMES = animationFramesFactory();\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ObjectUnsubscribedError extends Error {}\n\nexport interface ObjectUnsubscribedErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ObjectUnsubscribedError;\n}\n\n/**\n * An error thrown when an action is invalid because the object has been\n * unsubscribed.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n *\n * @class ObjectUnsubscribedError\n */\nexport const ObjectUnsubscribedError: ObjectUnsubscribedErrorCtor = createErrorClass(\n  (_super) =>\n    function ObjectUnsubscribedErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ObjectUnsubscribedError';\n      this.message = 'object unsubscribed';\n    }\n);\n", "import { Operator } from './Operator';\nimport { Observable } from './Observable';\nimport { Subscriber } from './Subscriber';\nimport { Subscription, EMPTY_SUBSCRIPTION } from './Subscription';\nimport { Observer, SubscriptionLike, TeardownLogic } from './types';\nimport { ObjectUnsubscribedError } from './util/ObjectUnsubscribedError';\nimport { arrRemove } from './util/arrRemove';\nimport { errorContext } from './util/errorContext';\n\n/**\n * A Subject is a special type of Observable that allows values to be\n * multicasted to many Observers. Subjects are like EventEmitters.\n *\n * Every Subject is an Observable and an Observer. You can subscribe to a\n * Subject, and you can call next to feed values as well as error and complete.\n */\nexport class Subject<T> extends Observable<T> implements SubscriptionLike {\n  closed = false;\n\n  private currentObservers: Observer<T>[] | null = null;\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  observers: Observer<T>[] = [];\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  isStopped = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  hasError = false;\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  thrownError: any = null;\n\n  /**\n   * Creates a \"subject\" by basically gluing an observer to an observable.\n   *\n   * @deprecated Recommended you do not use. Will be removed at some point in the future. Plans for replacement still under discussion.\n   */\n  static create: (...args: any[]) => any = <T>(destination: Observer<T>, source: Observable<T>): AnonymousSubject<T> => {\n    return new AnonymousSubject<T>(destination, source);\n  };\n\n  constructor() {\n    // NOTE: This must be here to obscure Observable's constructor.\n    super();\n  }\n\n  /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n  lift<R>(operator: Operator<T, R>): Observable<R> {\n    const subject = new AnonymousSubject(this, this);\n    subject.operator = operator as any;\n    return subject as any;\n  }\n\n  /** @internal */\n  protected _throwIfClosed() {\n    if (this.closed) {\n      throw new ObjectUnsubscribedError();\n    }\n  }\n\n  next(value: T) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        if (!this.currentObservers) {\n          this.currentObservers = Array.from(this.observers);\n        }\n        for (const observer of this.currentObservers) {\n          observer.next(value);\n        }\n      }\n    });\n  }\n\n  error(err: any) {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.hasError = this.isStopped = true;\n        this.thrownError = err;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.error(err);\n        }\n      }\n    });\n  }\n\n  complete() {\n    errorContext(() => {\n      this._throwIfClosed();\n      if (!this.isStopped) {\n        this.isStopped = true;\n        const { observers } = this;\n        while (observers.length) {\n          observers.shift()!.complete();\n        }\n      }\n    });\n  }\n\n  unsubscribe() {\n    this.isStopped = this.closed = true;\n    this.observers = this.currentObservers = null!;\n  }\n\n  get observed() {\n    return this.observers?.length > 0;\n  }\n\n  /** @internal */\n  protected _trySubscribe(subscriber: Subscriber<T>): TeardownLogic {\n    this._throwIfClosed();\n    return super._trySubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._checkFinalizedStatuses(subscriber);\n    return this._innerSubscribe(subscriber);\n  }\n\n  /** @internal */\n  protected _innerSubscribe(subscriber: Subscriber<any>) {\n    const { hasError, isStopped, observers } = this;\n    if (hasError || isStopped) {\n      return EMPTY_SUBSCRIPTION;\n    }\n    this.currentObservers = null;\n    observers.push(subscriber);\n    return new Subscription(() => {\n      this.currentObservers = null;\n      arrRemove(observers, subscriber);\n    });\n  }\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<any>) {\n    const { hasError, thrownError, isStopped } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped) {\n      subscriber.complete();\n    }\n  }\n\n  /**\n   * Creates a new Observable with this Subject as the source. You can do this\n   * to create custom Observer-side logic of the Subject and conceal it from\n   * code that uses the Observable.\n   * @return Observable that this Subject casts to.\n   */\n  asObservable(): Observable<T> {\n    const observable: any = new Observable<T>();\n    observable.source = this;\n    return observable;\n  }\n}\n\nexport class AnonymousSubject<T> extends Subject<T> {\n  constructor(\n    /** @deprecated Internal implementation detail, do not use directly. Will be made internal in v8. */\n    public destination?: Observer<T>,\n    source?: Observable<T>\n  ) {\n    super();\n    this.source = source;\n  }\n\n  next(value: T) {\n    this.destination?.next?.(value);\n  }\n\n  error(err: any) {\n    this.destination?.error?.(err);\n  }\n\n  complete() {\n    this.destination?.complete?.();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    return this.source?.subscribe(subscriber) ?? EMPTY_SUBSCRIPTION;\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\n\n/**\n * A variant of Subject that requires an initial value and emits its current\n * value whenever it is subscribed to.\n */\nexport class BehaviorSubject<T> extends Subject<T> {\n  constructor(private _value: T) {\n    super();\n  }\n\n  get value(): T {\n    return this.getValue();\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    const subscription = super._subscribe(subscriber);\n    !subscription.closed && subscriber.next(this._value);\n    return subscription;\n  }\n\n  getValue(): T {\n    const { hasError, thrownError, _value } = this;\n    if (hasError) {\n      throw thrownError;\n    }\n    this._throwIfClosed();\n    return _value;\n  }\n\n  next(value: T): void {\n    super.next((this._value = value));\n  }\n}\n", "import { TimestampProvider } from '../types';\n\ninterface DateTimestampProvider extends TimestampProvider {\n  delegate: TimestampProvider | undefined;\n}\n\nexport const dateTimestampProvider: DateTimestampProvider = {\n  now() {\n    // Use the variable rather than `this` so that the function can be called\n    // without being bound to the provider.\n    return (dateTimestampProvider.delegate || Date).now();\n  },\n  delegate: undefined,\n};\n", "import { Subject } from './Subject';\nimport { TimestampProvider } from './types';\nimport { Subscriber } from './Subscriber';\nimport { Subscription } from './Subscription';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * A variant of {@link Subject} that \"replays\" old values to new subscribers by emitting them when they first subscribe.\n *\n * `ReplaySubject` has an internal buffer that will store a specified number of values that it has observed. Like `Subject`,\n * `ReplaySubject` \"observes\" values by having them passed to its `next` method. When it observes a value, it will store that\n * value for a time determined by the configuration of the `ReplaySubject`, as passed to its constructor.\n *\n * When a new subscriber subscribes to the `ReplaySubject` instance, it will synchronously emit all values in its buffer in\n * a First-In-First-Out (FIFO) manner. The `ReplaySubject` will also complete, if it has observed completion; and it will\n * error if it has observed an error.\n *\n * There are two main configuration items to be concerned with:\n *\n * 1. `bufferSize` - This will determine how many items are stored in the buffer, defaults to infinite.\n * 2. `windowTime` - The amount of time to hold a value in the buffer before removing it from the buffer.\n *\n * Both configurations may exist simultaneously. So if you would like to buffer a maximum of 3 values, as long as the values\n * are less than 2 seconds old, you could do so with a `new ReplaySubject(3, 2000)`.\n *\n * ### Differences with BehaviorSubject\n *\n * `BehaviorSubject` is similar to `new ReplaySubject(1)`, with a couple of exceptions:\n *\n * 1. `BehaviorSubject` comes \"primed\" with a single value upon construction.\n * 2. `ReplaySubject` will replay values, even after observing an error, where `BehaviorSubject` will not.\n *\n * @see {@link Subject}\n * @see {@link BehaviorSubject}\n * @see {@link shareReplay}\n */\nexport class ReplaySubject<T> extends Subject<T> {\n  private _buffer: (T | number)[] = [];\n  private _infiniteTimeWindow = true;\n\n  /**\n   * @param _bufferSize The size of the buffer to replay on subscription\n   * @param _windowTime The amount of time the buffered items will stay buffered\n   * @param _timestampProvider An object with a `now()` method that provides the current timestamp. This is used to\n   * calculate the amount of time something has been buffered.\n   */\n  constructor(\n    private _bufferSize = Infinity,\n    private _windowTime = Infinity,\n    private _timestampProvider: TimestampProvider = dateTimestampProvider\n  ) {\n    super();\n    this._infiniteTimeWindow = _windowTime === Infinity;\n    this._bufferSize = Math.max(1, _bufferSize);\n    this._windowTime = Math.max(1, _windowTime);\n  }\n\n  next(value: T): void {\n    const { isStopped, _buffer, _infiniteTimeWindow, _timestampProvider, _windowTime } = this;\n    if (!isStopped) {\n      _buffer.push(value);\n      !_infiniteTimeWindow && _buffer.push(_timestampProvider.now() + _windowTime);\n    }\n    this._trimBuffer();\n    super.next(value);\n  }\n\n  /** @internal */\n  protected _subscribe(subscriber: Subscriber<T>): Subscription {\n    this._throwIfClosed();\n    this._trimBuffer();\n\n    const subscription = this._innerSubscribe(subscriber);\n\n    const { _infiniteTimeWindow, _buffer } = this;\n    // We use a copy here, so reentrant code does not mutate our array while we're\n    // emitting it to a new subscriber.\n    const copy = _buffer.slice();\n    for (let i = 0; i < copy.length && !subscriber.closed; i += _infiniteTimeWindow ? 1 : 2) {\n      subscriber.next(copy[i] as T);\n    }\n\n    this._checkFinalizedStatuses(subscriber);\n\n    return subscription;\n  }\n\n  private _trimBuffer() {\n    const { _bufferSize, _timestampProvider, _buffer, _infiniteTimeWindow } = this;\n    // If we don't have an infinite buffer size, and we're over the length,\n    // use splice to truncate the old buffer values off. Note that we have to\n    // double the size for instances where we're not using an infinite time window\n    // because we're storing the values and the timestamps in the same array.\n    const adjustedBufferSize = (_infiniteTimeWindow ? 1 : 2) * _bufferSize;\n    _bufferSize < Infinity && adjustedBufferSize < _buffer.length && _buffer.splice(0, _buffer.length - adjustedBufferSize);\n\n    // Now, if we're not in an infinite time window, remove all values where the time is\n    // older than what is allowed.\n    if (!_infiniteTimeWindow) {\n      const now = _timestampProvider.now();\n      let last = 0;\n      // Search the array for the first timestamp that isn't expired and\n      // truncate the buffer up to that point.\n      for (let i = 1; i < _buffer.length && (_buffer[i] as number) <= now; i += 2) {\n        last = i;\n      }\n      last && _buffer.splice(0, last + 1);\n    }\n  }\n}\n", "import { Subject } from './Subject';\nimport { Subscriber } from './Subscriber';\n\n/**\n * A variant of Subject that only emits a value when it completes. It will emit\n * its latest value to all its observers on completion.\n */\nexport class AsyncSubject<T> extends Subject<T> {\n  private _value: T | null = null;\n  private _hasValue = false;\n  private _isComplete = false;\n\n  /** @internal */\n  protected _checkFinalizedStatuses(subscriber: Subscriber<T>) {\n    const { hasError, _hasValue, _value, thrownError, isStopped, _isComplete } = this;\n    if (hasError) {\n      subscriber.error(thrownError);\n    } else if (isStopped || _isComplete) {\n      _hasValue && subscriber.next(_value!);\n      subscriber.complete();\n    }\n  }\n\n  next(value: T): void {\n    if (!this.isStopped) {\n      this._value = value;\n      this._hasValue = true;\n    }\n  }\n\n  complete(): void {\n    const { _hasValue, _value, _isComplete } = this;\n    if (!_isComplete) {\n      this._isComplete = true;\n      _hasValue && super.next(_value!);\n      super.complete();\n    }\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Subscription } from '../Subscription';\nimport { SchedulerAction } from '../types';\n\n/**\n * A unit of work to be executed in a `scheduler`. An action is typically\n * created from within a {@link SchedulerLike} and an RxJS user does not need to concern\n * themselves about creating and manipulating an Action.\n *\n * ```ts\n * class Action<T> extends Subscription {\n *   new (scheduler: Scheduler, work: (state?: T) => void);\n *   schedule(state?: T, delay: number = 0): Subscription;\n * }\n * ```\n */\nexport class Action<T> extends Subscription {\n  constructor(scheduler: Scheduler, work: (this: SchedulerAction<T>, state?: T) => void) {\n    super();\n  }\n  /**\n   * Schedules this action on its parent {@link SchedulerLike} for execution. May be passed\n   * some context object, `state`. May happen at some point in the future,\n   * according to the `delay` parameter, if specified.\n   * @param state Some contextual data that the `work` function uses when called by the\n   * Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is implicit\n   * and defined by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule(state?: T, delay: number = 0): Subscription {\n    return this;\n  }\n}\n", "import type { TimerHandle } from './timerHandle';\ntype SetIntervalFunction = (handler: () => void, timeout?: number, ...args: any[]) => TimerHandle;\ntype ClearIntervalFunction = (handle: TimerHandle) => void;\n\ninterface IntervalProvider {\n  setInterval: SetIntervalFunction;\n  clearInterval: ClearIntervalFunction;\n  delegate:\n    | {\n        setInterval: SetIntervalFunction;\n        clearInterval: ClearIntervalFunction;\n      }\n    | undefined;\n}\n\nexport const intervalProvider: IntervalProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setInterval(handler: () => void, timeout?: number, ...args) {\n    const { delegate } = intervalProvider;\n    if (delegate?.setInterval) {\n      return delegate.setInterval(handler, timeout, ...args);\n    }\n    return setInterval(handler, timeout, ...args);\n  },\n  clearInterval(handle) {\n    const { delegate } = intervalProvider;\n    return (delegate?.clearInterval || clearInterval)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { Action } from './Action';\nimport { SchedulerAction } from '../types';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { intervalProvider } from './intervalProvider';\nimport { arrRemove } from '../util/arrRemove';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncAction<T> extends Action<T> {\n  public id: TimerHandle | undefined;\n  public state?: T;\n  // @ts-ignore: Property has no initializer and is not definitely assigned\n  public delay: number;\n  protected pending: boolean = false;\n\n  constructor(protected scheduler: AsyncScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (this.closed) {\n      return this;\n    }\n\n    // Always replace the current state with the new state.\n    this.state = state;\n\n    const id = this.id;\n    const scheduler = this.scheduler;\n\n    //\n    // Important implementation note:\n    //\n    // Actions only execute once by default, unless rescheduled from within the\n    // scheduled callback. This allows us to implement single and repeat\n    // actions via the same code path, without adding API surface area, as well\n    // as mimic traditional recursion but across asynchronous boundaries.\n    //\n    // However, JS runtimes and timers distinguish between intervals achieved by\n    // serial `setTimeout` calls vs. a single `setInterval` call. An interval of\n    // serial `setTimeout` calls can be individually delayed, which delays\n    // scheduling the next `setTimeout`, and so on. `setInterval` attempts to\n    // guarantee the interval callback will be invoked more precisely to the\n    // interval period, regardless of load.\n    //\n    // Therefore, we use `setInterval` to schedule single and repeat actions.\n    // If the action reschedules itself with the same delay, the interval is not\n    // canceled. If the action doesn't reschedule, or reschedules with a\n    // different delay, the interval will be canceled after scheduled callback\n    // execution.\n    //\n    if (id != null) {\n      this.id = this.recycleAsyncId(scheduler, id, delay);\n    }\n\n    // Set the pending flag indicating that this action has been scheduled, or\n    // has recursively rescheduled itself.\n    this.pending = true;\n\n    this.delay = delay;\n    // If this action has already an async Id, don't request a new one.\n    this.id = this.id ?? this.requestAsyncId(scheduler, this.id, delay);\n\n    return this;\n  }\n\n  protected requestAsyncId(scheduler: AsyncScheduler, _id?: TimerHandle, delay: number = 0): TimerHandle {\n    return intervalProvider.setInterval(scheduler.flush.bind(scheduler, this), delay);\n  }\n\n  protected recycleAsyncId(_scheduler: AsyncScheduler, id?: TimerHandle, delay: number | null = 0): TimerHandle | undefined {\n    // If this action is rescheduled with the same delay time, don't clear the interval id.\n    if (delay != null && this.delay === delay && this.pending === false) {\n      return id;\n    }\n    // Otherwise, if the action's delay time is different from the current delay,\n    // or the action has been rescheduled before it's executed, clear the interval id\n    if (id != null) {\n      intervalProvider.clearInterval(id);\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Immediately executes this action and the `work` it contains.\n   */\n  public execute(state: T, delay: number): any {\n    if (this.closed) {\n      return new Error('executing a cancelled action');\n    }\n\n    this.pending = false;\n    const error = this._execute(state, delay);\n    if (error) {\n      return error;\n    } else if (this.pending === false && this.id != null) {\n      // Dequeue if the action didn't reschedule itself. Don't call\n      // unsubscribe(), because the action could reschedule later.\n      // For example:\n      // ```\n      // scheduler.schedule(function doWork(counter) {\n      //   /* ... I'm a busy worker bee ... */\n      //   var originalAction = this;\n      //   /* wait 100ms before rescheduling the action */\n      //   setTimeout(function () {\n      //     originalAction.schedule(counter + 1);\n      //   }, 100);\n      // }, 1000);\n      // ```\n      this.id = this.recycleAsyncId(this.scheduler, this.id, null);\n    }\n  }\n\n  protected _execute(state: T, _delay: number): any {\n    let errored: boolean = false;\n    let errorValue: any;\n    try {\n      this.work(state);\n    } catch (e) {\n      errored = true;\n      // HACK: Since code elsewhere is relying on the \"truthiness\" of the\n      // return here, we can't have it return \"\" or 0 or false.\n      // TODO: Clean this up when we refactor schedulers mid-version-8 or so.\n      errorValue = e ? e : new Error('Scheduled action threw falsy error');\n    }\n    if (errored) {\n      this.unsubscribe();\n      return errorValue;\n    }\n  }\n\n  unsubscribe() {\n    if (!this.closed) {\n      const { id, scheduler } = this;\n      const { actions } = scheduler;\n\n      this.work = this.state = this.scheduler = null!;\n      this.pending = false;\n\n      arrRemove(actions, this);\n      if (id != null) {\n        this.id = this.recycleAsyncId(scheduler, id, null);\n      }\n\n      this.delay = null!;\n      super.unsubscribe();\n    }\n  }\n}\n", "let nextHandle = 1;\n// The promise needs to be created lazily otherwise it won't be patched by Zones\nlet resolved: Promise<any>;\nconst activeHandles: { [key: number]: any } = {};\n\n/**\n * Finds the handle in the list of active handles, and removes it.\n * Returns `true` if found, `false` otherwise. Used both to clear\n * Immediate scheduled tasks, and to identify if a task should be scheduled.\n */\nfunction findAndClearHandle(handle: number): boolean {\n  if (handle in activeHandles) {\n    delete activeHandles[handle];\n    return true;\n  }\n  return false;\n}\n\n/**\n * Helper functions to schedule and unschedule microtasks.\n */\nexport const Immediate = {\n  setImmediate(cb: () => void): number {\n    const handle = nextHandle++;\n    activeHandles[handle] = true;\n    if (!resolved) {\n      resolved = Promise.resolve();\n    }\n    resolved.then(() => findAndClearHandle(handle) && cb());\n    return handle;\n  },\n\n  clearImmediate(handle: number): void {\n    findAndClearHandle(handle);\n  },\n};\n\n/**\n * Used for internal testing purposes only. Do not export from library.\n */\nexport const TestTools = {\n  pending() {\n    return Object.keys(activeHandles).length;\n  }\n};\n", "import { Immediate } from '../util/Immediate';\nimport type { TimerHandle } from './timerHandle';\nconst { setImmediate, clearImmediate } = Immediate;\n\ntype SetImmediateFunction = (handler: () => void, ...args: any[]) => TimerHandle;\ntype ClearImmediateFunction = (handle: TimerHandle) => void;\n\ninterface ImmediateProvider {\n  setImmediate: SetImmediateFunction;\n  clearImmediate: ClearImmediateFunction;\n  delegate:\n    | {\n        setImmediate: SetImmediateFunction;\n        clearImmediate: ClearImmediateFunction;\n      }\n    | undefined;\n}\n\nexport const immediateProvider: ImmediateProvider = {\n  // When accessing the delegate, use the variable rather than `this` so that\n  // the functions can be called without being bound to the provider.\n  setImmediate(...args) {\n    const { delegate } = immediateProvider;\n    return (delegate?.setImmediate || setImmediate)(...args);\n  },\n  clearImmediate(handle) {\n    const { delegate } = immediateProvider;\n    return (delegate?.clearImmediate || clearImmediate)(handle as any);\n  },\n  delegate: undefined,\n};\n", "import { AsyncAction } from './AsyncAction';\nimport { AsapScheduler } from './AsapScheduler';\nimport { SchedulerAction } from '../types';\nimport { immediateProvider } from './immediateProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsapAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AsapScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If a microtask has already been scheduled, don't schedule another\n    // one. If a microtask hasn't been scheduled yet, schedule one now. Return\n    // the current scheduled microtask id.\n    return scheduler._scheduled || (scheduler._scheduled = immediateProvider.setImmediate(scheduler.flush.bind(scheduler, undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AsapScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested microtask and set the scheduled flag to undefined\n    // so the next AsapAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && actions[actions.length - 1]?.id !== id) {\n      immediateProvider.clearImmediate(id);\n      if (scheduler._scheduled === id) {\n        scheduler._scheduled = undefined;\n      }\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { Action } from './scheduler/Action';\nimport { Subscription } from './Subscription';\nimport { SchedulerLike, SchedulerAction } from './types';\nimport { dateTimestampProvider } from './scheduler/dateTimestampProvider';\n\n/**\n * An execution context and a data structure to order tasks and schedule their\n * execution. Provides a notion of (potentially virtual) time, through the\n * `now()` getter method.\n *\n * Each unit of work in a Scheduler is called an `Action`.\n *\n * ```ts\n * class Scheduler {\n *   now(): number;\n *   schedule(work, delay?, state?): Subscription;\n * }\n * ```\n *\n * @deprecated Scheduler is an internal implementation detail of RxJS, and\n * should not be used directly. Rather, create your own class and implement\n * {@link SchedulerLike}. Will be made internal in v8.\n */\nexport class Scheduler implements SchedulerLike {\n  public static now: () => number = dateTimestampProvider.now;\n\n  constructor(private schedulerActionCtor: typeof Action, now: () => number = Scheduler.now) {\n    this.now = now;\n  }\n\n  /**\n   * A getter method that returns a number representing the current time\n   * (at the time this function was called) according to the scheduler's own\n   * internal clock.\n   * @return A number that represents the current time. May or may not\n   * have a relation to wall-clock time. May or may not refer to a time unit\n   * (e.g. milliseconds).\n   */\n  public now: () => number;\n\n  /**\n   * Schedules a function, `work`, for execution. May happen at some point in\n   * the future, according to the `delay` parameter, if specified. May be passed\n   * some context object, `state`, which will be passed to the `work` function.\n   *\n   * The given arguments will be processed an stored as an Action object in a\n   * queue of actions.\n   *\n   * @param work A function representing a task, or some unit of work to be\n   * executed by the Scheduler.\n   * @param delay Time to wait before executing the work, where the time unit is\n   * implicit and defined by the Scheduler itself.\n   * @param state Some contextual data that the `work` function uses when called\n   * by the Scheduler.\n   * @return A subscription in order to be able to unsubscribe the scheduled work.\n   */\n  public schedule<T>(work: (this: SchedulerAction<T>, state?: T) => void, delay: number = 0, state?: T): Subscription {\n    return new this.schedulerActionCtor<T>(this, work).schedule(state, delay);\n  }\n}\n", "import { Scheduler } from '../Scheduler';\nimport { Action } from './Action';\nimport { AsyncAction } from './AsyncAction';\nimport { TimerHandle } from './timerHandle';\n\nexport class AsyncScheduler extends Scheduler {\n  public actions: Array<AsyncAction<any>> = [];\n  /**\n   * A flag to indicate whether the Scheduler is currently executing a batch of\n   * queued actions.\n   * @internal\n   */\n  public _active: boolean = false;\n  /**\n   * An internal ID used to track the latest asynchronous task such as those\n   * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n   * others.\n   * @internal\n   */\n  public _scheduled: TimerHandle | undefined;\n\n  constructor(SchedulerAction: typeof Action, now: () => number = Scheduler.now) {\n    super(SchedulerAction, now);\n  }\n\n  public flush(action: AsyncAction<any>): void {\n    const { actions } = this;\n\n    if (this._active) {\n      actions.push(action);\n      return;\n    }\n\n    let error: any;\n    this._active = true;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions.shift()!)); // exhaust the scheduler queue\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions.shift()!)) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AsapScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    const flushId = this._scheduled;\n    this._scheduled = undefined;\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AsapAction } from './AsapAction';\nimport { AsapScheduler } from './AsapScheduler';\n\n/**\n *\n * Asap Scheduler\n *\n * <span class=\"informal\">Perform task as fast as it can be performed asynchronously</span>\n *\n * `asap` scheduler behaves the same as {@link asyncScheduler} scheduler when you use it to delay task\n * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing\n * code to end and then it will try to execute given task as fast as possible.\n *\n * `asap` scheduler will do its best to minimize time between end of currently executing code\n * and start of scheduled task. This makes it best candidate for performing so called \"deferring\".\n * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves\n * some (although minimal) unwanted delay.\n *\n * Note that using `asap` scheduler does not necessarily mean that your task will be first to process\n * after currently executing code. In particular, if some task was also scheduled with `asap` before,\n * that task will execute first. That being said, if you need to schedule task asynchronously, but\n * as soon as possible, `asap` scheduler is your best bet.\n *\n * ## Example\n * Compare async and asap scheduler<\n * ```ts\n * import { asapScheduler, asyncScheduler } from 'rxjs';\n *\n * asyncScheduler.schedule(() => console.log('async')); // scheduling 'async' first...\n * asapScheduler.schedule(() => console.log('asap'));\n *\n * // Logs:\n * // \"asap\"\n * // \"async\"\n * // ... but 'asap' goes first!\n * ```\n */\n\nexport const asapScheduler = new AsapScheduler(AsapAction);\n\n/**\n * @deprecated Renamed to {@link asapScheduler}. Will be removed in v8.\n */\nexport const asap = asapScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\n/**\n *\n * Async Scheduler\n *\n * <span class=\"informal\">Schedule task as if you used setTimeout(task, duration)</span>\n *\n * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript\n * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating\n * in intervals.\n *\n * If you just want to \"defer\" task, that is to perform it right after currently\n * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),\n * better choice will be the {@link asapScheduler} scheduler.\n *\n * ## Examples\n * Use async scheduler to delay task\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * const task = () => console.log('it works!');\n *\n * asyncScheduler.schedule(task, 2000);\n *\n * // After 2 seconds logs:\n * // \"it works!\"\n * ```\n *\n * Use async scheduler to repeat task in intervals\n * ```ts\n * import { asyncScheduler } from 'rxjs';\n *\n * function task(state) {\n *   console.log(state);\n *   this.schedule(state + 1, 1000); // `this` references currently executing Action,\n *                                   // which we reschedule with new state and delay\n * }\n *\n * asyncScheduler.schedule(task, 3000, 0);\n *\n * // Logs:\n * // 0 after 3s\n * // 1 after 4s\n * // 2 after 5s\n * // 3 after 6s\n * ```\n */\n\nexport const asyncScheduler = new AsyncScheduler(AsyncAction);\n\n/**\n * @deprecated Renamed to {@link asyncScheduler}. Will be removed in v8.\n */\nexport const async = asyncScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { QueueScheduler } from './QueueScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class QueueAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: QueueScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (delay > 0) {\n      return super.schedule(state, delay);\n    }\n    this.delay = delay;\n    this.state = state;\n    this.scheduler.flush(this);\n    return this;\n  }\n\n  public execute(state: T, delay: number): any {\n    return delay > 0 || this.closed ? super.execute(state, delay) : this._execute(state, delay);\n  }\n\n  protected requestAsyncId(scheduler: QueueScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n\n    if ((delay != null && delay > 0) || (delay == null && this.delay > 0)) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n\n    // Otherwise flush the scheduler starting with this action.\n    scheduler.flush(this);\n\n    // HACK: In the past, this was returning `void`. However, `void` isn't a valid\n    // `TimerHandle`, and generally the return value here isn't really used. So the\n    // compromise is to return `0` which is both \"falsy\" and a valid `TimerHandle`,\n    // as opposed to refactoring every other instanceo of `requestAsyncId`.\n    return 0;\n  }\n}\n", "import { AsyncScheduler } from './AsyncScheduler';\n\nexport class QueueScheduler extends AsyncScheduler {\n}\n", "import { QueueAction } from './QueueAction';\nimport { QueueScheduler } from './QueueScheduler';\n\n/**\n *\n * Queue Scheduler\n *\n * <span class=\"informal\">Put every next task on a queue, instead of executing it immediately</span>\n *\n * `queue` scheduler, when used with delay, behaves the same as {@link asyncScheduler} scheduler.\n *\n * When used without delay, it schedules given task synchronously - executes it right when\n * it is scheduled. However when called recursively, that is when inside the scheduled task,\n * another task is scheduled with queue scheduler, instead of executing immediately as well,\n * that task will be put on a queue and wait for current one to finish.\n *\n * This means that when you execute task with `queue` scheduler, you are sure it will end\n * before any other task scheduled with that scheduler will start.\n *\n * ## Examples\n * Schedule recursively first, then do something\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(() => {\n *   queueScheduler.schedule(() => console.log('second')); // will not happen now, but will be put on a queue\n *\n *   console.log('first');\n * });\n *\n * // Logs:\n * // \"first\"\n * // \"second\"\n * ```\n *\n * Reschedule itself recursively\n * ```ts\n * import { queueScheduler } from 'rxjs';\n *\n * queueScheduler.schedule(function(state) {\n *   if (state !== 0) {\n *     console.log('before', state);\n *     this.schedule(state - 1); // `this` references currently executing Action,\n *                               // which we reschedule with new state\n *     console.log('after', state);\n *   }\n * }, 0, 3);\n *\n * // In scheduler that runs recursively, you would expect:\n * // \"before\", 3\n * // \"before\", 2\n * // \"before\", 1\n * // \"after\", 1\n * // \"after\", 2\n * // \"after\", 3\n *\n * // But with queue it logs:\n * // \"before\", 3\n * // \"after\", 3\n * // \"before\", 2\n * // \"after\", 2\n * // \"before\", 1\n * // \"after\", 1\n * ```\n */\n\nexport const queueScheduler = new QueueScheduler(QueueAction);\n\n/**\n * @deprecated Renamed to {@link queueScheduler}. Will be removed in v8.\n */\nexport const queue = queueScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\nimport { SchedulerAction } from '../types';\nimport { animationFrameProvider } from './animationFrameProvider';\nimport { TimerHandle } from './timerHandle';\n\nexport class AnimationFrameAction<T> extends AsyncAction<T> {\n  constructor(protected scheduler: AnimationFrameScheduler, protected work: (this: SchedulerAction<T>, state?: T) => void) {\n    super(scheduler, work);\n  }\n\n  protected requestAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle {\n    // If delay is greater than 0, request as an async action.\n    if (delay !== null && delay > 0) {\n      return super.requestAsyncId(scheduler, id, delay);\n    }\n    // Push the action to the end of the scheduler queue.\n    scheduler.actions.push(this);\n    // If an animation frame has already been requested, don't request another\n    // one. If an animation frame hasn't been requested yet, request one. Return\n    // the current animation frame request id.\n    return scheduler._scheduled || (scheduler._scheduled = animationFrameProvider.requestAnimationFrame(() => scheduler.flush(undefined)));\n  }\n\n  protected recycleAsyncId(scheduler: AnimationFrameScheduler, id?: TimerHandle, delay: number = 0): TimerHandle | undefined {\n    // If delay exists and is greater than 0, or if the delay is null (the\n    // action wasn't rescheduled) but was originally scheduled as an async\n    // action, then recycle as an async action.\n    if (delay != null ? delay > 0 : this.delay > 0) {\n      return super.recycleAsyncId(scheduler, id, delay);\n    }\n    // If the scheduler queue has no remaining actions with the same async id,\n    // cancel the requested animation frame and set the scheduled flag to\n    // undefined so the next AnimationFrameAction will request its own.\n    const { actions } = scheduler;\n    if (id != null && id === scheduler._scheduled && actions[actions.length - 1]?.id !== id) {\n      animationFrameProvider.cancelAnimationFrame(id as number);\n      scheduler._scheduled = undefined;\n    }\n    // Return undefined so the action knows to request a new async id if it's rescheduled.\n    return undefined;\n  }\n}\n", "import { AsyncAction } from './AsyncAction';\nimport { AsyncScheduler } from './AsyncScheduler';\n\nexport class AnimationFrameScheduler extends AsyncScheduler {\n  public flush(action?: AsyncAction<any>): void {\n    this._active = true;\n    // The async id that effects a call to flush is stored in _scheduled.\n    // Before executing an action, it's necessary to check the action's async\n    // id to determine whether it's supposed to be executed in the current\n    // flush.\n    // Previous implementations of this method used a count to determine this,\n    // but that was unsound, as actions that are unsubscribed - i.e. cancelled -\n    // are removed from the actions array and that can shift actions that are\n    // scheduled to be executed in a subsequent flush into positions at which\n    // they are executed within the current flush.\n    let flushId;\n    if (action) {\n      flushId = action.id;\n    } else {\n      flushId = this._scheduled;\n      this._scheduled = undefined;\n    }\n\n    const { actions } = this;\n    let error: any;\n    action = action || actions.shift()!;\n\n    do {\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    } while ((action = actions[0]) && action.id === flushId && actions.shift());\n\n    this._active = false;\n\n    if (error) {\n      while ((action = actions[0]) && action.id === flushId && actions.shift()) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n", "import { AnimationFrameAction } from './AnimationFrameAction';\nimport { AnimationFrameScheduler } from './AnimationFrameScheduler';\n\n/**\n *\n * Animation Frame Scheduler\n *\n * <span class=\"informal\">Perform task when `window.requestAnimationFrame` would fire</span>\n *\n * When `animationFrame` scheduler is used with delay, it will fall back to {@link asyncScheduler} scheduler\n * behaviour.\n *\n * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.\n * It makes sure scheduled task will happen just before next browser content repaint,\n * thus performing animations as efficiently as possible.\n *\n * ## Example\n * Schedule div height animation\n * ```ts\n * // html: <div style=\"background: #0ff;\"></div>\n * import { animationFrameScheduler } from 'rxjs';\n *\n * const div = document.querySelector('div');\n *\n * animationFrameScheduler.schedule(function(height) {\n *   div.style.height = height + \"px\";\n *\n *   this.schedule(height + 1);  // `this` references currently executing Action,\n *                               // which we reschedule with new state\n * }, 0, 0);\n *\n * // You will see a div element growing in height\n * ```\n */\n\nexport const animationFrameScheduler = new AnimationFrameScheduler(AnimationFrameAction);\n\n/**\n * @deprecated Renamed to {@link animationFrameScheduler}. Will be removed in v8.\n */\nexport const animationFrame = animationFrameScheduler;\n", "import { AsyncAction } from './AsyncAction';\nimport { Subscription } from '../Subscription';\nimport { AsyncScheduler } from './AsyncScheduler';\nimport { SchedulerAction } from '../types';\nimport { TimerHandle } from './timerHandle';\n\nexport class VirtualTimeScheduler extends AsyncScheduler {\n  /** @deprecated Not used in VirtualTimeScheduler directly. Will be removed in v8. */\n  static frameTimeFactor = 10;\n\n  /**\n   * The current frame for the state of the virtual scheduler instance. The difference\n   * between two \"frames\" is synonymous with the passage of \"virtual time units\". So if\n   * you record `scheduler.frame` to be `1`, then later, observe `scheduler.frame` to be at `11`,\n   * that means `10` virtual time units have passed.\n   */\n  public frame: number = 0;\n\n  /**\n   * Used internally to examine the current virtual action index being processed.\n   * @deprecated Internal implementation detail, do not use directly. Will be made internal in v8.\n   */\n  public index: number = -1;\n\n  /**\n   * This creates an instance of a `VirtualTimeScheduler`. Experts only. The signature of\n   * this constructor is likely to change in the long run.\n   *\n   * @param schedulerActionCtor The type of Action to initialize when initializing actions during scheduling.\n   * @param maxFrames The maximum number of frames to process before stopping. Used to prevent endless flush cycles.\n   */\n  constructor(schedulerActionCtor: typeof AsyncAction = VirtualAction as any, public maxFrames: number = Infinity) {\n    super(schedulerActionCtor, () => this.frame);\n  }\n\n  /**\n   * Prompt the Scheduler to execute all of its queued actions, therefore\n   * clearing its queue.\n   */\n  public flush(): void {\n    const { actions, maxFrames } = this;\n    let error: any;\n    let action: AsyncAction<any> | undefined;\n\n    while ((action = actions[0]) && action.delay <= maxFrames) {\n      actions.shift();\n      this.frame = action.delay;\n\n      if ((error = action.execute(action.state, action.delay))) {\n        break;\n      }\n    }\n\n    if (error) {\n      while ((action = actions.shift())) {\n        action.unsubscribe();\n      }\n      throw error;\n    }\n  }\n}\n\nexport class VirtualAction<T> extends AsyncAction<T> {\n  protected active: boolean = true;\n\n  constructor(\n    protected scheduler: VirtualTimeScheduler,\n    protected work: (this: SchedulerAction<T>, state?: T) => void,\n    protected index: number = (scheduler.index += 1)\n  ) {\n    super(scheduler, work);\n    this.index = scheduler.index = index;\n  }\n\n  public schedule(state?: T, delay: number = 0): Subscription {\n    if (Number.isFinite(delay)) {\n      if (!this.id) {\n        return super.schedule(state, delay);\n      }\n      this.active = false;\n      // If an action is rescheduled, we save allocations by mutating its state,\n      // pushing it to the end of the scheduler queue, and recycling the action.\n      // But since the VirtualTimeScheduler is used for testing, VirtualActions\n      // must be immutable so they can be inspected later.\n      const action = new VirtualAction(this.scheduler, this.work);\n      this.add(action);\n      return action.schedule(state, delay);\n    } else {\n      // If someone schedules something with Infinity, it'll never happen. So we\n      // don't even schedule it.\n      return Subscription.EMPTY;\n    }\n  }\n\n  protected requestAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle {\n    this.delay = scheduler.frame + delay;\n    const { actions } = scheduler;\n    actions.push(this);\n    (actions as Array<VirtualAction<T>>).sort(VirtualAction.sortActions);\n    return 1;\n  }\n\n  protected recycleAsyncId(scheduler: VirtualTimeScheduler, id?: any, delay: number = 0): TimerHandle | undefined {\n    return undefined;\n  }\n\n  protected _execute(state: T, delay: number): any {\n    if (this.active === true) {\n      return super._execute(state, delay);\n    }\n  }\n\n  private static sortActions<T>(a: VirtualAction<T>, b: VirtualAction<T>) {\n    if (a.delay === b.delay) {\n      if (a.index === b.index) {\n        return 0;\n      } else if (a.index > b.index) {\n        return 1;\n      } else {\n        return -1;\n      }\n    } else if (a.delay > b.delay) {\n      return 1;\n    } else {\n      return -1;\n    }\n  }\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\n/**\n * A simple Observable that emits no items to the Observer and immediately\n * emits a complete notification.\n *\n * <span class=\"informal\">Just emits 'complete', and nothing else.</span>\n *\n * ![](empty.png)\n *\n * A simple Observable that only emits the complete notification. It can be used\n * for composing with other Observables, such as in a {@link mergeMap}.\n *\n * ## Examples\n *\n * Log complete notification\n *\n * ```ts\n * import { EMPTY } from 'rxjs';\n *\n * EMPTY.subscribe({\n *   next: () => console.log('Next'),\n *   complete: () => console.log('Complete!')\n * });\n *\n * // Outputs\n * // Complete!\n * ```\n *\n * Emit the number 7, then complete\n *\n * ```ts\n * import { EMPTY, startWith } from 'rxjs';\n *\n * const result = EMPTY.pipe(startWith(7));\n * result.subscribe(x => console.log(x));\n *\n * // Outputs\n * // 7\n * ```\n *\n * Map and flatten only odd numbers to the sequence `'a'`, `'b'`, `'c'`\n *\n * ```ts\n * import { interval, mergeMap, of, EMPTY } from 'rxjs';\n *\n * const interval$ = interval(1000);\n * const result = interval$.pipe(\n *   mergeMap(x => x % 2 === 1 ? of('a', 'b', 'c') : EMPTY),\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following to the console:\n * // x is equal to the count on the interval, e.g. (0, 1, 2, 3, ...)\n * // x will occur every 1000ms\n * // if x % 2 is equal to 1, print a, b, c (each on its own)\n * // if x % 2 is not equal to 1, nothing will be output\n * ```\n *\n * @see {@link Observable}\n * @see {@link NEVER}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const EMPTY = new Observable<never>((subscriber) => subscriber.complete());\n\n/**\n * @param scheduler A {@link SchedulerLike} to use for scheduling\n * the emission of the complete notification.\n * @deprecated Replaced with the {@link EMPTY} constant or {@link scheduled} (e.g. `scheduled([], scheduler)`). Will be removed in v8.\n */\nexport function empty(scheduler?: SchedulerLike) {\n  return scheduler ? emptyScheduled(scheduler) : EMPTY;\n}\n\nfunction emptyScheduled(scheduler: SchedulerLike) {\n  return new Observable<never>((subscriber) => scheduler.schedule(() => subscriber.complete()));\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport function isScheduler(value: any): value is SchedulerLike {\n  return value && isFunction(value.schedule);\n}\n", "import { SchedulerLike } from '../types';\nimport { isFunction } from './isFunction';\nimport { isScheduler } from './isScheduler';\n\nfunction last<T>(arr: T[]): T | undefined {\n  return arr[arr.length - 1];\n}\n\nexport function popResultSelector(args: any[]): ((...args: unknown[]) => unknown) | undefined {\n  return isFunction(last(args)) ? args.pop() : undefined;\n}\n\nexport function popScheduler(args: any[]): SchedulerLike | undefined {\n  return isScheduler(last(args)) ? args.pop() : undefined;\n}\n\nexport function popNumber(args: any[], defaultValue: number): number {\n  return typeof last(args) === 'number' ? args.pop()! : defaultValue;\n}\n", "export const isArrayLike = (<T>(x: any): x is ArrayLike<T> => x && typeof x.length === 'number' && typeof x !== 'function');", "import { isFunction } from \"./isFunction\";\n\n/**\n * Tests to see if the object is \"thennable\".\n * @param value the object to test\n */\nexport function isPromise(value: any): value is PromiseLike<any> {\n  return isFunction(value?.then);\n}\n", "import { InteropObservable } from '../types';\nimport { observable as Symbol_observable } from '../symbol/observable';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being Observable (but not necessary an Rx Observable) */\nexport function isInteropObservable(input: any): input is InteropObservable<any> {\n  return isFunction(input[Symbol_observable]);\n}\n", "import { isFunction } from './isFunction';\n\nexport function isAsyncIterable<T>(obj: any): obj is AsyncIterable<T> {\n  return Symbol.asyncIterator && isFunction(obj?.[Symbol.asyncIterator]);\n}\n", "/**\n * Creates the TypeError to throw if an invalid object is passed to `from` or `scheduled`.\n * @param input The object that was passed.\n */\nexport function createInvalidObservableTypeError(input: any) {\n  // TODO: We should create error codes that can be looked up, so this can be less verbose.\n  return new TypeError(\n    `You provided ${\n      input !== null && typeof input === 'object' ? 'an invalid object' : `'${input}'`\n    } where a stream was expected. You can provide an Observable, Promise, ReadableStream, Array, AsyncIterable, or Iterable.`\n  );\n}\n", "export function getSymbolIterator(): symbol {\n  if (typeof Symbol !== 'function' || !Symbol.iterator) {\n    return '@@iterator' as any;\n  }\n\n  return Symbol.iterator;\n}\n\nexport const iterator = getSymbolIterator();\n", "import { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from './isFunction';\n\n/** Identifies an input as being an Iterable */\nexport function isIterable(input: any): input is Iterable<any> {\n  return isFunction(input?.[Symbol_iterator]);\n}\n", "import { ReadableStreamLike } from '../types';\nimport { isFunction } from './isFunction';\n\nexport async function* readableStreamLikeToAsyncGenerator<T>(readableStream: ReadableStreamLike<T>): AsyncGenerator<T> {\n  const reader = readableStream.getReader();\n  try {\n    while (true) {\n      const { value, done } = await reader.read();\n      if (done) {\n        return;\n      }\n      yield value!;\n    }\n  } finally {\n    reader.releaseLock();\n  }\n}\n\nexport function isReadableStreamLike<T>(obj: any): obj is ReadableStreamLike<T> {\n  // We don't want to use instanceof checks because they would return\n  // false for instances from another Realm, like an <iframe>.\n  return isFunction(obj?.getReader);\n}\n", "import { isArrayLike } from '../util/isArrayLike';\nimport { isPromise } from '../util/isPromise';\nimport { Observable } from '../Observable';\nimport { ObservableInput, ObservedValueOf, ReadableStreamLike } from '../types';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isIterable } from '../util/isIterable';\nimport { isReadableStreamLike, readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\nimport { Subscriber } from '../Subscriber';\nimport { isFunction } from '../util/isFunction';\nimport { reportUnhandledError } from '../util/reportUnhandledError';\nimport { observable as Symbol_observable } from '../symbol/observable';\n\nexport function innerFrom<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\nexport function innerFrom<T>(input: ObservableInput<T>): Observable<T> {\n  if (input instanceof Observable) {\n    return input;\n  }\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return fromInteropObservable(input);\n    }\n    if (isArrayLike(input)) {\n      return fromArrayLike(input);\n    }\n    if (isPromise(input)) {\n      return fromPromise(input);\n    }\n    if (isAsyncIterable(input)) {\n      return fromAsyncIterable(input);\n    }\n    if (isIterable(input)) {\n      return fromIterable(input);\n    }\n    if (isReadableStreamLike(input)) {\n      return fromReadableStreamLike(input);\n    }\n  }\n\n  throw createInvalidObservableTypeError(input);\n}\n\n/**\n * Creates an RxJS Observable from an object that implements `Symbol.observable`.\n * @param obj An object that properly implements `Symbol.observable`.\n */\nexport function fromInteropObservable<T>(obj: any) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    const obs = obj[Symbol_observable]();\n    if (isFunction(obs.subscribe)) {\n      return obs.subscribe(subscriber);\n    }\n    // Should be caught by observable subscribe function error handling.\n    throw new TypeError('Provided object does not correctly implement Symbol.observable');\n  });\n}\n\n/**\n * Synchronously emits the values of an array like and completes.\n * This is exported because there are creation functions and operators that need to\n * make direct use of the same logic, and there's no reason to make them run through\n * `from` conditionals because we *know* they're dealing with an array.\n * @param array The array to emit values from\n */\nexport function fromArrayLike<T>(array: ArrayLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    // Loop over the array and emit each value. Note two things here:\n    // 1. We're making sure that the subscriber is not closed on each loop.\n    //    This is so we don't continue looping over a very large array after\n    //    something like a `take`, `takeWhile`, or other synchronous unsubscription\n    //    has already unsubscribed.\n    // 2. In this form, reentrant code can alter that array we're looping over.\n    //    This is a known issue, but considered an edge case. The alternative would\n    //    be to copy the array before executing the loop, but this has\n    //    performance implications.\n    for (let i = 0; i < array.length && !subscriber.closed; i++) {\n      subscriber.next(array[i]);\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromPromise<T>(promise: PromiseLike<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    promise\n      .then(\n        (value) => {\n          if (!subscriber.closed) {\n            subscriber.next(value);\n            subscriber.complete();\n          }\n        },\n        (err: any) => subscriber.error(err)\n      )\n      .then(null, reportUnhandledError);\n  });\n}\n\nexport function fromIterable<T>(iterable: Iterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    for (const value of iterable) {\n      subscriber.next(value);\n      if (subscriber.closed) {\n        return;\n      }\n    }\n    subscriber.complete();\n  });\n}\n\nexport function fromAsyncIterable<T>(asyncIterable: AsyncIterable<T>) {\n  return new Observable((subscriber: Subscriber<T>) => {\n    process(asyncIterable, subscriber).catch((err) => subscriber.error(err));\n  });\n}\n\nexport function fromReadableStreamLike<T>(readableStream: ReadableStreamLike<T>) {\n  return fromAsyncIterable(readableStreamLikeToAsyncGenerator(readableStream));\n}\n\nasync function process<T>(asyncIterable: AsyncIterable<T>, subscriber: Subscriber<T>) {\n  for await (const value of asyncIterable) {\n    subscriber.next(value);\n    // A side-effect may have closed our subscriber,\n    // check before the next iteration.\n    if (subscriber.closed) {\n      return;\n    }\n  }\n  subscriber.complete();\n}\n", "import { Subscription } from '../Subscription';\nimport { SchedulerAction, SchedulerLike } from '../types';\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay: number,\n  repeat: true\n): void;\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay?: number,\n  repeat?: false\n): Subscription;\n\nexport function executeSchedule(\n  parentSubscription: Subscription,\n  scheduler: SchedulerLike,\n  work: () => void,\n  delay = 0,\n  repeat = false\n): Subscription | void {\n  const scheduleSubscription = scheduler.schedule(function (this: SchedulerAction<any>) {\n    work();\n    if (repeat) {\n      parentSubscription.add(this.schedule(null, delay));\n    } else {\n      this.unsubscribe();\n    }\n  }, delay);\n\n  parentSubscription.add(scheduleSubscription);\n\n  if (!repeat) {\n    // Because user-land scheduler implementations are unlikely to properly reuse\n    // Actions for repeat scheduling, we can't trust that the returned subscription\n    // will control repeat subscription scenarios. So we're trying to avoid using them\n    // incorrectly within this library.\n    return scheduleSubscription;\n  }\n}\n", "/** @prettier */\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Re-emits all notifications from source Observable with specified scheduler.\n *\n * <span class=\"informal\">Ensure a specific scheduler is used, from outside of an Observable.</span>\n *\n * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule\n * notifications emitted by the source Observable. It might be useful, if you do not have control over\n * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.\n *\n * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,\n * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal\n * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits\n * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.\n * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split\n * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source\n * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a\n * little bit more, to ensure that they are emitted at expected moments.\n *\n * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications\n * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`\n * will delay all notifications - including error notifications - while `delay` will pass through error\n * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator\n * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used\n * for notification emissions in general.\n *\n * ## Example\n *\n * Ensure values in subscribe are called just before browser repaint\n *\n * ```ts\n * import { interval, observeOn, animationFrameScheduler } from 'rxjs';\n *\n * const someDiv = document.createElement('div');\n * someDiv.style.cssText = 'width: 200px;background: #09c';\n * document.body.appendChild(someDiv);\n * const intervals = interval(10);      // Intervals are scheduled\n *                                      // with async scheduler by default...\n * intervals.pipe(\n *   observeOn(animationFrameScheduler) // ...but we will observe on animationFrame\n * )                                    // scheduler to ensure smooth animation.\n * .subscribe(val => {\n *   someDiv.style.height = val + 'px';\n * });\n * ```\n *\n * @see {@link delay}\n *\n * @param scheduler Scheduler that will be used to reschedule notifications from source Observable.\n * @param delay Number of milliseconds that states with what delay every notification should be rescheduled.\n * @return A function that returns an Observable that emits the same\n * notifications as the source Observable, but with provided scheduler.\n */\nexport function observeOn<T>(scheduler: SchedulerLike, delay = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => executeSchedule(subscriber, scheduler, () => subscriber.next(value), delay),\n        () => executeSchedule(subscriber, scheduler, () => subscriber.complete(), delay),\n        (err) => executeSchedule(subscriber, scheduler, () => subscriber.error(err), delay)\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Asynchronously subscribes Observers to this Observable on the specified {@link SchedulerLike}.\n *\n * With `subscribeOn` you can decide what type of scheduler a specific Observable will be using when it is subscribed to.\n *\n * Schedulers control the speed and order of emissions to observers from an Observable stream.\n *\n * ![](subscribeOn.png)\n *\n * ## Example\n *\n * Given the following code:\n *\n * ```ts\n * import { of, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3);\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 1\n * // 2\n * // 3\n * // 4\n * // 5\n * // 6\n * ```\n *\n * Both Observable `a` and `b` will emit their values directly and synchronously once they are subscribed to.\n *\n * If we instead use the `subscribeOn` operator declaring that we want to use the {@link asyncScheduler} for values emitted by Observable `a`:\n *\n * ```ts\n * import { of, subscribeOn, asyncScheduler, merge } from 'rxjs';\n *\n * const a = of(1, 2, 3).pipe(subscribeOn(asyncScheduler));\n * const b = of(4, 5, 6);\n *\n * merge(a, b).subscribe(console.log);\n *\n * // Outputs\n * // 4\n * // 5\n * // 6\n * // 1\n * // 2\n * // 3\n * ```\n *\n * The reason for this is that Observable `b` emits its values directly and synchronously like before\n * but the emissions from `a` are scheduled on the event loop because we are now using the {@link asyncScheduler} for that specific Observable.\n *\n * @param scheduler The {@link SchedulerLike} to perform subscription actions on.\n * @param delay A delay to pass to the scheduler to delay subscriptions\n * @return A function that returns an Observable modified so that its\n * subscriptions happen on the specified {@link SchedulerLike}.\n */\nexport function subscribeOn<T>(scheduler: SchedulerLike, delay: number = 0): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    subscriber.add(scheduler.schedule(() => source.subscribe(subscriber), delay));\n  });\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { InteropObservable, SchedulerLike } from '../types';\n\nexport function scheduleObservable<T>(input: InteropObservable<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { observeOn } from '../operators/observeOn';\nimport { subscribeOn } from '../operators/subscribeOn';\nimport { SchedulerLike } from '../types';\n\nexport function schedulePromise<T>(input: PromiseLike<T>, scheduler: SchedulerLike) {\n  return innerFrom(input).pipe(subscribeOn(scheduler), observeOn(scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\n\nexport function scheduleArray<T>(input: ArrayLike<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    // The current array index.\n    let i = 0;\n    // Start iterating over the array like on a schedule.\n    return scheduler.schedule(function () {\n      if (i === input.length) {\n        // If we have hit the end of the array like in the\n        // previous job, we can complete.\n        subscriber.complete();\n      } else {\n        // Otherwise let's next the value at the current index,\n        // then increment our index.\n        subscriber.next(input[i++]);\n        // If the last emission didn't cause us to close the subscriber\n        // (via take or some side effect), reschedule the job and we'll\n        // make another pass.\n        if (!subscriber.closed) {\n          this.schedule();\n        }\n      }\n    });\n  });\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { iterator as Symbol_iterator } from '../symbol/iterator';\nimport { isFunction } from '../util/isFunction';\nimport { executeSchedule } from '../util/executeSchedule';\n\n/**\n * Used in {@link scheduled} to create an observable from an Iterable.\n * @param input The iterable to create an observable from\n * @param scheduler The scheduler to use\n */\nexport function scheduleIterable<T>(input: Iterable<T>, scheduler: SchedulerLike) {\n  return new Observable<T>((subscriber) => {\n    let iterator: Iterator<T, T>;\n\n    // Schedule the initial creation of the iterator from\n    // the iterable. This is so the code in the iterable is\n    // not called until the scheduled job fires.\n    executeSchedule(subscriber, scheduler, () => {\n      // Create the iterator.\n      iterator = (input as any)[Symbol_iterator]();\n\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          let value: T;\n          let done: boolean | undefined;\n          try {\n            // Pull the value out of the iterator\n            ({ value, done } = iterator.next());\n          } catch (err) {\n            // We got an error while pulling from the iterator\n            subscriber.error(err);\n            return;\n          }\n\n          if (done) {\n            // If it is \"done\" we just complete. This mimics the\n            // behavior of JavaScript's `for..of` consumption of\n            // iterables, which will not emit the value from an iterator\n            // result of `{ done: true: value: 'here' }`.\n            subscriber.complete();\n          } else {\n            // The iterable is not done, emit the value.\n            subscriber.next(value);\n          }\n        },\n        0,\n        true\n      );\n    });\n\n    // During finalization, if we see this iterator has a `return` method,\n    // then we know it is a Generator, and not just an Iterator. So we call\n    // the `return()` function. This will ensure that any `finally { }` blocks\n    // inside of the generator we can hit will be hit properly.\n    return () => isFunction(iterator?.return) && iterator.return();\n  });\n}\n", "import { SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport function scheduleAsyncIterable<T>(input: AsyncIterable<T>, scheduler: SchedulerLike) {\n  if (!input) {\n    throw new Error('Iterable cannot be null');\n  }\n  return new Observable<T>((subscriber) => {\n    executeSchedule(subscriber, scheduler, () => {\n      const iterator = input[Symbol.asyncIterator]();\n      executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          iterator.next().then((result) => {\n            if (result.done) {\n              // This will remove the subscriptions from\n              // the parent subscription.\n              subscriber.complete();\n            } else {\n              subscriber.next(result.value);\n            }\n          });\n        },\n        0,\n        true\n      );\n    });\n  });\n}\n", "import { SchedulerLike, ReadableStreamLike } from '../types';\nimport { Observable } from '../Observable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { readableStreamLikeToAsyncGenerator } from '../util/isReadableStreamLike';\n\nexport function scheduleReadableStreamLike<T>(input: ReadableStreamLike<T>, scheduler: SchedulerLike): Observable<T> {\n  return scheduleAsyncIterable(readableStreamLikeToAsyncGenerator(input), scheduler);\n}\n", "import { scheduleObservable } from './scheduleObservable';\nimport { schedulePromise } from './schedulePromise';\nimport { scheduleArray } from './scheduleArray';\nimport { scheduleIterable } from './scheduleIterable';\nimport { scheduleAsyncIterable } from './scheduleAsyncIterable';\nimport { isInteropObservable } from '../util/isInteropObservable';\nimport { isPromise } from '../util/isPromise';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isIterable } from '../util/isIterable';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { Observable } from '../Observable';\nimport { isAsyncIterable } from '../util/isAsyncIterable';\nimport { createInvalidObservableTypeError } from '../util/throwUnobservableError';\nimport { isReadableStreamLike } from '../util/isReadableStreamLike';\nimport { scheduleReadableStreamLike } from './scheduleReadableStreamLike';\n\n/**\n * Converts from a common {@link ObservableInput} type to an observable where subscription and emissions\n * are scheduled on the provided scheduler.\n *\n * @see {@link from}\n * @see {@link of}\n *\n * @param input The observable, array, promise, iterable, etc you would like to schedule\n * @param scheduler The scheduler to use to schedule the subscription and emissions from\n * the returned observable.\n */\nexport function scheduled<T>(input: ObservableInput<T>, scheduler: SchedulerLike): Observable<T> {\n  if (input != null) {\n    if (isInteropObservable(input)) {\n      return scheduleObservable(input, scheduler);\n    }\n    if (isArrayLike(input)) {\n      return scheduleArray(input, scheduler);\n    }\n    if (isPromise(input)) {\n      return schedulePromise(input, scheduler);\n    }\n    if (isAsyncIterable(input)) {\n      return scheduleAsyncIterable(input, scheduler);\n    }\n    if (isIterable(input)) {\n      return scheduleIterable(input, scheduler);\n    }\n    if (isReadableStreamLike(input)) {\n      return scheduleReadableStreamLike(input, scheduler);\n    }\n  }\n  throw createInvalidObservableTypeError(input);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, SchedulerLike, ObservedValueOf } from '../types';\nimport { scheduled } from '../scheduled/scheduled';\nimport { innerFrom } from './innerFrom';\n\nexport function from<O extends ObservableInput<any>>(input: O): Observable<ObservedValueOf<O>>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function from<O extends ObservableInput<any>>(input: O, scheduler: SchedulerLike | undefined): Observable<ObservedValueOf<O>>;\n\n/**\n * Creates an Observable from an Array, an array-like object, a Promise, an iterable object, or an Observable-like object.\n *\n * <span class=\"informal\">Converts almost anything to an Observable.</span>\n *\n * ![](from.png)\n *\n * `from` converts various other objects and data types into Observables. It also converts a Promise, an array-like, or an\n * <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols#iterable\" target=\"_blank\">iterable</a>\n * object into an Observable that emits the items in that promise, array, or iterable. A String, in this context, is treated\n * as an array of characters. Observable-like objects (contains a function named with the ES2015 Symbol for Observable) can also be\n * converted through this operator.\n *\n * ## Examples\n *\n * Converts an array to an Observable\n *\n * ```ts\n * import { from } from 'rxjs';\n *\n * const array = [10, 20, 30];\n * const result = from(array);\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 10\n * // 20\n * // 30\n * ```\n *\n * Convert an infinite iterable (from a generator) to an Observable\n *\n * ```ts\n * import { from, take } from 'rxjs';\n *\n * function* generateDoubles(seed) {\n *    let i = seed;\n *    while (true) {\n *      yield i;\n *      i = 2 * i; // double it\n *    }\n * }\n *\n * const iterator = generateDoubles(3);\n * const result = from(iterator).pipe(take(10));\n *\n * result.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 3\n * // 6\n * // 12\n * // 24\n * // 48\n * // 96\n * // 192\n * // 384\n * // 768\n * // 1536\n * ```\n *\n * With `asyncScheduler`\n *\n * ```ts\n * import { from, asyncScheduler } from 'rxjs';\n *\n * console.log('start');\n *\n * const array = [10, 20, 30];\n * const result = from(array, asyncScheduler);\n *\n * result.subscribe(x => console.log(x));\n *\n * console.log('end');\n *\n * // Logs:\n * // 'start'\n * // 'end'\n * // 10\n * // 20\n * // 30\n * ```\n *\n * @see {@link fromEvent}\n * @see {@link fromEventPattern}\n *\n * @param input A subscription object, a Promise, an Observable-like,\n * an Array, an iterable, or an array-like object to be converted.\n * @param scheduler An optional {@link SchedulerLike} on which to schedule the emission of values.\n * @return An Observable converted from {@link ObservableInput}.\n */\nexport function from<T>(input: ObservableInput<T>, scheduler?: SchedulerLike): Observable<T> {\n  return scheduler ? scheduled(input, scheduler) : innerFrom(input);\n}\n", "import { SchedulerLike, ValueFromArray } from '../types';\nimport { Observable } from '../Observable';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\n// Devs are more likely to pass null or undefined than they are a scheduler\n// without accompanying values. To make things easier for (naughty) devs who\n// use the `strictNullChecks: false` TypeScript compiler option, these\n// overloads with explicit null and undefined values are included.\n\nexport function of(value: null): Observable<null>;\nexport function of(value: undefined): Observable<undefined>;\n\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of(scheduler: SchedulerLike): Observable<never>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function of<A extends readonly unknown[]>(...valuesAndScheduler: [...A, SchedulerLike]): Observable<ValueFromArray<A>>;\n\nexport function of(): Observable<never>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function of<T>(): Observable<T>;\nexport function of<T>(value: T): Observable<T>;\nexport function of<A extends readonly unknown[]>(...values: A): Observable<ValueFromArray<A>>;\n\n/**\n * Converts the arguments to an observable sequence.\n *\n * <span class=\"informal\">Each argument becomes a `next` notification.</span>\n *\n * ![](of.png)\n *\n * Unlike {@link from}, it does not do any flattening and emits each argument in whole\n * as a separate `next` notification.\n *\n * ## Examples\n *\n * Emit the values `10, 20, 30`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of(10, 20, 30)\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: 10\n * // next: 20\n * // next: 30\n * // the end\n * ```\n *\n * Emit the array `[1, 2, 3]`\n *\n * ```ts\n * import { of } from 'rxjs';\n *\n * of([1, 2, 3])\n *   .subscribe({\n *     next: value => console.log('next:', value),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // Outputs\n * // next: [1, 2, 3]\n * // the end\n * ```\n *\n * @see {@link from}\n * @see {@link range}\n *\n * @param args A comma separated list of arguments you want to be emitted.\n * @return An Observable that synchronously emits the arguments described\n * above and then immediately completes.\n */\nexport function of<T>(...args: Array<T | SchedulerLike>): Observable<T> {\n  const scheduler = popScheduler(args);\n  return from(args as T[], scheduler);\n}\n", "import { Observable } from '../Observable';\nimport { Subscriber } from '../Subscriber';\nimport { SchedulerLike } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/**\n * Creates an observable that will create an error instance and push it to the consumer as an error\n * immediately upon subscription.\n *\n * <span class=\"informal\">Just errors and does nothing else</span>\n *\n * ![](throw.png)\n *\n * This creation function is useful for creating an observable that will create an error and error every\n * time it is subscribed to. Generally, inside of most operators when you might want to return an errored\n * observable, this is unnecessary. In most cases, such as in the inner return of {@link concatMap},\n * {@link mergeMap}, {@link defer}, and many others, you can simply throw the error, and RxJS will pick\n * that up and notify the consumer of the error.\n *\n * ## Example\n *\n * Create a simple observable that will create a new error with a timestamp and log it\n * and the message every time you subscribe to it\n *\n * ```ts\n * import { throwError } from 'rxjs';\n *\n * let errorCount = 0;\n *\n * const errorWithTimestamp$ = throwError(() => {\n *   const error: any = new Error(`This is error number ${ ++errorCount }`);\n *   error.timestamp = Date.now();\n *   return error;\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * errorWithTimestamp$.subscribe({\n *   error: err => console.log(err.timestamp, err.message)\n * });\n *\n * // Logs the timestamp and a new error message for each subscription\n * ```\n *\n * ### Unnecessary usage\n *\n * Using `throwError` inside of an operator or creation function\n * with a callback, is usually not necessary\n *\n * ```ts\n * import { of, concatMap, timer, throwError } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // This is probably overkill.\n *       return throwError(() => new Error(`Invalid time ${ ms }`));\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * You can just throw the error instead\n *\n * ```ts\n * import { of, concatMap, timer } from 'rxjs';\n *\n * const delays$ = of(1000, 2000, Infinity, 3000);\n *\n * delays$.pipe(\n *   concatMap(ms => {\n *     if (ms < 10000) {\n *       return timer(ms);\n *     } else {\n *       // Cleaner and easier to read for most folks.\n *       throw new Error(`Invalid time ${ ms }`);\n *     }\n *   })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * @param errorFactory A factory function that will create the error instance that is pushed.\n */\nexport function throwError(errorFactory: () => any): Observable<never>;\n\n/**\n * Returns an observable that will error with the specified error immediately upon subscription.\n *\n * @param error The error instance to emit\n * @deprecated Support for passing an error value will be removed in v8. Instead, pass a factory function to `throwError(() => new Error('test'))`. This is\n * because it will create the error at the moment it should be created and capture a more appropriate stack trace. If\n * for some reason you need to create the error ahead of time, you can still do that: `const err = new Error('test'); throwError(() => err);`.\n */\nexport function throwError(error: any): Observable<never>;\n\n/**\n * Notifies the consumer of an error using a given scheduler by scheduling it at delay `0` upon subscription.\n *\n * @param errorOrErrorFactory An error instance or error factory\n * @param scheduler A scheduler to use to schedule the error notification\n * @deprecated The `scheduler` parameter will be removed in v8.\n * Use `throwError` in combination with {@link observeOn}: `throwError(() => new Error('test')).pipe(observeOn(scheduler));`.\n * Details: https://rxjs.dev/deprecations/scheduler-argument\n */\nexport function throwError(errorOrErrorFactory: any, scheduler: SchedulerLike): Observable<never>;\n\nexport function throwError(errorOrErrorFactory: any, scheduler?: SchedulerLike): Observable<never> {\n  const errorFactory = isFunction(errorOrErrorFactory) ? errorOrErrorFactory : () => errorOrErrorFactory;\n  const init = (subscriber: Subscriber<never>) => subscriber.error(errorFactory());\n  return new Observable(scheduler ? (subscriber) => scheduler.schedule(init as any, 0, subscriber) : init);\n}\n", "import { PartialObserver, ObservableNotification, CompleteNotification, NextNotification, ErrorNotification } from './types';\nimport { Observable } from './Observable';\nimport { EMPTY } from './observable/empty';\nimport { of } from './observable/of';\nimport { throwError } from './observable/throwError';\nimport { isFunction } from './util/isFunction';\n\n// TODO: When this enum is removed, replace it with a type alias. See #4556.\n/**\n * @deprecated Use a string literal instead. `NotificationKind` will be replaced with a type alias in v8.\n * It will not be replaced with a const enum as those are not compatible with isolated modules.\n */\nexport enum NotificationKind {\n  NEXT = 'N',\n  ERROR = 'E',\n  COMPLETE = 'C',\n}\n\n/**\n * Represents a push-based event or value that an {@link Observable} can emit.\n * This class is particularly useful for operators that manage notifications,\n * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and\n * others. Besides wrapping the actual delivered value, it also annotates it\n * with metadata of, for instance, what type of push message it is (`next`,\n * `error`, or `complete`).\n *\n * @see {@link materialize}\n * @see {@link dematerialize}\n * @see {@link observeOn}\n * @deprecated It is NOT recommended to create instances of `Notification` directly.\n * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n * Will be removed in v8.\n */\nexport class Notification<T> {\n  /**\n   * A value signifying that the notification will \"next\" if observed. In truth,\n   * This is really synonymous with just checking `kind === \"N\"`.\n   * @deprecated Will be removed in v8. Instead, just check to see if the value of `kind` is `\"N\"`.\n   */\n  readonly hasValue: boolean;\n\n  /**\n   * Creates a \"Next\" notification object.\n   * @param kind Always `'N'`\n   * @param value The value to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createNext createNext} instead.\n   */\n  constructor(kind: 'N', value?: T);\n  /**\n   * Creates an \"Error\" notification object.\n   * @param kind Always `'E'`\n   * @param value Always `undefined`\n   * @param error The error to notify with if observed.\n   * @deprecated Internal implementation detail. Use {@link Notification#createError createError} instead.\n   */\n  constructor(kind: 'E', value: undefined, error: any);\n  /**\n   * Creates a \"completion\" notification object.\n   * @param kind Always `'C'`\n   * @deprecated Internal implementation detail. Use {@link Notification#createComplete createComplete} instead.\n   */\n  constructor(kind: 'C');\n  constructor(public readonly kind: 'N' | 'E' | 'C', public readonly value?: T, public readonly error?: any) {\n    this.hasValue = kind === 'N';\n  }\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   */\n  observe(observer: PartialObserver<T>): void {\n    return observeNotification(this as ObservableNotification<T>, observer);\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  do(next: (value: T) => void): void;\n  do(nextHandler: (value: T) => void, errorHandler?: (err: any) => void, completeHandler?: () => void): void {\n    const { kind, value, error } = this;\n    return kind === 'N' ? nextHandler?.(value!) : kind === 'E' ? errorHandler?.(error) : completeHandler?.();\n  }\n\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @param complete A complete handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void, complete: () => void): void;\n  /**\n   * Executes a notification on the appropriate handler from a list provided.\n   * If a handler is missing for the kind of notification, nothing is called\n   * and no error is thrown, it will be a noop.\n   * @param next A next handler\n   * @param error An error handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void, error: (err: any) => void): void;\n  /**\n   * Executes the next handler if the Notification is of `kind` `\"N\"`. Otherwise\n   * this will not error, and it will be a noop.\n   * @param next The next handler\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(next: (value: T) => void): void;\n\n  /**\n   * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n   * If the handler is missing it will do nothing. Even if the notification is an error, if\n   * there is no error handler on the observer, an error will not be thrown, it will noop.\n   * @param observer The observer to notify.\n   * @deprecated Replaced with {@link Notification#observe observe}. Will be removed in v8.\n   */\n  accept(observer: PartialObserver<T>): void;\n  accept(nextOrObserver: PartialObserver<T> | ((value: T) => void), error?: (err: any) => void, complete?: () => void) {\n    return isFunction((nextOrObserver as any)?.next)\n      ? this.observe(nextOrObserver as PartialObserver<T>)\n      : this.do(nextOrObserver as (value: T) => void, error as any, complete as any);\n  }\n\n  /**\n   * Returns a simple Observable that just delivers the notification represented\n   * by this Notification instance.\n   *\n   * @deprecated Will be removed in v8. To convert a `Notification` to an {@link Observable},\n   * use {@link of} and {@link dematerialize}: `of(notification).pipe(dematerialize())`.\n   */\n  toObservable(): Observable<T> {\n    const { kind, value, error } = this;\n    // Select the observable to return by `kind`\n    const result =\n      kind === 'N'\n        ? // Next kind. Return an observable of that value.\n          of(value!)\n        : //\n        kind === 'E'\n        ? // Error kind. Return an observable that emits the error.\n          throwError(() => error)\n        : //\n        kind === 'C'\n        ? // Completion kind. Kind is \"C\", return an observable that just completes.\n          EMPTY\n        : // Unknown kind, return falsy, so we error below.\n          0;\n    if (!result) {\n      // TODO: consider removing this check. The only way to cause this would be to\n      // use the Notification constructor directly in a way that is not type-safe.\n      // and direct use of the Notification constructor is deprecated.\n      throw new TypeError(`Unexpected notification kind ${kind}`);\n    }\n    return result;\n  }\n\n  private static completeNotification = new Notification('C') as Notification<never> & CompleteNotification;\n  /**\n   * A shortcut to create a Notification instance of the type `next` from a\n   * given value.\n   * @param value The `next` value.\n   * @return The \"next\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createNext<T>(value: T) {\n    return new Notification('N', value) as Notification<T> & NextNotification<T>;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `error` from a\n   * given error.\n   * @param err The `error` error.\n   * @return The \"error\" Notification representing the argument.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createError(err?: any) {\n    return new Notification('E', undefined, err) as Notification<never> & ErrorNotification;\n  }\n\n  /**\n   * A shortcut to create a Notification instance of the type `complete`.\n   * @return The valueless \"complete\" Notification.\n   * @deprecated It is NOT recommended to create instances of `Notification` directly.\n   * Rather, try to create POJOs matching the signature outlined in {@link ObservableNotification}.\n   * For example: `{ kind: 'N', value: 1 }`, `{ kind: 'E', error: new Error('bad') }`, or `{ kind: 'C' }`.\n   * Will be removed in v8.\n   */\n  static createComplete(): Notification<never> & CompleteNotification {\n    return Notification.completeNotification;\n  }\n}\n\n/**\n * Executes the appropriate handler on a passed `observer` given the `kind` of notification.\n * If the handler is missing it will do nothing. Even if the notification is an error, if\n * there is no error handler on the observer, an error will not be thrown, it will noop.\n * @param notification The notification object to observe.\n * @param observer The observer to notify.\n */\nexport function observeNotification<T>(notification: ObservableNotification<T>, observer: PartialObserver<T>) {\n  const { kind, value, error } = notification as any;\n  if (typeof kind !== 'string') {\n    throw new TypeError('Invalid notification, missing \"kind\"');\n  }\n  kind === 'N' ? observer.next?.(value!) : kind === 'E' ? observer.error?.(error) : observer.complete?.();\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface EmptyError extends Error {}\n\nexport interface EmptyErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): EmptyError;\n}\n\n/**\n * An error thrown when an Observable or a sequence was queried but has no\n * elements.\n *\n * @see {@link first}\n * @see {@link last}\n * @see {@link single}\n * @see {@link firstValueFrom}\n * @see {@link lastValueFrom}\n */\nexport const EmptyError: EmptyErrorCtor = createErrorClass(\n  (_super) =>\n    function EmptyErrorImpl(this: any) {\n      _super(this);\n      this.name = 'EmptyError';\n      this.message = 'no elements in sequence';\n    }\n);\n", "import { Observable } from './Observable';\nimport { EmptyError } from './util/EmptyError';\nimport { SafeSubscriber } from './Subscriber';\n\nexport interface FirstValueFromConfig<T> {\n  defaultValue: T;\n}\n\nexport function firstValueFrom<T, D>(source: Observable<T>, config: FirstValueFromConfig<D>): Promise<T | D>;\nexport function firstValueFrom<T>(source: Observable<T>): Promise<T>;\n\n/**\n * Converts an observable to a promise by subscribing to the observable,\n * and returning a promise that will resolve as soon as the first value\n * arrives from the observable. The subscription will then be closed.\n *\n * If the observable stream completes before any values were emitted, the\n * returned promise will reject with {@link EmptyError} or will resolve\n * with the default value if a default was specified.\n *\n * If the observable stream emits an error, the returned promise will reject\n * with that error.\n *\n * **WARNING**: Only use this with observables you *know* will emit at least one value,\n * *OR* complete. If the source observable does not emit one value or complete, you will\n * end up with a promise that is hung up, and potentially all of the state of an\n * async function hanging out in memory. To avoid this situation, look into adding\n * something like {@link timeout}, {@link take}, {@link takeWhile}, or {@link takeUntil}\n * amongst others.\n *\n * ## Example\n *\n * Wait for the first value from a stream and emit it from a promise in\n * an async function\n *\n * ```ts\n * import { interval, firstValueFrom } from 'rxjs';\n *\n * async function execute() {\n *   const source$ = interval(2000);\n *   const firstNumber = await firstValueFrom(source$);\n *   console.log(`The first number is ${ firstNumber }`);\n * }\n *\n * execute();\n *\n * // Expected output:\n * // 'The first number is 0'\n * ```\n *\n * @see {@link lastValueFrom}\n *\n * @param source the observable to convert to a promise\n * @param config a configuration object to define the `defaultValue` to use if the source completes without emitting a value\n */\nexport function firstValueFrom<T, D>(source: Observable<T>, config?: FirstValueFromConfig<D>): Promise<T | D> {\n  const hasConfig = typeof config === 'object';\n  return new Promise<T | D>((resolve, reject) => {\n    const subscriber = new SafeSubscriber<T>({\n      next: (value) => {\n        resolve(value);\n        subscriber.unsubscribe();\n      },\n      error: reject,\n      complete: () => {\n        if (hasConfig) {\n          resolve(config!.defaultValue);\n        } else {\n          reject(new EmptyError());\n        }\n      },\n    });\n    source.subscribe(subscriber);\n  });\n}\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface ArgumentOutOfRangeError extends Error {}\n\nexport interface ArgumentOutOfRangeErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (): ArgumentOutOfRangeError;\n}\n\n/**\n * An error thrown when an element was queried at a certain index of an\n * Observable, but no such index or position exists in that sequence.\n *\n * @see {@link elementAt}\n * @see {@link take}\n * @see {@link takeLast}\n */\nexport const ArgumentOutOfRangeError: ArgumentOutOfRangeErrorCtor = createErrorClass(\n  (_super) =>\n    function ArgumentOutOfRangeErrorImpl(this: any) {\n      _super(this);\n      this.name = 'ArgumentOutOfRangeError';\n      this.message = 'argument out of range';\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface NotFoundError extends Error {}\n\nexport interface NotFoundErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): NotFoundError;\n}\n\n/**\n * An error thrown when a value or values are missing from an\n * observable sequence.\n *\n * @see {@link operators/single}\n */\nexport const NotFoundError: NotFoundErrorCtor = createErrorClass(\n  (_super) =>\n    function NotFoundErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'NotFoundError';\n      this.message = message;\n    }\n);\n", "import { createErrorClass } from './createErrorClass';\n\nexport interface SequenceError extends Error {}\n\nexport interface SequenceErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new (message: string): SequenceError;\n}\n\n/**\n * An error thrown when something is wrong with the sequence of\n * values arriving on the observable.\n *\n * @see {@link operators/single}\n */\nexport const SequenceError: SequenceErrorCtor = createErrorClass(\n  (_super) =>\n    function SequenceErrorImpl(this: any, message: string) {\n      _super(this);\n      this.name = 'SequenceError';\n      this.message = message;\n    }\n);\n", "/**\n * Checks to see if a value is not only a `Date` object,\n * but a *valid* `Date` object that can be converted to a\n * number. For example, `new Date('blah')` is indeed an\n * `instanceof Date`, however it cannot be converted to a\n * number.\n */\nexport function isValidDate(value: any): value is Date {\n  return value instanceof Date && !isNaN(value as any);\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike, OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\nimport { isValidDate } from '../util/isDate';\nimport { Subscription } from '../Subscription';\nimport { operate } from '../util/lift';\nimport { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { createErrorClass } from '../util/createErrorClass';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { executeSchedule } from '../util/executeSchedule';\n\nexport interface TimeoutConfig<T, O extends ObservableInput<unknown> = ObservableInput<T>, M = unknown> {\n  /**\n   * The time allowed between values from the source before timeout is triggered.\n   */\n  each?: number;\n\n  /**\n   * The relative time as a `number` in milliseconds, or a specific time as a `Date` object,\n   * by which the first value must arrive from the source before timeout is triggered.\n   */\n  first?: number | Date;\n\n  /**\n   * The scheduler to use with time-related operations within this operator. Defaults to {@link asyncScheduler}\n   */\n  scheduler?: SchedulerLike;\n\n  /**\n   * A factory used to create observable to switch to when timeout occurs. Provides\n   * a {@link TimeoutInfo} about the source observable's emissions and what delay or\n   * exact time triggered the timeout.\n   */\n  with?: (info: TimeoutInfo<T, M>) => O;\n\n  /**\n   * Optional additional metadata you can provide to code that handles\n   * the timeout, will be provided through the {@link TimeoutError}.\n   * This can be used to help identify the source of a timeout or pass along\n   * other information related to the timeout.\n   */\n  meta?: M;\n}\n\nexport interface TimeoutInfo<T, M = unknown> {\n  /** Optional metadata that was provided to the timeout configuration. */\n  readonly meta: M;\n  /** The number of messages seen before the timeout */\n  readonly seen: number;\n  /** The last message seen */\n  readonly lastValue: T | null;\n}\n\n/**\n * An error emitted when a timeout occurs.\n */\nexport interface TimeoutError<T = unknown, M = unknown> extends Error {\n  /**\n   * The information provided to the error by the timeout\n   * operation that created the error. Will be `null` if\n   * used directly in non-RxJS code with an empty constructor.\n   * (Note that using this constructor directly is not recommended,\n   * you should create your own errors)\n   */\n  info: TimeoutInfo<T, M> | null;\n}\n\nexport interface TimeoutErrorCtor {\n  /**\n   * @deprecated Internal implementation detail. Do not construct error instances.\n   * Cannot be tagged as internal: https://github.com/ReactiveX/rxjs/issues/6269\n   */\n  new <T = unknown, M = unknown>(info?: TimeoutInfo<T, M>): TimeoutError<T, M>;\n}\n\n/**\n * An error thrown by the {@link timeout} operator.\n *\n * Provided so users can use as a type and do quality comparisons.\n * We recommend you do not subclass this or create instances of this class directly.\n * If you have need of a error representing a timeout, you should\n * create your own error class and use that.\n *\n * @see {@link timeout}\n */\nexport const TimeoutError: TimeoutErrorCtor = createErrorClass(\n  (_super) =>\n    function TimeoutErrorImpl(this: any, info: TimeoutInfo<any> | null = null) {\n      _super(this);\n      this.message = 'Timeout has occurred';\n      this.name = 'TimeoutError';\n      this.info = info;\n    }\n);\n\n/**\n * If `with` is provided, this will return an observable that will switch to a different observable if the source\n * does not push values within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ## Examples\n *\n * Emit a custom error if there is too much time between values\n *\n * ```ts\n * import { interval, timeout, throwError } from 'rxjs';\n *\n * class CustomTimeoutError extends Error {\n *   constructor() {\n *     super('It was too slow');\n *     this.name = 'CustomTimeoutError';\n *   }\n * }\n *\n * const slow$ = interval(900);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => throwError(() => new CustomTimeoutError())\n *   })\n * )\n * .subscribe({\n *   error: console.error\n * });\n * ```\n *\n * Switch to a faster observable if your source is slow.\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * const slow$ = interval(900);\n * const fast$ = interval(500);\n *\n * slow$.pipe(\n *   timeout({\n *     each: 1000,\n *     with: () => fast$,\n *   })\n * )\n * .subscribe(console.log);\n * ```\n * @param config The configuration for the timeout.\n */\nexport function timeout<T, O extends ObservableInput<unknown>, M = unknown>(\n  config: TimeoutConfig<T, O, M> & { with: (info: TimeoutInfo<T, M>) => O }\n): OperatorFunction<T, T | ObservedValueOf<O>>;\n\n/**\n * Returns an observable that will error or switch to a different observable if the source does not push values\n * within the specified time parameters.\n *\n * <span class=\"informal\">The most flexible option for creating a timeout behavior.</span>\n *\n * The first thing to know about the configuration is if you do not provide a `with` property to the configuration,\n * when timeout conditions are met, this operator will emit a {@link TimeoutError}. Otherwise, it will use the factory\n * function provided by `with`, and switch your subscription to the result of that. Timeout conditions are provided by\n * the settings in `first` and `each`.\n *\n * The `first` property can be either a `Date` for a specific time, a `number` for a time period relative to the\n * point of subscription, or it can be skipped. This property is to check timeout conditions for the arrival of\n * the first value from the source _only_. The timings of all subsequent values  from the source will be checked\n * against the time period provided by `each`, if it was provided.\n *\n * The `each` property can be either a `number` or skipped. If a value for `each` is provided, it represents the amount of\n * time the resulting observable will wait between the arrival of values from the source before timing out. Note that if\n * `first` is _not_ provided, the value from `each` will be used to check timeout conditions for the arrival of the first\n * value and all subsequent values. If `first` _is_ provided, `each` will only be use to check all values after the first.\n *\n * ### Handling TimeoutErrors\n *\n * If no `with` property was provided, subscriptions to the resulting observable may emit an error of {@link TimeoutError}.\n * The timeout error provides useful information you can examine when you're handling the error. The most common way to handle\n * the error would be with {@link catchError}, although you could use {@link tap} or just the error handler in your `subscribe` call\n * directly, if your error handling is only a side effect (such as notifying the user, or logging).\n *\n * In this case, you would check the error for `instanceof TimeoutError` to validate that the error was indeed from `timeout`, and\n * not from some other source. If it's not from `timeout`, you should probably rethrow it if you're in a `catchError`.\n *\n * ## Examples\n *\n * Emit a {@link TimeoutError} if the first value, and _only_ the first value, does not arrive within 5 seconds\n *\n * ```ts\n * import { interval, timeout } from 'rxjs';\n *\n * // A random interval that lasts between 0 and 10 seconds per tick\n * const source$ = interval(Math.round(Math.random() * 10_000));\n *\n * source$.pipe(\n *   timeout({ first: 5_000 })\n * )\n * .subscribe({\n *   next: console.log,\n *   error: console.error\n * });\n * ```\n *\n * Emit a {@link TimeoutError} if the source waits longer than 5 seconds between any two values or the first value\n * and subscription.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n *\n * Emit a {@link TimeoutError} if the source does not emit before 7 seconds, _or_ if the source waits longer than\n * 5 seconds between any two values after the first.\n *\n * ```ts\n * import { timer, timeout, expand } from 'rxjs';\n *\n * const getRandomTime = () => Math.round(Math.random() * 10_000);\n *\n * // An observable that waits a random amount of time between each delivered value\n * const source$ = timer(getRandomTime())\n *   .pipe(expand(() => timer(getRandomTime())));\n *\n * source$\n *   .pipe(timeout({ first: 7_000, each: 5_000 }))\n *   .subscribe({\n *     next: console.log,\n *     error: console.error\n *   });\n * ```\n */\nexport function timeout<T, M = unknown>(config: Omit<TimeoutConfig<T, any, M>, 'with'>): OperatorFunction<T, T>;\n\n/**\n * Returns an observable that will error if the source does not push its first value before the specified time passed as a `Date`.\n * This is functionally the same as `timeout({ first: someDate })`.\n *\n * <span class=\"informal\">Errors if the first value doesn't show up before the given date and time</span>\n *\n * ![](timeout.png)\n *\n * @param first The date to at which the resulting observable will timeout if the source observable\n * does not emit at least one value.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(first: Date, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns an observable that will error if the source does not push a value within the specified time in milliseconds.\n * This is functionally the same as `timeout({ each: milliseconds })`.\n *\n * <span class=\"informal\">Errors if it waits too long between any value</span>\n *\n * ![](timeout.png)\n *\n * @param each The time allowed between each pushed value from the source before the resulting observable\n * will timeout.\n * @param scheduler The scheduler to use. Defaults to {@link asyncScheduler}.\n */\nexport function timeout<T>(each: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n *\n * Errors if Observable does not emit a value in given time span.\n *\n * <span class=\"informal\">Timeouts on Observable that doesn't emit values fast enough.</span>\n *\n * ![](timeout.png)\n *\n * @see {@link timeoutWith}\n *\n * @return A function that returns an Observable that mirrors behaviour of the\n * source Observable, unless timeout happens when it throws an error.\n */\nexport function timeout<T, O extends ObservableInput<any>, M>(\n  config: number | Date | TimeoutConfig<T, O, M>,\n  schedulerArg?: SchedulerLike\n): OperatorFunction<T, T | ObservedValueOf<O>> {\n  // Intentionally terse code.\n  // If the first argument is a valid `Date`, then we use it as the `first` config.\n  // Otherwise, if the first argument is a `number`, then we use it as the `each` config.\n  // Otherwise, it can be assumed the first argument is the configuration object itself, and\n  // we destructure that into what we're going to use, setting important defaults as we do.\n  // NOTE: The default for `scheduler` will be the `scheduler` argument if it exists, or\n  // it will default to the `asyncScheduler`.\n  const {\n    first,\n    each,\n    with: _with = timeoutErrorFactory,\n    scheduler = schedulerArg ?? asyncScheduler,\n    meta = null!,\n  } = (isValidDate(config) ? { first: config } : typeof config === 'number' ? { each: config } : config) as TimeoutConfig<T, O, M>;\n\n  if (first == null && each == null) {\n    // Ensure timeout was provided at runtime.\n    throw new TypeError('No timeout provided.');\n  }\n\n  return operate((source, subscriber) => {\n    // This subscription encapsulates our subscription to the\n    // source for this operator. We're capturing it separately,\n    // because if there is a `with` observable to fail over to,\n    // we want to unsubscribe from our original subscription, and\n    // hand of the subscription to that one.\n    let originalSourceSubscription: Subscription;\n    // The subscription for our timeout timer. This changes\n    // every time we get a new value.\n    let timerSubscription: Subscription;\n    // A bit of state we pass to our with and error factories to\n    // tell what the last value we saw was.\n    let lastValue: T | null = null;\n    // A bit of state we pass to the with and error factories to\n    // tell how many values we have seen so far.\n    let seen = 0;\n    const startTimer = (delay: number) => {\n      timerSubscription = executeSchedule(\n        subscriber,\n        scheduler,\n        () => {\n          try {\n            originalSourceSubscription.unsubscribe();\n            innerFrom(\n              _with!({\n                meta,\n                lastValue,\n                seen,\n              })\n            ).subscribe(subscriber);\n          } catch (err) {\n            subscriber.error(err);\n          }\n        },\n        delay\n      );\n    };\n\n    originalSourceSubscription = source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value: T) => {\n          // clear the timer so we can emit and start another one.\n          timerSubscription?.unsubscribe();\n          seen++;\n          // Emit\n          subscriber.next((lastValue = value));\n          // null | undefined are both < 0. Thanks, JavaScript.\n          each! > 0 && startTimer(each!);\n        },\n        undefined,\n        undefined,\n        () => {\n          if (!timerSubscription?.closed) {\n            timerSubscription?.unsubscribe();\n          }\n          // Be sure not to hold the last value in memory after unsubscription\n          // it could be quite large.\n          lastValue = null;\n        }\n      )\n    );\n\n    // Intentionally terse code.\n    // If we've `seen` a value, that means the \"first\" clause was met already, if it existed.\n    //   it also means that a timer was already started for \"each\" (in the next handler above).\n    // If `first` was provided, and it's a number, then use it.\n    // If `first` was provided and it's not a number, it's a Date, and we get the difference between it and \"now\".\n    // If `first` was not provided at all, then our first timer will be the value from `each`.\n    !seen && startTimer(first != null ? (typeof first === 'number' ? first : +first - scheduler!.now()) : each!);\n  });\n}\n\n/**\n * The default function to use to emit an error when timeout occurs and a `with` function\n * is not specified.\n * @param info The information about the timeout to pass along to the error\n */\nfunction timeoutErrorFactory(info: TimeoutInfo<any>): Observable<never> {\n  throw new TimeoutError(info);\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\nexport function map<T, R>(project: (value: T, index: number) => R): OperatorFunction<T, R>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function map<T, R, A>(project: (this: A, value: T, index: number) => R, thisArg: A): OperatorFunction<T, R>;\n\n/**\n * Applies a given `project` function to each value emitted by the source\n * Observable, and emits the resulting values as an Observable.\n *\n * <span class=\"informal\">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),\n * it passes each source value through a transformation function to get\n * corresponding output values.</span>\n *\n * ![](map.png)\n *\n * Similar to the well known `Array.prototype.map` function, this operator\n * applies a projection to each value and emits that projection in the output\n * Observable.\n *\n * ## Example\n *\n * Map every click to the `clientX` position of that click\n *\n * ```ts\n * import { fromEvent, map } from 'rxjs';\n *\n * const clicks = fromEvent<PointerEvent>(document, 'click');\n * const positions = clicks.pipe(map(ev => ev.clientX));\n *\n * positions.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link mapTo}\n * @see {@link pluck}\n *\n * @param project The function to apply to each `value` emitted by the source\n * Observable. The `index` parameter is the number `i` for the i-th emission\n * that has happened since the subscription, starting from the number `0`.\n * @param thisArg An optional argument to define what `this` is in the\n * `project` function.\n * @return A function that returns an Observable that emits the values from the\n * source Observable transformed by the given `project` function.\n */\nexport function map<T, R>(project: (value: T, index: number) => R, thisArg?: any): OperatorFunction<T, R> {\n  return operate((source, subscriber) => {\n    // The index of the value from the source. Used with projection.\n    let index = 0;\n    // Subscribe to the source, all errors and completions are sent along\n    // to the consumer.\n    source.subscribe(\n      createOperatorSubscriber(subscriber, (value: T) => {\n        // Call the projection function with the appropriate this context,\n        // and send the resulting value to the consumer.\n        subscriber.next(project.call(thisArg, value, index++));\n      })\n    );\n  });\n}\n", "import { OperatorFunction } from \"../types\";\nimport { map } from \"../operators/map\";\n\nconst { isArray } = Array;\n\nfunction callOrApply<T, R>(fn: ((...values: T[]) => R), args: T|T[]): R {\n    return isArray(args) ? fn(...args) : fn(args);\n}\n\n/**\n * Used in several -- mostly deprecated -- situations where we need to \n * apply a list of arguments or a single argument to a result selector.\n */\nexport function mapOneOrManyArgs<T, R>(fn: ((...values: T[]) => R)): OperatorFunction<T|T[], R> {\n    return map(args => callOrApply(fn, args))\n}", "const { isArray } = Array;\nconst { getPrototypeOf, prototype: objectProto, keys: getKeys } = Object;\n\n/**\n * Used in functions where either a list of arguments, a single array of arguments, or a\n * dictionary of arguments can be returned. Returns an object with an `args` property with\n * the arguments in an array, if it is a dictionary, it will also return the `keys` in another\n * property.\n */\nexport function argsArgArrayOrObject<T, O extends Record<string, T>>(args: T[] | [O] | [T[]]): { args: T[]; keys: string[] | null } {\n  if (args.length === 1) {\n    const first = args[0];\n    if (isArray(first)) {\n      return { args: first, keys: null };\n    }\n    if (isPOJO(first)) {\n      const keys = getKeys(first);\n      return {\n        args: keys.map((key) => first[key]),\n        keys,\n      };\n    }\n  }\n\n  return { args: args as T[], keys: null };\n}\n\nfunction isPOJO(obj: any): obj is object {\n  return obj && typeof obj === 'object' && getPrototypeOf(obj) === objectProto;\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from '../observable/innerFrom';\nimport { Subscriber } from '../Subscriber';\nimport { ObservableInput, SchedulerLike } from '../types';\nimport { executeSchedule } from '../util/executeSchedule';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * A process embodying the general \"merge\" strategy. This is used in\n * `mergeMap` and `mergeScan` because the logic is otherwise nearly identical.\n * @param source The original source observable\n * @param subscriber The consumer subscriber\n * @param project The projection function to get our inner sources\n * @param concurrent The number of concurrent inner subscriptions\n * @param onBeforeNext Additional logic to apply before nexting to our consumer\n * @param expand If `true` this will perform an \"expand\" strategy, which differs only\n * in that it recurses, and the inner subscription must be schedule-able.\n * @param innerSubScheduler A scheduler to use to schedule inner subscriptions,\n * this is to support the expand strategy, mostly, and should be deprecated\n */\nexport function mergeInternals<T, R>(\n  source: Observable<T>,\n  subscriber: Subscriber<R>,\n  project: (value: T, index: number) => ObservableInput<R>,\n  concurrent: number,\n  onBeforeNext?: (innerValue: R) => void,\n  expand?: boolean,\n  innerSubScheduler?: SchedulerLike,\n  additionalFinalizer?: () => void\n) {\n  // Buffered values, in the event of going over our concurrency limit\n  const buffer: T[] = [];\n  // The number of active inner subscriptions.\n  let active = 0;\n  // An index to pass to our accumulator function\n  let index = 0;\n  // Whether or not the outer source has completed.\n  let isComplete = false;\n\n  /**\n   * Checks to see if we can complete our result or not.\n   */\n  const checkComplete = () => {\n    // If the outer has completed, and nothing is left in the buffer,\n    // and we don't have any active inner subscriptions, then we can\n    // Emit the state and complete.\n    if (isComplete && !buffer.length && !active) {\n      subscriber.complete();\n    }\n  };\n\n  // If we're under our concurrency limit, just start the inner subscription, otherwise buffer and wait.\n  const outerNext = (value: T) => (active < concurrent ? doInnerSub(value) : buffer.push(value));\n\n  const doInnerSub = (value: T) => {\n    // If we're expanding, we need to emit the outer values and the inner values\n    // as the inners will \"become outers\" in a way as they are recursively fed\n    // back to the projection mechanism.\n    expand && subscriber.next(value as any);\n\n    // Increment the number of active subscriptions so we can track it\n    // against our concurrency limit later.\n    active++;\n\n    // A flag used to show that the inner observable completed.\n    // This is checked during finalization to see if we should\n    // move to the next item in the buffer, if there is on.\n    let innerComplete = false;\n\n    // Start our inner subscription.\n    innerFrom(project(value, index++)).subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (innerValue) => {\n          // `mergeScan` has additional handling here. For example\n          // taking the inner value and updating state.\n          onBeforeNext?.(innerValue);\n\n          if (expand) {\n            // If we're expanding, then just recurse back to our outer\n            // handler. It will emit the value first thing.\n            outerNext(innerValue as any);\n          } else {\n            // Otherwise, emit the inner value.\n            subscriber.next(innerValue);\n          }\n        },\n        () => {\n          // Flag that we have completed, so we know to check the buffer\n          // during finalization.\n          innerComplete = true;\n        },\n        // Errors are passed to the destination.\n        undefined,\n        () => {\n          // During finalization, if the inner completed (it wasn't errored or\n          // cancelled), then we want to try the next item in the buffer if\n          // there is one.\n          if (innerComplete) {\n            // We have to wrap this in a try/catch because it happens during\n            // finalization, possibly asynchronously, and we want to pass\n            // any errors that happen (like in a projection function) to\n            // the outer Subscriber.\n            try {\n              // INNER SOURCE COMPLETE\n              // Decrement the active count to ensure that the next time\n              // we try to call `doInnerSub`, the number is accurate.\n              active--;\n              // If we have more values in the buffer, try to process those\n              // Note that this call will increment `active` ahead of the\n              // next conditional, if there were any more inner subscriptions\n              // to start.\n              while (buffer.length && active < concurrent) {\n                const bufferedValue = buffer.shift()!;\n                // Particularly for `expand`, we need to check to see if a scheduler was provided\n                // for when we want to start our inner subscription. Otherwise, we just start\n                // are next inner subscription.\n                if (innerSubScheduler) {\n                  executeSchedule(subscriber, innerSubScheduler, () => doInnerSub(bufferedValue));\n                } else {\n                  doInnerSub(bufferedValue);\n                }\n              }\n              // Check to see if we can complete, and complete if so.\n              checkComplete();\n            } catch (err) {\n              subscriber.error(err);\n            }\n          }\n        }\n      )\n    );\n  };\n\n  // Subscribe to our source observable.\n  source.subscribe(\n    createOperatorSubscriber(subscriber, outerNext, () => {\n      // Outer completed, make a note of it, and check to see if we can complete everything.\n      isComplete = true;\n      checkComplete();\n    })\n  );\n\n  // Additional finalization (for when the destination is torn down).\n  // Other finalization is added implicitly via subscription above.\n  return () => {\n    additionalFinalizer?.();\n  };\n}\n", "import { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { map } from './map';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { mergeInternals } from './mergeInternals';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined,\n  concurrent?: number\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R,\n  concurrent?: number\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link mergeAll}.</span>\n *\n * ![](mergeMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an Observable, and then merging those resulting Observables and\n * emitting the results of this merger.\n *\n * ## Example\n *\n * Map and flatten each letter to an Observable ticking every 1 second\n *\n * ```ts\n * import { of, mergeMap, interval, map } from 'rxjs';\n *\n * const letters = of('a', 'b', 'c');\n * const result = letters.pipe(\n *   mergeMap(x => interval(1000).pipe(map(i => x + i)))\n * );\n *\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // a0\n * // b0\n * // c0\n * // a1\n * // b1\n * // c1\n * // continues to list a, b, c every second with respective ascending integers\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link merge}\n * @see {@link mergeAll}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @param concurrent Maximum number of `ObservableInput`s being subscribed to concurrently.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and merging\n * the results of the Observables obtained from this transformation.\n */\nexport function mergeMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: ((outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R) | number,\n  concurrent: number = Infinity\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  if (isFunction(resultSelector)) {\n    // DEPRECATED PATH\n    return mergeMap((a, i) => map((b: any, ii: number) => resultSelector(a, b, i, ii))(innerFrom(project(a, i))), concurrent);\n  } else if (typeof resultSelector === 'number') {\n    concurrent = resultSelector;\n  }\n\n  return operate((source, subscriber) => mergeInternals(source, subscriber, project, concurrent));\n}\n", "import { mergeMap } from './mergeMap';\nimport { identity } from '../util/identity';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable which\n * concurrently delivers all values that are emitted on the inner Observables.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables.</span>\n *\n * ![](mergeAll.png)\n *\n * `mergeAll` subscribes to an Observable that emits Observables, also known as\n * a higher-order Observable. Each time it observes one of these emitted inner\n * Observables, it subscribes to that and delivers all the values from the\n * inner Observable on the output Observable. The output Observable only\n * completes once all inner Observables have completed. Any error delivered by\n * a inner Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Spawn a new interval Observable for each click event, and blend their outputs as one Observable\n *\n * ```ts\n * import { fromEvent, map, interval, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(map(() => interval(1000)));\n * const firstOrder = higherOrder.pipe(mergeAll());\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * Count from 0 to 9 every second for each click, but only allow 2 concurrent timers\n *\n * ```ts\n * import { fromEvent, map, interval, take, mergeAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(10)))\n * );\n * const firstOrder = higherOrder.pipe(mergeAll(2));\n *\n * firstOrder.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concatAll}\n * @see {@link exhaustAll}\n * @see {@link merge}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @param concurrent Maximum number of inner Observables being subscribed to\n * concurrently.\n * @return A function that returns an Observable that emits values coming from\n * all the inner Observables emitted by the source Observable.\n */\nexport function mergeAll<O extends ObservableInput<any>>(concurrent: number = Infinity): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeMap(identity, concurrent);\n}\n", "import { mergeAll } from './mergeAll';\nimport { OperatorFunction, ObservableInput, ObservedValueOf } from '../types';\n\n/**\n * Converts a higher-order Observable into a first-order Observable by\n * concatenating the inner Observables in order.\n *\n * <span class=\"informal\">Flattens an Observable-of-Observables by putting one\n * inner Observable after the other.</span>\n *\n * ![](concatAll.svg)\n *\n * Joins every Observable emitted by the source (a higher-order Observable), in\n * a serial fashion. It subscribes to each inner Observable only after the\n * previous inner Observable has completed, and merges all of their values into\n * the returned observable.\n *\n * __Warning:__ If the source Observable emits Observables quickly and\n * endlessly, and the inner Observables it emits generally complete slower than\n * the source emits, you can run into memory issues as the incoming Observables\n * collect in an unbounded buffer.\n *\n * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, map, interval, take, concatAll } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const higherOrder = clicks.pipe(\n *   map(() => interval(1000).pipe(take(4)))\n * );\n * const firstOrder = higherOrder.pipe(concatAll());\n * firstOrder.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link combineLatestAll}\n * @see {@link concat}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link exhaustAll}\n * @see {@link mergeAll}\n * @see {@link switchAll}\n * @see {@link switchMap}\n * @see {@link zipAll}\n *\n * @return A function that returns an Observable emitting values from all the\n * inner Observables concatenated.\n */\nexport function concatAll<O extends ObservableInput<any>>(): OperatorFunction<O, ObservedValueOf<O>> {\n  return mergeAll(1);\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInputTuple, SchedulerLike } from '../types';\nimport { concatAll } from '../operators/concatAll';\nimport { popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function concat<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function concat<T extends readonly unknown[]>(\n  ...inputsAndScheduler: [...ObservableInputTuple<T>, SchedulerLike]\n): Observable<T[number]>;\n\n/**\n * Creates an output Observable which sequentially emits all values from the first given\n * Observable and then moves on to the next.\n *\n * <span class=\"informal\">Concatenates multiple Observables together by\n * sequentially emitting their values, one Observable after the other.</span>\n *\n * ![](concat.png)\n *\n * `concat` joins multiple Observables together, by subscribing to them one at a time and\n * merging their results into the output Observable. You can pass either an array of\n * Observables, or put them directly as arguments. Passing an empty array will result\n * in Observable that completes immediately.\n *\n * `concat` will subscribe to first input Observable and emit all its values, without\n * changing or affecting them in any way. When that Observable completes, it will\n * subscribe to then next Observable passed and, again, emit its values. This will be\n * repeated, until the operator runs out of Observables. When last input Observable completes,\n * `concat` will complete as well. At any given moment only one Observable passed to operator\n * emits values. If you would like to emit values from passed Observables concurrently, check out\n * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,\n * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.\n *\n * Note that if some input Observable never completes, `concat` will also never complete\n * and Observables following the one that did not complete will never be subscribed. On the other\n * hand, if some Observable simply completes immediately after it is subscribed, it will be\n * invisible for `concat`, which will just move on to the next Observable.\n *\n * If any Observable in chain errors, instead of passing control to the next Observable,\n * `concat` will error immediately as well. Observables that would be subscribed after\n * the one that emitted error, never will.\n *\n * If you pass to `concat` the same Observable many times, its stream of values\n * will be \"replayed\" on every subscription, which means you can repeat given Observable\n * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,\n * you can always use {@link repeat}.\n *\n * ## Examples\n *\n * Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10\n *\n * ```ts\n * import { interval, take, range, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(4));\n * const sequence = range(1, 10);\n * const result = concat(timer, sequence);\n * result.subscribe(x => console.log(x));\n *\n * // results in:\n * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10\n * ```\n *\n * Concatenate 3 Observables\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const result = concat(timer1, timer2, timer3);\n * result.subscribe(x => console.log(x));\n *\n * // results in the following:\n * // (Prints to console sequentially)\n * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9\n * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5\n * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9\n * ```\n *\n * Concatenate the same Observable to repeat it\n *\n * ```ts\n * import { interval, take, concat } from 'rxjs';\n *\n * const timer = interval(1000).pipe(take(2));\n *\n * concat(timer, timer) // concatenating the same Observable!\n *   .subscribe({\n *     next: value => console.log(value),\n *     complete: () => console.log('...and it is done!')\n *   });\n *\n * // Logs:\n * // 0 after 1s\n * // 1 after 2s\n * // 0 after 3s\n * // 1 after 4s\n * // '...and it is done!' also after 4s\n * ```\n *\n * @see {@link concatAll}\n * @see {@link concatMap}\n * @see {@link concatMapTo}\n * @see {@link startWith}\n * @see {@link endWith}\n *\n * @param args `ObservableInput`s to concatenate.\n */\nexport function concat(...args: any[]): Observable<unknown> {\n  return concatAll()(from(args, popScheduler(args)));\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { Observable } from '../Observable';\nimport { mergeMap } from '../operators/mergeMap';\nimport { isArrayLike } from '../util/isArrayLike';\nimport { isFunction } from '../util/isFunction';\nimport { mapOneOrManyArgs } from '../util/mapOneOrManyArgs';\n\n// These constants are used to create handler registry functions using array mapping below.\nconst nodeEventEmitterMethods = ['addListener', 'removeListener'] as const;\nconst eventTargetMethods = ['addEventListener', 'removeEventListener'] as const;\nconst jqueryMethods = ['on', 'off'] as const;\n\nexport interface NodeStyleEventEmitter {\n  addListener(eventName: string | symbol, handler: NodeEventHandler): this;\n  removeListener(eventName: string | symbol, handler: NodeEventHandler): this;\n}\n\nexport type NodeEventHandler = (...args: any[]) => void;\n\n// For APIs that implement `addListener` and `removeListener` methods that may\n// not use the same arguments or return EventEmitter values\n// such as React Native\nexport interface NodeCompatibleEventEmitter {\n  addListener(eventName: string, handler: NodeEventHandler): void | {};\n  removeListener(eventName: string, handler: NodeEventHandler): void | {};\n}\n\n// Use handler types like those in @types/jquery. See:\n// https://github.com/DefinitelyTyped/DefinitelyTyped/blob/847731ba1d7fa6db6b911c0e43aa0afe596e7723/types/jquery/misc.d.ts#L6395\nexport interface JQueryStyleEventEmitter<TContext, T> {\n  on(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n  off(eventName: string, handler: (this: TContext, t: T, ...args: any[]) => any): void;\n}\n\nexport interface EventListenerObject<E> {\n  handleEvent(evt: E): void;\n}\n\nexport interface HasEventTargetAddRemove<E> {\n  addEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: boolean | AddEventListenerOptions\n  ): void;\n  removeEventListener(\n    type: string,\n    listener: ((evt: E) => void) | EventListenerObject<E> | null,\n    options?: EventListenerOptions | boolean\n  ): void;\n}\n\nexport interface EventListenerOptions {\n  capture?: boolean;\n  passive?: boolean;\n  once?: boolean;\n}\n\nexport interface AddEventListenerOptions extends EventListenerOptions {\n  once?: boolean;\n  passive?: boolean;\n}\n\nexport function fromEvent<T>(target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>, eventName: string): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  resultSelector: (event: T) => R\n): Observable<R>;\nexport function fromEvent<T>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: HasEventTargetAddRemove<T> | ArrayLike<HasEventTargetAddRemove<T>>,\n  eventName: string,\n  options: EventListenerOptions,\n  resultSelector: (event: T) => R\n): Observable<R>;\n\nexport function fromEvent(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeStyleEventEmitter | ArrayLike<NodeStyleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string\n): Observable<unknown>;\n/** @deprecated Do not specify explicit type parameters. Signatures with type parameters that cannot be inferred will be removed in v8. */\nexport function fromEvent<T>(target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>, eventName: string): Observable<T>;\nexport function fromEvent<R>(\n  target: NodeCompatibleEventEmitter | ArrayLike<NodeCompatibleEventEmitter>,\n  eventName: string,\n  resultSelector: (...args: any[]) => R\n): Observable<R>;\n\nexport function fromEvent<T>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string\n): Observable<T>;\nexport function fromEvent<T, R>(\n  target: JQueryStyleEventEmitter<any, T> | ArrayLike<JQueryStyleEventEmitter<any, T>>,\n  eventName: string,\n  resultSelector: (value: T, ...args: any[]) => R\n): Observable<R>;\n\n/**\n * Creates an Observable that emits events of a specific type coming from the\n * given event target.\n *\n * <span class=\"informal\">Creates an Observable from DOM events, or Node.js\n * EventEmitter events or others.</span>\n *\n * ![](fromEvent.png)\n *\n * `fromEvent` accepts as a first argument event target, which is an object with methods\n * for registering event handler functions. As a second argument it takes string that indicates\n * type of event we want to listen for. `fromEvent` supports selected types of event targets,\n * which are described in detail below. If your event target does not match any of the ones listed,\n * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.\n * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event\n * handler functions have different names, but they all accept a string describing event type\n * and function itself, which will be called whenever said event happens.\n *\n * Every time resulting Observable is subscribed, event handler function will be registered\n * to event target on given event type. When that event fires, value\n * passed as a first argument to registered function will be emitted by output Observable.\n * When Observable is unsubscribed, function will be unregistered from event target.\n *\n * Note that if event target calls registered function with more than one argument, second\n * and following arguments will not appear in resulting stream. In order to get access to them,\n * you can pass to `fromEvent` optional project function, which will be called with all arguments\n * passed to event handler. Output Observable will then emit value returned by project function,\n * instead of the usual value.\n *\n * Remember that event targets listed below are checked via duck typing. It means that\n * no matter what kind of object you have and no matter what environment you work in,\n * you can safely use `fromEvent` on that object if it exposes described methods (provided\n * of course they behave as was described above). So for example if Node.js library exposes\n * event target which has the same method names as DOM EventTarget, `fromEvent` is still\n * a good choice.\n *\n * If the API you use is more callback then event handler oriented (subscribed\n * callback function fires only once and thus there is no need to manually\n * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}\n * instead.\n *\n * `fromEvent` supports following types of event targets:\n *\n * **DOM EventTarget**\n *\n * This is an object with `addEventListener` and `removeEventListener` methods.\n *\n * In the browser, `addEventListener` accepts - apart from event type string and event\n * handler function arguments - optional third parameter, which is either an object or boolean,\n * both used for additional configuration how and when passed function will be called. When\n * `fromEvent` is used with event target of that type, you can provide this values\n * as third parameter as well.\n *\n * **Node.js EventEmitter**\n *\n * An object with `addListener` and `removeListener` methods.\n *\n * **JQuery-style event target**\n *\n * An object with `on` and `off` methods\n *\n * **DOM NodeList**\n *\n * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.\n *\n * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes\n * it contains and install event handler function in every of them. When returned Observable\n * is unsubscribed, function will be removed from all Nodes.\n *\n * **DOM HtmlCollection**\n *\n * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is\n * installed and removed in each of elements.\n *\n *\n * ## Examples\n *\n * Emit clicks happening on the DOM document\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * clicks.subscribe(x => console.log(x));\n *\n * // Results in:\n * // MouseEvent object logged to console every time a click\n * // occurs on the document.\n * ```\n *\n * Use `addEventListener` with capture option\n *\n * ```ts\n * import { fromEvent } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * // note optional configuration parameter which will be passed to addEventListener\n * const clicksInDocument = fromEvent(document, 'click', { capture: true });\n * const clicksInDiv = fromEvent(div, 'click');\n *\n * clicksInDocument.subscribe(() => console.log('document'));\n * clicksInDiv.subscribe(() => console.log('div'));\n *\n * // By default events bubble UP in DOM tree, so normally\n * // when we would click on div in document\n * // \"div\" would be logged first and then \"document\".\n * // Since we specified optional `capture` option, document\n * // will catch event when it goes DOWN DOM tree, so console\n * // will log \"document\" and then \"div\".\n * ```\n *\n * @see {@link bindCallback}\n * @see {@link bindNodeCallback}\n * @see {@link fromEventPattern}\n *\n * @param target The DOM EventTarget, Node.js EventEmitter, JQuery-like event target,\n * NodeList or HTMLCollection to attach the event handler to.\n * @param eventName The event name of interest, being emitted by the `target`.\n * @param options Options to pass through to the underlying `addListener`,\n * `addEventListener` or `on` functions.\n * @param resultSelector A mapping function used to transform events. It takes the\n * arguments from the event handler and should return a single value.\n * @return An Observable emitting events registered through `target`'s\n * listener handlers.\n */\nexport function fromEvent<T>(\n  target: any,\n  eventName: string,\n  options?: EventListenerOptions | ((...args: any[]) => T),\n  resultSelector?: (...args: any[]) => T\n): Observable<T> {\n  if (isFunction(options)) {\n    resultSelector = options;\n    options = undefined;\n  }\n  if (resultSelector) {\n    return fromEvent<T>(target, eventName, options as EventListenerOptions).pipe(mapOneOrManyArgs(resultSelector));\n  }\n\n  // Figure out our add and remove methods. In order to do this,\n  // we are going to analyze the target in a preferred order, if\n  // the target matches a given signature, we take the two \"add\" and \"remove\"\n  // method names and apply them to a map to create opposite versions of the\n  // same function. This is because they all operate in duplicate pairs,\n  // `addListener(name, handler)`, `removeListener(name, handler)`, for example.\n  // The call only differs by method name, as to whether or not you're adding or removing.\n  const [add, remove] =\n    // If it is an EventTarget, we need to use a slightly different method than the other two patterns.\n    isEventTarget(target)\n      ? eventTargetMethods.map((methodName) => (handler: any) => target[methodName](eventName, handler, options as EventListenerOptions))\n      : // In all other cases, the call pattern is identical with the exception of the method names.\n      isNodeStyleEventEmitter(target)\n      ? nodeEventEmitterMethods.map(toCommonHandlerRegistry(target, eventName))\n      : isJQueryStyleEventEmitter(target)\n      ? jqueryMethods.map(toCommonHandlerRegistry(target, eventName))\n      : [];\n\n  // If add is falsy, it's because we didn't match a pattern above.\n  // Check to see if it is an ArrayLike, because if it is, we want to\n  // try to apply fromEvent to all of it's items. We do this check last,\n  // because there are may be some types that are both ArrayLike *and* implement\n  // event registry points, and we'd rather delegate to that when possible.\n  if (!add) {\n    if (isArrayLike(target)) {\n      return mergeMap((subTarget: any) => fromEvent(subTarget, eventName, options as EventListenerOptions))(\n        innerFrom(target)\n      ) as Observable<T>;\n    }\n  }\n\n  // If add is falsy and we made it here, it's because we didn't\n  // match any valid target objects above.\n  if (!add) {\n    throw new TypeError('Invalid event target');\n  }\n\n  return new Observable<T>((subscriber) => {\n    // The handler we are going to register. Forwards the event object, by itself, or\n    // an array of arguments to the event handler, if there is more than one argument,\n    // to the consumer.\n    const handler = (...args: any[]) => subscriber.next(1 < args.length ? args : args[0]);\n    // Do the work of adding the handler to the target.\n    add(handler);\n    // When we finalize, we want to remove the handler and free up memory.\n    return () => remove!(handler);\n  });\n}\n\n/**\n * Used to create `add` and `remove` functions to register and unregister event handlers\n * from a target in the most common handler pattern, where there are only two arguments.\n * (e.g.  `on(name, fn)`, `off(name, fn)`, `addListener(name, fn)`, or `removeListener(name, fn)`)\n * @param target The target we're calling methods on\n * @param eventName The event name for the event we're creating register or unregister functions for\n */\nfunction toCommonHandlerRegistry(target: any, eventName: string) {\n  return (methodName: string) => (handler: any) => target[methodName](eventName, handler);\n}\n\n/**\n * Checks to see if the target implements the required node-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isNodeStyleEventEmitter(target: any): target is NodeStyleEventEmitter {\n  return isFunction(target.addListener) && isFunction(target.removeListener);\n}\n\n/**\n * Checks to see if the target implements the required jQuery-style EventEmitter methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isJQueryStyleEventEmitter(target: any): target is JQueryStyleEventEmitter<any, any> {\n  return isFunction(target.on) && isFunction(target.off);\n}\n\n/**\n * Checks to see if the target implements the required EventTarget methods\n * for adding and removing event handlers.\n * @param target the object to check\n */\nfunction isEventTarget(target: any): target is HasEventTargetAddRemove<any> {\n  return isFunction(target.addEventListener) && isFunction(target.removeEventListener);\n}\n", "import { Observable } from '../Observable';\nimport { SchedulerLike } from '../types';\nimport { async as asyncScheduler } from '../scheduler/async';\nimport { isScheduler } from '../util/isScheduler';\nimport { isValidDate } from '../util/isDate';\n\n/**\n * Creates an observable that will wait for a specified time period, or exact date, before\n * emitting the number 0.\n *\n * <span class=\"informal\">Used to emit a notification after a delay.</span>\n *\n * This observable is useful for creating delays in code, or racing against other values\n * for ad-hoc timeouts.\n *\n * The `delay` is specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Examples\n *\n * Wait 3 seconds and start another observable\n *\n * You might want to use `timer` to delay subscription to an\n * observable by a set amount of time. Here we use a timer with\n * {@link concatMapTo} or {@link concatMap} in order to wait\n * a few seconds and start a subscription to a source.\n *\n * ```ts\n * import { of, timer, concatMap } from 'rxjs';\n *\n * // This could be any observable\n * const source = of(1, 2, 3);\n *\n * timer(3000)\n *   .pipe(concatMap(() => source))\n *   .subscribe(console.log);\n * ```\n *\n * Take all values until the start of the next minute\n *\n * Using a `Date` as the trigger for the first emission, you can\n * do things like wait until midnight to fire an event, or in this case,\n * wait until a new minute starts (chosen so the example wouldn't take\n * too long to run) in order to stop watching a stream. Leveraging\n * {@link takeUntil}.\n *\n * ```ts\n * import { interval, takeUntil, timer } from 'rxjs';\n *\n * // Build a Date object that marks the\n * // next minute.\n * const currentDate = new Date();\n * const startOfNextMinute = new Date(\n *   currentDate.getFullYear(),\n *   currentDate.getMonth(),\n *   currentDate.getDate(),\n *   currentDate.getHours(),\n *   currentDate.getMinutes() + 1\n * );\n *\n * // This could be any observable stream\n * const source = interval(1000);\n *\n * const result = source.pipe(\n *   takeUntil(timer(startOfNextMinute))\n * );\n *\n * result.subscribe(console.log);\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `dueTime`.\n *\n * @param due If a `number`, the amount of time in milliseconds to wait before emitting.\n * If a `Date`, the exact time at which to emit.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(due: number | Date, scheduler?: SchedulerLike): Observable<0>;\n\n/**\n * Creates an observable that starts an interval after a specified delay, emitting incrementing numbers -- starting at `0` --\n * on each interval after words.\n *\n * The `delay` and `intervalDuration` are specified by default in milliseconds, however providing a custom scheduler could\n * create a different behavior.\n *\n * ## Example\n *\n * ### Start an interval that starts right away\n *\n * Since {@link interval} waits for the passed delay before starting,\n * sometimes that's not ideal. You may want to start an interval immediately.\n * `timer` works well for this. Here we have both side-by-side so you can\n * see them in comparison.\n *\n * Note that this observable will never complete.\n *\n * ```ts\n * import { timer, interval } from 'rxjs';\n *\n * timer(0, 1000).subscribe(n => console.log('timer', n));\n * interval(1000).subscribe(n => console.log('interval', n));\n * ```\n *\n * ### Known Limitations\n *\n * - The {@link asyncScheduler} uses `setTimeout` which has limitations for how far in the future it can be scheduled.\n *\n * - If a `scheduler` is provided that returns a timestamp other than an epoch from `now()`, and\n * a `Date` object is passed to the `dueTime` argument, the calculation for when the first emission\n * should occur will be incorrect. In this case, it would be best to do your own calculations\n * ahead of time, and pass a `number` in as the `startDue`.\n * @param startDue If a `number`, is the time to wait before starting the interval.\n * If a `Date`, is the exact time at which to start the interval.\n * @param intervalDuration The delay between each value emitted in the interval. Passing a\n * negative number here will result in immediate completion after the first value is emitted, as though\n * no `intervalDuration` was passed at all.\n * @param scheduler The scheduler to use to schedule the delay. Defaults to {@link asyncScheduler}.\n */\nexport function timer(startDue: number | Date, intervalDuration: number, scheduler?: SchedulerLike): Observable<number>;\n\n/**\n * @deprecated The signature allowing `undefined` to be passed for `intervalDuration` will be removed in v8. Use the `timer(dueTime, scheduler?)` signature instead.\n */\nexport function timer(dueTime: number | Date, unused: undefined, scheduler?: SchedulerLike): Observable<0>;\n\nexport function timer(\n  dueTime: number | Date = 0,\n  intervalOrScheduler?: number | SchedulerLike,\n  scheduler: SchedulerLike = asyncScheduler\n): Observable<number> {\n  // Since negative intervalDuration is treated as though no\n  // interval was specified at all, we start with a negative number.\n  let intervalDuration = -1;\n\n  if (intervalOrScheduler != null) {\n    // If we have a second argument, and it's a scheduler,\n    // override the scheduler we had defaulted. Otherwise,\n    // it must be an interval.\n    if (isScheduler(intervalOrScheduler)) {\n      scheduler = intervalOrScheduler;\n    } else {\n      // Note that this *could* be negative, in which case\n      // it's like not passing an intervalDuration at all.\n      intervalDuration = intervalOrScheduler;\n    }\n  }\n\n  return new Observable((subscriber) => {\n    // If a valid date is passed, calculate how long to wait before\n    // executing the first value... otherwise, if it's a number just schedule\n    // that many milliseconds (or scheduler-specified unit size) in the future.\n    let due = isValidDate(dueTime) ? +dueTime - scheduler!.now() : dueTime;\n\n    if (due < 0) {\n      // Ensure we don't schedule in the future.\n      due = 0;\n    }\n\n    // The incrementing value we emit.\n    let n = 0;\n\n    // Start the timer.\n    return scheduler.schedule(function () {\n      if (!subscriber.closed) {\n        // Emit the next value and increment.\n        subscriber.next(n++);\n\n        if (0 <= intervalDuration) {\n          // If we have a interval after the initial timer,\n          // reschedule with the period.\n          this.schedule(undefined, intervalDuration);\n        } else {\n          // We didn't have an interval. So just complete.\n          subscriber.complete();\n        }\n      }\n    }, due);\n  });\n}\n", "import { Observable } from '../Observable';\nimport { ObservableInput, ObservableInputTuple, SchedulerLike } from '../types';\nimport { mergeAll } from '../operators/mergeAll';\nimport { innerFrom } from './innerFrom';\nimport { EMPTY } from './empty';\nimport { popNumber, popScheduler } from '../util/args';\nimport { from } from './from';\n\nexport function merge<A extends readonly unknown[]>(...sources: [...ObservableInputTuple<A>]): Observable<A[number]>;\nexport function merge<A extends readonly unknown[]>(...sourcesAndConcurrency: [...ObservableInputTuple<A>, number?]): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndScheduler: [...ObservableInputTuple<A>, SchedulerLike?]\n): Observable<A[number]>;\n/** @deprecated The `scheduler` parameter will be removed in v8. Use `scheduled` and `mergeAll`. Details: https://rxjs.dev/deprecations/scheduler-argument */\nexport function merge<A extends readonly unknown[]>(\n  ...sourcesAndConcurrencyAndScheduler: [...ObservableInputTuple<A>, number?, SchedulerLike?]\n): Observable<A[number]>;\n\n/**\n * Creates an output Observable which concurrently emits all values from every\n * given input Observable.\n *\n * <span class=\"informal\">Flattens multiple Observables together by blending\n * their values into one Observable.</span>\n *\n * ![](merge.png)\n *\n * `merge` subscribes to each given input Observable (as arguments), and simply\n * forwards (without doing any transformation) all the values from all the input\n * Observables to the output Observable. The output Observable only completes\n * once all input Observables have completed. Any error delivered by an input\n * Observable will be immediately emitted on the output Observable.\n *\n * ## Examples\n *\n * Merge together two Observables: 1s interval and clicks\n *\n * ```ts\n * import { merge, fromEvent, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const timer = interval(1000);\n * const clicksOrTimer = merge(clicks, timer);\n * clicksOrTimer.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // timer will emit ascending values, one every second(1000ms) to console\n * // clicks logs MouseEvents to console every time the \"document\" is clicked\n * // Since the two streams are merged you see these happening\n * // as they occur.\n * ```\n *\n * Merge together 3 Observables, but run only 2 concurrently\n *\n * ```ts\n * import { interval, take, merge } from 'rxjs';\n *\n * const timer1 = interval(1000).pipe(take(10));\n * const timer2 = interval(2000).pipe(take(6));\n * const timer3 = interval(500).pipe(take(10));\n *\n * const concurrent = 2; // the argument\n * const merged = merge(timer1, timer2, timer3, concurrent);\n * merged.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // - First timer1 and timer2 will run concurrently\n * // - timer1 will emit a value every 1000ms for 10 iterations\n * // - timer2 will emit a value every 2000ms for 6 iterations\n * // - after timer1 hits its max iteration, timer2 will\n * //   continue, and timer3 will start to run concurrently with timer2\n * // - when timer2 hits its max iteration it terminates, and\n * //   timer3 will continue to emit a value every 500ms until it is complete\n * ```\n *\n * @see {@link mergeAll}\n * @see {@link mergeMap}\n * @see {@link mergeMapTo}\n * @see {@link mergeScan}\n *\n * @param args `ObservableInput`s to merge together. If the last parameter\n * is of type number, `merge` will use it to limit number of concurrently\n * subscribed `ObservableInput`s. If the last parameter is {@link SchedulerLike},\n * it will be used for scheduling the emission of values.\n * @return An Observable that emits items that are the result of every input Observable.\n */\nexport function merge(...args: (ObservableInput<unknown> | number | SchedulerLike)[]): Observable<unknown> {\n  const scheduler = popScheduler(args);\n  const concurrent = popNumber(args, Infinity);\n  const sources = args as ObservableInput<unknown>[];\n  return !sources.length\n    ? // No source provided\n      EMPTY\n    : sources.length === 1\n    ? // One source? Just return it.\n      innerFrom(sources[0])\n    : // Merge all sources\n      mergeAll(concurrent)(from(sources, scheduler));\n}\n", "import { Observable } from '../Observable';\nimport { noop } from '../util/noop';\n\n/**\n * An Observable that emits no items to the Observer and never completes.\n *\n * ![](never.png)\n *\n * A simple Observable that emits neither values nor errors nor the completion\n * notification. It can be used for testing purposes or for composing with other\n * Observables. Please note that by never emitting a complete notification, this\n * Observable keeps the subscription from being disposed automatically.\n * Subscriptions need to be manually disposed.\n *\n * ##  Example\n *\n * Emit the number 7, then never emit anything else (not even complete)\n *\n * ```ts\n * import { NEVER, startWith } from 'rxjs';\n *\n * const info = () => console.log('Will not be called');\n *\n * const result = NEVER.pipe(startWith(7));\n * result.subscribe({\n *   next: x => console.log(x),\n *   error: info,\n *   complete: info\n * });\n * ```\n *\n * @see {@link Observable}\n * @see {@link EMPTY}\n * @see {@link of}\n * @see {@link throwError}\n */\nexport const NEVER = new Observable<never>(noop);\n\n/**\n * @deprecated Replaced with the {@link NEVER} constant. Will be removed in v8.\n */\nexport function never() {\n  return NEVER;\n}\n", "const { isArray } = Array;\n\n/**\n * Used in operators and functions that accept either a list of arguments, or an array of arguments\n * as a single argument.\n */\nexport function argsOrArgArray<T>(args: (T | T[])[]): T[] {\n  return args.length === 1 && isArray(args[0]) ? args[0] : (args as T[]);\n}\n", "import { OperatorFunction, MonoTypeOperatorFunction, TruthyTypesOf } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, S extends T, A>(predicate: (this: A, value: T, index: number) => value is S, thisArg: A): OperatorFunction<T, S>;\nexport function filter<T, S extends T>(predicate: (value: T, index: number) => value is S): OperatorFunction<T, S>;\nexport function filter<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\n/** @deprecated Use a closure instead of a `thisArg`. Signatures accepting a `thisArg` will be removed in v8. */\nexport function filter<T, A>(predicate: (this: A, value: T, index: number) => boolean, thisArg: A): MonoTypeOperatorFunction<T>;\nexport function filter<T>(predicate: (value: T, index: number) => boolean): MonoTypeOperatorFunction<T>;\n\n/**\n * Filter items emitted by the source Observable by only emitting those that\n * satisfy a specified predicate.\n *\n * <span class=\"informal\">Like\n * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),\n * it only emits a value from the source if it passes a criterion function.</span>\n *\n * ![](filter.png)\n *\n * Similar to the well-known `Array.prototype.filter` method, this operator\n * takes values from the source Observable, passes them through a `predicate`\n * function and only emits those values that yielded `true`.\n *\n * ## Example\n *\n * Emit only click events whose target was a DIV element\n *\n * ```ts\n * import { fromEvent, filter } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksOnDivs = clicks.pipe(filter(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * clicksOnDivs.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link distinct}\n * @see {@link distinctUntilChanged}\n * @see {@link distinctUntilKeyChanged}\n * @see {@link ignoreElements}\n * @see {@link partition}\n * @see {@link skip}\n *\n * @param predicate A function that\n * evaluates each value emitted by the source Observable. If it returns `true`,\n * the value is emitted, if `false` the value is not passed to the output\n * Observable. The `index` parameter is the number `i` for the i-th source\n * emission that has happened since the subscription, starting from the number\n * `0`.\n * @param thisArg An optional argument to determine the value of `this`\n * in the `predicate` function.\n * @return A function that returns an Observable that emits items from the\n * source Observable that satisfy the specified `predicate`.\n */\nexport function filter<T>(predicate: (value: T, index: number) => boolean, thisArg?: any): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // An index passed to our predicate function on each call.\n    let index = 0;\n\n    // Subscribe to the source, all errors and completions are\n    // forwarded to the consumer.\n    source.subscribe(\n      // Call the predicate with the appropriate `this` context,\n      // if the predicate returns `true`, then send the value\n      // to the consumer.\n      createOperatorSubscriber(subscriber, (value) => predicate.call(thisArg, value, index++) && subscriber.next(value))\n    );\n  });\n}\n", "import { Observable } from '../Observable';\nimport { innerFrom } from './innerFrom';\nimport { Subscription } from '../Subscription';\nimport { ObservableInput, ObservableInputTuple } from '../types';\nimport { argsOrArgArray } from '../util/argsOrArgArray';\nimport { createOperatorSubscriber } from '../operators/OperatorSubscriber';\nimport { Subscriber } from '../Subscriber';\n\nexport function race<T extends readonly unknown[]>(inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\nexport function race<T extends readonly unknown[]>(...inputs: [...ObservableInputTuple<T>]): Observable<T[number]>;\n\n/**\n * Returns an observable that mirrors the first source observable to emit an item.\n *\n * ![](race.png)\n *\n * `race` returns an observable, that when subscribed to, subscribes to all source observables immediately.\n * As soon as one of the source observables emits a value, the result unsubscribes from the other sources.\n * The resulting observable will forward all notifications, including error and completion, from the \"winning\"\n * source observable.\n *\n * If one of the used source observable throws an errors before a first notification\n * the race operator will also throw an error, no matter if another source observable\n * could potentially win the race.\n *\n * `race` can be useful for selecting the response from the fastest network connection for\n * HTTP or WebSockets. `race` can also be useful for switching observable context based on user\n * input.\n *\n * ## Example\n *\n * Subscribes to the observable that was the first to start emitting.\n *\n * ```ts\n * import { interval, map, race } from 'rxjs';\n *\n * const obs1 = interval(7000).pipe(map(() => 'slow one'));\n * const obs2 = interval(3000).pipe(map(() => 'fast one'));\n * const obs3 = interval(5000).pipe(map(() => 'medium one'));\n *\n * race(obs1, obs2, obs3)\n *   .subscribe(winner => console.log(winner));\n *\n * // Outputs\n * // a series of 'fast one'\n * ```\n *\n * @param sources Used to race for which `ObservableInput` emits first.\n * @return An Observable that mirrors the output of the first Observable to emit an item.\n */\nexport function race<T>(...sources: (ObservableInput<T> | ObservableInput<T>[])[]): Observable<any> {\n  sources = argsOrArgArray(sources);\n  // If only one source was passed, just return it. Otherwise return the race.\n  return sources.length === 1 ? innerFrom(sources[0] as ObservableInput<T>) : new Observable<T>(raceInit(sources as ObservableInput<T>[]));\n}\n\n/**\n * An observable initializer function for both the static version and the\n * operator version of race.\n * @param sources The sources to race\n */\nexport function raceInit<T>(sources: ObservableInput<T>[]) {\n  return (subscriber: Subscriber<T>) => {\n    let subscriptions: Subscription[] = [];\n\n    // Subscribe to all of the sources. Note that we are checking `subscriptions` here\n    // Is is an array of all actively \"racing\" subscriptions, and it is `null` after the\n    // race has been won. So, if we have racer that synchronously \"wins\", this loop will\n    // stop before it subscribes to any more.\n    for (let i = 0; subscriptions && !subscriber.closed && i < sources.length; i++) {\n      subscriptions.push(\n        innerFrom(sources[i] as ObservableInput<T>).subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            if (subscriptions) {\n              // We're still racing, but we won! So unsubscribe\n              // all other subscriptions that we have, except this one.\n              for (let s = 0; s < subscriptions.length; s++) {\n                s !== i && subscriptions[s].unsubscribe();\n              }\n              subscriptions = null!;\n            }\n            subscriber.next(value);\n          })\n        )\n      );\n    }\n  };\n}\n", "import { mergeMap } from './mergeMap';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { isFunction } from '../util/isFunction';\n\n/* tslint:disable:max-line-length */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, in a serialized fashion waiting for each one to complete before\n * merging the next.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link concatAll}.</span>\n *\n * ![](concatMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each new inner Observable is\n * concatenated with the previous inner Observable.\n *\n * __Warning:__ if source values arrive endlessly and faster than their\n * corresponding inner Observables can complete, it will result in memory issues\n * as inner Observables amass in an unbounded buffer waiting for their turn to\n * be subscribed to.\n *\n * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set\n * to `1`.\n *\n * ## Example\n *\n * For each click event, tick every second from 0 to 3, with no concurrency\n *\n * ```ts\n * import { fromEvent, concatMap, interval, take } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(\n *   concatMap(ev => interval(1000).pipe(take(4)))\n * );\n * result.subscribe(x => console.log(x));\n *\n * // Results in the following:\n * // (results are not concurrent)\n * // For every click on the \"document\" it will emit values 0 to 3 spaced\n * // on a 1000ms interval\n * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3\n * ```\n *\n * @see {@link concat}\n * @see {@link concatAll}\n * @see {@link concatMapTo}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchMap}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * values from each projected inner Observable sequentially.\n */\nexport function concatMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return isFunction(resultSelector) ? mergeMap(project, resultSelector, 1) : mergeMap(project, 1);\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits a given value if the source Observable completes without emitting any\n * `next` value, otherwise mirrors the source Observable.\n *\n * <span class=\"informal\">If the source Observable turns out to be empty, then\n * this operator will emit a default value.</span>\n *\n * ![](defaultIfEmpty.png)\n *\n * `defaultIfEmpty` emits the values emitted by the source Observable or a\n * specified default value if the source Observable is empty (completes without\n * having emitted any `next` value).\n *\n * ## Example\n *\n * If no clicks happen in 5 seconds, then emit 'no clicks'\n *\n * ```ts\n * import { fromEvent, takeUntil, interval, defaultIfEmpty } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const clicksBeforeFive = clicks.pipe(takeUntil(interval(5000)));\n * const result = clicksBeforeFive.pipe(defaultIfEmpty('no clicks'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link empty}\n * @see {@link last}\n *\n * @param defaultValue The default value used if the source\n * Observable is empty.\n * @return A function that returns an Observable that emits either the\n * specified `defaultValue` if the source Observable emits no items, or the\n * values emitted by the source Observable.\n */\nexport function defaultIfEmpty<T, R>(defaultValue: R): OperatorFunction<T, T | R> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => {\n          if (!hasValue) {\n            subscriber.next(defaultValue!);\n          }\n          subscriber.complete();\n        }\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { EMPTY } from '../observable/empty';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * Emits only the first `count` values emitted by the source Observable.\n *\n * <span class=\"informal\">Takes the first `count` values from the source, then\n * completes.</span>\n *\n * ![](take.png)\n *\n * `take` returns an Observable that emits only the first `count` values emitted\n * by the source Observable. If the source emits fewer than `count` values then\n * all of its values are emitted. After that, it completes, regardless if the\n * source completes.\n *\n * ## Example\n *\n * Take the first 5 seconds of an infinite 1-second interval Observable\n *\n * ```ts\n * import { interval, take } from 'rxjs';\n *\n * const intervalCount = interval(1000);\n * const takeFive = intervalCount.pipe(take(5));\n * takeFive.subscribe(x => console.log(x));\n *\n * // Logs:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * ```\n *\n * @see {@link takeLast}\n * @see {@link takeUntil}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param count The maximum number of `next` values to emit.\n * @return A function that returns an Observable that emits only the first\n * `count` values emitted by the source Observable, or all of the values from\n * the source if the source emits fewer than `count` values.\n */\nexport function take<T>(count: number): MonoTypeOperatorFunction<T> {\n  return count <= 0\n    ? // If we are taking no values, that's empty.\n      () => EMPTY\n    : operate((source, subscriber) => {\n        let seen = 0;\n        source.subscribe(\n          createOperatorSubscriber(subscriber, (value) => {\n            // Increment the number of values we have seen,\n            // then check it against the allowed count to see\n            // if we are still letting values through.\n            if (++seen <= count) {\n              subscriber.next(value);\n              // If we have met or passed our allowed count,\n              // we need to complete. We have to do <= here,\n              // because re-entrant code will increment `seen` twice.\n              if (count <= seen) {\n                subscriber.complete();\n              }\n            }\n          })\n        );\n      });\n}\n", "import { OperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { noop } from '../util/noop';\n\n/**\n * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.\n *\n * ![](ignoreElements.png)\n *\n * The `ignoreElements` operator suppresses all items emitted by the source Observable,\n * but allows its termination notification (either `error` or `complete`) to pass through unchanged.\n *\n * If you do not care about the items being emitted by an Observable, but you do want to be notified\n * when it completes or when it terminates with an error, you can apply the `ignoreElements` operator\n * to the Observable, which will ensure that it will never call its observers `next` handlers.\n *\n * ## Example\n *\n * Ignore all `next` emissions from the source\n *\n * ```ts\n * import { of, ignoreElements } from 'rxjs';\n *\n * of('you', 'talking', 'to', 'me')\n *   .pipe(ignoreElements())\n *   .subscribe({\n *     next: word => console.log(word),\n *     error: err => console.log('error:', err),\n *     complete: () => console.log('the end'),\n *   });\n *\n * // result:\n * // 'the end'\n * ```\n *\n * @return A function that returns an empty Observable that only calls\n * `complete` or `error`, based on which one is called by the source\n * Observable.\n */\nexport function ignoreElements(): OperatorFunction<unknown, never> {\n  return operate((source, subscriber) => {\n    source.subscribe(createOperatorSubscriber(subscriber, noop));\n  });\n}\n", "import { OperatorFunction } from '../types';\nimport { map } from './map';\n\n/** @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`. */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R>;\n/**\n * @deprecated Do not specify explicit type parameters. Signatures with type parameters\n * that cannot be inferred will be removed in v8. `mapTo` itself will be removed in v9,\n * use {@link map} instead: `map(() => value)`.\n * */\nexport function mapTo<T, R>(value: R): OperatorFunction<T, R>;\n\n/**\n * Emits the given constant value on the output Observable every time the source\n * Observable emits a value.\n *\n * <span class=\"informal\">Like {@link map}, but it maps every source value to\n * the same output value every time.</span>\n *\n * ![](mapTo.png)\n *\n * Takes a constant `value` as argument, and emits that whenever the source\n * Observable emits a value. In other words, ignores the actual source value,\n * and simply uses the emission moment to know when to emit the given `value`.\n *\n * ## Example\n *\n * Map every click to the string `'Hi'`\n *\n * ```ts\n * import { fromEvent, mapTo } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const greetings = clicks.pipe(mapTo('Hi'));\n *\n * greetings.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link map}\n *\n * @param value The value to map each source value to.\n * @return A function that returns an Observable that emits the given `value`\n * every time the source Observable emits.\n * @deprecated To be removed in v9. Use {@link map} instead: `map(() => value)`.\n */\nexport function mapTo<R>(value: R): OperatorFunction<unknown, R> {\n  return map(() => value);\n}\n", "import { Observable } from '../Observable';\nimport { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { concat } from '../observable/concat';\nimport { take } from './take';\nimport { ignoreElements } from './ignoreElements';\nimport { mapTo } from './mapTo';\nimport { mergeMap } from './mergeMap';\nimport { innerFrom } from '../observable/innerFrom';\n\n/** @deprecated The `subscriptionDelay` parameter will be removed in v8. */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay: Observable<any>\n): MonoTypeOperatorFunction<T>;\nexport function delayWhen<T>(delayDurationSelector: (value: T, index: number) => ObservableInput<any>): MonoTypeOperatorFunction<T>;\n\n/**\n * Delays the emission of items from the source Observable by a given time span\n * determined by the emissions of another Observable.\n *\n * <span class=\"informal\">It's like {@link delay}, but the time span of the\n * delay duration is determined by a second Observable.</span>\n *\n * ![](delayWhen.png)\n *\n * `delayWhen` operator shifts each emitted value from the source Observable by\n * a time span determined by another Observable. When the source emits a value,\n * the `delayDurationSelector` function is called with the value emitted from\n * the source Observable as the first argument to the `delayDurationSelector`.\n * The `delayDurationSelector` function should return an {@link ObservableInput},\n * that is internally converted to an Observable that is called the \"duration\"\n * Observable.\n *\n * The source value is emitted on the output Observable only when the \"duration\"\n * Observable emits ({@link guide/glossary-and-semantics#next next}s) any value.\n * Upon that, the \"duration\" Observable gets unsubscribed.\n *\n * Before RxJS V7, the {@link guide/glossary-and-semantics#complete completion}\n * of the \"duration\" Observable would have been triggering the emission of the\n * source value to the output Observable, but with RxJS V7, this is not the case\n * anymore.\n *\n * Only next notifications (from the \"duration\" Observable) trigger values from\n * the source Observable to be passed to the output Observable. If the \"duration\"\n * Observable only emits the complete notification (without next), the value\n * emitted by the source Observable will never get to the output Observable - it\n * will be swallowed. If the \"duration\" Observable errors, the error will be\n * propagated to the output Observable.\n *\n * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which\n * is an Observable. When `subscriptionDelay` emits its first value or\n * completes, the source Observable is subscribed to and starts behaving like\n * described in the previous paragraph. If `subscriptionDelay` is not provided,\n * `delayWhen` will subscribe to the source Observable as soon as the output\n * Observable is subscribed.\n *\n * ## Example\n *\n * Delay each click by a random amount of time, between 0 and 5 seconds\n *\n * ```ts\n * import { fromEvent, delayWhen, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(\n *   delayWhen(() => interval(Math.random() * 5000))\n * );\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delay}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param delayDurationSelector A function that returns an `ObservableInput` for\n * each `value` emitted by the source Observable, which is then used to delay the\n * emission of that `value` on the output Observable until the `ObservableInput`\n * returned from this function emits a next value. When called, beside `value`,\n * this function receives a zero-based `index` of the emission order.\n * @param subscriptionDelay An Observable that triggers the subscription to the\n * source Observable once it emits any value.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by an amount of time specified by the Observable\n * returned by `delayDurationSelector`.\n */\nexport function delayWhen<T>(\n  delayDurationSelector: (value: T, index: number) => ObservableInput<any>,\n  subscriptionDelay?: Observable<any>\n): MonoTypeOperatorFunction<T> {\n  if (subscriptionDelay) {\n    // DEPRECATED PATH\n    return (source: Observable<T>) =>\n      concat(subscriptionDelay.pipe(take(1), ignoreElements()), source.pipe(delayWhen(delayDurationSelector)));\n  }\n\n  return mergeMap((value, index) => innerFrom(delayDurationSelector(value, index)).pipe(take(1), mapTo(value)));\n}\n", "import { asyncScheduler } from '../scheduler/async';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { delayWhen } from './delayWhen';\nimport { timer } from '../observable/timer';\n\n/**\n * Delays the emission of items from the source Observable by a given timeout or\n * until a given Date.\n *\n * <span class=\"informal\">Time shifts each item by some specified amount of\n * milliseconds.</span>\n *\n * ![](delay.svg)\n *\n * If the delay argument is a Number, this operator time shifts the source\n * Observable by that amount of time expressed in milliseconds. The relative\n * time intervals between the values are preserved.\n *\n * If the delay argument is a Date, this operator time shifts the start of the\n * Observable execution until the given date occurs.\n *\n * ## Examples\n *\n * Delay each click by one second\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const delayedClicks = clicks.pipe(delay(1000)); // each click emitted after 1 second\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * Delay all clicks until a future date happens\n *\n * ```ts\n * import { fromEvent, delay } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const date = new Date('March 15, 2050 12:00:00'); // in the future\n * const delayedClicks = clicks.pipe(delay(date)); // click emitted only after that date\n * delayedClicks.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link delayWhen}\n * @see {@link throttle}\n * @see {@link throttleTime}\n * @see {@link debounce}\n * @see {@link debounceTime}\n * @see {@link sample}\n * @see {@link sampleTime}\n * @see {@link audit}\n * @see {@link auditTime}\n *\n * @param due The delay duration in milliseconds (a `number`) or a `Date` until\n * which the emission of the source items is delayed.\n * @param scheduler The {@link SchedulerLike} to use for managing the timers\n * that handle the time-shift for each item.\n * @return A function that returns an Observable that delays the emissions of\n * the source Observable by the specified timeout or Date.\n */\nexport function delay<T>(due: number | Date, scheduler: SchedulerLike = asyncScheduler): MonoTypeOperatorFunction<T> {\n  const duration = timer(due, scheduler);\n  return delayWhen(() => duration);\n}\n", "import { EmptyError } from '../util/EmptyError';\nimport { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/**\n * If the source observable completes without emitting a value, it will emit\n * an error. The error will be created at that time by the optional\n * `errorFactory` argument, otherwise, the error will be {@link EmptyError}.\n *\n * ![](throwIfEmpty.png)\n *\n * ## Example\n *\n * Throw an error if the document wasn't clicked within 1 second\n *\n * ```ts\n * import { fromEvent, takeUntil, timer, throwIfEmpty } from 'rxjs';\n *\n * const click$ = fromEvent(document, 'click');\n *\n * click$.pipe(\n *   takeUntil(timer(1000)),\n *   throwIfEmpty(() => new Error('The document was not clicked within 1 second'))\n * )\n * .subscribe({\n *   next() {\n *    console.log('The document was clicked');\n *   },\n *   error(err) {\n *     console.error(err.message);\n *   }\n * });\n * ```\n *\n * @param errorFactory A factory function called to produce the\n * error to be thrown when the source observable completes without emitting a\n * value.\n * @return A function that returns an Observable that throws an error if the\n * source Observable completed without emitting.\n */\nexport function throwIfEmpty<T>(errorFactory: () => any = defaultErrorFactory): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    let hasValue = false;\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          hasValue = true;\n          subscriber.next(value);\n        },\n        () => (hasValue ? subscriber.complete() : subscriber.error(errorFactory()))\n      )\n    );\n  });\n}\n\nfunction defaultErrorFactory() {\n  return new EmptyError();\n}\n", "import { MonoTypeOperatorFunction } from '../types';\nimport { operate } from '../util/lift';\n\n/**\n * Returns an Observable that mirrors the source Observable, but will call a specified function when\n * the source terminates on complete or error.\n * The specified function will also be called when the subscriber explicitly unsubscribes.\n *\n * ## Examples\n *\n * Execute callback function when the observable completes\n *\n * ```ts\n * import { interval, take, finalize } from 'rxjs';\n *\n * // emit value in sequence every 1 second\n * const source = interval(1000);\n * const example = source.pipe(\n *   take(5), //take only the first 5 values\n *   finalize(() => console.log('Sequence complete')) // Execute when the observable completes\n * );\n * const subscribe = example.subscribe(val => console.log(val));\n *\n * // results:\n * // 0\n * // 1\n * // 2\n * // 3\n * // 4\n * // 'Sequence complete'\n * ```\n *\n * Execute callback function when the subscriber explicitly unsubscribes\n *\n * ```ts\n * import { interval, finalize, tap, noop, timer } from 'rxjs';\n *\n * const source = interval(100).pipe(\n *   finalize(() => console.log('[finalize] Called')),\n *   tap({\n *     next: () => console.log('[next] Called'),\n *     error: () => console.log('[error] Not called'),\n *     complete: () => console.log('[tap complete] Not called')\n *   })\n * );\n *\n * const sub = source.subscribe({\n *   next: x => console.log(x),\n *   error: noop,\n *   complete: () => console.log('[complete] Not called')\n * });\n *\n * timer(150).subscribe(() => sub.unsubscribe());\n *\n * // results:\n * // '[next] Called'\n * // 0\n * // '[finalize] Called'\n * ```\n *\n * @param callback Function to be called when source terminates.\n * @return A function that returns an Observable that mirrors the source, but\n * will call the specified function on termination.\n */\nexport function finalize<T>(callback: () => void): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    // TODO: This try/finally was only added for `useDeprecatedSynchronousErrorHandling`.\n    // REMOVE THIS WHEN THAT HOT GARBAGE IS REMOVED IN V8.\n    try {\n      source.subscribe(subscriber);\n    } finally {\n      subscriber.add(callback);\n    }\n  });\n}\n", "import { Observable } from '../Observable';\nimport { EmptyError } from '../util/EmptyError';\nimport { OperatorFunction, TruthyTypesOf } from '../types';\nimport { filter } from './filter';\nimport { take } from './take';\nimport { defaultIfEmpty } from './defaultIfEmpty';\nimport { throwIfEmpty } from './throwIfEmpty';\nimport { identity } from '../util/identity';\n\nexport function first<T, D = T>(predicate?: null, defaultValue?: D): OperatorFunction<T, T | D>;\nexport function first<T>(predicate: BooleanConstructor): OperatorFunction<T, TruthyTypesOf<T>>;\nexport function first<T, D>(predicate: BooleanConstructor, defaultValue: D): OperatorFunction<T, TruthyTypesOf<T> | D>;\nexport function first<T, S extends T>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue?: S\n): OperatorFunction<T, S>;\nexport function first<T, S extends T, D>(\n  predicate: (value: T, index: number, source: Observable<T>) => value is S,\n  defaultValue: D\n): OperatorFunction<T, S | D>;\nexport function first<T, D = T>(\n  predicate: (value: T, index: number, source: Observable<T>) => boolean,\n  defaultValue?: D\n): OperatorFunction<T, T | D>;\n\n/**\n * Emits only the first value (or the first value that meets some condition)\n * emitted by the source Observable.\n *\n * <span class=\"informal\">Emits only the first value. Or emits only the first\n * value that passes some test.</span>\n *\n * ![](first.png)\n *\n * If called with no arguments, `first` emits the first value of the source\n * Observable, then completes. If called with a `predicate` function, `first`\n * emits the first value of the source that matches the specified condition. Emits an error\n * notification if `defaultValue` was not provided and a matching element is not found.\n *\n * ## Examples\n *\n * Emit only the first click that happens on the DOM\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first());\n * result.subscribe(x => console.log(x));\n * ```\n *\n * Emits the first click that happens on a DIV\n *\n * ```ts\n * import { fromEvent, first } from 'rxjs';\n *\n * const div = document.createElement('div');\n * div.style.cssText = 'width: 200px; height: 200px; background: #09c;';\n * document.body.appendChild(div);\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(first(ev => (<HTMLElement>ev.target).tagName === 'DIV'));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link filter}\n * @see {@link find}\n * @see {@link take}\n * @see {@link last}\n *\n * @throws {EmptyError} Delivers an `EmptyError` to the Observer's `error`\n * callback if the Observable completes before any `next` notification was sent.\n * This is how `first()` is different from `take(1)` which completes instead.\n *\n * @param predicate An optional function called with each item to test for condition\n * matching.\n * @param defaultValue The default value emitted in case no valid value was found on\n * the source.\n * @return A function that returns an Observable that emits the first item that\n * matches the condition.\n */\nexport function first<T, D>(\n  predicate?: ((value: T, index: number, source: Observable<T>) => boolean) | null,\n  defaultValue?: D\n): OperatorFunction<T, T | D> {\n  const hasDefaultValue = arguments.length >= 2;\n  return (source: Observable<T>) =>\n    source.pipe(\n      predicate ? filter((v, i) => predicate(v, i, source)) : identity,\n      take(1),\n      hasDefaultValue ? defaultIfEmpty(defaultValue!) : throwIfEmpty(() => new EmptyError())\n    );\n}\n", "import { innerFrom } from '../observable/innerFrom';\nimport { Subject } from '../Subject';\nimport { SafeSubscriber } from '../Subscriber';\nimport { Subscription } from '../Subscription';\nimport { MonoTypeOperatorFunction, SubjectLike, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\n\nexport interface ShareConfig<T> {\n  /**\n   * The factory used to create the subject that will connect the source observable to\n   * multicast consumers.\n   */\n  connector?: () => SubjectLike<T>;\n  /**\n   * If `true`, the resulting observable will reset internal state on error from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"retried\" in the event of an error.\n   * If `false`, when an error comes from the source it will push the error into the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent retries\n   * or resubscriptions will resubscribe to that same subject. In all cases, RxJS subjects will emit the same error again, however\n   * {@link ReplaySubject} will also push its buffered values before pushing the error.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnError?: boolean | ((error: any) => ObservableInput<any>);\n  /**\n   * If `true`, the resulting observable will reset internal state on completion from source and return to a \"cold\" state. This\n   * allows the resulting observable to be \"repeated\" after it is done.\n   * If `false`, when the source completes, it will push the completion through the connecting subject, and the subject\n   * will remain the connecting subject, meaning the resulting observable will not go \"cold\" again, and subsequent repeats\n   * or resubscriptions will resubscribe to that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnComplete?: boolean | (() => ObservableInput<any>);\n  /**\n   * If `true`, when the number of subscribers to the resulting observable reaches zero due to those subscribers unsubscribing, the\n   * internal state will be reset and the resulting observable will return to a \"cold\" state. This means that the next\n   * time the resulting observable is subscribed to, a new subject will be created and the source will be subscribed to\n   * again.\n   * If `false`, when the number of subscribers to the resulting observable reaches zero due to unsubscription, the subject\n   * will remain connected to the source, and new subscriptions to the result will be connected through that same subject.\n   * It is also possible to pass a notifier factory returning an `ObservableInput` instead which grants more fine-grained\n   * control over how and when the reset should happen. This allows behaviors like conditional or delayed resets.\n   */\n  resetOnRefCountZero?: boolean | (() => ObservableInput<any>);\n}\n\nexport function share<T>(): MonoTypeOperatorFunction<T>;\n\nexport function share<T>(options: ShareConfig<T>): MonoTypeOperatorFunction<T>;\n\n/**\n * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one\n * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will\n * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.\n * This is an alias for `multicast(() => new Subject()), refCount()`.\n *\n * The subscription to the underlying source Observable can be reset (unsubscribe and resubscribe for new subscribers),\n * if the subscriber count to the shared observable drops to 0, or if the source Observable errors or completes. It is\n * possible to use notifier factories for the resets to allow for behaviors like conditional or delayed resets. Please\n * note that resetting on error or complete of the source Observable does not behave like a transparent retry or restart\n * of the source because the error or complete will be forwarded to all subscribers and their subscription will be\n * closed. Only new subscribers after a reset on error or complete happened will cause a fresh subscription to the\n * source. To achieve transparent retries or restarts pipe the source through appropriate operators before sharing.\n *\n * ![](share.png)\n *\n * ## Example\n *\n * Generate new multicast Observable from the `source` Observable value\n *\n * ```ts\n * import { interval, tap, map, take, share } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   tap(x => console.log('Processing: ', x)),\n *   map(x => x * x),\n *   take(6),\n *   share()\n * );\n *\n * source.subscribe(x => console.log('subscription 1: ', x));\n * source.subscribe(x => console.log('subscription 2: ', x));\n *\n * // Logs:\n * // Processing: 0\n * // subscription 1: 0\n * // subscription 2: 0\n * // Processing: 1\n * // subscription 1: 1\n * // subscription 2: 1\n * // Processing: 2\n * // subscription 1: 4\n * // subscription 2: 4\n * // Processing: 3\n * // subscription 1: 9\n * // subscription 2: 9\n * // Processing: 4\n * // subscription 1: 16\n * // subscription 2: 16\n * // Processing: 5\n * // subscription 1: 25\n * // subscription 2: 25\n * ```\n *\n * ## Example with notifier factory: Delayed reset\n *\n * ```ts\n * import { interval, take, share, timer } from 'rxjs';\n *\n * const source = interval(1000).pipe(\n *   take(3),\n *   share({\n *     resetOnRefCountZero: () => timer(1000)\n *   })\n * );\n *\n * const subscriptionOne = source.subscribe(x => console.log('subscription 1: ', x));\n * setTimeout(() => subscriptionOne.unsubscribe(), 1300);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 2: ', x)), 1700);\n *\n * setTimeout(() => source.subscribe(x => console.log('subscription 3: ', x)), 5000);\n *\n * // Logs:\n * // subscription 1:  0\n * // (subscription 1 unsubscribes here)\n * // (subscription 2 subscribes here ~400ms later, source was not reset)\n * // subscription 2:  1\n * // subscription 2:  2\n * // (subscription 2 unsubscribes here)\n * // (subscription 3 subscribes here ~2000ms later, source did reset before)\n * // subscription 3:  0\n * // subscription 3:  1\n * // subscription 3:  2\n * ```\n *\n * @see {@link shareReplay}\n *\n * @return A function that returns an Observable that mirrors the source.\n */\nexport function share<T>(options: ShareConfig<T> = {}): MonoTypeOperatorFunction<T> {\n  const { connector = () => new Subject<T>(), resetOnError = true, resetOnComplete = true, resetOnRefCountZero = true } = options;\n  // It's necessary to use a wrapper here, as the _operator_ must be\n  // referentially transparent. Otherwise, it cannot be used in calls to the\n  // static `pipe` function - to create a partial pipeline.\n  //\n  // The _operator function_ - the function returned by the _operator_ - will\n  // not be referentially transparent - as it shares its source - but the\n  // _operator function_ is called when the complete pipeline is composed via a\n  // call to a source observable's `pipe` method - not when the static `pipe`\n  // function is called.\n  return (wrapperSource) => {\n    let connection: SafeSubscriber<T> | undefined;\n    let resetConnection: Subscription | undefined;\n    let subject: SubjectLike<T> | undefined;\n    let refCount = 0;\n    let hasCompleted = false;\n    let hasErrored = false;\n\n    const cancelReset = () => {\n      resetConnection?.unsubscribe();\n      resetConnection = undefined;\n    };\n    // Used to reset the internal state to a \"cold\"\n    // state, as though it had never been subscribed to.\n    const reset = () => {\n      cancelReset();\n      connection = subject = undefined;\n      hasCompleted = hasErrored = false;\n    };\n    const resetAndUnsubscribe = () => {\n      // We need to capture the connection before\n      // we reset (if we need to reset).\n      const conn = connection;\n      reset();\n      conn?.unsubscribe();\n    };\n\n    return operate<T, T>((source, subscriber) => {\n      refCount++;\n      if (!hasErrored && !hasCompleted) {\n        cancelReset();\n      }\n\n      // Create the subject if we don't have one yet. Grab a local reference to\n      // it as well, which avoids non-null assertions when using it and, if we\n      // connect to it now, then error/complete need a reference after it was\n      // reset.\n      const dest = (subject = subject ?? connector());\n\n      // Add the finalization directly to the subscriber - instead of returning it -\n      // so that the handling of the subscriber's unsubscription will be wired\n      // up _before_ the subscription to the source occurs. This is done so that\n      // the assignment to the source connection's `closed` property will be seen\n      // by synchronous firehose sources.\n      subscriber.add(() => {\n        refCount--;\n\n        // If we're resetting on refCount === 0, and it's 0, we only want to do\n        // that on \"unsubscribe\", really. Resetting on error or completion is a different\n        // configuration.\n        if (refCount === 0 && !hasErrored && !hasCompleted) {\n          resetConnection = handleReset(resetAndUnsubscribe, resetOnRefCountZero);\n        }\n      });\n\n      // The following line adds the subscription to the subscriber passed.\n      // Basically, `subscriber === dest.subscribe(subscriber)` is `true`.\n      dest.subscribe(subscriber);\n\n      if (\n        !connection &&\n        // Check this shareReplay is still activate - it can be reset to 0\n        // and be \"unsubscribed\" _before_ it actually subscribes.\n        // If we were to subscribe then, it'd leak and get stuck.\n        refCount > 0\n      ) {\n        // We need to create a subscriber here - rather than pass an observer and\n        // assign the returned subscription to connection - because it's possible\n        // for reentrant subscriptions to the shared observable to occur and in\n        // those situations we want connection to be already-assigned so that we\n        // don't create another connection to the source.\n        connection = new SafeSubscriber({\n          next: (value) => dest.next(value),\n          error: (err) => {\n            hasErrored = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnError, err);\n            dest.error(err);\n          },\n          complete: () => {\n            hasCompleted = true;\n            cancelReset();\n            resetConnection = handleReset(reset, resetOnComplete);\n            dest.complete();\n          },\n        });\n        innerFrom(source).subscribe(connection);\n      }\n    })(wrapperSource);\n  };\n}\n\nfunction handleReset<T extends unknown[] = never[]>(\n  reset: () => void,\n  on: boolean | ((...args: T) => ObservableInput<any>),\n  ...args: T\n): Subscription | undefined {\n  if (on === true) {\n    reset();\n    return;\n  }\n\n  if (on === false) {\n    return;\n  }\n\n  const onSubscriber = new SafeSubscriber({\n    next: () => {\n      onSubscriber.unsubscribe();\n      reset();\n    },\n  });\n\n  return innerFrom(on(...args)).subscribe(onSubscriber);\n}\n", "import { ReplaySubject } from '../ReplaySubject';\nimport { MonoTypeOperatorFunction, SchedulerLike } from '../types';\nimport { share } from './share';\n\nexport interface ShareReplayConfig {\n  bufferSize?: number;\n  windowTime?: number;\n  refCount: boolean;\n  scheduler?: SchedulerLike;\n}\n\nexport function shareReplay<T>(config: ShareReplayConfig): MonoTypeOperatorFunction<T>;\nexport function shareReplay<T>(bufferSize?: number, windowTime?: number, scheduler?: SchedulerLike): MonoTypeOperatorFunction<T>;\n\n/**\n * Share source and replay specified number of emissions on subscription.\n *\n * This operator is a specialization of `replay` that connects to a source observable\n * and multicasts through a `ReplaySubject` constructed with the specified arguments.\n * A successfully completed source will stay cached in the `shareReplay`ed observable forever,\n * but an errored source can be retried.\n *\n * ## Why use `shareReplay`?\n *\n * You generally want to use `shareReplay` when you have side-effects or taxing computations\n * that you do not wish to be executed amongst multiple subscribers.\n * It may also be valuable in situations where you know you will have late subscribers to\n * a stream that need access to previously emitted values.\n * This ability to replay values on subscription is what differentiates {@link share} and `shareReplay`.\n *\n * ## Reference counting\n *\n * By default `shareReplay` will use `refCount` of false, meaning that it will _not_ unsubscribe the\n * source when the reference counter drops to zero, i.e. the inner `ReplaySubject` will _not_ be unsubscribed\n * (and potentially run for ever).\n * This is the default as it is expected that `shareReplay` is often used to keep around expensive to setup\n * observables which we want to keep running instead of having to do the expensive setup again.\n *\n * As of RXJS version 6.4.0 a new overload signature was added to allow for manual control over what\n * happens when the operators internal reference counter drops to zero.\n * If `refCount` is true, the source will be unsubscribed from once the reference count drops to zero, i.e.\n * the inner `ReplaySubject` will be unsubscribed. All new subscribers will receive value emissions from a\n * new `ReplaySubject` which in turn will cause a new subscription to the source observable.\n *\n * ## Examples\n *\n * Example with a third subscriber coming late to the party\n *\n * ```ts\n * import { interval, take, shareReplay } from 'rxjs';\n *\n * const shared$ = interval(2000).pipe(\n *   take(6),\n *   shareReplay(3)\n * );\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * setTimeout(() => {\n *   shared$.subscribe(y => console.log('sub C: ', y));\n * }, 11000);\n *\n * // Logs:\n * // (after ~2000 ms)\n * // sub A: 0\n * // sub B: 0\n * // (after ~4000 ms)\n * // sub A: 1\n * // sub B: 1\n * // (after ~6000 ms)\n * // sub A: 2\n * // sub B: 2\n * // (after ~8000 ms)\n * // sub A: 3\n * // sub B: 3\n * // (after ~10000 ms)\n * // sub A: 4\n * // sub B: 4\n * // (after ~11000 ms, sub C gets the last 3 values)\n * // sub C: 2\n * // sub C: 3\n * // sub C: 4\n * // (after ~12000 ms)\n * // sub A: 5\n * // sub B: 5\n * // sub C: 5\n * ```\n *\n * Example for `refCount` usage\n *\n * ```ts\n * import { Observable, tap, interval, shareReplay, take } from 'rxjs';\n *\n * const log = <T>(name: string, source: Observable<T>) => source.pipe(\n *   tap({\n *     subscribe: () => console.log(`${ name }: subscribed`),\n *     next: value => console.log(`${ name }: ${ value }`),\n *     complete: () => console.log(`${ name }: completed`),\n *     finalize: () => console.log(`${ name }: unsubscribed`)\n *   })\n * );\n *\n * const obs$ = log('source', interval(1000));\n *\n * const shared$ = log('shared', obs$.pipe(\n *   shareReplay({ bufferSize: 1, refCount: true }),\n *   take(2)\n * ));\n *\n * shared$.subscribe(x => console.log('sub A: ', x));\n * shared$.subscribe(y => console.log('sub B: ', y));\n *\n * // PRINTS:\n * // shared: subscribed <-- reference count = 1\n * // source: subscribed\n * // shared: subscribed <-- reference count = 2\n * // source: 0\n * // shared: 0\n * // sub A: 0\n * // shared: 0\n * // sub B: 0\n * // source: 1\n * // shared: 1\n * // sub A: 1\n * // shared: completed <-- take(2) completes the subscription for sub A\n * // shared: unsubscribed <-- reference count = 1\n * // shared: 1\n * // sub B: 1\n * // shared: completed <-- take(2) completes the subscription for sub B\n * // shared: unsubscribed <-- reference count = 0\n * // source: unsubscribed <-- replaySubject unsubscribes from source observable because the reference count dropped to 0 and refCount is true\n *\n * // In case of refCount being false, the unsubscribe is never called on the source and the source would keep on emitting, even if no subscribers\n * // are listening.\n * // source: 2\n * // source: 3\n * // source: 4\n * // ...\n * ```\n *\n * @see {@link publish}\n * @see {@link share}\n * @see {@link publishReplay}\n *\n * @param configOrBufferSize Maximum element count of the replay buffer or {@link ShareReplayConfig configuration}\n * object.\n * @param windowTime Maximum time length of the replay buffer in milliseconds.\n * @param scheduler Scheduler where connected observers within the selector function\n * will be invoked on.\n * @return A function that returns an Observable sequence that contains the\n * elements of a sequence produced by multicasting the source sequence within a\n * selector function.\n */\nexport function shareReplay<T>(\n  configOrBufferSize?: ShareReplayConfig | number,\n  windowTime?: number,\n  scheduler?: SchedulerLike\n): MonoTypeOperatorFunction<T> {\n  let bufferSize: number;\n  let refCount = false;\n  if (configOrBufferSize && typeof configOrBufferSize === 'object') {\n    ({ bufferSize = Infinity, windowTime = Infinity, refCount = false, scheduler } = configOrBufferSize);\n  } else {\n    bufferSize = (configOrBufferSize ?? Infinity) as number;\n  }\n  return share<T>({\n    connector: () => new ReplaySubject(bufferSize, windowTime, scheduler),\n    resetOnError: true,\n    resetOnComplete: false,\n    resetOnRefCountZero: refCount,\n  });\n}\n", "import { Subscriber } from '../Subscriber';\nimport { ObservableInput, OperatorFunction, ObservedValueOf } from '../types';\nimport { innerFrom } from '../observable/innerFrom';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\n\n/* tslint:disable:max-line-length */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: undefined\n): OperatorFunction<T, ObservedValueOf<O>>;\n/** @deprecated The `resultSelector` parameter will be removed in v8. Use an inner `map` instead. Details: https://rxjs.dev/deprecations/resultSelector */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, R>;\n/* tslint:enable:max-line-length */\n\n/**\n * Projects each source value to an Observable which is merged in the output\n * Observable, emitting values only from the most recently projected Observable.\n *\n * <span class=\"informal\">Maps each value to an Observable, then flattens all of\n * these inner Observables using {@link switchAll}.</span>\n *\n * ![](switchMap.png)\n *\n * Returns an Observable that emits items based on applying a function that you\n * supply to each item emitted by the source Observable, where that function\n * returns an (so-called \"inner\") Observable. Each time it observes one of these\n * inner Observables, the output Observable begins emitting the items emitted by\n * that inner Observable. When a new inner Observable is emitted, `switchMap`\n * stops emitting items from the earlier-emitted inner Observable and begins\n * emitting items from the new one. It continues to behave like this for\n * subsequent inner Observables.\n *\n * ## Example\n *\n * Generate new Observable according to source Observable values\n *\n * ```ts\n * import { of, switchMap } from 'rxjs';\n *\n * const switched = of(1, 2, 3).pipe(switchMap(x => of(x, x ** 2, x ** 3)));\n * switched.subscribe(x => console.log(x));\n * // outputs\n * // 1\n * // 1\n * // 1\n * // 2\n * // 4\n * // 8\n * // 3\n * // 9\n * // 27\n * ```\n *\n * Restart an interval Observable on every click event\n *\n * ```ts\n * import { fromEvent, switchMap, interval } from 'rxjs';\n *\n * const clicks = fromEvent(document, 'click');\n * const result = clicks.pipe(switchMap(() => interval(1000)));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link concatMap}\n * @see {@link exhaustMap}\n * @see {@link mergeMap}\n * @see {@link switchAll}\n * @see {@link switchMapTo}\n *\n * @param project A function that, when applied to an item emitted by the source\n * Observable, returns an Observable.\n * @return A function that returns an Observable that emits the result of\n * applying the projection function (and the optional deprecated\n * `resultSelector`) to each item emitted by the source Observable and taking\n * only the values from the most recently projected inner Observable.\n */\nexport function switchMap<T, R, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n  resultSelector?: (outerValue: T, innerValue: ObservedValueOf<O>, outerIndex: number, innerIndex: number) => R\n): OperatorFunction<T, ObservedValueOf<O> | R> {\n  return operate((source, subscriber) => {\n    let innerSubscriber: Subscriber<ObservedValueOf<O>> | null = null;\n    let index = 0;\n    // Whether or not the source subscription has completed\n    let isComplete = false;\n\n    // We only complete the result if the source is complete AND we don't have an active inner subscription.\n    // This is called both when the source completes and when the inners complete.\n    const checkComplete = () => isComplete && !innerSubscriber && subscriber.complete();\n\n    source.subscribe(\n      createOperatorSubscriber(\n        subscriber,\n        (value) => {\n          // Cancel the previous inner subscription if there was one\n          innerSubscriber?.unsubscribe();\n          let innerIndex = 0;\n          const outerIndex = index++;\n          // Start the next inner subscription\n          innerFrom(project(value, outerIndex)).subscribe(\n            (innerSubscriber = createOperatorSubscriber(\n              subscriber,\n              // When we get a new inner value, next it through. Note that this is\n              // handling the deprecate result selector here. This is because with this architecture\n              // it ends up being smaller than using the map operator.\n              (innerValue) => subscriber.next(resultSelector ? resultSelector(value, innerValue, outerIndex, innerIndex++) : innerValue),\n              () => {\n                // The inner has completed. Null out the inner subscriber to\n                // free up memory and to signal that we have no inner subscription\n                // currently.\n                innerSubscriber = null!;\n                checkComplete();\n              }\n            ))\n          );\n        },\n        () => {\n          isComplete = true;\n          checkComplete();\n        }\n      )\n    );\n  });\n}\n", "import { MonoTypeOperatorFunction, ObservableInput } from '../types';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { innerFrom } from '../observable/innerFrom';\nimport { noop } from '../util/noop';\n\n/**\n * Emits the values emitted by the source Observable until a `notifier`\n * Observable emits a value.\n *\n * <span class=\"informal\">Lets values pass until a second Observable,\n * `notifier`, emits a value. Then, it completes.</span>\n *\n * ![](takeUntil.png)\n *\n * `takeUntil` subscribes and begins mirroring the source Observable. It also\n * monitors a second Observable, `notifier` that you provide. If the `notifier`\n * emits a value, the output Observable stops mirroring the source Observable\n * and completes. If the `notifier` doesn't emit any value and completes\n * then `takeUntil` will pass all values.\n *\n * ## Example\n *\n * Tick every second until the first click happens\n *\n * ```ts\n * import { interval, fromEvent, takeUntil } from 'rxjs';\n *\n * const source = interval(1000);\n * const clicks = fromEvent(document, 'click');\n * const result = source.pipe(takeUntil(clicks));\n * result.subscribe(x => console.log(x));\n * ```\n *\n * @see {@link take}\n * @see {@link takeLast}\n * @see {@link takeWhile}\n * @see {@link skip}\n *\n * @param notifier The `ObservableInput` whose first emitted value will cause the output\n * Observable of `takeUntil` to stop emitting values from the source Observable.\n * @return A function that returns an Observable that emits the values from the\n * source Observable until `notifier` emits its first value.\n */\nexport function takeUntil<T>(notifier: ObservableInput<any>): MonoTypeOperatorFunction<T> {\n  return operate((source, subscriber) => {\n    innerFrom(notifier).subscribe(createOperatorSubscriber(subscriber, () => subscriber.complete(), noop));\n    !subscriber.closed && source.subscribe(subscriber);\n  });\n}\n", "import { MonoTypeOperatorFunction, Observer } from '../types';\nimport { isFunction } from '../util/isFunction';\nimport { operate } from '../util/lift';\nimport { createOperatorSubscriber } from './OperatorSubscriber';\nimport { identity } from '../util/identity';\n\n/**\n * An extension to the {@link Observer} interface used only by the {@link tap} operator.\n *\n * It provides a useful set of callbacks a user can register to do side-effects in\n * cases other than what the usual {@link Observer} callbacks are\n * ({@link guide/glossary-and-semantics#next next},\n * {@link guide/glossary-and-semantics#error error} and/or\n * {@link guide/glossary-and-semantics#complete complete}).\n *\n * ## Example\n *\n * ```ts\n * import { fromEvent, switchMap, tap, interval, take } from 'rxjs';\n *\n * const source$ = fromEvent(document, 'click');\n * const result$ = source$.pipe(\n *   switchMap((_, i) => i % 2 === 0\n *     ? fromEvent(document, 'mousemove').pipe(\n *         tap({\n *           subscribe: () => console.log('Subscribed to the mouse move events after click #' + i),\n *           unsubscribe: () => console.log('Mouse move events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('Mouse move events #' + i + ' finalized')\n *         })\n *       )\n *     : interval(1_000).pipe(\n *         take(5),\n *         tap({\n *           subscribe: () => console.log('Subscribed to the 1-second interval events after click #' + i),\n *           unsubscribe: () => console.log('1-second interval events #' + i + ' unsubscribed'),\n *           finalize: () => console.log('1-second interval events #' + i + ' finalized')\n *         })\n *       )\n *   )\n * );\n *\n * const subscription = result$.subscribe({\n *   next: console.log\n * });\n *\n * setTimeout(() => {\n *   console.log('Unsubscribe after 60 seconds');\n *   subscription.unsubscribe();\n * }, 60_000);\n * ```\n */\nexport interface TapObserver<T> extends Observer<T> {\n  /**\n   * The callback that `tap` operator invokes at the moment when the source Observable\n   * gets subscribed to.\n   */\n  subscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when an explicit\n   * {@link guide/glossary-and-semantics#unsubscription unsubscribe} happens. It won't get invoked on\n   * `error` or `complete` events.\n   */\n  unsubscribe: () => void;\n  /**\n   * The callback that `tap` operator invokes when any kind of\n   * {@link guide/glossary-and-semantics#finalization finalization} happens - either when\n   * the source Observable `error`s or `complete`s or when it gets explicitly unsubscribed\n   * by the user. There is no difference in using this callback or the {@link finalize}\n   * operator, but if you're already using `tap` operator, you can use this callback\n   * instead. You'd get the same result in either case.\n   */\n  finalize: () => void;\n}\nexport function tap<T>(observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void)): MonoTypeOperatorFunction<T>;\n/** @deprecated Instead of passing separate callback arguments, use an observer argument. Signatures taking separate callback arguments will be removed in v8. Details: https://rxjs.dev/deprecations/subscribe-arguments */\nexport function tap<T>(\n  next?: ((value: T) => void) | null,\n  error?: ((error: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T>;\n\n/**\n * Used to perform side-effects for notifications from the source observable\n *\n * <span class=\"informal\">Used when you want to affect outside state with a notification without altering the notification</span>\n *\n * ![](tap.png)\n *\n * Tap is designed to allow the developer a designated place to perform side effects. While you _could_ perform side-effects\n * inside of a `map` or a `mergeMap`, that would make their mapping functions impure, which isn't always a big deal, but will\n * make it so you can't do things like memoize those functions. The `tap` operator is designed solely for such side-effects to\n * help you remove side-effects from other operations.\n *\n * For any notification, next, error, or complete, `tap` will call the appropriate callback you have provided to it, via a function\n * reference, or a partial observer, then pass that notification down the stream.\n *\n * The observable returned by `tap` is an exact mirror of the source, with one exception: Any error that occurs -- synchronously -- in a handler\n * provided to `tap` will be emitted as an error from the returned observable.\n *\n * > Be careful! You can mutate objects as they pass through the `tap` operator's handlers.\n *\n * The most common use of `tap` is actually for debugging. You can place a `tap(console.log)` anywhere\n * in your observable `pipe`, log out the notifications as they are emitted by the source returned by the previous\n * operation.\n *\n * ## Examples\n *\n * Check a random number before it is handled. Below is an observable that will use a random number between 0 and 1,\n * and emit `'big'` or `'small'` depending on the size of that number. But we wanted to log what the original number\n * was, so we have added a `tap(console.log)`.\n *\n * ```ts\n * import { of, tap, map } from 'rxjs';\n *\n * of(Math.random()).pipe(\n *   tap(console.log),\n *   map(n => n > 0.5 ? 'big' : 'small')\n * ).subscribe(console.log);\n * ```\n *\n * Using `tap` to analyze a value and force an error. Below is an observable where in our system we only\n * want to emit numbers 3 or less we get from another source. We can force our observable to error\n * using `tap`.\n *\n * ```ts\n * import { of, tap } from 'rxjs';\n *\n * const source = of(1, 2, 3, 4, 5);\n *\n * source.pipe(\n *   tap(n => {\n *     if (n > 3) {\n *       throw new TypeError(`Value ${ n } is greater than 3`);\n *     }\n *   })\n * )\n * .subscribe({ next: console.log, error: err => console.log(err.message) });\n * ```\n *\n * We want to know when an observable completes before moving on to the next observable. The system\n * below will emit a random series of `'X'` characters from 3 different observables in sequence. The\n * only way we know when one observable completes and moves to the next one, in this case, is because\n * we have added a `tap` with the side effect of logging to console.\n *\n * ```ts\n * import { of, concatMap, interval, take, map, tap } from 'rxjs';\n *\n * of(1, 2, 3).pipe(\n *   concatMap(n => interval(1000).pipe(\n *     take(Math.round(Math.random() * 10)),\n *     map(() => 'X'),\n *     tap({ complete: () => console.log(`Done with ${ n }`) })\n *   ))\n * )\n * .subscribe(console.log);\n * ```\n *\n * @see {@link finalize}\n * @see {@link TapObserver}\n *\n * @param observerOrNext A next handler or partial observer\n * @param error An error handler\n * @param complete A completion handler\n * @return A function that returns an Observable identical to the source, but\n * runs the specified Observer or callback(s) for each item.\n */\nexport function tap<T>(\n  observerOrNext?: Partial<TapObserver<T>> | ((value: T) => void) | null,\n  error?: ((e: any) => void) | null,\n  complete?: (() => void) | null\n): MonoTypeOperatorFunction<T> {\n  // We have to check to see not only if next is a function,\n  // but if error or complete were passed. This is because someone\n  // could technically call tap like `tap(null, fn)` or `tap(null, null, fn)`.\n  const tapObserver =\n    isFunction(observerOrNext) || error || complete\n      ? // tslint:disable-next-line: no-object-literal-type-assertion\n        ({ next: observerOrNext as Exclude<typeof observerOrNext, Partial<TapObserver<T>>>, error, complete } as Partial<TapObserver<T>>)\n      : observerOrNext;\n\n  return tapObserver\n    ? operate((source, subscriber) => {\n        tapObserver.subscribe?.();\n        let isUnsub = true;\n        source.subscribe(\n          createOperatorSubscriber(\n            subscriber,\n            (value) => {\n              tapObserver.next?.(value);\n              subscriber.next(value);\n            },\n            () => {\n              isUnsub = false;\n              tapObserver.complete?.();\n              subscriber.complete();\n            },\n            (err) => {\n              isUnsub = false;\n              tapObserver.error?.(err);\n              subscriber.error(err);\n            },\n            () => {\n              if (isUnsub) {\n                tapObserver.unsubscribe?.();\n              }\n              tapObserver.finalize?.();\n            }\n          )\n        );\n      })\n    : // Tap was called with no valid tap observer or handler\n      // (e.g. `tap(null, null, null)` or `tap(null)` or `tap()`)\n      // so we're going to just mirror the source.\n      identity;\n}\n", "/**\n * Internal webcrypto alias.\n * We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n * See utils.ts for details.\n * @module\n */\ndeclare const globalThis: Record<string, any> | undefined;\nexport const crypto: any =\n  typeof globalThis === 'object' && 'crypto' in globalThis ? globalThis.crypto : undefined;\n", "/**\n * Utilities for hex, bytes, CSPRNG.\n * @module\n */\n/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// We use WebCrypto aka globalThis.crypto, which exists in browsers and node.js 16+.\n// node.js versions earlier than v19 don't declare it in global scope.\n// For node.js, package.json#exports field mapping rewrites import\n// from `crypto` to `cryptoNode`, which imports native module.\n// Makes the utils un-importable in browsers without a bundler.\n// Once node.js 18 is deprecated (2025-04-30), we can just drop the import.\nimport { crypto } from '@noble/hashes/crypto';\n\n/** Checks if something is Uint8Array. Be careful: nodejs Buffer will return true. */\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\n/** Asserts something is positive integer. */\nexport function anumber(n: number): void {\n  if (!Number.isSafeInteger(n) || n < 0) throw new Error('positive integer expected, got ' + n);\n}\n\n/** Asserts something is Uint8Array. */\nexport function abytes(b: Uint8Array | undefined, ...lengths: number[]): void {\n  if (!isBytes(b)) throw new Error('Uint8Array expected');\n  if (lengths.length > 0 && !lengths.includes(b.length))\n    throw new Error('Uint8Array expected of length ' + lengths + ', got length=' + b.length);\n}\n\n/** Asserts something is hash */\nexport function ahash(h: IHash): void {\n  if (typeof h !== 'function' || typeof h.create !== 'function')\n    throw new Error('Hash should be wrapped by utils.createHasher');\n  anumber(h.outputLen);\n  anumber(h.blockLen);\n}\n\n/** Asserts a hash instance has not been destroyed / finished */\nexport function aexists(instance: any, checkFinished = true): void {\n  if (instance.destroyed) throw new Error('Hash instance has been destroyed');\n  if (checkFinished && instance.finished) throw new Error('Hash#digest() has already been called');\n}\n\n/** Asserts output is properly-sized byte array */\nexport function aoutput(out: any, instance: any): void {\n  abytes(out);\n  const min = instance.outputLen;\n  if (out.length < min) {\n    throw new Error('digestInto() expects output buffer of length at least ' + min);\n  }\n}\n\n/** Generic type encompassing 8/16/32-byte arrays - but not 64-byte. */\n// prettier-ignore\nexport type TypedArray = Int8Array | Uint8ClampedArray | Uint8Array |\n  Uint16Array | Int16Array | Uint32Array | Int32Array;\n\n/** Cast u8 / u16 / u32 to u8. */\nexport function u8(arr: TypedArray): Uint8Array {\n  return new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** Cast u8 / u16 / u32 to u32. */\nexport function u32(arr: TypedArray): Uint32Array {\n  return new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));\n}\n\n/** Zeroize a byte array. Warning: JS provides no guarantees. */\nexport function clean(...arrays: TypedArray[]): void {\n  for (let i = 0; i < arrays.length; i++) {\n    arrays[i].fill(0);\n  }\n}\n\n/** Create DataView of an array for easy byte-level manipulation. */\nexport function createView(arr: TypedArray): DataView {\n  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);\n}\n\n/** The rotate right (circular right shift) operation for uint32 */\nexport function rotr(word: number, shift: number): number {\n  return (word << (32 - shift)) | (word >>> shift);\n}\n\n/** The rotate left (circular left shift) operation for uint32 */\nexport function rotl(word: number, shift: number): number {\n  return (word << shift) | ((word >>> (32 - shift)) >>> 0);\n}\n\n/** Is current platform little-endian? Most are. Big-Endian platform: IBM */\nexport const isLE: boolean = /* @__PURE__ */ (() =>\n  new Uint8Array(new Uint32Array([0x11223344]).buffer)[0] === 0x44)();\n\n/** The byte swap operation for uint32 */\nexport function byteSwap(word: number): number {\n  return (\n    ((word << 24) & 0xff000000) |\n    ((word << 8) & 0xff0000) |\n    ((word >>> 8) & 0xff00) |\n    ((word >>> 24) & 0xff)\n  );\n}\n/** Conditionally byte swap if on a big-endian platform */\nexport const swap8IfBE: (n: number) => number = isLE\n  ? (n: number) => n\n  : (n: number) => byteSwap(n);\n\n/** @deprecated */\nexport const byteSwapIfBE: typeof swap8IfBE = swap8IfBE;\n/** In place byte swap for Uint32Array */\nexport function byteSwap32(arr: Uint32Array): Uint32Array {\n  for (let i = 0; i < arr.length; i++) {\n    arr[i] = byteSwap(arr[i]);\n  }\n  return arr;\n}\n\nexport const swap32IfBE: (u: Uint32Array) => Uint32Array = isLE\n  ? (u: Uint32Array) => u\n  : byteSwap32;\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean = /* @__PURE__ */ (() =>\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function')();\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n/**\n * There is no setImmediate in browser and setTimeout is slow.\n * Call of async fn will return Promise, which will be fullfiled only on\n * next scheduler queue processing step and this is exactly what we need.\n */\nexport const nextTick = async (): Promise<void> => {};\n\n/** Returns control to thread each 'tick' ms to avoid blocking. */\nexport async function asyncLoop(\n  iters: number,\n  tick: number,\n  cb: (i: number) => void\n): Promise<void> {\n  let ts = Date.now();\n  for (let i = 0; i < iters; i++) {\n    cb(i);\n    // Date.now() is not monotonic, so in case if clock goes backwards we return return control too\n    const diff = Date.now() - ts;\n    if (diff >= 0 && diff < tick) continue;\n    await nextTick();\n    ts += diff;\n  }\n}\n\n// Global symbols, but ts doesn't see them: https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\ndeclare const TextDecoder: any;\n\n/**\n * Converts string to bytes using UTF8 encoding.\n * @example utf8ToBytes('abc') // Uint8Array.from([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\nexport function bytesToUtf8(bytes: Uint8Array): string {\n  return new TextDecoder().decode(bytes);\n}\n\n/** Accepted input of hash functions. Strings are converted to byte arrays. */\nexport type Input = string | Uint8Array;\n/**\n * Normalizes (non-hex) string or Uint8Array to Uint8Array.\n * Warning: when Uint8Array is passed, it would NOT get copied.\n * Keep in mind for future mutable operations.\n */\nexport function toBytes(data: Input): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** KDFs can accept string or Uint8Array for user convenience. */\nexport type KDFInput = string | Uint8Array;\n/**\n * Helper for KDFs: consumes uint8array or string.\n * When string is passed, does utf8 decoding, using TextDecoder.\n */\nexport function kdfInputToBytes(data: KDFInput): Uint8Array {\n  if (typeof data === 'string') data = utf8ToBytes(data);\n  abytes(data);\n  return data;\n}\n\n/** Copies several Uint8Arrays into one. */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\ntype EmptyObj = {};\nexport function checkOpts<T1 extends EmptyObj, T2 extends EmptyObj>(\n  defaults: T1,\n  opts?: T2\n): T1 & T2 {\n  if (opts !== undefined && {}.toString.call(opts) !== '[object Object]')\n    throw new Error('options should be object or undefined');\n  const merged = Object.assign(defaults, opts);\n  return merged as T1 & T2;\n}\n\n/** Hash interface. */\nexport type IHash = {\n  (data: Uint8Array): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create: any;\n};\n\n/** For runtime check if class implements interface */\nexport abstract class Hash<T extends Hash<T>> {\n  abstract blockLen: number; // Bytes per block\n  abstract outputLen: number; // Bytes in output\n  abstract update(buf: Input): this;\n  // Writes digest into buf\n  abstract digestInto(buf: Uint8Array): void;\n  abstract digest(): Uint8Array;\n  /**\n   * Resets internal state. Makes Hash instance unusable.\n   * Reset is impossible for keyed hashes if key is consumed into state. If digest is not consumed\n   * by user, they will need to manually call `destroy()` when zeroing is necessary.\n   */\n  abstract destroy(): void;\n  /**\n   * Clones hash instance. Unsafe: doesn't check whether `to` is valid. Can be used as `clone()`\n   * when no options are passed.\n   * Reasons to use `_cloneInto` instead of clone: 1) performance 2) reuse instance => all internal\n   * buffers are overwritten => causes buffer overwrite which is used for digest in some cases.\n   * There are no guarantees for clean-up because it's impossible in JS.\n   */\n  abstract _cloneInto(to?: T): T;\n  // Safe version that clones internal state\n  abstract clone(): T;\n}\n\n/**\n * XOF: streaming API to read digest in chunks.\n * Same as 'squeeze' in keccak/k12 and 'seek' in blake3, but more generic name.\n * When hash used in XOF mode it is up to user to call '.destroy' afterwards, since we cannot\n * destroy state, next call can require more bytes.\n */\nexport type HashXOF<T extends Hash<T>> = Hash<T> & {\n  xof(bytes: number): Uint8Array; // Read 'bytes' bytes from digest stream\n  xofInto(buf: Uint8Array): Uint8Array; // read buf.length bytes from digest stream into buf\n};\n\n/** Hash function */\nexport type CHash = ReturnType<typeof createHasher>;\n/** Hash function with output */\nexport type CHashO = ReturnType<typeof createOptHasher>;\n/** XOF with output */\nexport type CHashXO = ReturnType<typeof createXOFer>;\n\n/** Wraps hash function, creating an interface on top of it */\nexport function createHasher<T extends Hash<T>>(\n  hashCons: () => Hash<T>\n): {\n  (msg: Input): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(): Hash<T>;\n} {\n  const hashC = (msg: Input): Uint8Array => hashCons().update(toBytes(msg)).digest();\n  const tmp = hashCons();\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = () => hashCons();\n  return hashC;\n}\n\nexport function createOptHasher<H extends Hash<H>, T extends Object>(\n  hashCons: (opts?: T) => Hash<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): Hash<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\n\nexport function createXOFer<H extends HashXOF<H>, T extends Object>(\n  hashCons: (opts?: T) => HashXOF<H>\n): {\n  (msg: Input, opts?: T): Uint8Array;\n  outputLen: number;\n  blockLen: number;\n  create(opts?: T): HashXOF<H>;\n} {\n  const hashC = (msg: Input, opts?: T): Uint8Array => hashCons(opts).update(toBytes(msg)).digest();\n  const tmp = hashCons({} as T);\n  hashC.outputLen = tmp.outputLen;\n  hashC.blockLen = tmp.blockLen;\n  hashC.create = (opts?: T) => hashCons(opts);\n  return hashC;\n}\nexport const wrapConstructor: typeof createHasher = createHasher;\nexport const wrapConstructorWithOpts: typeof createOptHasher = createOptHasher;\nexport const wrapXOFConstructorWithOpts: typeof createXOFer = createXOFer;\n\n/** Cryptographically secure PRNG. Uses internal OS-level `crypto.getRandomValues`. */\nexport function randomBytes(bytesLength = 32): Uint8Array {\n  if (crypto && typeof crypto.getRandomValues === 'function') {\n    return crypto.getRandomValues(new Uint8Array(bytesLength));\n  }\n  // Legacy Node.js compatibility\n  if (crypto && typeof crypto.randomBytes === 'function') {\n    return Uint8Array.from(crypto.randomBytes(bytesLength));\n  }\n  throw new Error('crypto.getRandomValues must be defined');\n}\n", "/**\n * Internal Merkle-Damgard hash utils.\n * @module\n */\nimport { type Input, Hash, abytes, aexists, aoutput, clean, createView, toBytes } from './utils.ts';\n\n/** Polyfill for Safari 14. https://caniuse.com/mdn-javascript_builtins_dataview_setbiguint64 */\nexport function setBigUint64(\n  view: DataView,\n  byteOffset: number,\n  value: bigint,\n  isLE: boolean\n): void {\n  if (typeof view.setBigUint64 === 'function') return view.setBigUint64(byteOffset, value, isLE);\n  const _32n = BigInt(32);\n  const _u32_max = BigInt(0xffffffff);\n  const wh = Number((value >> _32n) & _u32_max);\n  const wl = Number(value & _u32_max);\n  const h = isLE ? 4 : 0;\n  const l = isLE ? 0 : 4;\n  view.setUint32(byteOffset + h, wh, isLE);\n  view.setUint32(byteOffset + l, wl, isLE);\n}\n\n/** Choice: a ? b : c */\nexport function Chi(a: number, b: number, c: number): number {\n  return (a & b) ^ (~a & c);\n}\n\n/** Majority function, true if any two inputs is true. */\nexport function Maj(a: number, b: number, c: number): number {\n  return (a & b) ^ (a & c) ^ (b & c);\n}\n\n/**\n * Merkle-Damgard hash construction base class.\n * Could be used to create MD5, RIPEMD, SHA1, SHA2.\n */\nexport abstract class HashMD<T extends HashMD<T>> extends Hash<T> {\n  protected abstract process(buf: DataView, offset: number): void;\n  protected abstract get(): number[];\n  protected abstract set(...args: number[]): void;\n  abstract destroy(): void;\n  protected abstract roundClean(): void;\n\n  readonly blockLen: number;\n  readonly outputLen: number;\n  readonly padOffset: number;\n  readonly isLE: boolean;\n\n  // For partial updates less than block size\n  protected buffer: Uint8Array;\n  protected view: DataView;\n  protected finished = false;\n  protected length = 0;\n  protected pos = 0;\n  protected destroyed = false;\n\n  constructor(blockLen: number, outputLen: number, padOffset: number, isLE: boolean) {\n    super();\n    this.blockLen = blockLen;\n    this.outputLen = outputLen;\n    this.padOffset = padOffset;\n    this.isLE = isLE;\n    this.buffer = new Uint8Array(blockLen);\n    this.view = createView(this.buffer);\n  }\n  update(data: Input): this {\n    aexists(this);\n    data = toBytes(data);\n    abytes(data);\n    const { view, buffer, blockLen } = this;\n    const len = data.length;\n    for (let pos = 0; pos < len; ) {\n      const take = Math.min(blockLen - this.pos, len - pos);\n      // Fast path: we have at least one block in input, cast it to view and process\n      if (take === blockLen) {\n        const dataView = createView(data);\n        for (; blockLen <= len - pos; pos += blockLen) this.process(dataView, pos);\n        continue;\n      }\n      buffer.set(data.subarray(pos, pos + take), this.pos);\n      this.pos += take;\n      pos += take;\n      if (this.pos === blockLen) {\n        this.process(view, 0);\n        this.pos = 0;\n      }\n    }\n    this.length += data.length;\n    this.roundClean();\n    return this;\n  }\n  digestInto(out: Uint8Array): void {\n    aexists(this);\n    aoutput(out, this);\n    this.finished = true;\n    // Padding\n    // We can avoid allocation of buffer for padding completely if it\n    // was previously not allocated here. But it won't change performance.\n    const { buffer, view, blockLen, isLE } = this;\n    let { pos } = this;\n    // append the bit '1' to the message\n    buffer[pos++] = 0b10000000;\n    clean(this.buffer.subarray(pos));\n    // we have less than padOffset left in buffer, so we cannot put length in\n    // current block, need process it and pad again\n    if (this.padOffset > blockLen - pos) {\n      this.process(view, 0);\n      pos = 0;\n    }\n    // Pad until full block byte with zeros\n    for (let i = pos; i < blockLen; i++) buffer[i] = 0;\n    // Note: sha512 requires length to be 128bit integer, but length in JS will overflow before that\n    // You need to write around 2 exabytes (u64_max / 8 / (1024**6)) for this to happen.\n    // So we just write lowest 64 bits of that value.\n    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);\n    this.process(view, 0);\n    const oview = createView(out);\n    const len = this.outputLen;\n    // NOTE: we do division by 4 later, which should be fused in single op with modulo by JIT\n    if (len % 4) throw new Error('_sha2: outputLen should be aligned to 32bit');\n    const outLen = len / 4;\n    const state = this.get();\n    if (outLen > state.length) throw new Error('_sha2: outputLen bigger than state');\n    for (let i = 0; i < outLen; i++) oview.setUint32(4 * i, state[i], isLE);\n  }\n  digest(): Uint8Array {\n    const { buffer, outputLen } = this;\n    this.digestInto(buffer);\n    const res = buffer.slice(0, outputLen);\n    this.destroy();\n    return res;\n  }\n  _cloneInto(to?: T): T {\n    to ||= new (this.constructor as any)() as T;\n    to.set(...this.get());\n    const { blockLen, buffer, length, finished, destroyed, pos } = this;\n    to.destroyed = destroyed;\n    to.finished = finished;\n    to.length = length;\n    to.pos = pos;\n    if (length % blockLen) to.buffer.set(buffer);\n    return to;\n  }\n  clone(): T {\n    return this._cloneInto();\n  }\n}\n\n/**\n * Initial SHA-2 state: fractional parts of square roots of first 16 primes 2..53.\n * Check out `test/misc/sha2-gen-iv.js` for recomputation guide.\n */\n\n/** Initial SHA256 state. Bits 0..32 of frac part of sqrt of primes 2..19 */\nexport const SHA256_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19,\n]);\n\n/** Initial SHA224 state. Bits 32..64 of frac part of sqrt of primes 23..53 */\nexport const SHA224_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4,\n]);\n\n/** Initial SHA384 state. Bits 0..64 of frac part of sqrt of primes 23..53 */\nexport const SHA384_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0xcbbb9d5d, 0xc1059ed8, 0x629a292a, 0x367cd507, 0x9159015a, 0x3070dd17, 0x152fecd8, 0xf70e5939,\n  0x67332667, 0xffc00b31, 0x8eb44a87, 0x68581511, 0xdb0c2e0d, 0x64f98fa7, 0x47b5481d, 0xbefa4fa4,\n]);\n\n/** Initial SHA512 state. Bits 0..64 of frac part of sqrt of primes 2..19 */\nexport const SHA512_IV: Uint32Array = /* @__PURE__ */ Uint32Array.from([\n  0x6a09e667, 0xf3bcc908, 0xbb67ae85, 0x84caa73b, 0x3c6ef372, 0xfe94f82b, 0xa54ff53a, 0x5f1d36f1,\n  0x510e527f, 0xade682d1, 0x9b05688c, 0x2b3e6c1f, 0x1f83d9ab, 0xfb41bd6b, 0x5be0cd19, 0x137e2179,\n]);\n", "/**\n * Internal helpers for u64. BigUint64Array is too slow as per 2025, so we implement it using Uint32Array.\n * @todo re-check https://issues.chromium.org/issues/42212588\n * @module\n */\nconst U32_MASK64 = /* @__PURE__ */ BigInt(2 ** 32 - 1);\nconst _32n = /* @__PURE__ */ BigInt(32);\n\nfunction fromBig(\n  n: bigint,\n  le = false\n): {\n  h: number;\n  l: number;\n} {\n  if (le) return { h: Number(n & U32_MASK64), l: Number((n >> _32n) & U32_MASK64) };\n  return { h: Number((n >> _32n) & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };\n}\n\nfunction split(lst: bigint[], le = false): Uint32Array[] {\n  const len = lst.length;\n  let Ah = new Uint32Array(len);\n  let Al = new Uint32Array(len);\n  for (let i = 0; i < len; i++) {\n    const { h, l } = fromBig(lst[i], le);\n    [Ah[i], Al[i]] = [h, l];\n  }\n  return [Ah, Al];\n}\n\nconst toBig = (h: number, l: number): bigint => (BigInt(h >>> 0) << _32n) | BigInt(l >>> 0);\n// for Shift in [0, 32)\nconst shrSH = (h: number, _l: number, s: number): number => h >>> s;\nconst shrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in [1, 32)\nconst rotrSH = (h: number, l: number, s: number): number => (h >>> s) | (l << (32 - s));\nconst rotrSL = (h: number, l: number, s: number): number => (h << (32 - s)) | (l >>> s);\n// Right rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotrBH = (h: number, l: number, s: number): number => (h << (64 - s)) | (l >>> (s - 32));\nconst rotrBL = (h: number, l: number, s: number): number => (h >>> (s - 32)) | (l << (64 - s));\n// Right rotate for shift===32 (just swaps l&h)\nconst rotr32H = (_h: number, l: number): number => l;\nconst rotr32L = (h: number, _l: number): number => h;\n// Left rotate for Shift in [1, 32)\nconst rotlSH = (h: number, l: number, s: number): number => (h << s) | (l >>> (32 - s));\nconst rotlSL = (h: number, l: number, s: number): number => (l << s) | (h >>> (32 - s));\n// Left rotate for Shift in (32, 64), NOTE: 32 is special case.\nconst rotlBH = (h: number, l: number, s: number): number => (l << (s - 32)) | (h >>> (64 - s));\nconst rotlBL = (h: number, l: number, s: number): number => (h << (s - 32)) | (l >>> (64 - s));\n\n// JS uses 32-bit signed integers for bitwise operations which means we cannot\n// simple take carry out of low bit sum by shift, we need to use division.\nfunction add(\n  Ah: number,\n  Al: number,\n  Bh: number,\n  Bl: number\n): {\n  h: number;\n  l: number;\n} {\n  const l = (Al >>> 0) + (Bl >>> 0);\n  return { h: (Ah + Bh + ((l / 2 ** 32) | 0)) | 0, l: l | 0 };\n}\n// Addition with more than 2 elements\nconst add3L = (Al: number, Bl: number, Cl: number): number => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);\nconst add3H = (low: number, Ah: number, Bh: number, Ch: number): number =>\n  (Ah + Bh + Ch + ((low / 2 ** 32) | 0)) | 0;\nconst add4L = (Al: number, Bl: number, Cl: number, Dl: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);\nconst add4H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number): number =>\n  (Ah + Bh + Ch + Dh + ((low / 2 ** 32) | 0)) | 0;\nconst add5L = (Al: number, Bl: number, Cl: number, Dl: number, El: number): number =>\n  (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);\nconst add5H = (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number): number =>\n  (Ah + Bh + Ch + Dh + Eh + ((low / 2 ** 32) | 0)) | 0;\n\n// prettier-ignore\nexport {\n  add, add3H, add3L, add4H, add4L, add5H, add5L, fromBig, rotlBH, rotlBL, rotlSH, rotlSL, rotr32H, rotr32L, rotrBH, rotrBL, rotrSH, rotrSL, shrSH, shrSL, split, toBig\n};\n// prettier-ignore\nconst u64: { fromBig: typeof fromBig; split: typeof split; toBig: (h: number, l: number) => bigint; shrSH: (h: number, _l: number, s: number) => number; shrSL: (h: number, l: number, s: number) => number; rotrSH: (h: number, l: number, s: number) => number; rotrSL: (h: number, l: number, s: number) => number; rotrBH: (h: number, l: number, s: number) => number; rotrBL: (h: number, l: number, s: number) => number; rotr32H: (_h: number, l: number) => number; rotr32L: (h: number, _l: number) => number; rotlSH: (h: number, l: number, s: number) => number; rotlSL: (h: number, l: number, s: number) => number; rotlBH: (h: number, l: number, s: number) => number; rotlBL: (h: number, l: number, s: number) => number; add: typeof add; add3L: (Al: number, Bl: number, Cl: number) => number; add3H: (low: number, Ah: number, Bh: number, Ch: number) => number; add4L: (Al: number, Bl: number, Cl: number, Dl: number) => number; add4H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number) => number; add5H: (low: number, Ah: number, Bh: number, Ch: number, Dh: number, Eh: number) => number; add5L: (Al: number, Bl: number, Cl: number, Dl: number, El: number) => number; } = {\n  fromBig, split, toBig,\n  shrSH, shrSL,\n  rotrSH, rotrSL, rotrBH, rotrBL,\n  rotr32H, rotr32L,\n  rotlSH, rotlSL, rotlBH, rotlBL,\n  add, add3L, add3H, add4L, add4H, add5H, add5L,\n};\nexport default u64;\n", "/**\n * SHA2 hash function. A.k.a. sha256, sha384, sha512, sha512_224, sha512_256.\n * SHA256 is the fastest hash implementable in JS, even faster than Blake3.\n * Check out [RFC 4634](https://datatracker.ietf.org/doc/html/rfc4634) and\n * [FIPS 180-4](https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.180-4.pdf).\n * @module\n */\nimport { Chi, HashMD, Maj, SHA224_IV, SHA256_IV, SHA384_IV, SHA512_IV } from './_md.ts';\nimport * as u64 from './_u64.ts';\nimport { type CHash, clean, createHasher, rotr } from './utils.ts';\n\n/**\n * Round constants:\n * First 32 bits of fractional parts of the cube roots of the first 64 primes 2..311)\n */\n// prettier-ignore\nconst SHA256_K = /* @__PURE__ */ Uint32Array.from([\n  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,\n  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,\n  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,\n  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,\n  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,\n  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,\n  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,\n  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2\n]);\n\n/** Reusable temporary buffer. \"W\" comes straight from spec. */\nconst SHA256_W = /* @__PURE__ */ new Uint32Array(64);\nexport class SHA256 extends HashMD<SHA256> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  protected A: number = SHA256_IV[0] | 0;\n  protected B: number = SHA256_IV[1] | 0;\n  protected C: number = SHA256_IV[2] | 0;\n  protected D: number = SHA256_IV[3] | 0;\n  protected E: number = SHA256_IV[4] | 0;\n  protected F: number = SHA256_IV[5] | 0;\n  protected G: number = SHA256_IV[6] | 0;\n  protected H: number = SHA256_IV[7] | 0;\n\n  constructor(outputLen: number = 32) {\n    super(64, outputLen, 8, false);\n  }\n  protected get(): [number, number, number, number, number, number, number, number] {\n    const { A, B, C, D, E, F, G, H } = this;\n    return [A, B, C, D, E, F, G, H];\n  }\n  // prettier-ignore\n  protected set(\n    A: number, B: number, C: number, D: number, E: number, F: number, G: number, H: number\n  ): void {\n    this.A = A | 0;\n    this.B = B | 0;\n    this.C = C | 0;\n    this.D = D | 0;\n    this.E = E | 0;\n    this.F = F | 0;\n    this.G = G | 0;\n    this.H = H | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 48 words w[16..63] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) SHA256_W[i] = view.getUint32(offset, false);\n    for (let i = 16; i < 64; i++) {\n      const W15 = SHA256_W[i - 15];\n      const W2 = SHA256_W[i - 2];\n      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ (W15 >>> 3);\n      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ (W2 >>> 10);\n      SHA256_W[i] = (s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16]) | 0;\n    }\n    // Compression function main loop, 64 rounds\n    let { A, B, C, D, E, F, G, H } = this;\n    for (let i = 0; i < 64; i++) {\n      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);\n      const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);\n      const T2 = (sigma0 + Maj(A, B, C)) | 0;\n      H = G;\n      G = F;\n      F = E;\n      E = (D + T1) | 0;\n      D = C;\n      C = B;\n      B = A;\n      A = (T1 + T2) | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    A = (A + this.A) | 0;\n    B = (B + this.B) | 0;\n    C = (C + this.C) | 0;\n    D = (D + this.D) | 0;\n    E = (E + this.E) | 0;\n    F = (F + this.F) | 0;\n    G = (G + this.G) | 0;\n    H = (H + this.H) | 0;\n    this.set(A, B, C, D, E, F, G, H);\n  }\n  protected roundClean(): void {\n    clean(SHA256_W);\n  }\n  destroy(): void {\n    this.set(0, 0, 0, 0, 0, 0, 0, 0);\n    clean(this.buffer);\n  }\n}\n\nexport class SHA224 extends SHA256 {\n  protected A: number = SHA224_IV[0] | 0;\n  protected B: number = SHA224_IV[1] | 0;\n  protected C: number = SHA224_IV[2] | 0;\n  protected D: number = SHA224_IV[3] | 0;\n  protected E: number = SHA224_IV[4] | 0;\n  protected F: number = SHA224_IV[5] | 0;\n  protected G: number = SHA224_IV[6] | 0;\n  protected H: number = SHA224_IV[7] | 0;\n  constructor() {\n    super(28);\n  }\n}\n\n// SHA2-512 is slower than sha256 in js because u64 operations are slow.\n\n// Round contants\n// First 32 bits of the fractional parts of the cube roots of the first 80 primes 2..409\n// prettier-ignore\nconst K512 = /* @__PURE__ */ (() => u64.split([\n  '0x428a2f98d728ae22', '0x7137449123ef65cd', '0xb5c0fbcfec4d3b2f', '0xe9b5dba58189dbbc',\n  '0x3956c25bf348b538', '0x59f111f1b605d019', '0x923f82a4af194f9b', '0xab1c5ed5da6d8118',\n  '0xd807aa98a3030242', '0x12835b0145706fbe', '0x243185be4ee4b28c', '0x550c7dc3d5ffb4e2',\n  '0x72be5d74f27b896f', '0x80deb1fe3b1696b1', '0x9bdc06a725c71235', '0xc19bf174cf692694',\n  '0xe49b69c19ef14ad2', '0xefbe4786384f25e3', '0x0fc19dc68b8cd5b5', '0x240ca1cc77ac9c65',\n  '0x2de92c6f592b0275', '0x4a7484aa6ea6e483', '0x5cb0a9dcbd41fbd4', '0x76f988da831153b5',\n  '0x983e5152ee66dfab', '0xa831c66d2db43210', '0xb00327c898fb213f', '0xbf597fc7beef0ee4',\n  '0xc6e00bf33da88fc2', '0xd5a79147930aa725', '0x06ca6351e003826f', '0x142929670a0e6e70',\n  '0x27b70a8546d22ffc', '0x2e1b21385c26c926', '0x4d2c6dfc5ac42aed', '0x53380d139d95b3df',\n  '0x650a73548baf63de', '0x766a0abb3c77b2a8', '0x81c2c92e47edaee6', '0x92722c851482353b',\n  '0xa2bfe8a14cf10364', '0xa81a664bbc423001', '0xc24b8b70d0f89791', '0xc76c51a30654be30',\n  '0xd192e819d6ef5218', '0xd69906245565a910', '0xf40e35855771202a', '0x106aa07032bbd1b8',\n  '0x19a4c116b8d2d0c8', '0x1e376c085141ab53', '0x2748774cdf8eeb99', '0x34b0bcb5e19b48a8',\n  '0x391c0cb3c5c95a63', '0x4ed8aa4ae3418acb', '0x5b9cca4f7763e373', '0x682e6ff3d6b2b8a3',\n  '0x748f82ee5defb2fc', '0x78a5636f43172f60', '0x84c87814a1f0ab72', '0x8cc702081a6439ec',\n  '0x90befffa23631e28', '0xa4506cebde82bde9', '0xbef9a3f7b2c67915', '0xc67178f2e372532b',\n  '0xca273eceea26619c', '0xd186b8c721c0c207', '0xeada7dd6cde0eb1e', '0xf57d4f7fee6ed178',\n  '0x06f067aa72176fba', '0x0a637dc5a2c898a6', '0x113f9804bef90dae', '0x1b710b35131c471b',\n  '0x28db77f523047d84', '0x32caab7b40c72493', '0x3c9ebe0a15c9bebc', '0x431d67c49c100d4c',\n  '0x4cc5d4becb3e42b6', '0x597f299cfc657e2a', '0x5fcb6fab3ad6faec', '0x6c44198c4a475817'\n].map(n => BigInt(n))))();\nconst SHA512_Kh = /* @__PURE__ */ (() => K512[0])();\nconst SHA512_Kl = /* @__PURE__ */ (() => K512[1])();\n\n// Reusable temporary buffers\nconst SHA512_W_H = /* @__PURE__ */ new Uint32Array(80);\nconst SHA512_W_L = /* @__PURE__ */ new Uint32Array(80);\n\nexport class SHA512 extends HashMD<SHA512> {\n  // We cannot use array here since array allows indexing by variable\n  // which means optimizer/compiler cannot use registers.\n  // h -- high 32 bits, l -- low 32 bits\n  protected Ah: number = SHA512_IV[0] | 0;\n  protected Al: number = SHA512_IV[1] | 0;\n  protected Bh: number = SHA512_IV[2] | 0;\n  protected Bl: number = SHA512_IV[3] | 0;\n  protected Ch: number = SHA512_IV[4] | 0;\n  protected Cl: number = SHA512_IV[5] | 0;\n  protected Dh: number = SHA512_IV[6] | 0;\n  protected Dl: number = SHA512_IV[7] | 0;\n  protected Eh: number = SHA512_IV[8] | 0;\n  protected El: number = SHA512_IV[9] | 0;\n  protected Fh: number = SHA512_IV[10] | 0;\n  protected Fl: number = SHA512_IV[11] | 0;\n  protected Gh: number = SHA512_IV[12] | 0;\n  protected Gl: number = SHA512_IV[13] | 0;\n  protected Hh: number = SHA512_IV[14] | 0;\n  protected Hl: number = SHA512_IV[15] | 0;\n\n  constructor(outputLen: number = 64) {\n    super(128, outputLen, 16, false);\n  }\n  // prettier-ignore\n  protected get(): [\n    number, number, number, number, number, number, number, number,\n    number, number, number, number, number, number, number, number\n  ] {\n    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];\n  }\n  // prettier-ignore\n  protected set(\n    Ah: number, Al: number, Bh: number, Bl: number, Ch: number, Cl: number, Dh: number, Dl: number,\n    Eh: number, El: number, Fh: number, Fl: number, Gh: number, Gl: number, Hh: number, Hl: number\n  ): void {\n    this.Ah = Ah | 0;\n    this.Al = Al | 0;\n    this.Bh = Bh | 0;\n    this.Bl = Bl | 0;\n    this.Ch = Ch | 0;\n    this.Cl = Cl | 0;\n    this.Dh = Dh | 0;\n    this.Dl = Dl | 0;\n    this.Eh = Eh | 0;\n    this.El = El | 0;\n    this.Fh = Fh | 0;\n    this.Fl = Fl | 0;\n    this.Gh = Gh | 0;\n    this.Gl = Gl | 0;\n    this.Hh = Hh | 0;\n    this.Hl = Hl | 0;\n  }\n  protected process(view: DataView, offset: number): void {\n    // Extend the first 16 words into the remaining 64 words w[16..79] of the message schedule array\n    for (let i = 0; i < 16; i++, offset += 4) {\n      SHA512_W_H[i] = view.getUint32(offset);\n      SHA512_W_L[i] = view.getUint32((offset += 4));\n    }\n    for (let i = 16; i < 80; i++) {\n      // s0 := (w[i-15] rightrotate 1) xor (w[i-15] rightrotate 8) xor (w[i-15] rightshift 7)\n      const W15h = SHA512_W_H[i - 15] | 0;\n      const W15l = SHA512_W_L[i - 15] | 0;\n      const s0h = u64.rotrSH(W15h, W15l, 1) ^ u64.rotrSH(W15h, W15l, 8) ^ u64.shrSH(W15h, W15l, 7);\n      const s0l = u64.rotrSL(W15h, W15l, 1) ^ u64.rotrSL(W15h, W15l, 8) ^ u64.shrSL(W15h, W15l, 7);\n      // s1 := (w[i-2] rightrotate 19) xor (w[i-2] rightrotate 61) xor (w[i-2] rightshift 6)\n      const W2h = SHA512_W_H[i - 2] | 0;\n      const W2l = SHA512_W_L[i - 2] | 0;\n      const s1h = u64.rotrSH(W2h, W2l, 19) ^ u64.rotrBH(W2h, W2l, 61) ^ u64.shrSH(W2h, W2l, 6);\n      const s1l = u64.rotrSL(W2h, W2l, 19) ^ u64.rotrBL(W2h, W2l, 61) ^ u64.shrSL(W2h, W2l, 6);\n      // SHA256_W[i] = s0 + s1 + SHA256_W[i - 7] + SHA256_W[i - 16];\n      const SUMl = u64.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);\n      const SUMh = u64.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);\n      SHA512_W_H[i] = SUMh | 0;\n      SHA512_W_L[i] = SUMl | 0;\n    }\n    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;\n    // Compression function main loop, 80 rounds\n    for (let i = 0; i < 80; i++) {\n      // S1 := (e rightrotate 14) xor (e rightrotate 18) xor (e rightrotate 41)\n      const sigma1h = u64.rotrSH(Eh, El, 14) ^ u64.rotrSH(Eh, El, 18) ^ u64.rotrBH(Eh, El, 41);\n      const sigma1l = u64.rotrSL(Eh, El, 14) ^ u64.rotrSL(Eh, El, 18) ^ u64.rotrBL(Eh, El, 41);\n      //const T1 = (H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i]) | 0;\n      const CHIh = (Eh & Fh) ^ (~Eh & Gh);\n      const CHIl = (El & Fl) ^ (~El & Gl);\n      // T1 = H + sigma1 + Chi(E, F, G) + SHA512_K[i] + SHA512_W[i]\n      // prettier-ignore\n      const T1ll = u64.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);\n      const T1h = u64.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);\n      const T1l = T1ll | 0;\n      // S0 := (a rightrotate 28) xor (a rightrotate 34) xor (a rightrotate 39)\n      const sigma0h = u64.rotrSH(Ah, Al, 28) ^ u64.rotrBH(Ah, Al, 34) ^ u64.rotrBH(Ah, Al, 39);\n      const sigma0l = u64.rotrSL(Ah, Al, 28) ^ u64.rotrBL(Ah, Al, 34) ^ u64.rotrBL(Ah, Al, 39);\n      const MAJh = (Ah & Bh) ^ (Ah & Ch) ^ (Bh & Ch);\n      const MAJl = (Al & Bl) ^ (Al & Cl) ^ (Bl & Cl);\n      Hh = Gh | 0;\n      Hl = Gl | 0;\n      Gh = Fh | 0;\n      Gl = Fl | 0;\n      Fh = Eh | 0;\n      Fl = El | 0;\n      ({ h: Eh, l: El } = u64.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));\n      Dh = Ch | 0;\n      Dl = Cl | 0;\n      Ch = Bh | 0;\n      Cl = Bl | 0;\n      Bh = Ah | 0;\n      Bl = Al | 0;\n      const All = u64.add3L(T1l, sigma0l, MAJl);\n      Ah = u64.add3H(All, T1h, sigma0h, MAJh);\n      Al = All | 0;\n    }\n    // Add the compressed chunk to the current hash value\n    ({ h: Ah, l: Al } = u64.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));\n    ({ h: Bh, l: Bl } = u64.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));\n    ({ h: Ch, l: Cl } = u64.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));\n    ({ h: Dh, l: Dl } = u64.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));\n    ({ h: Eh, l: El } = u64.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));\n    ({ h: Fh, l: Fl } = u64.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));\n    ({ h: Gh, l: Gl } = u64.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));\n    ({ h: Hh, l: Hl } = u64.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));\n    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);\n  }\n  protected roundClean(): void {\n    clean(SHA512_W_H, SHA512_W_L);\n  }\n  destroy(): void {\n    clean(this.buffer);\n    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);\n  }\n}\n\nexport class SHA384 extends SHA512 {\n  protected Ah: number = SHA384_IV[0] | 0;\n  protected Al: number = SHA384_IV[1] | 0;\n  protected Bh: number = SHA384_IV[2] | 0;\n  protected Bl: number = SHA384_IV[3] | 0;\n  protected Ch: number = SHA384_IV[4] | 0;\n  protected Cl: number = SHA384_IV[5] | 0;\n  protected Dh: number = SHA384_IV[6] | 0;\n  protected Dl: number = SHA384_IV[7] | 0;\n  protected Eh: number = SHA384_IV[8] | 0;\n  protected El: number = SHA384_IV[9] | 0;\n  protected Fh: number = SHA384_IV[10] | 0;\n  protected Fl: number = SHA384_IV[11] | 0;\n  protected Gh: number = SHA384_IV[12] | 0;\n  protected Gl: number = SHA384_IV[13] | 0;\n  protected Hh: number = SHA384_IV[14] | 0;\n  protected Hl: number = SHA384_IV[15] | 0;\n\n  constructor() {\n    super(48);\n  }\n}\n\n/**\n * Truncated SHA512/256 and SHA512/224.\n * SHA512_IV is XORed with 0xa5a5a5a5a5a5a5a5, then used as \"intermediary\" IV of SHA512/t.\n * Then t hashes string to produce result IV.\n * See `test/misc/sha2-gen-iv.js`.\n */\n\n/** SHA512/224 IV */\nconst T224_IV = /* @__PURE__ */ Uint32Array.from([\n  0x8c3d37c8, 0x19544da2, 0x73e19966, 0x89dcd4d6, 0x1dfab7ae, 0x32ff9c82, 0x679dd514, 0x582f9fcf,\n  0x0f6d2b69, 0x7bd44da8, 0x77e36f73, 0x04c48942, 0x3f9d85a8, 0x6a1d36c8, 0x1112e6ad, 0x91d692a1,\n]);\n\n/** SHA512/256 IV */\nconst T256_IV = /* @__PURE__ */ Uint32Array.from([\n  0x22312194, 0xfc2bf72c, 0x9f555fa3, 0xc84c64c2, 0x2393b86b, 0x6f53b151, 0x96387719, 0x5940eabd,\n  0x96283ee2, 0xa88effe3, 0xbe5e1e25, 0x53863992, 0x2b0199fc, 0x2c85b8aa, 0x0eb72ddc, 0x81c52ca2,\n]);\n\nexport class SHA512_224 extends SHA512 {\n  protected Ah: number = T224_IV[0] | 0;\n  protected Al: number = T224_IV[1] | 0;\n  protected Bh: number = T224_IV[2] | 0;\n  protected Bl: number = T224_IV[3] | 0;\n  protected Ch: number = T224_IV[4] | 0;\n  protected Cl: number = T224_IV[5] | 0;\n  protected Dh: number = T224_IV[6] | 0;\n  protected Dl: number = T224_IV[7] | 0;\n  protected Eh: number = T224_IV[8] | 0;\n  protected El: number = T224_IV[9] | 0;\n  protected Fh: number = T224_IV[10] | 0;\n  protected Fl: number = T224_IV[11] | 0;\n  protected Gh: number = T224_IV[12] | 0;\n  protected Gl: number = T224_IV[13] | 0;\n  protected Hh: number = T224_IV[14] | 0;\n  protected Hl: number = T224_IV[15] | 0;\n\n  constructor() {\n    super(28);\n  }\n}\n\nexport class SHA512_256 extends SHA512 {\n  protected Ah: number = T256_IV[0] | 0;\n  protected Al: number = T256_IV[1] | 0;\n  protected Bh: number = T256_IV[2] | 0;\n  protected Bl: number = T256_IV[3] | 0;\n  protected Ch: number = T256_IV[4] | 0;\n  protected Cl: number = T256_IV[5] | 0;\n  protected Dh: number = T256_IV[6] | 0;\n  protected Dl: number = T256_IV[7] | 0;\n  protected Eh: number = T256_IV[8] | 0;\n  protected El: number = T256_IV[9] | 0;\n  protected Fh: number = T256_IV[10] | 0;\n  protected Fl: number = T256_IV[11] | 0;\n  protected Gh: number = T256_IV[12] | 0;\n  protected Gl: number = T256_IV[13] | 0;\n  protected Hh: number = T256_IV[14] | 0;\n  protected Hl: number = T256_IV[15] | 0;\n\n  constructor() {\n    super(32);\n  }\n}\n\n/**\n * SHA2-256 hash function from RFC 4634.\n *\n * It is the fastest JS hash, even faster than Blake3.\n * To break sha256 using birthday attack, attackers need to try 2^128 hashes.\n * BTC network is doing 2^70 hashes/sec (2^95 hashes/year) as per 2025.\n */\nexport const sha256: CHash = /* @__PURE__ */ createHasher(() => new SHA256());\n/** SHA2-224 hash function from RFC 4634 */\nexport const sha224: CHash = /* @__PURE__ */ createHasher(() => new SHA224());\n\n/** SHA2-512 hash function from RFC 4634. */\nexport const sha512: CHash = /* @__PURE__ */ createHasher(() => new SHA512());\n/** SHA2-384 hash function from RFC 4634. */\nexport const sha384: CHash = /* @__PURE__ */ createHasher(() => new SHA384());\n\n/**\n * SHA2-512/256 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_256: CHash = /* @__PURE__ */ createHasher(() => new SHA512_256());\n/**\n * SHA2-512/224 \"truncated\" hash function, with improved resistance to length extension attacks.\n * See the paper on [truncated SHA512](https://eprint.iacr.org/2010/548.pdf).\n */\nexport const sha512_224: CHash = /* @__PURE__ */ createHasher(() => new SHA512_224());\n", "/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  abytes as abytes_,\n  bytesToHex as bytesToHex_,\n  concatBytes as concatBytes_,\n  hexToBytes as hexToBytes_,\n  isBytes as isBytes_,\n} from '@noble/hashes/utils.js';\nexport {\n  abytes,\n  anumber,\n  bytesToHex,\n  bytesToUtf8,\n  concatBytes,\n  hexToBytes,\n  isBytes,\n  randomBytes,\n  utf8ToBytes,\n} from '@noble/hashes/utils.js';\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\n// tmp name until v2\nexport function _abool2(value: boolean, title: string = ''): boolean {\n  if (typeof value !== 'boolean') {\n    const prefix = title && `\"${title}\"`;\n    throw new Error(prefix + 'expected boolean, got type=' + typeof value);\n  }\n  return value;\n}\n\n// tmp name until v2\n/** Asserts something is Uint8Array. */\nexport function _abytes2(value: Uint8Array, length?: number, title: string = ''): Uint8Array {\n  const bytes = isBytes_(value);\n  const len = value?.length;\n  const needsLen = length !== undefined;\n  if (!bytes || (needsLen && len !== length)) {\n    const prefix = title && `\"${title}\" `;\n    const ofLen = needsLen ? ` of length ${length}` : '';\n    const got = bytes ? `length=${len}` : `type=${typeof value}`;\n    throw new Error(prefix + 'expected Uint8Array' + ofLen + ', got ' + got);\n  }\n  return value;\n}\n\n// Used in weierstrass, der\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex_(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes_(bytes);\n  return hexToNumber(bytesToHex_(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes_(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes_(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'secret key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes_(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes_(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * Copies Uint8Array. We can't use u8a.slice(), because u8a can be Buffer,\n * and Buffer#slice creates mutable copy. Never use Buffers!\n */\nexport function copyBytes(bytes: Uint8Array): Uint8Array {\n  return Uint8Array.from(bytes);\n}\n\n/**\n * Decodes 7-bit ASCII string to Uint8Array, throws on non-ascii symbols\n * Should be safe to use for things expected to be ASCII.\n * Returns exact same result as utf8ToBytes for ASCII or throws.\n */\nexport function asciiToBytes(ascii: string): Uint8Array {\n  return Uint8Array.from(ascii, (c, i) => {\n    const charCode = c.charCodeAt(0);\n    if (c.length !== 1 || charCode > 127) {\n      throw new Error(\n        `string contains non-ASCII character \"${ascii[i]}\" with code ${charCode} at position ${i}`\n      );\n    }\n    return charCode;\n  });\n}\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\n// export const utf8ToBytes: typeof utf8ToBytes_ = utf8ToBytes_;\n/**\n * Converts bytes to string using UTF8 encoding.\n * @example bytesToUtf8(Uint8Array.from([97, 98, 99])) // 'abc'\n */\n// export const bytesToUtf8: typeof bytesToUtf8_ = bytesToUtf8_;\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n * TODO: merge with nLength in modular\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  const u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\n  const u8of = (byte: number) => Uint8Array.of(byte); // another shortcut\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8of(0x00), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8of(0x01), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes_(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes_(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\nexport function isHash(val: CHash): boolean {\n  return typeof val === 'function' && Number.isSafeInteger(val.outputLen);\n}\nexport function _validateObject(\n  object: Record<string, any>,\n  fields: Record<string, string>,\n  optFields: Record<string, string> = {}\n): void {\n  if (!object || typeof object !== 'object') throw new Error('expected valid options object');\n  type Item = keyof typeof object;\n  function checkField(fieldName: Item, expectedType: string, isOpt: boolean) {\n    const val = object[fieldName];\n    if (isOpt && val === undefined) return;\n    const current = typeof val;\n    if (current !== expectedType || val === null)\n      throw new Error(`param \"${fieldName}\" is invalid: expected ${expectedType}, got ${current}`);\n  }\n  Object.entries(fields).forEach(([k, v]) => checkField(k, v, false));\n  Object.entries(optFields).forEach(([k, v]) => checkField(k, v, true));\n}\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n", "/**\n * Utils for modular division and fields.\n * Field over 11 is a finite (Galois) field is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  anumber,\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n} from '../utils.ts';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _7n = /* @__PURE__ */ BigInt(7);\n// prettier-ignore\nconst _8n = /* @__PURE__ */ BigInt(8), _9n = /* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  return FpPow(Field(modulo), num, power);\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\nfunction assertIsSquare<T>(Fp: IField<T>, root: T, n: T): void {\n  if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n}\n\n// Not all roots are possible! Example which will throw:\n// const NUM =\n// n = 72057594037927816n;\n// Fp = Field(BigInt('0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab'));\nfunction sqrt3mod4<T>(Fp: IField<T>, n: T) {\n  const p1div4 = (Fp.ORDER + _1n) / _4n;\n  const root = Fp.pow(n, p1div4);\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\nfunction sqrt5mod8<T>(Fp: IField<T>, n: T) {\n  const p5div8 = (Fp.ORDER - _5n) / _8n;\n  const n2 = Fp.mul(n, _2n);\n  const v = Fp.pow(n2, p5div8);\n  const nv = Fp.mul(n, v);\n  const i = Fp.mul(Fp.mul(nv, _2n), v);\n  const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n  assertIsSquare(Fp, root, n);\n  return root;\n}\n\n// Based on RFC9380, Kong algorithm\n// prettier-ignore\nfunction sqrt9mod16(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  const Fp_ = Field(P);\n  const tn = tonelliShanks(P);\n  const c1 = tn(Fp_, Fp_.neg(Fp_.ONE));//  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n  const c2 = tn(Fp_, c1);              //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n  const c3 = tn(Fp_, Fp_.neg(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n  const c4 = (P + _7n) / _16n;         //  4. c4 = (q + 7) / 16        # Integer arithmetic\n  return <T>(Fp: IField<T>, n: T) => {\n    let tv1 = Fp.pow(n, c4);           //  1. tv1 = x^c4\n    let tv2 = Fp.mul(tv1, c1);         //  2. tv2 = c1 * tv1\n    const tv3 = Fp.mul(tv1, c2);       //  3. tv3 = c2 * tv1\n    const tv4 = Fp.mul(tv1, c3);       //  4. tv4 = c3 * tv1\n    const e1 = Fp.eql(Fp.sqr(tv2), n); //  5.  e1 = (tv2^2) == x\n    const e2 = Fp.eql(Fp.sqr(tv3), n); //  6.  e2 = (tv3^2) == x\n    tv1 = Fp.cmov(tv1, tv2, e1);       //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    tv2 = Fp.cmov(tv4, tv3, e2);       //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    const e3 = Fp.eql(Fp.sqr(tv2), n); //  9.  e3 = (tv2^2) == x\n    const root = Fp.cmov(tv1, tv2, e3);// 10.  z = CMOV(tv1, tv2, e3)   # Select sqrt from tv1 & tv2\n    assertIsSquare(Fp, root, n);\n    return root;\n  };\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Initialization (precomputation).\n  // Caching initialization could boost perf by 7%.\n  if (P < _3n) throw new Error('sqrt is not defined for small field');\n  // Factor P - 1 = Q * 2^S, where Q is odd\n  let Q = P - _1n;\n  let S = 0;\n  while (Q % _2n === _0n) {\n    Q /= _2n;\n    S++;\n  }\n\n  // Find the first quadratic non-residue Z >= 2\n  let Z = _2n;\n  const _Fp = Field(P);\n  while (FpLegendre(_Fp, Z) === 1) {\n    // Basic primality test for P. After x iterations, chance of\n    // not finding quadratic non-residue is 2^x, so 2^1000.\n    if (Z++ > 1000) throw new Error('Cannot find square root: probably non-prime P');\n  }\n  // Fast-path; usually done before Z, but we do \"primality test\".\n  if (S === 1) return sqrt3mod4;\n\n  // Slow-path\n  // TODO: test on Fp2 and others\n  let cc = _Fp.pow(Z, Q); // c = z^Q\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    if (Fp.is0(n)) return n;\n    // Check if n is a quadratic residue using Legendre symbol\n    if (FpLegendre(Fp, n) !== 1) throw new Error('Cannot find square root');\n\n    // Initialize variables for the main loop\n    let M = S;\n    let c = Fp.mul(Fp.ONE, cc); // c = z^Q, move cc from field _Fp into field Fp\n    let t = Fp.pow(n, Q); // t = n^Q, first guess at the fudge factor\n    let R = Fp.pow(n, Q1div2); // R = n^((Q+1)/2), first guess at the square root\n\n    // Main loop\n    // while t != 1\n    while (!Fp.eql(t, Fp.ONE)) {\n      if (Fp.is0(t)) return Fp.ZERO; // if t=0 return R=0\n      let i = 1;\n\n      // Find the smallest i >= 1 such that t^(2^i)  1 (mod P)\n      let t_tmp = Fp.sqr(t); // t^(2^1)\n      while (!Fp.eql(t_tmp, Fp.ONE)) {\n        i++;\n        t_tmp = Fp.sqr(t_tmp); // t^(2^2)...\n        if (i === M) throw new Error('Cannot find square root');\n      }\n\n      // Calculate the exponent for b: 2^(M - i - 1)\n      const exponent = _1n << BigInt(M - i - 1); // bigint is important\n      const b = Fp.pow(c, exponent); // b = 2^(M - i - 1)\n\n      // Update variables\n      M = i;\n      c = Fp.sqr(b); // c = b^2\n      t = Fp.mul(t, c); // t = (t * b^2)\n      R = Fp.mul(R, b); // R = R*b\n    }\n    return R;\n  };\n}\n\n/**\n * Square root for a finite field. Will try optimized versions first:\n *\n * 1. P  3 (mod 4)\n * 2. P  5 (mod 8)\n * 3. P  9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P  3 (mod 4) => n = n^((P+1)/4)\n  if (P % _4n === _3n) return sqrt3mod4;\n  // P  5 (mod 8) => Atkin algorithm, page 10 of https://eprint.iacr.org/2012/685.pdf\n  if (P % _8n === _5n) return sqrt5mod8;\n  // P  9 (mod 16) => Kong algorithm, page 11 of https://eprint.iacr.org/2012/685.pdf (algorithm 4)\n  if (P % _16n === _9n) return sqrt9mod16(P);\n  // Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  isValidNot0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  allowedLengths?: number[];\n  // legendre?(num: T): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array, skipValidation?: boolean): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'number',\n    BITS: 'number',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  _validateObject(field, opts);\n  // const max = 16384;\n  // if (field.BYTES < 1 || field.BYTES > max) throw new Error('invalid field');\n  // if (field.BITS < 1 || field.BITS > 8 * max) throw new Error('invalid field');\n  return field;\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(Fp: IField<T>, num: T, power: bigint): T {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return Fp.ONE;\n  if (power === _1n) return num;\n  let p = Fp.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = Fp.mul(p, d);\n    d = Fp.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * Exception-free. Will return `undefined` for 0 elements.\n * @param passZero map 0 to 0 (instead of undefined)\n */\nexport function FpInvertBatch<T>(Fp: IField<T>, nums: T[], passZero = false): T[] {\n  const inverted = new Array(nums.length).fill(passZero ? Fp.ZERO : undefined);\n  // Walk from first to last, multiply them by each other MOD p\n  const multipliedAcc = nums.reduce((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = acc;\n    return Fp.mul(acc, num);\n  }, Fp.ONE);\n  // Invert last element\n  const invertedAcc = Fp.inv(multipliedAcc);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (Fp.is0(num)) return acc;\n    inverted[i] = Fp.mul(acc, inverted[i]);\n    return Fp.mul(acc, num);\n  }, invertedAcc);\n  return inverted;\n}\n\n// TODO: remove\nexport function FpDiv<T>(Fp: IField<T>, lhs: T, rhs: T | bigint): T {\n  return Fp.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, Fp.ORDER) : Fp.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * Legendre constant is used to calculate Legendre symbol (a | p)\n * which denotes the value of a^((p-1)/2) (mod p).\n *\n * * (a | p)  1    if a is a square (mod p), quadratic residue\n * * (a | p)  -1   if a is not a square (mod p), quadratic non residue\n * * (a | p)  0    if a  0 (mod p)\n */\nexport function FpLegendre<T>(Fp: IField<T>, n: T): -1 | 0 | 1 {\n  // We can use 3rd argument as optional cache of this value\n  // but seems unneeded for now. The operation is very fast.\n  const p1mod2 = (Fp.ORDER - _1n) / _2n;\n  const powered = Fp.pow(n, p1mod2);\n  const yes = Fp.eql(powered, Fp.ONE);\n  const zero = Fp.eql(powered, Fp.ZERO);\n  const no = Fp.eql(powered, Fp.neg(Fp.ONE));\n  if (!yes && !zero && !no) throw new Error('invalid Legendre symbol result');\n  return yes ? 1 : zero ? 0 : -1;\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(Fp: IField<T>, n: T): boolean {\n  const l = FpLegendre(Fp, n);\n  return l === 1;\n}\n\nexport type NLength = { nByteLength: number; nBitLength: number };\n// CURVE.n lengths\nexport function nLength(n: bigint, nBitLength?: number): NLength {\n  // Bit size, byte size of CURVE.n\n  if (nBitLength !== undefined) anumber(nBitLength);\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\ntype SqrtFn = (n: bigint) => bigint;\ntype FieldOpts = Partial<{\n  sqrt: SqrtFn;\n  isLE: boolean;\n  BITS: number;\n  modFromBytes: boolean; // bls12-381 requires mod(n) instead of rejecting keys >= n\n  allowedLengths?: readonly number[]; // for P521 (adds padding for smaller sizes)\n}>;\n/**\n * Creates a finite field. Major performance optimizations:\n * * 1. Denormalized operations like mulN instead of mul.\n * * 2. Identical object shape: never add or remove keys.\n * * 3. `Object.freeze`.\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n *\n * Note about field properties:\n * * CHARACTERISTIC p = prime number, number of elements in main subgroup.\n * * ORDER q = similar to cofactor in curves, may be composite `q = p^m`.\n *\n * @param ORDER field order, probably prime, or could be composite\n * @param bitLen how many bits the field consumes\n * @param isLE (default: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLenOrOpts?: number | FieldOpts, // TODO: use opts only in v2?\n  isLE = false,\n  opts: { sqrt?: SqrtFn } = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  let _nbitLength: number | undefined = undefined;\n  let _sqrt: SqrtFn | undefined = undefined;\n  let modFromBytes: boolean = false;\n  let allowedLengths: undefined | readonly number[] = undefined;\n  if (typeof bitLenOrOpts === 'object' && bitLenOrOpts != null) {\n    if (opts.sqrt || isLE) throw new Error('cannot specify opts in two arguments');\n    const _opts = bitLenOrOpts;\n    if (_opts.BITS) _nbitLength = _opts.BITS;\n    if (_opts.sqrt) _sqrt = _opts.sqrt;\n    if (typeof _opts.isLE === 'boolean') isLE = _opts.isLE;\n    if (typeof _opts.modFromBytes === 'boolean') modFromBytes = _opts.modFromBytes;\n    allowedLengths = _opts.allowedLengths;\n  } else {\n    if (typeof bitLenOrOpts === 'number') _nbitLength = bitLenOrOpts;\n    if (opts.sqrt) _sqrt = opts.sqrt;\n  }\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, _nbitLength);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    allowedLengths: allowedLengths,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    // is valid and invertible\n    isValidNot0: (num: bigint) => !f.is0(num) && f.isValid(num),\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      _sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes, skipValidation = true) => {\n      if (allowedLengths) {\n        if (!allowedLengths.includes(bytes.length) || bytes.length > BYTES) {\n          throw new Error(\n            'Field.fromBytes: expected ' + allowedLengths + ' bytes, got ' + bytes.length\n          );\n        }\n        const padded = new Uint8Array(BYTES);\n        // isLE add 0 to right, !isLE to the left.\n        padded.set(bytes, isLE ? 0 : padded.length - bytes.length);\n        bytes = padded;\n      }\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      let scalar = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n      if (modFromBytes) scalar = mod(scalar, ORDER);\n      if (!skipValidation)\n        if (!f.isValid(scalar)) throw new Error('invalid field element: outside of range 0..ORDER');\n      // NOTE: we don't validate scalar here, please use isValid. This done such way because some\n      // protocol may allow non-reduced scalar that reduced later or changed some other way.\n      return scalar;\n    },\n    // TODO: we don't need it here, move out to separate fn\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // We can't move this out because Fp6, Fp12 implement it\n    // and it's unclear what to return in there.\n    cmov: (a, b, c) => (c ? b : a),\n  } as FpField);\n  return Object.freeze(f);\n}\n\n// Generic random scalar, we can do same for other fields if via Fp2.mul(Fp2.ONE, Fp2.random)?\n// This allows unsafe methods like ignore bias or zero. These unsafe, but often used in different protocols (if deterministic RNG).\n// which mean we cannot force this via opts.\n// Not sure what to do with randomBytes, we can accept it inside opts if wanted.\n// Probably need to export getMinHashLength somewhere?\n// random(bytes?: Uint8Array, unsafeAllowZero = false, unsafeAllowBias = false) {\n//   const LEN = !unsafeAllowBias ? getMinHashLength(ORDER) : BYTES;\n//   if (bytes === undefined) bytes = randomBytes(LEN); // _opts.randomBytes?\n//   const num = isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n//   // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n//   const reduced = unsafeAllowZero ? mod(num, ORDER) : mod(num, ORDER - _1n) + _1n;\n//   return reduced;\n// },\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n", "/**\n * Methods for elliptic curve multiplication by scalars.\n * Contains wNAF, pippenger.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { bitLen, bitMask, validateObject } from '../utils.ts';\nimport { Field, FpInvertBatch, nLength, validateField, type IField } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\n\nexport type AffinePoint<T> = {\n  x: T;\n  y: T;\n} & { Z?: never };\n\n// This was initialy do this way to re-use montgomery ladder in field (add->mul,double->sqr), but\n// that didn't happen and there is probably not much reason to have separate Group like this?\nexport interface Group<T extends Group<T>> {\n  double(): T;\n  negate(): T;\n  add(other: T): T;\n  subtract(other: T): T;\n  equals(other: T): boolean;\n  multiply(scalar: bigint): T;\n  toAffine?(invertedZ?: any): AffinePoint<any>;\n}\n\n// We can't \"abstract out\" coordinates (X, Y, Z; and T in Edwards): argument names of constructor\n// are not accessible. See Typescript gh-56093, gh-41594.\n//\n// We have to use recursive types, so it will return actual point, not constained `CurvePoint`.\n// If, at any point, P is `any`, it will erase all types and replace it\n// with `any`, because of recursion, `any implements CurvePoint`,\n// but we lose all constrains on methods.\n\n/** Base interface for all elliptic curve Points. */\nexport interface CurvePoint<F, P extends CurvePoint<F, P>> extends Group<P> {\n  /** Affine x coordinate. Different from projective / extended X coordinate. */\n  x: F;\n  /** Affine y coordinate. Different from projective / extended Y coordinate. */\n  y: F;\n  Z?: F;\n  double(): P;\n  negate(): P;\n  add(other: P): P;\n  subtract(other: P): P;\n  equals(other: P): boolean;\n  multiply(scalar: bigint): P;\n  assertValidity(): void;\n  clearCofactor(): P;\n  is0(): boolean;\n  isTorsionFree(): boolean;\n  isSmallOrder(): boolean;\n  multiplyUnsafe(scalar: bigint): P;\n  /**\n   * Massively speeds up `p.multiply(n)` by using precompute tables (caching). See {@link wNAF}.\n   * @param isLazy calculate cache now. Default (true) ensures it's deferred to first `multiply()`\n   */\n  precompute(windowSize?: number, isLazy?: boolean): P;\n  /** Converts point to 2D xy affine coordinates */\n  toAffine(invertedZ?: F): AffinePoint<F>;\n  toBytes(): Uint8Array;\n  toHex(): string;\n}\n\n/** Base interface for all elliptic curve Point constructors. */\nexport interface CurvePointCons<P extends CurvePoint<any, P>> {\n  [Symbol.hasInstance]: (item: unknown) => boolean;\n  BASE: P;\n  ZERO: P;\n  /** Field for basic curve math */\n  Fp: IField<P_F<P>>;\n  /** Scalar field, for scalars in multiply and others */\n  Fn: IField<bigint>;\n  /** Creates point from x, y. Does NOT validate if the point is valid. Use `.assertValidity()`. */\n  fromAffine(p: AffinePoint<P_F<P>>): P;\n  fromBytes(bytes: Uint8Array): P;\n  fromHex(hex: Uint8Array | string): P;\n}\n\n// Type inference helpers: PC - PointConstructor, P - Point, Fp - Field element\n// Short names, because we use them a lot in result types:\n// * we can't do 'P = GetCurvePoint<PC>': this is default value and doesn't constrain anything\n// * we can't do 'type X = GetCurvePoint<PC>': it won't be accesible for arguments/return types\n// * `CurvePointCons<P extends CurvePoint<any, P>>` constraints from interface definition\n//   won't propagate, if `PC extends CurvePointCons<any>`: the P would be 'any', which is incorrect\n// * PC could be super specific with super specific P, which implements CurvePoint<any, P>.\n//   this means we need to do stuff like\n//   `function test<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(`\n//   if we want type safety around P, otherwise PC_P<PC> will be any\n\n/** Returns Fp type from Point (P_F<P> == P.F) */\nexport type P_F<P extends CurvePoint<any, P>> = P extends CurvePoint<infer F, P> ? F : never;\n/** Returns Fp type from PointCons (PC_F<PC> == PC.P.F) */\nexport type PC_F<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['Fp']['ZERO'];\n/** Returns Point type from PointCons (PC_P<PC> == PC.P) */\nexport type PC_P<PC extends CurvePointCons<CurvePoint<any, any>>> = PC['ZERO'];\n\n// Ugly hack to get proper type inference, because in typescript fails to infer resursively.\n// The hack allows to do up to 10 chained operations without applying type erasure.\n//\n// Types which won't work:\n// * `CurvePointCons<CurvePoint<any, any>>`, will return `any` after 1 operation\n// * `CurvePointCons<any>: WeierstrassPointCons<bigint> extends CurvePointCons<any> = false`\n// * `P extends CurvePoint, PC extends CurvePointCons<P>`\n//     * It can't infer P from PC alone\n//     * Too many relations between F, P & PC\n//     * It will infer P/F if `arg: CurvePointCons<F, P>`, but will fail if PC is generic\n//     * It will work correctly if there is an additional argument of type P\n//     * But generally, we don't want to parametrize `CurvePointCons` over `F`: it will complicate\n//       types, making them un-inferable\n// prettier-ignore\nexport type PC_ANY = CurvePointCons<\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any,\n  CurvePoint<any, any>\n  >>>>>>>>>\n>;\n\nexport interface CurveLengths {\n  secretKey?: number;\n  publicKey?: number;\n  publicKeyUncompressed?: number;\n  publicKeyHasPrefix?: boolean;\n  signature?: number;\n  seed?: number;\n}\nexport type GroupConstructor<T> = {\n  BASE: T;\n  ZERO: T;\n};\n/** @deprecated */\nexport type ExtendedGroupConstructor<T> = GroupConstructor<T> & {\n  Fp: IField<any>;\n  Fn: IField<bigint>;\n  fromAffine(ap: AffinePoint<any>): T;\n};\nexport type Mapper<T> = (i: T[]) => T[];\n\nexport function negateCt<T extends { negate: () => T }>(condition: boolean, item: T): T {\n  const neg = item.negate();\n  return condition ? neg : item;\n}\n\n/**\n * Takes a bunch of Projective Points but executes only one\n * inversion on all of them. Inversion is very slow operation,\n * so this improves performance massively.\n * Optimization: converts a list of projective points to a list of identical points with Z=1.\n */\nexport function normalizeZ<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  points: P[]\n): P[] {\n  const invertedZs = FpInvertBatch(\n    c.Fp,\n    points.map((p) => p.Z!)\n  );\n  return points.map((p, i) => c.fromAffine(p.toAffine(invertedZs[i])));\n}\n\nfunction validateW(W: number, bits: number) {\n  if (!Number.isSafeInteger(W) || W <= 0 || W > bits)\n    throw new Error('invalid window size, expected [1..' + bits + '], got W=' + W);\n}\n\n/** Internal wNAF opts for specific W and scalarBits */\nexport type WOpts = {\n  windows: number;\n  windowSize: number;\n  mask: bigint;\n  maxNumber: number;\n  shiftBy: bigint;\n};\n\nfunction calcWOpts(W: number, scalarBits: number): WOpts {\n  validateW(W, scalarBits);\n  const windows = Math.ceil(scalarBits / W) + 1; // W=8 33. Not 32, because we skip zero\n  const windowSize = 2 ** (W - 1); // W=8 128. Not 256, because we skip zero\n  const maxNumber = 2 ** W; // W=8 256\n  const mask = bitMask(W); // W=8 255 == mask 0b11111111\n  const shiftBy = BigInt(W); // W=8 8\n  return { windows, windowSize, mask, maxNumber, shiftBy };\n}\n\nfunction calcOffsets(n: bigint, window: number, wOpts: WOpts) {\n  const { windowSize, mask, maxNumber, shiftBy } = wOpts;\n  let wbits = Number(n & mask); // extract W bits.\n  let nextN = n >> shiftBy; // shift number by W bits.\n\n  // What actually happens here:\n  // const highestBit = Number(mask ^ (mask >> 1n));\n  // let wbits2 = wbits - 1; // skip zero\n  // if (wbits2 & highestBit) { wbits2 ^= Number(mask); // (~);\n\n  // split if bits > max: +224 => 256-32\n  if (wbits > windowSize) {\n    // we skip zero, which means instead of `>= size-1`, we do `> size`\n    wbits -= maxNumber; // -32, can be maxNumber - wbits, but then we need to set isNeg here.\n    nextN += _1n; // +256 (carry)\n  }\n  const offsetStart = window * windowSize;\n  const offset = offsetStart + Math.abs(wbits) - 1; // -1 because we skip zero\n  const isZero = wbits === 0; // is current window slice a 0?\n  const isNeg = wbits < 0; // is current window slice negative?\n  const isNegF = window % 2 !== 0; // fake random statement for noise\n  const offsetF = offsetStart; // fake offset for noise\n  return { nextN, offset, isZero, isNeg, isNegF, offsetF };\n}\n\nfunction validateMSMPoints(points: any[], c: any) {\n  if (!Array.isArray(points)) throw new Error('array expected');\n  points.forEach((p, i) => {\n    if (!(p instanceof c)) throw new Error('invalid point at index ' + i);\n  });\n}\nfunction validateMSMScalars(scalars: any[], field: any) {\n  if (!Array.isArray(scalars)) throw new Error('array of scalars expected');\n  scalars.forEach((s, i) => {\n    if (!field.isValid(s)) throw new Error('invalid scalar at index ' + i);\n  });\n}\n\n// Since points in different groups cannot be equal (different object constructor),\n// we can have single place to store precomputes.\n// Allows to make points frozen / immutable.\nconst pointPrecomputes = new WeakMap<any, any[]>();\nconst pointWindowSizes = new WeakMap<any, number>();\n\nfunction getW(P: any): number {\n  // To disable precomputes:\n  // return 1;\n  return pointWindowSizes.get(P) || 1;\n}\n\nfunction assert0(n: bigint): void {\n  if (n !== _0n) throw new Error('invalid wNAF');\n}\n\n/**\n * Elliptic curve multiplication of Point by scalar. Fragile.\n * Table generation takes **30MB of ram and 10ms on high-end CPU**,\n * but may take much longer on slow devices. Actual generation will happen on\n * first call of `multiply()`. By default, `BASE` point is precomputed.\n *\n * Scalars should always be less than curve order: this should be checked inside of a curve itself.\n * Creates precomputation tables for fast multiplication:\n * - private scalar is split by fixed size windows of W bits\n * - every window point is collected from window's table & added to accumulator\n * - since windows are different, same point inside tables won't be accessed more than once per calc\n * - each multiplication is 'Math.ceil(CURVE_ORDER / ) + 1' point additions (fixed for any scalar)\n * - +1 window is neccessary for wNAF\n * - wNAF reduces table size: 2x less memory + 2x faster generation, but 10% slower multiplication\n *\n * @todo Research returning 2d JS array of windows, instead of a single window.\n * This would allow windows to be in different memory locations\n */\nexport class wNAF<PC extends PC_ANY> {\n  private readonly BASE: PC_P<PC>;\n  private readonly ZERO: PC_P<PC>;\n  private readonly Fn: PC['Fn'];\n  readonly bits: number;\n\n  // Parametrized with a given Point class (not individual point)\n  constructor(Point: PC, bits: number) {\n    this.BASE = Point.BASE;\n    this.ZERO = Point.ZERO;\n    this.Fn = Point.Fn;\n    this.bits = bits;\n  }\n\n  // non-const time multiplication ladder\n  _unsafeLadder(elm: PC_P<PC>, n: bigint, p: PC_P<PC> = this.ZERO): PC_P<PC> {\n    let d: PC_P<PC> = elm;\n    while (n > _0n) {\n      if (n & _1n) p = p.add(d);\n      d = d.double();\n      n >>= _1n;\n    }\n    return p;\n  }\n\n  /**\n   * Creates a wNAF precomputation window. Used for caching.\n   * Default window size is set by `utils.precompute()` and is equal to 8.\n   * Number of precomputed points depends on the curve size:\n   * 2^(1) * (Math.ceil( / ) + 1), where:\n   * -  is the window size\n   * -  is the bitlength of the curve order.\n   * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.\n   * @param point Point instance\n   * @param W window size\n   * @returns precomputed point tables flattened to a single array\n   */\n  private precomputeWindow(point: PC_P<PC>, W: number): PC_P<PC>[] {\n    const { windows, windowSize } = calcWOpts(W, this.bits);\n    const points: PC_P<PC>[] = [];\n    let p: PC_P<PC> = point;\n    let base = p;\n    for (let window = 0; window < windows; window++) {\n      base = p;\n      points.push(base);\n      // i=1, bc we skip 0\n      for (let i = 1; i < windowSize; i++) {\n        base = base.add(p);\n        points.push(base);\n      }\n      p = base.double();\n    }\n    return points;\n  }\n\n  /**\n   * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.\n   * More compact implementation:\n   * https://github.com/paulmillr/noble-secp256k1/blob/47cb1669b6e506ad66b35fe7d76132ae97465da2/index.ts#L502-L541\n   * @returns real and fake (for const-time) points\n   */\n  private wNAF(W: number, precomputes: PC_P<PC>[], n: bigint): { p: PC_P<PC>; f: PC_P<PC> } {\n    // Scalar should be smaller than field order\n    if (!this.Fn.isValid(n)) throw new Error('invalid scalar');\n    // Accumulators\n    let p = this.ZERO;\n    let f = this.BASE;\n    // This code was first written with assumption that 'f' and 'p' will never be infinity point:\n    // since each addition is multiplied by 2 ** W, it cannot cancel each other. However,\n    // there is negate now: it is possible that negated element from low value\n    // would be the same as high element, which will create carry into next window.\n    // It's not obvious how this can fail, but still worth investigating later.\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      // (n === _0n) is handled and not early-exited. isEven and offsetF are used for noise\n      const { nextN, offset, isZero, isNeg, isNegF, offsetF } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // bits are 0: add garbage to fake point\n        // Important part for const-time getPublicKey: add random \"noise\" point to f.\n        f = f.add(negateCt(isNegF, precomputes[offsetF]));\n      } else {\n        // bits are 1: add to result point\n        p = p.add(negateCt(isNeg, precomputes[offset]));\n      }\n    }\n    assert0(n);\n    // Return both real and fake points: JIT won't eliminate f.\n    // At this point there is a way to F be infinity-point even if p is not,\n    // which makes it less const-time: around 1 bigint multiply.\n    return { p, f };\n  }\n\n  /**\n   * Implements ec unsafe (non const-time) multiplication using precomputed tables and w-ary non-adjacent form.\n   * @param acc accumulator point to add result of multiplication\n   * @returns point\n   */\n  private wNAFUnsafe(\n    W: number,\n    precomputes: PC_P<PC>[],\n    n: bigint,\n    acc: PC_P<PC> = this.ZERO\n  ): PC_P<PC> {\n    const wo = calcWOpts(W, this.bits);\n    for (let window = 0; window < wo.windows; window++) {\n      if (n === _0n) break; // Early-exit, skip 0 value\n      const { nextN, offset, isZero, isNeg } = calcOffsets(n, window, wo);\n      n = nextN;\n      if (isZero) {\n        // Window bits are 0: skip processing.\n        // Move to next window.\n        continue;\n      } else {\n        const item = precomputes[offset];\n        acc = acc.add(isNeg ? item.negate() : item); // Re-using acc allows to save adds in MSM\n      }\n    }\n    assert0(n);\n    return acc;\n  }\n\n  private getPrecomputes(W: number, point: PC_P<PC>, transform?: Mapper<PC_P<PC>>): PC_P<PC>[] {\n    // Calculate precomputes on a first run, reuse them after\n    let comp = pointPrecomputes.get(point);\n    if (!comp) {\n      comp = this.precomputeWindow(point, W) as PC_P<PC>[];\n      if (W !== 1) {\n        // Doing transform outside of if brings 15% perf hit\n        if (typeof transform === 'function') comp = transform(comp);\n        pointPrecomputes.set(point, comp);\n      }\n    }\n    return comp;\n  }\n\n  cached(\n    point: PC_P<PC>,\n    scalar: bigint,\n    transform?: Mapper<PC_P<PC>>\n  ): { p: PC_P<PC>; f: PC_P<PC> } {\n    const W = getW(point);\n    return this.wNAF(W, this.getPrecomputes(W, point, transform), scalar);\n  }\n\n  unsafe(point: PC_P<PC>, scalar: bigint, transform?: Mapper<PC_P<PC>>, prev?: PC_P<PC>): PC_P<PC> {\n    const W = getW(point);\n    if (W === 1) return this._unsafeLadder(point, scalar, prev); // For W=1 ladder is ~x2 faster\n    return this.wNAFUnsafe(W, this.getPrecomputes(W, point, transform), scalar, prev);\n  }\n\n  // We calculate precomputes for elliptic curve point multiplication\n  // using windowed method. This specifies window size and\n  // stores precomputed values. Usually only base point would be precomputed.\n  createCache(P: PC_P<PC>, W: number): void {\n    validateW(W, this.bits);\n    pointWindowSizes.set(P, W);\n    pointPrecomputes.delete(P);\n  }\n\n  hasCache(elm: PC_P<PC>): boolean {\n    return getW(elm) !== 1;\n  }\n}\n\n/**\n * Endomorphism-specific multiplication for Koblitz curves.\n * Cost: 128 dbl, 0-256 adds.\n */\nexport function mulEndoUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  Point: PC,\n  point: P,\n  k1: bigint,\n  k2: bigint\n): { p1: P; p2: P } {\n  let acc = point;\n  let p1 = Point.ZERO;\n  let p2 = Point.ZERO;\n  while (k1 > _0n || k2 > _0n) {\n    if (k1 & _1n) p1 = p1.add(acc);\n    if (k2 & _1n) p2 = p2.add(acc);\n    acc = acc.double();\n    k1 >>= _1n;\n    k2 >>= _1n;\n  }\n  return { p1, p2 };\n}\n\n/**\n * Pippenger algorithm for multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * 30x faster vs naive addition on L=4096, 10x faster than precomputes.\n * For N=254bit, L=1, it does: 1024 ADD + 254 DBL. For L=5: 1536 ADD + 254 DBL.\n * Algorithmically constant-time (for same L), even when 1 point + scalar, or when scalar = 0.\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @param scalars array of L scalars (aka secret keys / bigints)\n */\nexport function pippenger<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  scalars: bigint[]\n): P {\n  // If we split scalars by some window (let's say 8 bits), every chunk will only\n  // take 256 buckets even if there are 4096 scalars, also re-uses double.\n  // TODO:\n  // - https://eprint.iacr.org/2024/750.pdf\n  // - https://tches.iacr.org/index.php/TCHES/article/view/10287\n  // 0 is accepted in scalars\n  validateMSMPoints(points, c);\n  validateMSMScalars(scalars, fieldN);\n  const plength = points.length;\n  const slength = scalars.length;\n  if (plength !== slength) throw new Error('arrays of points and scalars must have equal length');\n  // if (plength === 0) throw new Error('array must be of length >= 2');\n  const zero = c.ZERO;\n  const wbits = bitLen(BigInt(plength));\n  let windowSize = 1; // bits\n  if (wbits > 12) windowSize = wbits - 3;\n  else if (wbits > 4) windowSize = wbits - 2;\n  else if (wbits > 0) windowSize = 2;\n  const MASK = bitMask(windowSize);\n  const buckets = new Array(Number(MASK) + 1).fill(zero); // +1 for zero array\n  const lastBits = Math.floor((fieldN.BITS - 1) / windowSize) * windowSize;\n  let sum = zero;\n  for (let i = lastBits; i >= 0; i -= windowSize) {\n    buckets.fill(zero);\n    for (let j = 0; j < slength; j++) {\n      const scalar = scalars[j];\n      const wbits = Number((scalar >> BigInt(i)) & MASK);\n      buckets[wbits] = buckets[wbits].add(points[j]);\n    }\n    let resI = zero; // not using this will do small speed-up, but will lose ct\n    // Skip first bucket, because it is zero\n    for (let j = buckets.length - 1, sumI = zero; j > 0; j--) {\n      sumI = sumI.add(buckets[j]);\n      resI = resI.add(sumI);\n    }\n    sum = sum.add(resI);\n    if (i !== 0) for (let j = 0; j < windowSize; j++) sum = sum.double();\n  }\n  return sum as P;\n}\n/**\n * Precomputed multi-scalar multiplication (MSM, Pa + Qb + Rc + ...).\n * @param c Curve Point constructor\n * @param fieldN field over CURVE.N - important that it's not over CURVE.P\n * @param points array of L curve points\n * @returns function which multiplies points with scaars\n */\nexport function precomputeMSMUnsafe<P extends CurvePoint<any, P>, PC extends CurvePointCons<P>>(\n  c: PC,\n  fieldN: IField<bigint>,\n  points: P[],\n  windowSize: number\n): (scalars: bigint[]) => P {\n  /**\n   * Performance Analysis of Window-based Precomputation\n   *\n   * Base Case (256-bit scalar, 8-bit window):\n   * - Standard precomputation requires:\n   *   - 31 additions per scalar  256 scalars = 7,936 ops\n   *   - Plus 255 summary additions = 8,191 total ops\n   *   Note: Summary additions can be optimized via accumulator\n   *\n   * Chunked Precomputation Analysis:\n   * - Using 32 chunks requires:\n   *   - 255 additions per chunk\n   *   - 256 doublings\n   *   - Total: (255  32) + 256 = 8,416 ops\n   *\n   * Memory Usage Comparison:\n   * Window Size | Standard Points | Chunked Points\n   * ------------|-----------------|---------------\n   *     4-bit   |     520         |      15\n   *     8-bit   |    4,224        |     255\n   *    10-bit   |   13,824        |   1,023\n   *    16-bit   |  557,056        |  65,535\n   *\n   * Key Advantages:\n   * 1. Enables larger window sizes due to reduced memory overhead\n   * 2. More efficient for smaller scalar counts:\n   *    - 16 chunks: (16  255) + 256 = 4,336 ops\n   *    - ~2x faster than standard 8,191 ops\n   *\n   * Limitations:\n   * - Not suitable for plain precomputes (requires 256 constant doublings)\n   * - Performance degrades with larger scalar counts:\n   *   - Optimal for ~256 scalars\n   *   - Less efficient for 4096+ scalars (Pippenger preferred)\n   */\n  validateW(windowSize, fieldN.BITS);\n  validateMSMPoints(points, c);\n  const zero = c.ZERO;\n  const tableSize = 2 ** windowSize - 1; // table size (without zero)\n  const chunks = Math.ceil(fieldN.BITS / windowSize); // chunks of item\n  const MASK = bitMask(windowSize);\n  const tables = points.map((p: P) => {\n    const res = [];\n    for (let i = 0, acc = p; i < tableSize; i++) {\n      res.push(acc);\n      acc = acc.add(p);\n    }\n    return res;\n  });\n  return (scalars: bigint[]): P => {\n    validateMSMScalars(scalars, fieldN);\n    if (scalars.length > points.length)\n      throw new Error('array of scalars must be smaller than array of points');\n    let res = zero;\n    for (let i = 0; i < chunks; i++) {\n      // No need to double if accumulator is still zero.\n      if (res !== zero) for (let j = 0; j < windowSize; j++) res = res.double();\n      const shiftBy = BigInt(chunks * windowSize - (i + 1) * windowSize);\n      for (let j = 0; j < scalars.length; j++) {\n        const n = scalars[j];\n        const curr = Number((n >> shiftBy) & MASK);\n        if (!curr) continue; // skip zero scalars chunks\n        res = res.add(tables[j][curr - 1]);\n      }\n    }\n    return res;\n  };\n}\n\n// TODO: remove\n/**\n * Generic BasicCurve interface: works even for polynomial fields (BLS): P, n, h would be ok.\n * Though generator can be different (Fp2 / Fp6 for BLS).\n */\nexport type BasicCurve<T> = {\n  Fp: IField<T>; // Field over which we'll do calculations (Fp)\n  n: bigint; // Curve order, total count of valid points in the field\n  nBitLength?: number; // bit length of curve order\n  nByteLength?: number; // byte length of curve order\n  h: bigint; // cofactor. we can assign default=1, but users will just ignore it w/o validation\n  hEff?: bigint; // Number to multiply to clear cofactor\n  Gx: T; // base point X coordinate\n  Gy: T; // base point Y coordinate\n  allowInfinityPoint?: boolean; // bls12-381 requires it. ZERO point is valid, but invalid pubkey\n};\n\n// TODO: remove\n/** @deprecated */\nexport function validateBasic<FP, T>(\n  curve: BasicCurve<FP> & T\n): Readonly<\n  {\n    readonly nBitLength: number;\n    readonly nByteLength: number;\n  } & BasicCurve<FP> &\n    T & {\n      p: bigint;\n    }\n> {\n  validateField(curve.Fp);\n  validateObject(\n    curve,\n    {\n      n: 'bigint',\n      h: 'bigint',\n      Gx: 'field',\n      Gy: 'field',\n    },\n    {\n      nBitLength: 'isSafeInteger',\n      nByteLength: 'isSafeInteger',\n    }\n  );\n  // Set defaults\n  return Object.freeze({\n    ...nLength(curve.n, curve.nBitLength),\n    ...curve,\n    ...{ p: curve.Fp.ORDER },\n  } as const);\n}\n\nexport type ValidCurveParams<T> = {\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: T;\n  b?: T;\n  d?: T;\n  Gx: T;\n  Gy: T;\n};\n\nfunction createField<T>(order: bigint, field?: IField<T>, isLE?: boolean): IField<T> {\n  if (field) {\n    if (field.ORDER !== order) throw new Error('Field.ORDER must match order: Fp == p, Fn == n');\n    validateField(field);\n    return field;\n  } else {\n    return Field(order, { isLE }) as unknown as IField<T>;\n  }\n}\nexport type FpFn<T> = { Fp: IField<T>; Fn: IField<bigint> };\n\n/** Validates CURVE opts and creates fields */\nexport function _createCurveFields<T>(\n  type: 'weierstrass' | 'edwards',\n  CURVE: ValidCurveParams<T>,\n  curveOpts: Partial<FpFn<T>> = {},\n  FpFnLE?: boolean\n): FpFn<T> & { CURVE: ValidCurveParams<T> } {\n  if (FpFnLE === undefined) FpFnLE = type === 'edwards';\n  if (!CURVE || typeof CURVE !== 'object') throw new Error(`expected valid ${type} CURVE object`);\n  for (const p of ['p', 'n', 'h'] as const) {\n    const val = CURVE[p];\n    if (!(typeof val === 'bigint' && val > _0n))\n      throw new Error(`CURVE.${p} must be positive bigint`);\n  }\n  const Fp = createField(CURVE.p, curveOpts.Fp, FpFnLE);\n  const Fn = createField(CURVE.n, curveOpts.Fn, FpFnLE);\n  const _b: 'b' | 'd' = type === 'weierstrass' ? 'b' : 'd';\n  const params = ['Gx', 'Gy', 'a', _b] as const;\n  for (const p of params) {\n    // @ts-ignore\n    if (!Fp.isValid(CURVE[p]))\n      throw new Error(`CURVE.${p} must be valid field element of CURVE.Fp`);\n  }\n  CURVE = Object.freeze(Object.assign({}, CURVE));\n  return { CURVE, Fp, Fn };\n}\n", "/**\n * Twisted Edwards curve. The formula is: ax + y = 1 + dxy.\n * For design rationale of types / exports, see weierstrass module documentation.\n * Untwisted Edwards curves exist, but they aren't used in real-world protocols.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  _abool2 as abool,\n  _abytes2 as abytes,\n  aInRange,\n  bytesToHex,\n  bytesToNumberLE,\n  concatBytes,\n  copyBytes,\n  ensureBytes,\n  isBytes,\n  memoized,\n  notImplemented,\n  randomBytes as randomBytesWeb,\n  type FHash,\n  type Hex,\n} from '../utils.ts';\nimport {\n  _createCurveFields,\n  normalizeZ,\n  pippenger,\n  wNAF,\n  type AffinePoint,\n  type BasicCurve,\n  type CurveLengths,\n  type CurvePoint,\n  type CurvePointCons,\n} from './curve.ts';\nimport { Field, type IField, type NLength } from './modular.ts';\n\n// Be friendly to bad ECMAScript parsers by not using bigint literals\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _8n = BigInt(8);\n\nexport type UVRatio = (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n\n/** Instance of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPoint extends CurvePoint<bigint, EdwardsPoint> {\n  /** extended X coordinate. Different from affine x. */\n  readonly X: bigint;\n  /** extended Y coordinate. Different from affine y. */\n  readonly Y: bigint;\n  /** extended Z coordinate */\n  readonly Z: bigint;\n  /** extended T coordinate */\n  readonly T: bigint;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array;\n  /** @deprecated use `p.precompute(windowSize)` */\n  _setWindowSize(windowSize: number): void;\n  /** @deprecated use .X */\n  readonly ex: bigint;\n  /** @deprecated use .Y */\n  readonly ey: bigint;\n  /** @deprecated use .Z */\n  readonly ez: bigint;\n  /** @deprecated use .T */\n  readonly et: bigint;\n}\n/** Static methods of Extended Point with coordinates in X, Y, Z, T. */\nexport interface EdwardsPointCons extends CurvePointCons<EdwardsPoint> {\n  new (X: bigint, Y: bigint, Z: bigint, T: bigint): EdwardsPoint;\n  CURVE(): EdwardsOpts;\n  fromBytes(bytes: Uint8Array, zip215?: boolean): EdwardsPoint;\n  fromHex(hex: Hex, zip215?: boolean): EdwardsPoint;\n  /** @deprecated use `import { pippenger } from '@noble/curves/abstract/curve.js';` */\n  msm(points: EdwardsPoint[], scalars: bigint[]): EdwardsPoint;\n}\n/** @deprecated use EdwardsPoint */\nexport type ExtPointType = EdwardsPoint;\n/** @deprecated use EdwardsPointCons */\nexport type ExtPointConstructor = EdwardsPointCons;\n\n/**\n * Twisted Edwards curve options.\n *\n * * a: formula param\n * * d: formula param\n * * p: prime characteristic (order) of finite field, in which arithmetics is done\n * * n: order of prime subgroup a.k.a total amount of valid curve points\n * * h: cofactor. h*n is group order; n is subgroup order\n * * Gx: x coordinate of generator point a.k.a. base point\n * * Gy: y coordinate of generator point\n */\nexport type EdwardsOpts = Readonly<{\n  p: bigint;\n  n: bigint;\n  h: bigint;\n  a: bigint;\n  d: bigint;\n  Gx: bigint;\n  Gy: bigint;\n}>;\n\n/**\n * Extra curve options for Twisted Edwards.\n *\n * * Fp: redefined Field over curve.p\n * * Fn: redefined Field over curve.n\n * * uvRatio: helper function for decompression, calculating (u/v)\n */\nexport type EdwardsExtraOpts = Partial<{\n  Fp: IField<bigint>;\n  Fn: IField<bigint>;\n  FpFnLE: boolean;\n  uvRatio: (u: bigint, v: bigint) => { isValid: boolean; value: bigint };\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) options.\n *\n * * hash: hash function used to hash secret keys and messages\n * * adjustScalarBytes: clears bits to get valid field element\n * * domain: Used for hashing\n * * mapToCurve: for hash-to-curve standard\n * * prehash: RFC 8032 pre-hashing of messages to sign() / verify()\n * * randomBytes: function generating random bytes, used for randomSecretKey\n */\nexport type EdDSAOpts = Partial<{\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  domain: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array;\n  mapToCurve: (scalar: bigint[]) => AffinePoint<bigint>;\n  prehash: FHash;\n  randomBytes: (bytesLength?: number) => Uint8Array;\n}>;\n\n/**\n * EdDSA (Edwards Digital Signature algorithm) interface.\n *\n * Allows to create and verify signatures, create public and secret keys.\n */\nexport interface EdDSA {\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n  getPublicKey: (secretKey: Hex) => Uint8Array;\n  sign: (message: Hex, secretKey: Hex, options?: { context?: Hex }) => Uint8Array;\n  verify: (\n    sig: Hex,\n    message: Hex,\n    publicKey: Hex,\n    options?: { context?: Hex; zip215: boolean }\n  ) => boolean;\n  Point: EdwardsPointCons;\n  utils: {\n    randomSecretKey: (seed?: Uint8Array) => Uint8Array;\n    isValidSecretKey: (secretKey: Uint8Array) => boolean;\n    isValidPublicKey: (publicKey: Uint8Array, zip215?: boolean) => boolean;\n\n    /**\n     * Converts ed public key to x public key.\n     *\n     * There is NO `fromMontgomery`:\n     * - There are 2 valid ed25519 points for every x25519, with flipped coordinate\n     * - Sometimes there are 0 valid ed25519 points, because x25519 *additionally*\n     *   accepts inputs on the quadratic twist, which can't be moved to ed25519\n     *\n     * @example\n     * ```js\n     * const someonesPub = ed25519.getPublicKey(ed25519.utils.randomSecretKey());\n     * const aPriv = x25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(aPriv, ed25519.utils.toMontgomery(someonesPub))\n     * ```\n     */\n    toMontgomery: (publicKey: Uint8Array) => Uint8Array;\n    /**\n     * Converts ed secret key to x secret key.\n     * @example\n     * ```js\n     * const someonesPub = x25519.getPublicKey(x25519.utils.randomSecretKey());\n     * const aPriv = ed25519.utils.randomSecretKey();\n     * x25519.getSharedSecret(ed25519.utils.toMontgomerySecret(aPriv), someonesPub)\n     * ```\n     */\n    toMontgomerySecret: (privateKey: Uint8Array) => Uint8Array;\n    getExtendedPublicKey: (key: Hex) => {\n      head: Uint8Array;\n      prefix: Uint8Array;\n      scalar: bigint;\n      point: EdwardsPoint;\n      pointBytes: Uint8Array;\n    };\n\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: (seed?: Uint8Array) => Uint8Array;\n    /** @deprecated use `point.precompute()` */\n    precompute: (windowSize?: number, point?: EdwardsPoint) => EdwardsPoint;\n  };\n  lengths: CurveLengths;\n}\n\nfunction isEdValidXY(Fp: IField<bigint>, CURVE: EdwardsOpts, x: bigint, y: bigint): boolean {\n  const x2 = Fp.sqr(x);\n  const y2 = Fp.sqr(y);\n  const left = Fp.add(Fp.mul(CURVE.a, x2), y2);\n  const right = Fp.add(Fp.ONE, Fp.mul(CURVE.d, Fp.mul(x2, y2)));\n  return Fp.eql(left, right);\n}\n\nexport function edwards(params: EdwardsOpts, extraOpts: EdwardsExtraOpts = {}): EdwardsPointCons {\n  const validated = _createCurveFields('edwards', params, extraOpts, extraOpts.FpFnLE);\n  const { Fp, Fn } = validated;\n  let CURVE = validated.CURVE as EdwardsOpts;\n  const { h: cofactor } = CURVE;\n  _validateObject(extraOpts, {}, { uvRatio: 'function' });\n\n  // Important:\n  // There are some places where Fp.BYTES is used instead of nByteLength.\n  // So far, everything has been tested with curves of Fp.BYTES == nByteLength.\n  // TODO: test and find curves which behave otherwise.\n  const MASK = _2n << (BigInt(Fn.BYTES * 8) - _1n);\n  const modP = (n: bigint) => Fp.create(n); // Function overrides\n\n  // sqrt(u/v)\n  const uvRatio =\n    extraOpts.uvRatio ||\n    ((u: bigint, v: bigint) => {\n      try {\n        return { isValid: true, value: Fp.sqrt(Fp.div(u, v)) };\n      } catch (e) {\n        return { isValid: false, value: _0n };\n      }\n    });\n\n  // Validate whether the passed curve params are valid.\n  // equation ax + y = 1 + dxy should work for generator point.\n  if (!isEdValidXY(Fp, CURVE, CURVE.Gx, CURVE.Gy))\n    throw new Error('bad curve params: generator point');\n\n  /**\n   * Asserts coordinate is valid: 0 <= n < MASK.\n   * Coordinates >= Fp.ORDER are allowed for zip215.\n   */\n  function acoord(title: string, n: bigint, banZero = false) {\n    const min = banZero ? _1n : _0n;\n    aInRange('coordinate ' + title, n, min, MASK);\n    return n;\n  }\n\n  function aextpoint(other: unknown) {\n    if (!(other instanceof Point)) throw new Error('ExtendedPoint expected');\n  }\n  // Converts Extended point to default (x, y) coordinates.\n  // Can accept precomputed Z^-1 - for example, from invertBatch.\n  const toAffineMemo = memoized((p: Point, iz?: bigint): AffinePoint<bigint> => {\n    const { X, Y, Z } = p;\n    const is0 = p.is0();\n    if (iz == null) iz = is0 ? _8n : (Fp.inv(Z) as bigint); // 8 was chosen arbitrarily\n    const x = modP(X * iz);\n    const y = modP(Y * iz);\n    const zz = Fp.mul(Z, iz);\n    if (is0) return { x: _0n, y: _1n };\n    if (zz !== _1n) throw new Error('invZ was invalid');\n    return { x, y };\n  });\n  const assertValidMemo = memoized((p: Point) => {\n    const { a, d } = CURVE;\n    if (p.is0()) throw new Error('bad point: ZERO'); // TODO: optimize, with vars below?\n    // Equation in affine coordinates: ax + y = 1 + dxy\n    // Equation in projective coordinates (X/Z, Y/Z, Z):  (aX + Y)Z = Z + dXY\n    const { X, Y, Z, T } = p;\n    const X2 = modP(X * X); // X\n    const Y2 = modP(Y * Y); // Y\n    const Z2 = modP(Z * Z); // Z\n    const Z4 = modP(Z2 * Z2); // Z\n    const aX2 = modP(X2 * a); // aX\n    const left = modP(Z2 * modP(aX2 + Y2)); // (aX + Y)Z\n    const right = modP(Z4 + modP(d * modP(X2 * Y2))); // Z + dXY\n    if (left !== right) throw new Error('bad point: equation left != right (1)');\n    // In Extended coordinates we also have T, which is x*y=T/Z: check X*Y == Z*T\n    const XY = modP(X * Y);\n    const ZT = modP(Z * T);\n    if (XY !== ZT) throw new Error('bad point: equation left != right (2)');\n    return true;\n  });\n\n  // Extended Point works in extended coordinates: (X, Y, Z, T)  (x=X/Z, y=Y/Z, T=xy).\n  // https://en.wikipedia.org/wiki/Twisted_Edwards_curve#Extended_coordinates\n  class Point implements EdwardsPoint {\n    // base / generator point\n    static readonly BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));\n    // zero / infinity / identity point\n    static readonly ZERO = new Point(_0n, _1n, _1n, _0n); // 0, 1, 1, 0\n    // math field\n    static readonly Fp = Fp;\n    // scalar field\n    static readonly Fn = Fn;\n\n    readonly X: bigint;\n    readonly Y: bigint;\n    readonly Z: bigint;\n    readonly T: bigint;\n\n    constructor(X: bigint, Y: bigint, Z: bigint, T: bigint) {\n      this.X = acoord('x', X);\n      this.Y = acoord('y', Y);\n      this.Z = acoord('z', Z, true);\n      this.T = acoord('t', T);\n      Object.freeze(this);\n    }\n\n    static CURVE(): EdwardsOpts {\n      return CURVE;\n    }\n\n    static fromAffine(p: AffinePoint<bigint>): Point {\n      if (p instanceof Point) throw new Error('extended point not allowed');\n      const { x, y } = p || {};\n      acoord('x', x);\n      acoord('y', y);\n      return new Point(x, y, _1n, modP(x * y));\n    }\n\n    // Uses algo from RFC8032 5.1.3.\n    static fromBytes(bytes: Uint8Array, zip215 = false): Point {\n      const len = Fp.BYTES;\n      const { a, d } = CURVE;\n      bytes = copyBytes(abytes(bytes, len, 'point'));\n      abool(zip215, 'zip215');\n      const normed = copyBytes(bytes); // copy again, we'll manipulate it\n      const lastByte = bytes[len - 1]; // select last byte\n      normed[len - 1] = lastByte & ~0x80; // clear last bit\n      const y = bytesToNumberLE(normed);\n\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // RFC8032 prohibits >= p, but ZIP215 doesn't\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      const max = zip215 ? MASK : Fp.ORDER;\n      aInRange('point.y', y, _0n, max);\n\n      // Ed25519: x = (y-1)/(dy+1) mod p. Ed448: x = (y-1)/(dy-1) mod p. Generic case:\n      // ax+y=1+dxy => y-1=dxy-ax => y-1=x(dy-a) => x=(y-1)/(dy-a)\n      const y2 = modP(y * y); // denominator is always non-0 mod p.\n      const u = modP(y2 - _1n); // u = y - 1\n      const v = modP(d * y2 - a); // v = d y + 1.\n      let { isValid, value: x } = uvRatio(u, v); // (u/v)\n      if (!isValid) throw new Error('bad point: invalid y coordinate');\n      const isXOdd = (x & _1n) === _1n; // There are 2 square roots. Use x_0 bit to select proper\n      const isLastByteOdd = (lastByte & 0x80) !== 0; // x_0, last bit\n      if (!zip215 && x === _0n && isLastByteOdd)\n        // if x=0 and x_0 = 1, fail\n        throw new Error('bad point: x=0 and x_0=1');\n      if (isLastByteOdd !== isXOdd) x = modP(-x); // if x_0 != x mod 2, set x = p-x\n      return Point.fromAffine({ x, y });\n    }\n    static fromHex(bytes: Uint8Array, zip215 = false): Point {\n      return Point.fromBytes(ensureBytes('point', bytes), zip215);\n    }\n\n    get x(): bigint {\n      return this.toAffine().x;\n    }\n    get y(): bigint {\n      return this.toAffine().y;\n    }\n\n    precompute(windowSize: number = 8, isLazy = true) {\n      wnaf.createCache(this, windowSize);\n      if (!isLazy) this.multiply(_2n); // random number\n      return this;\n    }\n\n    // Useful in fromAffine() - not for fromBytes(), which always created valid points.\n    assertValidity(): void {\n      assertValidMemo(this);\n    }\n\n    // Compare one point to another.\n    equals(other: Point): boolean {\n      aextpoint(other);\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const { X: X2, Y: Y2, Z: Z2 } = other;\n      const X1Z2 = modP(X1 * Z2);\n      const X2Z1 = modP(X2 * Z1);\n      const Y1Z2 = modP(Y1 * Z2);\n      const Y2Z1 = modP(Y2 * Z1);\n      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;\n    }\n\n    is0(): boolean {\n      return this.equals(Point.ZERO);\n    }\n\n    negate(): Point {\n      // Flips point sign to a negative one (-x, y in affine coords)\n      return new Point(modP(-this.X), this.Y, this.Z, modP(-this.T));\n    }\n\n    // Fast algo for doubling Extended Point.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd\n    // Cost: 4M + 4S + 1*a + 6add + 1*2.\n    double(): Point {\n      const { a } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1 } = this;\n      const A = modP(X1 * X1); // A = X12\n      const B = modP(Y1 * Y1); // B = Y12\n      const C = modP(_2n * modP(Z1 * Z1)); // C = 2*Z12\n      const D = modP(a * A); // D = a*A\n      const x1y1 = X1 + Y1;\n      const E = modP(modP(x1y1 * x1y1) - A - B); // E = (X1+Y1)2-A-B\n      const G = D + B; // G = D+B\n      const F = G - C; // F = G-C\n      const H = D - B; // H = D-B\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    // Fast algo for adding 2 Extended Points.\n    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd\n    // Cost: 9M + 1*a + 1*d + 7add.\n    add(other: Point) {\n      aextpoint(other);\n      const { a, d } = CURVE;\n      const { X: X1, Y: Y1, Z: Z1, T: T1 } = this;\n      const { X: X2, Y: Y2, Z: Z2, T: T2 } = other;\n      const A = modP(X1 * X2); // A = X1*X2\n      const B = modP(Y1 * Y2); // B = Y1*Y2\n      const C = modP(T1 * d * T2); // C = T1*d*T2\n      const D = modP(Z1 * Z2); // D = Z1*Z2\n      const E = modP((X1 + Y1) * (X2 + Y2) - A - B); // E = (X1+Y1)*(X2+Y2)-A-B\n      const F = D - C; // F = D-C\n      const G = D + C; // G = D+C\n      const H = modP(B - a * A); // H = B-a*A\n      const X3 = modP(E * F); // X3 = E*F\n      const Y3 = modP(G * H); // Y3 = G*H\n      const T3 = modP(E * H); // T3 = E*H\n      const Z3 = modP(F * G); // Z3 = F*G\n      return new Point(X3, Y3, Z3, T3);\n    }\n\n    subtract(other: Point): Point {\n      return this.add(other.negate());\n    }\n\n    // Constant-time multiplication.\n    multiply(scalar: bigint): Point {\n      // 1 <= scalar < L\n      if (!Fn.isValidNot0(scalar)) throw new Error('invalid scalar: expected 1 <= sc < curve.n');\n      const { p, f } = wnaf.cached(this, scalar, (p) => normalizeZ(Point, p));\n      return normalizeZ(Point, [p, f])[0];\n    }\n\n    // Non-constant-time multiplication. Uses double-and-add algorithm.\n    // It's faster, but should only be used when you don't care about\n    // an exposed private key e.g. sig verification.\n    // Does NOT allow scalars higher than CURVE.n.\n    // Accepts optional accumulator to merge with multiply (important for sparse scalars)\n    multiplyUnsafe(scalar: bigint, acc = Point.ZERO): Point {\n      // 0 <= scalar < L\n      if (!Fn.isValid(scalar)) throw new Error('invalid scalar: expected 0 <= sc < curve.n');\n      if (scalar === _0n) return Point.ZERO;\n      if (this.is0() || scalar === _1n) return this;\n      return wnaf.unsafe(this, scalar, (p) => normalizeZ(Point, p), acc);\n    }\n\n    // Checks if point is of small order.\n    // If you add something to small order point, you will have \"dirty\"\n    // point with torsion component.\n    // Multiplies point by cofactor and checks if the result is 0.\n    isSmallOrder(): boolean {\n      return this.multiplyUnsafe(cofactor).is0();\n    }\n\n    // Multiplies point by curve order and checks if the result is 0.\n    // Returns `false` is the point is dirty.\n    isTorsionFree(): boolean {\n      return wnaf.unsafe(this, CURVE.n).is0();\n    }\n\n    // Converts Extended point to default (x, y) coordinates.\n    // Can accept precomputed Z^-1 - for example, from invertBatch.\n    toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n      return toAffineMemo(this, invertedZ);\n    }\n\n    clearCofactor(): Point {\n      if (cofactor === _1n) return this;\n      return this.multiplyUnsafe(cofactor);\n    }\n\n    toBytes(): Uint8Array {\n      const { x, y } = this.toAffine();\n      // Fp.toBytes() allows non-canonical encoding of y (>= p).\n      const bytes = Fp.toBytes(y);\n      // Each y has 2 valid points: (x, y), (x,-y).\n      // When compressing, it's enough to store y and use the last byte to encode sign of x\n      bytes[bytes.length - 1] |= x & _1n ? 0x80 : 0;\n      return bytes;\n    }\n    toHex(): string {\n      return bytesToHex(this.toBytes());\n    }\n\n    toString() {\n      return `<Point ${this.is0() ? 'ZERO' : this.toHex()}>`;\n    }\n\n    // TODO: remove\n    get ex(): bigint {\n      return this.X;\n    }\n    get ey(): bigint {\n      return this.Y;\n    }\n    get ez(): bigint {\n      return this.Z;\n    }\n    get et(): bigint {\n      return this.T;\n    }\n    static normalizeZ(points: Point[]): Point[] {\n      return normalizeZ(Point, points);\n    }\n    static msm(points: Point[], scalars: bigint[]): Point {\n      return pippenger(Point, Fn, points, scalars);\n    }\n    _setWindowSize(windowSize: number) {\n      this.precompute(windowSize);\n    }\n    toRawBytes(): Uint8Array {\n      return this.toBytes();\n    }\n  }\n  const wnaf = new wNAF(Point, Fn.BITS);\n  Point.BASE.precompute(8); // Enable precomputes. Slows down first publicKey computation by 20ms.\n  return Point;\n}\n\n/**\n * Base class for prime-order points like Ristretto255 and Decaf448.\n * These points eliminate cofactor issues by representing equivalence classes\n * of Edwards curve points.\n */\nexport abstract class PrimeEdwardsPoint<T extends PrimeEdwardsPoint<T>>\n  implements CurvePoint<bigint, T>\n{\n  static BASE: PrimeEdwardsPoint<any>;\n  static ZERO: PrimeEdwardsPoint<any>;\n  static Fp: IField<bigint>;\n  static Fn: IField<bigint>;\n\n  protected readonly ep: EdwardsPoint;\n\n  constructor(ep: EdwardsPoint) {\n    this.ep = ep;\n  }\n\n  // Abstract methods that must be implemented by subclasses\n  abstract toBytes(): Uint8Array;\n  abstract equals(other: T): boolean;\n\n  // Static methods that must be implemented by subclasses\n  static fromBytes(_bytes: Uint8Array): any {\n    notImplemented();\n  }\n\n  static fromHex(_hex: Hex): any {\n    notImplemented();\n  }\n\n  get x(): bigint {\n    return this.toAffine().x;\n  }\n  get y(): bigint {\n    return this.toAffine().y;\n  }\n\n  // Common implementations\n  clearCofactor(): T {\n    // no-op for prime-order groups\n    return this as any;\n  }\n\n  assertValidity(): void {\n    this.ep.assertValidity();\n  }\n\n  toAffine(invertedZ?: bigint): AffinePoint<bigint> {\n    return this.ep.toAffine(invertedZ);\n  }\n\n  toHex(): string {\n    return bytesToHex(this.toBytes());\n  }\n\n  toString(): string {\n    return this.toHex();\n  }\n\n  isTorsionFree(): boolean {\n    return true;\n  }\n\n  isSmallOrder(): boolean {\n    return false;\n  }\n\n  add(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.add(other.ep));\n  }\n\n  subtract(other: T): T {\n    this.assertSame(other);\n    return this.init(this.ep.subtract(other.ep));\n  }\n\n  multiply(scalar: bigint): T {\n    return this.init(this.ep.multiply(scalar));\n  }\n\n  multiplyUnsafe(scalar: bigint): T {\n    return this.init(this.ep.multiplyUnsafe(scalar));\n  }\n\n  double(): T {\n    return this.init(this.ep.double());\n  }\n\n  negate(): T {\n    return this.init(this.ep.negate());\n  }\n\n  precompute(windowSize?: number, isLazy?: boolean): T {\n    return this.init(this.ep.precompute(windowSize, isLazy));\n  }\n\n  // Helper methods\n  abstract is0(): boolean;\n  protected abstract assertSame(other: T): void;\n  protected abstract init(ep: EdwardsPoint): T;\n\n  /** @deprecated use `toBytes` */\n  toRawBytes(): Uint8Array {\n    return this.toBytes();\n  }\n}\n\n/**\n * Initializes EdDSA signatures over given Edwards curve.\n */\nexport function eddsa(Point: EdwardsPointCons, cHash: FHash, eddsaOpts: EdDSAOpts = {}): EdDSA {\n  if (typeof cHash !== 'function') throw new Error('\"hash\" function param is required');\n  _validateObject(\n    eddsaOpts,\n    {},\n    {\n      adjustScalarBytes: 'function',\n      randomBytes: 'function',\n      domain: 'function',\n      prehash: 'function',\n      mapToCurve: 'function',\n    }\n  );\n\n  const { prehash } = eddsaOpts;\n  const { BASE, Fp, Fn } = Point;\n\n  const randomBytes = eddsaOpts.randomBytes || randomBytesWeb;\n  const adjustScalarBytes = eddsaOpts.adjustScalarBytes || ((bytes: Uint8Array) => bytes);\n  const domain =\n    eddsaOpts.domain ||\n    ((data: Uint8Array, ctx: Uint8Array, phflag: boolean) => {\n      abool(phflag, 'phflag');\n      if (ctx.length || phflag) throw new Error('Contexts/pre-hash are not supported');\n      return data;\n    }); // NOOP\n\n  // Little-endian SHA512 with modulo n\n  function modN_LE(hash: Uint8Array): bigint {\n    return Fn.create(bytesToNumberLE(hash)); // Not Fn.fromBytes: it has length limit\n  }\n\n  // Get the hashed private scalar per RFC8032 5.1.5\n  function getPrivateScalar(key: Hex) {\n    const len = lengths.secretKey;\n    key = ensureBytes('private key', key, len);\n    // Hash private key with curve's hash function to produce uniformingly random input\n    // Check byte lengths: ensure(64, h(ensure(32, key)))\n    const hashed = ensureBytes('hashed private key', cHash(key), 2 * len);\n    const head = adjustScalarBytes(hashed.slice(0, len)); // clear first half bits, produce FE\n    const prefix = hashed.slice(len, 2 * len); // second half is called key prefix (5.1.6)\n    const scalar = modN_LE(head); // The actual private scalar\n    return { head, prefix, scalar };\n  }\n\n  /** Convenience method that creates public key from scalar. RFC8032 5.1.5 */\n  function getExtendedPublicKey(secretKey: Hex) {\n    const { head, prefix, scalar } = getPrivateScalar(secretKey);\n    const point = BASE.multiply(scalar); // Point on Edwards curve aka public key\n    const pointBytes = point.toBytes();\n    return { head, prefix, scalar, point, pointBytes };\n  }\n\n  /** Calculates EdDSA pub key. RFC8032 5.1.5. */\n  function getPublicKey(secretKey: Hex): Uint8Array {\n    return getExtendedPublicKey(secretKey).pointBytes;\n  }\n\n  // int('LE', SHA512(dom2(F, C) || msgs)) mod N\n  function hashDomainToScalar(context: Hex = Uint8Array.of(), ...msgs: Uint8Array[]) {\n    const msg = concatBytes(...msgs);\n    return modN_LE(cHash(domain(msg, ensureBytes('context', context), !!prehash)));\n  }\n\n  /** Signs message with privateKey. RFC8032 5.1.6 */\n  function sign(msg: Hex, secretKey: Hex, options: { context?: Hex } = {}): Uint8Array {\n    msg = ensureBytes('message', msg);\n    if (prehash) msg = prehash(msg); // for ed25519ph etc.\n    const { prefix, scalar, pointBytes } = getExtendedPublicKey(secretKey);\n    const r = hashDomainToScalar(options.context, prefix, msg); // r = dom2(F, C) || prefix || PH(M)\n    const R = BASE.multiply(r).toBytes(); // R = rG\n    const k = hashDomainToScalar(options.context, R, pointBytes, msg); // R || A || PH(M)\n    const s = Fn.create(r + k * scalar); // S = (r + k * s) mod L\n    if (!Fn.isValid(s)) throw new Error('sign failed: invalid s'); // 0 <= s < L\n    const rs = concatBytes(R, Fn.toBytes(s));\n    return abytes(rs, lengths.signature, 'result');\n  }\n\n  // verification rule is either zip215 or rfc8032 / nist186-5. Consult fromHex:\n  const verifyOpts: { context?: Hex; zip215?: boolean } = { zip215: true };\n\n  /**\n   * Verifies EdDSA signature against message and public key. RFC8032 5.1.7.\n   * An extended group equation is checked.\n   */\n  function verify(sig: Hex, msg: Hex, publicKey: Hex, options = verifyOpts): boolean {\n    const { context, zip215 } = options;\n    const len = lengths.signature;\n    sig = ensureBytes('signature', sig, len);\n    msg = ensureBytes('message', msg);\n    publicKey = ensureBytes('publicKey', publicKey, lengths.publicKey);\n    if (zip215 !== undefined) abool(zip215, 'zip215');\n    if (prehash) msg = prehash(msg); // for ed25519ph, etc\n\n    const mid = len / 2;\n    const r = sig.subarray(0, mid);\n    const s = bytesToNumberLE(sig.subarray(mid, len));\n    let A, R, SB;\n    try {\n      // zip215=true is good for consensus-critical apps. =false follows RFC8032 / NIST186-5.\n      // zip215=true:  0 <= y < MASK (2^256 for ed25519)\n      // zip215=false: 0 <= y < P (2^255-19 for ed25519)\n      A = Point.fromBytes(publicKey, zip215);\n      R = Point.fromBytes(r, zip215);\n      SB = BASE.multiplyUnsafe(s); // 0 <= s < l is done inside\n    } catch (error) {\n      return false;\n    }\n    if (!zip215 && A.isSmallOrder()) return false; // zip215 allows public keys of small order\n\n    const k = hashDomainToScalar(context, R.toBytes(), A.toBytes(), msg);\n    const RkA = R.add(A.multiplyUnsafe(k));\n    // Extended group equation\n    // [8][S]B = [8]R + [8][k]A'\n    return RkA.subtract(SB).clearCofactor().is0();\n  }\n\n  const _size = Fp.BYTES; // 32 for ed25519, 57 for ed448\n  const lengths = {\n    secretKey: _size,\n    publicKey: _size,\n    signature: 2 * _size,\n    seed: _size,\n  };\n  function randomSecretKey(seed = randomBytes(lengths.seed)): Uint8Array {\n    return abytes(seed, lengths.seed, 'seed');\n  }\n  function keygen(seed?: Uint8Array) {\n    const secretKey = utils.randomSecretKey(seed);\n    return { secretKey, publicKey: getPublicKey(secretKey) };\n  }\n  function isValidSecretKey(key: Uint8Array): boolean {\n    return isBytes(key) && key.length === Fn.BYTES;\n  }\n  function isValidPublicKey(key: Uint8Array, zip215?: boolean): boolean {\n    try {\n      return !!Point.fromBytes(key, zip215);\n    } catch (error) {\n      return false;\n    }\n  }\n\n  const utils = {\n    getExtendedPublicKey,\n    randomSecretKey,\n    isValidSecretKey,\n    isValidPublicKey,\n    /**\n     * Converts ed public key to x public key. Uses formula:\n     * - ed25519:\n     *   - `(u, v) = ((1+y)/(1-y), sqrt(-486664)*u/x)`\n     *   - `(x, y) = (sqrt(-486664)*u/v, (u-1)/(u+1))`\n     * - ed448:\n     *   - `(u, v) = ((y-1)/(y+1), sqrt(156324)*u/x)`\n     *   - `(x, y) = (sqrt(156324)*u/v, (1+u)/(1-u))`\n     */\n    toMontgomery(publicKey: Uint8Array): Uint8Array {\n      const { y } = Point.fromBytes(publicKey);\n      const size = lengths.publicKey;\n      const is25519 = size === 32;\n      if (!is25519 && size !== 57) throw new Error('only defined for 25519 and 448');\n      const u = is25519 ? Fp.div(_1n + y, _1n - y) : Fp.div(y - _1n, y + _1n);\n      return Fp.toBytes(u);\n    },\n\n    toMontgomerySecret(secretKey: Uint8Array): Uint8Array {\n      const size = lengths.secretKey;\n      abytes(secretKey, size);\n      const hashed = cHash(secretKey.subarray(0, size));\n      return adjustScalarBytes(hashed).subarray(0, size);\n    },\n\n    /** @deprecated */\n    randomPrivateKey: randomSecretKey,\n    /** @deprecated */\n    precompute(windowSize = 8, point: EdwardsPoint = Point.BASE): EdwardsPoint {\n      return point.precompute(windowSize, false);\n    },\n  };\n\n  return Object.freeze({\n    keygen,\n    getPublicKey,\n    sign,\n    verify,\n    utils,\n    Point,\n    lengths,\n  });\n}\n\n// TODO: remove everything below\nexport type CurveType = BasicCurve<bigint> & {\n  a: bigint; // curve param a\n  d: bigint; // curve param d\n  /** @deprecated the property will be removed in next release */\n  hash: FHash; // Hashing\n  randomBytes?: (bytesLength?: number) => Uint8Array; // CSPRNG\n  adjustScalarBytes?: (bytes: Uint8Array) => Uint8Array; // clears bits to get valid field elemtn\n  domain?: (data: Uint8Array, ctx: Uint8Array, phflag: boolean) => Uint8Array; // Used for hashing\n  uvRatio?: UVRatio; // Ratio (u/v)\n  prehash?: FHash; // RFC 8032 pre-hashing of messages to sign() / verify()\n  mapToCurve?: (scalar: bigint[]) => AffinePoint<bigint>; // for hash-to-curve standard\n};\nexport type CurveTypeWithLength = Readonly<CurveType & Partial<NLength>>;\nexport type CurveFn = {\n  /** @deprecated the property will be removed in next release */\n  CURVE: CurveType;\n  keygen: EdDSA['keygen'];\n  getPublicKey: EdDSA['getPublicKey'];\n  sign: EdDSA['sign'];\n  verify: EdDSA['verify'];\n  Point: EdwardsPointCons;\n  /** @deprecated use `Point` */\n  ExtendedPoint: EdwardsPointCons;\n  utils: EdDSA['utils'];\n  lengths: CurveLengths;\n};\nexport type EdComposed = {\n  CURVE: EdwardsOpts;\n  curveOpts: EdwardsExtraOpts;\n  hash: FHash;\n  eddsaOpts: EdDSAOpts;\n};\nfunction _eddsa_legacy_opts_to_new(c: CurveTypeWithLength): EdComposed {\n  const CURVE: EdwardsOpts = {\n    a: c.a,\n    d: c.d,\n    p: c.Fp.ORDER,\n    n: c.n,\n    h: c.h,\n    Gx: c.Gx,\n    Gy: c.Gy,\n  };\n  const Fp = c.Fp;\n  const Fn = Field(CURVE.n, c.nBitLength, true);\n  const curveOpts: EdwardsExtraOpts = { Fp, Fn, uvRatio: c.uvRatio };\n  const eddsaOpts: EdDSAOpts = {\n    randomBytes: c.randomBytes,\n    adjustScalarBytes: c.adjustScalarBytes,\n    domain: c.domain,\n    prehash: c.prehash,\n    mapToCurve: c.mapToCurve,\n  };\n  return { CURVE, curveOpts, hash: c.hash, eddsaOpts };\n}\nfunction _eddsa_new_output_to_legacy(c: CurveTypeWithLength, eddsa: EdDSA): CurveFn {\n  const Point = eddsa.Point;\n  const legacy = Object.assign({}, eddsa, {\n    ExtendedPoint: Point,\n    CURVE: c,\n    nBitLength: Point.Fn.BITS,\n    nByteLength: Point.Fn.BYTES,\n  });\n  return legacy;\n}\n// TODO: remove. Use eddsa\nexport function twistedEdwards(c: CurveTypeWithLength): CurveFn {\n  const { CURVE, curveOpts, hash, eddsaOpts } = _eddsa_legacy_opts_to_new(c);\n  const Point = edwards(CURVE, curveOpts);\n  const EDDSA = eddsa(Point, hash, eddsaOpts);\n  return _eddsa_new_output_to_legacy(c, EDDSA);\n}\n", "/**\n * hash-to-curve from RFC 9380.\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * https://www.rfc-editor.org/rfc/rfc9380\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport type { CHash } from '../utils.ts';\nimport {\n  _validateObject,\n  abytes,\n  bytesToNumberBE,\n  concatBytes,\n  isBytes,\n  isHash,\n  utf8ToBytes,\n} from '../utils.ts';\nimport type { AffinePoint, Group, GroupConstructor } from './curve.ts';\nimport { FpInvertBatch, mod, type IField } from './modular.ts';\n\nexport type UnicodeOrBytes = string | Uint8Array;\n\n/**\n * * `DST` is a domain separation tag, defined in section 2.2.5\n * * `p` characteristic of F, where F is a finite field of characteristic p and order q = p^m\n * * `m` is extension degree (1 for prime fields)\n * * `k` is the target security target in bits (e.g. 128), from section 5.1\n * * `expand` is `xmd` (SHA2, SHA3, BLAKE) or `xof` (SHAKE, BLAKE-XOF)\n * * `hash` conforming to `utils.CHash` interface, with `outputLen` / `blockLen` props\n */\nexport type H2COpts = {\n  DST: UnicodeOrBytes;\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n  p: bigint;\n  m: number;\n  k: number;\n};\nexport type H2CHashOpts = {\n  expand: 'xmd' | 'xof';\n  hash: CHash;\n};\n// todo: remove\nexport type Opts = H2COpts;\n\n// Octet Stream to Integer. \"spec\" implementation of os2ip is 2.5x slower vs bytesToNumberBE.\nconst os2ip = bytesToNumberBE;\n\n// Integer to Octet Stream (numberToBytesBE)\nfunction i2osp(value: number, length: number): Uint8Array {\n  anum(value);\n  anum(length);\n  if (value < 0 || value >= 1 << (8 * length)) throw new Error('invalid I2OSP input: ' + value);\n  const res = Array.from({ length }).fill(0) as number[];\n  for (let i = length - 1; i >= 0; i--) {\n    res[i] = value & 0xff;\n    value >>>= 8;\n  }\n  return new Uint8Array(res);\n}\n\nfunction strxor(a: Uint8Array, b: Uint8Array): Uint8Array {\n  const arr = new Uint8Array(a.length);\n  for (let i = 0; i < a.length; i++) {\n    arr[i] = a[i] ^ b[i];\n  }\n  return arr;\n}\n\nfunction anum(item: unknown): void {\n  if (!Number.isSafeInteger(item)) throw new Error('number expected');\n}\n\nfunction normDST(DST: UnicodeOrBytes): Uint8Array {\n  if (!isBytes(DST) && typeof DST !== 'string') throw new Error('DST must be Uint8Array or string');\n  return typeof DST === 'string' ? utf8ToBytes(DST) : DST;\n}\n\n/**\n * Produces a uniformly random byte string using a cryptographic hash function H that outputs b bits.\n * [RFC 9380 5.3.1](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.1).\n */\nexport function expand_message_xmd(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  if (DST.length > 255) DST = H(concatBytes(utf8ToBytes('H2C-OVERSIZE-DST-'), DST));\n  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;\n  const ell = Math.ceil(lenInBytes / b_in_bytes);\n  if (lenInBytes > 65535 || ell > 255) throw new Error('expand_message_xmd: invalid lenInBytes');\n  const DST_prime = concatBytes(DST, i2osp(DST.length, 1));\n  const Z_pad = i2osp(0, r_in_bytes);\n  const l_i_b_str = i2osp(lenInBytes, 2); // len_in_bytes_str\n  const b = new Array<Uint8Array>(ell);\n  const b_0 = H(concatBytes(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));\n  b[0] = H(concatBytes(b_0, i2osp(1, 1), DST_prime));\n  for (let i = 1; i <= ell; i++) {\n    const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];\n    b[i] = H(concatBytes(...args));\n  }\n  const pseudo_random_bytes = concatBytes(...b);\n  return pseudo_random_bytes.slice(0, lenInBytes);\n}\n\n/**\n * Produces a uniformly random byte string using an extendable-output function (XOF) H.\n * 1. The collision resistance of H MUST be at least k bits.\n * 2. H MUST be an XOF that has been proved indifferentiable from\n *    a random oracle under a reasonable cryptographic assumption.\n * [RFC 9380 5.3.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.3.2).\n */\nexport function expand_message_xof(\n  msg: Uint8Array,\n  DST: UnicodeOrBytes,\n  lenInBytes: number,\n  k: number,\n  H: CHash\n): Uint8Array {\n  abytes(msg);\n  anum(lenInBytes);\n  DST = normDST(DST);\n  // https://www.rfc-editor.org/rfc/rfc9380#section-5.3.3\n  // DST = H('H2C-OVERSIZE-DST-' || a_very_long_DST, Math.ceil((lenInBytes * k) / 8));\n  if (DST.length > 255) {\n    const dkLen = Math.ceil((2 * k) / 8);\n    DST = H.create({ dkLen }).update(utf8ToBytes('H2C-OVERSIZE-DST-')).update(DST).digest();\n  }\n  if (lenInBytes > 65535 || DST.length > 255)\n    throw new Error('expand_message_xof: invalid lenInBytes');\n  return (\n    H.create({ dkLen: lenInBytes })\n      .update(msg)\n      .update(i2osp(lenInBytes, 2))\n      // 2. DST_prime = DST || I2OSP(len(DST), 1)\n      .update(DST)\n      .update(i2osp(DST.length, 1))\n      .digest()\n  );\n}\n\n/**\n * Hashes arbitrary-length byte strings to a list of one or more elements of a finite field F.\n * [RFC 9380 5.2](https://www.rfc-editor.org/rfc/rfc9380#section-5.2).\n * @param msg a byte string containing the message to hash\n * @param count the number of elements of F to output\n * @param options `{DST: string, p: bigint, m: number, k: number, expand: 'xmd' | 'xof', hash: H}`, see above\n * @returns [u_0, ..., u_(count - 1)], a list of field elements.\n */\nexport function hash_to_field(msg: Uint8Array, count: number, options: H2COpts): bigint[][] {\n  _validateObject(options, {\n    p: 'bigint',\n    m: 'number',\n    k: 'number',\n    hash: 'function',\n  });\n  const { p, k, m, hash, expand, DST } = options;\n  if (!isHash(options.hash)) throw new Error('expected valid hash');\n  abytes(msg);\n  anum(count);\n  const log2p = p.toString(2).length;\n  const L = Math.ceil((log2p + k) / 8); // section 5.1 of ietf draft link above\n  const len_in_bytes = count * m * L;\n  let prb; // pseudo_random_bytes\n  if (expand === 'xmd') {\n    prb = expand_message_xmd(msg, DST, len_in_bytes, hash);\n  } else if (expand === 'xof') {\n    prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);\n  } else if (expand === '_internal_pass') {\n    // for internal tests only\n    prb = msg;\n  } else {\n    throw new Error('expand must be \"xmd\" or \"xof\"');\n  }\n  const u = new Array(count);\n  for (let i = 0; i < count; i++) {\n    const e = new Array(m);\n    for (let j = 0; j < m; j++) {\n      const elm_offset = L * (j + i * m);\n      const tv = prb.subarray(elm_offset, elm_offset + L);\n      e[j] = mod(os2ip(tv), p);\n    }\n    u[i] = e;\n  }\n  return u;\n}\n\nexport type XY<T> = (x: T, y: T) => { x: T; y: T };\nexport type XYRatio<T> = [T[], T[], T[], T[]]; // xn/xd, yn/yd\nexport function isogenyMap<T, F extends IField<T>>(field: F, map: XYRatio<T>): XY<T> {\n  // Make same order as in spec\n  const coeff = map.map((i) => Array.from(i).reverse());\n  return (x: T, y: T) => {\n    const [xn, xd, yn, yd] = coeff.map((val) =>\n      val.reduce((acc, i) => field.add(field.mul(acc, x), i))\n    );\n    // 6.6.3\n    // Exceptional cases of iso_map are inputs that cause the denominator of\n    // either rational function to evaluate to zero; such cases MUST return\n    // the identity point on E.\n    const [xd_inv, yd_inv] = FpInvertBatch(field, [xd, yd], true);\n    x = field.mul(xn, xd_inv); // xNum / xDen\n    y = field.mul(y, field.mul(yn, yd_inv)); // y * (yNum / yDev)\n    return { x, y };\n  };\n}\n\n/** Point interface, which curves must implement to work correctly with the module. */\nexport interface H2CPoint<T> extends Group<H2CPoint<T>> {\n  add(rhs: H2CPoint<T>): H2CPoint<T>;\n  toAffine(iz?: bigint): AffinePoint<T>;\n  clearCofactor(): H2CPoint<T>;\n  assertValidity(): void;\n}\n\nexport interface H2CPointConstructor<T> extends GroupConstructor<H2CPoint<T>> {\n  fromAffine(ap: AffinePoint<T>): H2CPoint<T>;\n}\n\nexport type MapToCurve<T> = (scalar: bigint[]) => AffinePoint<T>;\n\n// Separated from initialization opts, so users won't accidentally change per-curve parameters\n// (changing DST is ok!)\nexport type htfBasicOpts = { DST: UnicodeOrBytes };\nexport type H2CMethod<T> = (msg: Uint8Array, options?: htfBasicOpts) => H2CPoint<T>;\n// TODO: remove\nexport type HTFMethod<T> = H2CMethod<T>;\nexport type MapMethod<T> = (scalars: bigint[]) => H2CPoint<T>;\nexport type H2CHasherBase<T> = {\n  hashToCurve: H2CMethod<T>;\n  hashToScalar: (msg: Uint8Array, options: htfBasicOpts) => bigint;\n};\n/**\n * RFC 9380 methods, with cofactor clearing. See https://www.rfc-editor.org/rfc/rfc9380#section-3.\n *\n * * hashToCurve: `map(hash(input))`, encodes RANDOM bytes to curve (WITH hashing)\n * * encodeToCurve: `map(hash(input))`, encodes NON-UNIFORM bytes to curve (WITH hashing)\n * * mapToCurve: `map(scalars)`, encodes NON-UNIFORM scalars to curve (NO hashing)\n */\nexport type H2CHasher<T> = H2CHasherBase<T> & {\n  encodeToCurve: H2CMethod<T>;\n  mapToCurve: MapMethod<T>;\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes };\n};\n// TODO: remove\nexport type Hasher<T> = H2CHasher<T>;\n\nexport const _DST_scalar: Uint8Array = utf8ToBytes('HashToScalar-');\n\n/** Creates hash-to-curve methods from EC Point and mapToCurve function. See {@link H2CHasher}. */\nexport function createHasher<T>(\n  Point: H2CPointConstructor<T>,\n  mapToCurve: MapToCurve<T>,\n  defaults: H2COpts & { encodeDST?: UnicodeOrBytes }\n): H2CHasher<T> {\n  if (typeof mapToCurve !== 'function') throw new Error('mapToCurve() must be defined');\n  function map(num: bigint[]) {\n    return Point.fromAffine(mapToCurve(num));\n  }\n  function clear(initial: H2CPoint<T>) {\n    const P = initial.clearCofactor();\n    if (P.equals(Point.ZERO)) return Point.ZERO; // zero will throw in assert\n    P.assertValidity();\n    return P;\n  }\n\n  return {\n    defaults,\n\n    hashToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const opts = Object.assign({}, defaults, options);\n      const u = hash_to_field(msg, 2, opts);\n      const u0 = map(u[0]);\n      const u1 = map(u[1]);\n      return clear(u0.add(u1));\n    },\n    encodeToCurve(msg: Uint8Array, options?: htfBasicOpts): H2CPoint<T> {\n      const optsDst = defaults.encodeDST ? { DST: defaults.encodeDST } : {};\n      const opts = Object.assign({}, defaults, optsDst, options);\n      const u = hash_to_field(msg, 1, opts);\n      const u0 = map(u[0]);\n      return clear(u0);\n    },\n    /** See {@link H2CHasher} */\n    mapToCurve(scalars: bigint[]): H2CPoint<T> {\n      if (!Array.isArray(scalars)) throw new Error('expected array of bigints');\n      for (const i of scalars)\n        if (typeof i !== 'bigint') throw new Error('expected array of bigints');\n      return clear(map(scalars));\n    },\n\n    // hash_to_scalar can produce 0: https://www.rfc-editor.org/errata/eid8393\n    // RFC 9380, draft-irtf-cfrg-bbs-signatures-08\n    hashToScalar(msg: Uint8Array, options?: htfBasicOpts): bigint {\n      // @ts-ignore\n      const N = Point.Fn.ORDER;\n      const opts = Object.assign({}, defaults, { p: N, m: 1, DST: _DST_scalar }, options);\n      return hash_to_field(msg, 1, opts)[0][0];\n    },\n  };\n}\n", "/**\n * Montgomery curve methods. It's not really whole montgomery curve,\n * just bunch of very specific methods for X25519 / X448 from\n * [RFC 7748](https://www.rfc-editor.org/rfc/rfc7748)\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  _validateObject,\n  abytes,\n  aInRange,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesLE,\n  randomBytes,\n} from '../utils.ts';\nimport type { CurveLengths } from './curve.ts';\nimport { mod } from './modular.ts';\n\nconst _0n = BigInt(0);\nconst _1n = BigInt(1);\nconst _2n = BigInt(2);\ntype Hex = string | Uint8Array;\n\nexport type CurveType = {\n  P: bigint; // finite field prime\n  type: 'x25519' | 'x448';\n  adjustScalarBytes: (bytes: Uint8Array) => Uint8Array;\n  powPminus2: (x: bigint) => bigint;\n  randomBytes?: (bytesLength?: number) => Uint8Array;\n};\n\nexport type MontgomeryECDH = {\n  scalarMult: (scalar: Hex, u: Hex) => Uint8Array;\n  scalarMultBase: (scalar: Hex) => Uint8Array;\n  getSharedSecret: (secretKeyA: Hex, publicKeyB: Hex) => Uint8Array;\n  getPublicKey: (secretKey: Hex) => Uint8Array;\n  utils: {\n    randomSecretKey: () => Uint8Array;\n    /** @deprecated use `randomSecretKey` */\n    randomPrivateKey: () => Uint8Array;\n  };\n  GuBytes: Uint8Array;\n  lengths: CurveLengths;\n  keygen: (seed?: Uint8Array) => { secretKey: Uint8Array; publicKey: Uint8Array };\n};\nexport type CurveFn = MontgomeryECDH;\n\nfunction validateOpts(curve: CurveType) {\n  _validateObject(curve, {\n    adjustScalarBytes: 'function',\n    powPminus2: 'function',\n  });\n  return Object.freeze({ ...curve } as const);\n}\n\nexport function montgomery(curveDef: CurveType): MontgomeryECDH {\n  const CURVE = validateOpts(curveDef);\n  const { P, type, adjustScalarBytes, powPminus2, randomBytes: rand } = CURVE;\n  const is25519 = type === 'x25519';\n  if (!is25519 && type !== 'x448') throw new Error('invalid type');\n  const randomBytes_ = rand || randomBytes;\n\n  const montgomeryBits = is25519 ? 255 : 448;\n  const fieldLen = is25519 ? 32 : 56;\n  const Gu = is25519 ? BigInt(9) : BigInt(5);\n  // RFC 7748 #5:\n  // The constant a24 is (486662 - 2) / 4 = 121665 for curve25519/X25519 and\n  // (156326 - 2) / 4 = 39081 for curve448/X448\n  // const a = is25519 ? 156326n : 486662n;\n  const a24 = is25519 ? BigInt(121665) : BigInt(39081);\n  // RFC: x25519 \"the resulting integer is of the form 2^254 plus\n  // eight times a value between 0 and 2^251 - 1 (inclusive)\"\n  // x448: \"2^447 plus four times a value between 0 and 2^445 - 1 (inclusive)\"\n  const minScalar = is25519 ? _2n ** BigInt(254) : _2n ** BigInt(447);\n  const maxAdded = is25519\n    ? BigInt(8) * _2n ** BigInt(251) - _1n\n    : BigInt(4) * _2n ** BigInt(445) - _1n;\n  const maxScalar = minScalar + maxAdded + _1n; // (inclusive)\n  const modP = (n: bigint) => mod(n, P);\n  const GuBytes = encodeU(Gu);\n  function encodeU(u: bigint): Uint8Array {\n    return numberToBytesLE(modP(u), fieldLen);\n  }\n  function decodeU(u: Hex): bigint {\n    const _u = ensureBytes('u coordinate', u, fieldLen);\n    // RFC: When receiving such an array, implementations of X25519\n    // (but not X448) MUST mask the most significant bit in the final byte.\n    if (is25519) _u[31] &= 127; // 0b0111_1111\n    // RFC: Implementations MUST accept non-canonical values and process them as\n    // if they had been reduced modulo the field prime.  The non-canonical\n    // values are 2^255 - 19 through 2^255 - 1 for X25519 and 2^448 - 2^224\n    // - 1 through 2^448 - 1 for X448.\n    return modP(bytesToNumberLE(_u));\n  }\n  function decodeScalar(scalar: Hex): bigint {\n    return bytesToNumberLE(adjustScalarBytes(ensureBytes('scalar', scalar, fieldLen)));\n  }\n  function scalarMult(scalar: Hex, u: Hex): Uint8Array {\n    const pu = montgomeryLadder(decodeU(u), decodeScalar(scalar));\n    // Some public keys are useless, of low-order. Curve author doesn't think\n    // it needs to be validated, but we do it nonetheless.\n    // https://cr.yp.to/ecdh.html#validate\n    if (pu === _0n) throw new Error('invalid private or public key received');\n    return encodeU(pu);\n  }\n  // Computes public key from private. By doing scalar multiplication of base point.\n  function scalarMultBase(scalar: Hex): Uint8Array {\n    return scalarMult(scalar, GuBytes);\n  }\n\n  // cswap from RFC7748 \"example code\"\n  function cswap(swap: bigint, x_2: bigint, x_3: bigint): { x_2: bigint; x_3: bigint } {\n    // dummy = mask(swap) AND (x_2 XOR x_3)\n    // Where mask(swap) is the all-1 or all-0 word of the same length as x_2\n    // and x_3, computed, e.g., as mask(swap) = 0 - swap.\n    const dummy = modP(swap * (x_2 - x_3));\n    x_2 = modP(x_2 - dummy); // x_2 = x_2 XOR dummy\n    x_3 = modP(x_3 + dummy); // x_3 = x_3 XOR dummy\n    return { x_2, x_3 };\n  }\n\n  /**\n   * Montgomery x-only multiplication ladder.\n   * @param pointU u coordinate (x) on Montgomery Curve 25519\n   * @param scalar by which the point would be multiplied\n   * @returns new Point on Montgomery curve\n   */\n  function montgomeryLadder(u: bigint, scalar: bigint): bigint {\n    aInRange('u', u, _0n, P);\n    aInRange('scalar', scalar, minScalar, maxScalar);\n    const k = scalar;\n    const x_1 = u;\n    let x_2 = _1n;\n    let z_2 = _0n;\n    let x_3 = u;\n    let z_3 = _1n;\n    let swap = _0n;\n    for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {\n      const k_t = (k >> t) & _1n;\n      swap ^= k_t;\n      ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n      ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n      swap = k_t;\n\n      const A = x_2 + z_2;\n      const AA = modP(A * A);\n      const B = x_2 - z_2;\n      const BB = modP(B * B);\n      const E = AA - BB;\n      const C = x_3 + z_3;\n      const D = x_3 - z_3;\n      const DA = modP(D * A);\n      const CB = modP(C * B);\n      const dacb = DA + CB;\n      const da_cb = DA - CB;\n      x_3 = modP(dacb * dacb);\n      z_3 = modP(x_1 * modP(da_cb * da_cb));\n      x_2 = modP(AA * BB);\n      z_2 = modP(E * (AA + modP(a24 * E)));\n    }\n    ({ x_2, x_3 } = cswap(swap, x_2, x_3));\n    ({ x_2: z_2, x_3: z_3 } = cswap(swap, z_2, z_3));\n    const z2 = powPminus2(z_2); // `Fp.pow(x, P - _2n)` is much slower equivalent\n    return modP(x_2 * z2); // Return x_2 * (z_2^(p - 2))\n  }\n  const lengths = {\n    secretKey: fieldLen,\n    publicKey: fieldLen,\n    seed: fieldLen,\n  };\n  const randomSecretKey = (seed = randomBytes_(fieldLen)) => {\n    abytes(seed, lengths.seed);\n    return seed;\n  };\n  function keygen(seed?: Uint8Array) {\n    const secretKey = randomSecretKey(seed);\n    return { secretKey, publicKey: scalarMultBase(secretKey) };\n  }\n  const utils = {\n    randomSecretKey,\n    randomPrivateKey: randomSecretKey,\n  };\n  return {\n    keygen,\n    getSharedSecret: (secretKey: Hex, publicKey: Hex) => scalarMult(secretKey, publicKey),\n    getPublicKey: (secretKey: Hex): Uint8Array => scalarMultBase(secretKey),\n    scalarMult,\n    scalarMultBase,\n    utils,\n    GuBytes: GuBytes.slice(),\n    lengths,\n  };\n}\n", "/**\n * ed25519 Twisted Edwards curve with following addons:\n * - X25519 ECDH\n * - Ristretto cofactor elimination\n * - Elligator hash-to-group / point indistinguishability\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport { sha512 } from '@noble/hashes/sha2.js';\nimport { abytes, concatBytes, utf8ToBytes } from '@noble/hashes/utils.js';\nimport { pippenger, type AffinePoint } from './abstract/curve.ts';\nimport {\n  PrimeEdwardsPoint,\n  twistedEdwards,\n  type CurveFn,\n  type EdwardsOpts,\n  type EdwardsPoint,\n} from './abstract/edwards.ts';\nimport {\n  _DST_scalar,\n  createHasher,\n  expand_message_xmd,\n  type H2CHasher,\n  type H2CHasherBase,\n  type H2CMethod,\n  type htfBasicOpts,\n} from './abstract/hash-to-curve.ts';\nimport {\n  Field,\n  FpInvertBatch,\n  FpSqrtEven,\n  isNegativeLE,\n  mod,\n  pow2,\n  type IField,\n} from './abstract/modular.ts';\nimport { montgomery, type MontgomeryECDH as XCurveFn } from './abstract/montgomery.ts';\nimport { bytesToNumberLE, ensureBytes, equalBytes, type Hex } from './utils.ts';\n\n// prettier-ignore\nconst _0n = /* @__PURE__ */ BigInt(0), _1n = BigInt(1), _2n = BigInt(2), _3n = BigInt(3);\n// prettier-ignore\nconst _5n = BigInt(5), _8n = BigInt(8);\n\n// P = 2n**255n-19n\nconst ed25519_CURVE_p = BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffed'\n);\n\n// N = 2n**252n + 27742317777372353535851937790883648493n\n// a = Fp.create(BigInt(-1))\n// d = -121665/121666 a.k.a. Fp.neg(121665 * Fp.inv(121666))\nconst ed25519_CURVE: EdwardsOpts = /* @__PURE__ */ (() => ({\n  p: ed25519_CURVE_p,\n  n: BigInt('0x1000000000000000000000000000000014def9dea2f79cd65812631a5cf5d3ed'),\n  h: _8n,\n  a: BigInt('0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec'),\n  d: BigInt('0x52036cee2b6ffe738cc740797779e89800700a4d4141d8ab75eb4dca135978a3'),\n  Gx: BigInt('0x216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a'),\n  Gy: BigInt('0x6666666666666666666666666666666666666666666666666666666666666658'),\n}))();\n\nfunction ed25519_pow_2_252_3(x: bigint) {\n  // prettier-ignore\n  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);\n  const P = ed25519_CURVE_p;\n  const x2 = (x * x) % P;\n  const b2 = (x2 * x) % P; // x^3, 11\n  const b4 = (pow2(b2, _2n, P) * b2) % P; // x^15, 1111\n  const b5 = (pow2(b4, _1n, P) * x) % P; // x^31\n  const b10 = (pow2(b5, _5n, P) * b5) % P;\n  const b20 = (pow2(b10, _10n, P) * b10) % P;\n  const b40 = (pow2(b20, _20n, P) * b20) % P;\n  const b80 = (pow2(b40, _40n, P) * b40) % P;\n  const b160 = (pow2(b80, _80n, P) * b80) % P;\n  const b240 = (pow2(b160, _80n, P) * b80) % P;\n  const b250 = (pow2(b240, _10n, P) * b10) % P;\n  const pow_p_5_8 = (pow2(b250, _2n, P) * x) % P;\n  // ^ To pow to (p+3)/8, multiply it by x.\n  return { pow_p_5_8, b2 };\n}\n\nfunction adjustScalarBytes(bytes: Uint8Array): Uint8Array {\n  // Section 5: For X25519, in order to decode 32 random bytes as an integer scalar,\n  // set the three least significant bits of the first byte\n  bytes[0] &= 248; // 0b1111_1000\n  // and the most significant bit of the last to zero,\n  bytes[31] &= 127; // 0b0111_1111\n  // set the second most significant bit of the last byte to 1\n  bytes[31] |= 64; // 0b0100_0000\n  return bytes;\n}\n\n// (-1) aka (a) aka 2^((p-1)/4)\n// Fp.sqrt(Fp.neg(1))\nconst ED25519_SQRT_M1 = /* @__PURE__ */ BigInt(\n  '19681161376707505956807079304988542015446066515923890162744021073123829784752'\n);\n// sqrt(u/v)\nfunction uvRatio(u: bigint, v: bigint): { isValid: boolean; value: bigint } {\n  const P = ed25519_CURVE_p;\n  const v3 = mod(v * v * v, P); // v\n  const v7 = mod(v3 * v3 * v, P); // v\n  // (p+3)/8 and (p-5)/8\n  const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;\n  let x = mod(u * v3 * pow, P); // (uv)(uv)^(p-5)/8\n  const vx2 = mod(v * x * x, P); // vx\n  const root1 = x; // First root candidate\n  const root2 = mod(x * ED25519_SQRT_M1, P); // Second root candidate\n  const useRoot1 = vx2 === u; // If vx = u (mod p), x is a square root\n  const useRoot2 = vx2 === mod(-u, P); // If vx = -u, set x <-- x * 2^((p-1)/4)\n  const noRoot = vx2 === mod(-u * ED25519_SQRT_M1, P); // There is no valid root, vx = -u(-1)\n  if (useRoot1) x = root1;\n  if (useRoot2 || noRoot) x = root2; // We return root2 anyway, for const-time\n  if (isNegativeLE(x, P)) x = mod(-x, P);\n  return { isValid: useRoot1 || useRoot2, value: x };\n}\n\nconst Fp = /* @__PURE__ */ (() => Field(ed25519_CURVE.p, { isLE: true }))();\nconst Fn = /* @__PURE__ */ (() => Field(ed25519_CURVE.n, { isLE: true }))();\n\nconst ed25519Defaults = /* @__PURE__ */ (() => ({\n  ...ed25519_CURVE,\n  Fp,\n  hash: sha512,\n  adjustScalarBytes,\n  // dom2\n  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.\n  // Constant-time, u/v\n  uvRatio,\n}))();\n\n/**\n * ed25519 curve with EdDSA signatures.\n * @example\n * import { ed25519 } from '@noble/curves/ed25519';\n * const { secretKey, publicKey } = ed25519.keygen();\n * const msg = new TextEncoder().encode('hello');\n * const sig = ed25519.sign(msg, priv);\n * ed25519.verify(sig, msg, pub); // Default mode: follows ZIP215\n * ed25519.verify(sig, msg, pub, { zip215: false }); // RFC8032 / FIPS 186-5\n */\nexport const ed25519: CurveFn = /* @__PURE__ */ (() => twistedEdwards(ed25519Defaults))();\n\nfunction ed25519_domain(data: Uint8Array, ctx: Uint8Array, phflag: boolean) {\n  if (ctx.length > 255) throw new Error('Context is too big');\n  return concatBytes(\n    utf8ToBytes('SigEd25519 no Ed25519 collisions'),\n    new Uint8Array([phflag ? 1 : 0, ctx.length]),\n    ctx,\n    data\n  );\n}\n\n/** Context of ed25519. Uses context for domain separation. */\nexport const ed25519ctx: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards({\n    ...ed25519Defaults,\n    domain: ed25519_domain,\n  }))();\n\n/** Prehashed version of ed25519. Accepts already-hashed messages in sign() and verify(). */\nexport const ed25519ph: CurveFn = /* @__PURE__ */ (() =>\n  twistedEdwards(\n    Object.assign({}, ed25519Defaults, {\n      domain: ed25519_domain,\n      prehash: sha512,\n    })\n  ))();\n\n/**\n * ECDH using curve25519 aka x25519.\n * @example\n * import { x25519 } from '@noble/curves/ed25519';\n * const priv = 'a546e36bf0527c9d3b16154b82465edd62144c0ac1fc5a18506a2244ba449ac4';\n * const pub = 'e6db6867583030db3594c1a424b15f7c726624ec26b3353b10a903a6d0ab1c4c';\n * x25519.getSharedSecret(priv, pub) === x25519.scalarMult(priv, pub); // aliases\n * x25519.getPublicKey(priv) === x25519.scalarMultBase(priv);\n * x25519.getPublicKey(x25519.utils.randomSecretKey());\n */\nexport const x25519: XCurveFn = /* @__PURE__ */ (() => {\n  const P = Fp.ORDER;\n  return montgomery({\n    P,\n    type: 'x25519',\n    powPminus2: (x: bigint): bigint => {\n      // x^(p-2) aka x^(2^255-21)\n      const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);\n      return mod(pow2(pow_p_5_8, _3n, P) * b2, P);\n    },\n    adjustScalarBytes,\n  });\n})();\n\n// Hash To Curve Elligator2 Map (NOTE: different from ristretto255 elligator)\n// NOTE: very important part is usage of FpSqrtEven for ELL2_C1_EDWARDS, since\n// SageMath returns different root first and everything falls apart\nconst ELL2_C1 = /* @__PURE__ */ (() => (ed25519_CURVE_p + _3n) / _8n)(); // 1. c1 = (q + 3) / 8       # Integer arithmetic\nconst ELL2_C2 = /* @__PURE__ */ (() => Fp.pow(_2n, ELL2_C1))(); // 2. c2 = 2^c1\nconst ELL2_C3 = /* @__PURE__ */ (() => Fp.sqrt(Fp.neg(Fp.ONE)))(); // 3. c3 = sqrt(-1)\n\n// prettier-ignore\nfunction map_to_curve_elligator2_curve25519(u: bigint) {\n  const ELL2_C4 = (ed25519_CURVE_p - _5n) / _8n; // 4. c4 = (q - 5) / 8       # Integer arithmetic\n  const ELL2_J = BigInt(486662);\n\n  let tv1 = Fp.sqr(u);          //  1.  tv1 = u^2\n  tv1 = Fp.mul(tv1, _2n);       //  2.  tv1 = 2 * tv1\n  let xd = Fp.add(tv1, Fp.ONE); //  3.   xd = tv1 + 1         # Nonzero: -1 is square (mod p), tv1 is not\n  let x1n = Fp.neg(ELL2_J);     //  4.  x1n = -J              # x1 = x1n / xd = -J / (1 + 2 * u^2)\n  let tv2 = Fp.sqr(xd);         //  5.  tv2 = xd^2\n  let gxd = Fp.mul(tv2, xd);    //  6.  gxd = tv2 * xd        # gxd = xd^3\n  let gx1 = Fp.mul(tv1, ELL2_J);//  7.  gx1 = J * tv1         # x1n + J * xd\n  gx1 = Fp.mul(gx1, x1n);       //  8.  gx1 = gx1 * x1n       # x1n^2 + J * x1n * xd\n  gx1 = Fp.add(gx1, tv2);       //  9.  gx1 = gx1 + tv2       # x1n^2 + J * x1n * xd + xd^2\n  gx1 = Fp.mul(gx1, x1n);       //  10. gx1 = gx1 * x1n       # x1n^3 + J * x1n^2 * xd + x1n * xd^2\n  let tv3 = Fp.sqr(gxd);        //  11. tv3 = gxd^2\n  tv2 = Fp.sqr(tv3);            //  12. tv2 = tv3^2           # gxd^4\n  tv3 = Fp.mul(tv3, gxd);       //  13. tv3 = tv3 * gxd       # gxd^3\n  tv3 = Fp.mul(tv3, gx1);       //  14. tv3 = tv3 * gx1       # gx1 * gxd^3\n  tv2 = Fp.mul(tv2, tv3);       //  15. tv2 = tv2 * tv3       # gx1 * gxd^7\n  let y11 = Fp.pow(tv2, ELL2_C4); //  16. y11 = tv2^c4        # (gx1 * gxd^7)^((p - 5) / 8)\n  y11 = Fp.mul(y11, tv3);       //  17. y11 = y11 * tv3       # gx1*gxd^3*(gx1*gxd^7)^((p-5)/8)\n  let y12 = Fp.mul(y11, ELL2_C3); //  18. y12 = y11 * c3\n  tv2 = Fp.sqr(y11);            //  19. tv2 = y11^2\n  tv2 = Fp.mul(tv2, gxd);       //  20. tv2 = tv2 * gxd\n  let e1 = Fp.eql(tv2, gx1);    //  21.  e1 = tv2 == gx1\n  let y1 = Fp.cmov(y12, y11, e1); //  22.  y1 = CMOV(y12, y11, e1)  # If g(x1) is square, this is its sqrt\n  let x2n = Fp.mul(x1n, tv1);   //  23. x2n = x1n * tv1       # x2 = x2n / xd = 2 * u^2 * x1n / xd\n  let y21 = Fp.mul(y11, u);     //  24. y21 = y11 * u\n  y21 = Fp.mul(y21, ELL2_C2);   //  25. y21 = y21 * c2\n  let y22 = Fp.mul(y21, ELL2_C3); //  26. y22 = y21 * c3\n  let gx2 = Fp.mul(gx1, tv1);   //  27. gx2 = gx1 * tv1       # g(x2) = gx2 / gxd = 2 * u^2 * g(x1)\n  tv2 = Fp.sqr(y21);            //  28. tv2 = y21^2\n  tv2 = Fp.mul(tv2, gxd);       //  29. tv2 = tv2 * gxd\n  let e2 = Fp.eql(tv2, gx2);    //  30.  e2 = tv2 == gx2\n  let y2 = Fp.cmov(y22, y21, e2); //  31.  y2 = CMOV(y22, y21, e2)  # If g(x2) is square, this is its sqrt\n  tv2 = Fp.sqr(y1);             //  32. tv2 = y1^2\n  tv2 = Fp.mul(tv2, gxd);       //  33. tv2 = tv2 * gxd\n  let e3 = Fp.eql(tv2, gx1);    //  34.  e3 = tv2 == gx1\n  let xn = Fp.cmov(x2n, x1n, e3); //  35.  xn = CMOV(x2n, x1n, e3)  # If e3, x = x1, else x = x2\n  let y = Fp.cmov(y2, y1, e3);  //  36.   y = CMOV(y2, y1, e3)    # If e3, y = y1, else y = y2\n  let e4 = Fp.isOdd!(y);         //  37.  e4 = sgn0(y) == 1        # Fix sign of y\n  y = Fp.cmov(y, Fp.neg(y), e3 !== e4); //  38.   y = CMOV(y, -y, e3 XOR e4)\n  return { xMn: xn, xMd: xd, yMn: y, yMd: _1n }; //  39. return (xn, xd, y, 1)\n}\n\nconst ELL2_C1_EDWARDS = /* @__PURE__ */ (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))(); // sgn0(c1) MUST equal 0\nfunction map_to_curve_elligator2_edwards25519(u: bigint) {\n  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u); //  1.  (xMn, xMd, yMn, yMd) =\n  // map_to_curve_elligator2_curve25519(u)\n  let xn = Fp.mul(xMn, yMd); //  2.  xn = xMn * yMd\n  xn = Fp.mul(xn, ELL2_C1_EDWARDS); //  3.  xn = xn * c1\n  let xd = Fp.mul(xMd, yMn); //  4.  xd = xMd * yMn    # xn / xd = c1 * xM / yM\n  let yn = Fp.sub(xMn, xMd); //  5.  yn = xMn - xMd\n  let yd = Fp.add(xMn, xMd); //  6.  yd = xMn + xMd    # (n / d - 1) / (n / d + 1) = (n - d) / (n + d)\n  let tv1 = Fp.mul(xd, yd); //  7. tv1 = xd * yd\n  let e = Fp.eql(tv1, Fp.ZERO); //  8.   e = tv1 == 0\n  xn = Fp.cmov(xn, Fp.ZERO, e); //  9.  xn = CMOV(xn, 0, e)\n  xd = Fp.cmov(xd, Fp.ONE, e); //  10. xd = CMOV(xd, 1, e)\n  yn = Fp.cmov(yn, Fp.ONE, e); //  11. yn = CMOV(yn, 1, e)\n  yd = Fp.cmov(yd, Fp.ONE, e); //  12. yd = CMOV(yd, 1, e)\n  const [xd_inv, yd_inv] = FpInvertBatch(Fp, [xd, yd], true); // batch division\n  return { x: Fp.mul(xn, xd_inv), y: Fp.mul(yn, yd_inv) }; //  13. return (xn, xd, yn, yd)\n}\n\n/** Hashing to ed25519 points / field. RFC 9380 methods. */\nexport const ed25519_hasher: H2CHasher<bigint> = /* @__PURE__ */ (() =>\n  createHasher(\n    ed25519.Point,\n    (scalars: bigint[]) => map_to_curve_elligator2_edwards25519(scalars[0]),\n    {\n      DST: 'edwards25519_XMD:SHA-512_ELL2_RO_',\n      encodeDST: 'edwards25519_XMD:SHA-512_ELL2_NU_',\n      p: ed25519_CURVE_p,\n      m: 1,\n      k: 128,\n      expand: 'xmd',\n      hash: sha512,\n    }\n  ))();\n\n// (-1) aka (a) aka 2^((p-1)/4)\nconst SQRT_M1 = ED25519_SQRT_M1;\n// (ad - 1)\nconst SQRT_AD_MINUS_ONE = /* @__PURE__ */ BigInt(\n  '25063068953384623474111414158702152701244531502492656460079210482610430750235'\n);\n// 1 / (a-d)\nconst INVSQRT_A_MINUS_D = /* @__PURE__ */ BigInt(\n  '54469307008909316920995813868745141605393597292927456921205312896311721017578'\n);\n// 1-d\nconst ONE_MINUS_D_SQ = /* @__PURE__ */ BigInt(\n  '1159843021668779879193775521855586647937357759715417654439879720876111806838'\n);\n// (d-1)\nconst D_MINUS_ONE_SQ = /* @__PURE__ */ BigInt(\n  '40440834346308536858101042469323190826248399146238708352240133220865137265952'\n);\n// Calculates 1/(number)\nconst invertSqrt = (number: bigint) => uvRatio(_1n, number);\n\nconst MAX_255B = /* @__PURE__ */ BigInt(\n  '0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'\n);\nconst bytes255ToNumberLE = (bytes: Uint8Array) =>\n  ed25519.Point.Fp.create(bytesToNumberLE(bytes) & MAX_255B);\n\ntype ExtendedPoint = EdwardsPoint;\n\n/**\n * Computes Elligator map for Ristretto255.\n * Described in [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#appendix-B) and on\n * the [website](https://ristretto.group/formulas/elligator.html).\n */\nfunction calcElligatorRistrettoMap(r0: bigint): ExtendedPoint {\n  const { d } = ed25519_CURVE;\n  const P = ed25519_CURVE_p;\n  const mod = (n: bigint) => Fp.create(n);\n  const r = mod(SQRT_M1 * r0 * r0); // 1\n  const Ns = mod((r + _1n) * ONE_MINUS_D_SQ); // 2\n  let c = BigInt(-1); // 3\n  const D = mod((c - d * r) * mod(r + d)); // 4\n  let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D); // 5\n  let s_ = mod(s * r0); // 6\n  if (!isNegativeLE(s_, P)) s_ = mod(-s_);\n  if (!Ns_D_is_sq) s = s_; // 7\n  if (!Ns_D_is_sq) c = r; // 8\n  const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D); // 9\n  const s2 = s * s;\n  const W0 = mod((s + s) * D); // 10\n  const W1 = mod(Nt * SQRT_AD_MINUS_ONE); // 11\n  const W2 = mod(_1n - s2); // 12\n  const W3 = mod(_1n + s2); // 13\n  return new ed25519.Point(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));\n}\n\nfunction ristretto255_map(bytes: Uint8Array): _RistrettoPoint {\n  abytes(bytes, 64);\n  const r1 = bytes255ToNumberLE(bytes.subarray(0, 32));\n  const R1 = calcElligatorRistrettoMap(r1);\n  const r2 = bytes255ToNumberLE(bytes.subarray(32, 64));\n  const R2 = calcElligatorRistrettoMap(r2);\n  return new _RistrettoPoint(R1.add(R2));\n}\n\n/**\n * Wrapper over Edwards Point for ristretto255.\n *\n * Each ed25519/ExtendedPoint has 8 different equivalent points. This can be\n * a source of bugs for protocols like ring signatures. Ristretto was created to solve this.\n * Ristretto point operates in X:Y:Z:T extended coordinates like ExtendedPoint,\n * but it should work in its own namespace: do not combine those two.\n * See [RFC9496](https://www.rfc-editor.org/rfc/rfc9496).\n */\nclass _RistrettoPoint extends PrimeEdwardsPoint<_RistrettoPoint> {\n  // Do NOT change syntax: the following gymnastics is done,\n  // because typescript strips comments, which makes bundlers disable tree-shaking.\n  // prettier-ignore\n  static BASE: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.BASE))();\n  // prettier-ignore\n  static ZERO: _RistrettoPoint =\n    /* @__PURE__ */ (() => new _RistrettoPoint(ed25519.Point.ZERO))();\n  // prettier-ignore\n  static Fp: IField<bigint> =\n    /* @__PURE__ */ (() => Fp)();\n  // prettier-ignore\n  static Fn: IField<bigint> =\n    /* @__PURE__ */ (() => Fn)();\n\n  constructor(ep: ExtendedPoint) {\n    super(ep);\n  }\n\n  static fromAffine(ap: AffinePoint<bigint>): _RistrettoPoint {\n    return new _RistrettoPoint(ed25519.Point.fromAffine(ap));\n  }\n\n  protected assertSame(other: _RistrettoPoint): void {\n    if (!(other instanceof _RistrettoPoint)) throw new Error('RistrettoPoint expected');\n  }\n\n  protected init(ep: EdwardsPoint): _RistrettoPoint {\n    return new _RistrettoPoint(ep);\n  }\n\n  /** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\n  static hashToCurve(hex: Hex): _RistrettoPoint {\n    return ristretto255_map(ensureBytes('ristrettoHash', hex, 64));\n  }\n\n  static fromBytes(bytes: Uint8Array): _RistrettoPoint {\n    abytes(bytes, 32);\n    const { a, d } = ed25519_CURVE;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const s = bytes255ToNumberLE(bytes);\n    // 1. Check that s_bytes is the canonical encoding of a field element, or else abort.\n    // 3. Check that s is non-negative, or else abort\n    if (!equalBytes(Fp.toBytes(s), bytes) || isNegativeLE(s, P))\n      throw new Error('invalid ristretto255 encoding 1');\n    const s2 = mod(s * s);\n    const u1 = mod(_1n + a * s2); // 4 (a is -1)\n    const u2 = mod(_1n - a * s2); // 5\n    const u1_2 = mod(u1 * u1);\n    const u2_2 = mod(u2 * u2);\n    const v = mod(a * d * u1_2 - u2_2); // 6\n    const { isValid, value: I } = invertSqrt(mod(v * u2_2)); // 7\n    const Dx = mod(I * u2); // 8\n    const Dy = mod(I * Dx * v); // 9\n    let x = mod((s + s) * Dx); // 10\n    if (isNegativeLE(x, P)) x = mod(-x); // 10\n    const y = mod(u1 * Dy); // 11\n    const t = mod(x * y); // 12\n    if (!isValid || isNegativeLE(t, P) || y === _0n)\n      throw new Error('invalid ristretto255 encoding 2');\n    return new _RistrettoPoint(new ed25519.Point(x, y, _1n, t));\n  }\n\n  /**\n   * Converts ristretto-encoded string to ristretto point.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-decode).\n   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding\n   */\n  static fromHex(hex: Hex): _RistrettoPoint {\n    return _RistrettoPoint.fromBytes(ensureBytes('ristrettoHex', hex, 32));\n  }\n\n  static msm(points: _RistrettoPoint[], scalars: bigint[]): _RistrettoPoint {\n    return pippenger(_RistrettoPoint, ed25519.Point.Fn, points, scalars);\n  }\n\n  /**\n   * Encodes ristretto point to Uint8Array.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-encode).\n   */\n  toBytes(): Uint8Array {\n    let { X, Y, Z, T } = this.ep;\n    const P = ed25519_CURVE_p;\n    const mod = (n: bigint) => Fp.create(n);\n    const u1 = mod(mod(Z + Y) * mod(Z - Y)); // 1\n    const u2 = mod(X * Y); // 2\n    // Square root always exists\n    const u2sq = mod(u2 * u2);\n    const { value: invsqrt } = invertSqrt(mod(u1 * u2sq)); // 3\n    const D1 = mod(invsqrt * u1); // 4\n    const D2 = mod(invsqrt * u2); // 5\n    const zInv = mod(D1 * D2 * T); // 6\n    let D: bigint; // 7\n    if (isNegativeLE(T * zInv, P)) {\n      let _x = mod(Y * SQRT_M1);\n      let _y = mod(X * SQRT_M1);\n      X = _x;\n      Y = _y;\n      D = mod(D1 * INVSQRT_A_MINUS_D);\n    } else {\n      D = D2; // 8\n    }\n    if (isNegativeLE(X * zInv, P)) Y = mod(-Y); // 9\n    let s = mod((Z - Y) * D); // 10 (check footer's note, no sqrt(-a))\n    if (isNegativeLE(s, P)) s = mod(-s);\n    return Fp.toBytes(s); // 11\n  }\n\n  /**\n   * Compares two Ristretto points.\n   * Described in [RFC9496](https://www.rfc-editor.org/rfc/rfc9496#name-equals).\n   */\n  equals(other: _RistrettoPoint): boolean {\n    this.assertSame(other);\n    const { X: X1, Y: Y1 } = this.ep;\n    const { X: X2, Y: Y2 } = other.ep;\n    const mod = (n: bigint) => Fp.create(n);\n    // (x1 * y2 == y1 * x2) | (y1 * y2 == x1 * x2)\n    const one = mod(X1 * Y2) === mod(Y1 * X2);\n    const two = mod(Y1 * Y2) === mod(X1 * X2);\n    return one || two;\n  }\n\n  is0(): boolean {\n    return this.equals(_RistrettoPoint.ZERO);\n  }\n}\n\nexport const ristretto255: {\n  Point: typeof _RistrettoPoint;\n} = { Point: _RistrettoPoint };\n\n/** Hashing to ristretto255 points / field. RFC 9380 methods. */\nexport const ristretto255_hasher: H2CHasherBase<bigint> = {\n  hashToCurve(msg: Uint8Array, options?: htfBasicOpts): _RistrettoPoint {\n    const DST = options?.DST || 'ristretto255_XMD:SHA-512_R255MAP_RO_';\n    const xmd = expand_message_xmd(msg, DST, 64, sha512);\n    return ristretto255_map(xmd);\n  },\n  hashToScalar(msg: Uint8Array, options: htfBasicOpts = { DST: _DST_scalar }) {\n    const xmd = expand_message_xmd(msg, options.DST, 64, sha512);\n    return Fn.create(bytesToNumberLE(xmd));\n  },\n};\n\n// export const ristretto255_oprf: OPRF = createORPF({\n//   name: 'ristretto255-SHA512',\n//   Point: RistrettoPoint,\n//   hash: sha512,\n//   hashToGroup: ristretto255_hasher.hashToCurve,\n//   hashToScalar: ristretto255_hasher.hashToScalar,\n// });\n\n/**\n * Weird / bogus points, useful for debugging.\n * All 8 ed25519 points of 8-torsion subgroup can be generated from the point\n * T = `26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05`.\n * T = { O, T, 2T, 3T, 4T, 5T, 6T, 7T }\n */\nexport const ED25519_TORSION_SUBGROUP: string[] = [\n  '0100000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a',\n  '0000000000000000000000000000000000000000000000000000000000000080',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05',\n  'ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f',\n  '26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85',\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa',\n];\n\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport function edwardsToMontgomeryPub(edwardsPub: Hex): Uint8Array {\n  return ed25519.utils.toMontgomery(ensureBytes('pub', edwardsPub));\n}\n/** @deprecated use `ed25519.utils.toMontgomery` */\nexport const edwardsToMontgomery: typeof edwardsToMontgomeryPub = edwardsToMontgomeryPub;\n\n/** @deprecated use `ed25519.utils.toMontgomerySecret` */\nexport function edwardsToMontgomeryPriv(edwardsPriv: Uint8Array): Uint8Array {\n  return ed25519.utils.toMontgomerySecret(ensureBytes('pub', edwardsPriv));\n}\n\n/** @deprecated use `ristretto255.Point` */\nexport const RistrettoPoint: typeof _RistrettoPoint = _RistrettoPoint;\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() => ed25519_hasher.hashToCurve)();\n/** @deprecated use `import { ed25519_hasher } from '@noble/curves/ed25519.js';` */\nexport const encodeToCurve: H2CMethod<bigint> = /* @__PURE__ */ (() =>\n  ed25519_hasher.encodeToCurve)();\ntype RistHasher = (msg: Uint8Array, options: htfBasicOpts) => _RistrettoPoint;\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hashToRistretto255: RistHasher = /* @__PURE__ */ (() =>\n  ristretto255_hasher.hashToCurve as RistHasher)();\n/** @deprecated use `import { ristretto255_hasher } from '@noble/curves/ed25519.js';` */\nexport const hash_to_ristretto255: RistHasher = /* @__PURE__ */ (() =>\n  ristretto255_hasher.hashToCurve as RistHasher)();\n", "const defaultErrorConfig = {\r\n    withStackTrace: false,\r\n};\r\n// Custom error object\r\n// Context / discussion: https://github.com/supermacro/neverthrow/pull/215\r\nconst createNeverThrowError = (message, result, config = defaultErrorConfig) => {\r\n    const data = result.isOk()\r\n        ? { type: 'Ok', value: result.value }\r\n        : { type: 'Err', value: result.error };\r\n    const maybeStack = config.withStackTrace ? new Error().stack : undefined;\r\n    return {\r\n        data,\r\n        message,\r\n        stack: maybeStack,\r\n    };\r\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\r\n\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = Object.create((typeof AsyncIterator === \"function\" ? AsyncIterator : Object).prototype), verb(\"next\"), verb(\"throw\"), verb(\"return\", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\r\n    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nclass ResultAsync {\r\n    constructor(res) {\r\n        this._promise = res;\r\n    }\r\n    static fromSafePromise(promise) {\r\n        const newPromise = promise.then((value) => new Ok(value));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    static fromPromise(promise, errorFn) {\r\n        const newPromise = promise\r\n            .then((value) => new Ok(value))\r\n            .catch((e) => new Err(errorFn(e)));\r\n        return new ResultAsync(newPromise);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    static fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            return new ResultAsync((() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    return new Ok(yield fn(...args));\r\n                }\r\n                catch (error) {\r\n                    return new Err(errorFn ? errorFn(error) : error);\r\n                }\r\n            }))());\r\n        };\r\n    }\r\n    static combine(asyncResultList) {\r\n        return combineResultAsyncList(asyncResultList);\r\n    }\r\n    static combineWithAllErrors(asyncResultList) {\r\n        return combineResultAsyncListWithAllErrors(asyncResultList);\r\n    }\r\n    map(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            return new Ok(yield f(res.value));\r\n        })));\r\n    }\r\n    andThrough(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newRes = yield f(res.value);\r\n            if (newRes.isErr()) {\r\n                return new Err(newRes.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    andTee(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            try {\r\n                yield f(res.value);\r\n            }\r\n            catch (e) {\r\n                // Tee does not care about the error\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    orTee(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isOk()) {\r\n                return new Ok(res.value);\r\n            }\r\n            try {\r\n                yield f(res.error);\r\n            }\r\n            catch (e) {\r\n                // Tee does not care about the error\r\n            }\r\n            return new Err(res.error);\r\n        })));\r\n    }\r\n    mapErr(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isOk()) {\r\n                return new Ok(res.value);\r\n            }\r\n            return new Err(yield f(res.error));\r\n        })));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return new ResultAsync(this._promise.then((res) => {\r\n            if (res.isErr()) {\r\n                return new Err(res.error);\r\n            }\r\n            const newValue = f(res.value);\r\n            return newValue instanceof ResultAsync ? newValue._promise : newValue;\r\n        }));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return new ResultAsync(this._promise.then((res) => __awaiter(this, void 0, void 0, function* () {\r\n            if (res.isErr()) {\r\n                return f(res.error);\r\n            }\r\n            return new Ok(res.value);\r\n        })));\r\n    }\r\n    match(ok, _err) {\r\n        return this._promise.then((res) => res.match(ok, _err));\r\n    }\r\n    unwrapOr(t) {\r\n        return this._promise.then((res) => res.unwrapOr(t));\r\n    }\r\n    /**\r\n     * @deprecated will be removed in 9.0.0.\r\n     *\r\n     * You can use `safeTry` without this method.\r\n     * @example\r\n     * ```typescript\r\n     * safeTry(async function* () {\r\n     *   const okValue = yield* yourResult\r\n     * })\r\n     * ```\r\n     * Emulates Rust's `?` operator in `safeTry`'s body. See also `safeTry`.\r\n     */\r\n    safeUnwrap() {\r\n        return __asyncGenerator(this, arguments, function* safeUnwrap_1() {\r\n            return yield __await(yield __await(yield* __asyncDelegator(__asyncValues(yield __await(this._promise.then((res) => res.safeUnwrap()))))));\r\n        });\r\n    }\r\n    // Makes ResultAsync implement PromiseLike<Result>\r\n    then(successCallback, failureCallback) {\r\n        return this._promise.then(successCallback, failureCallback);\r\n    }\r\n    [Symbol.asyncIterator]() {\r\n        return __asyncGenerator(this, arguments, function* _a() {\r\n            const result = yield __await(this._promise);\r\n            if (result.isErr()) {\r\n                // @ts-expect-error -- This is structurally equivalent and safe\r\n                yield yield __await(errAsync(result.error));\r\n            }\r\n            // @ts-expect-error -- This is structurally equivalent and safe\r\n            return yield __await(result.value);\r\n        });\r\n    }\r\n}\r\nfunction okAsync(value) {\r\n    return new ResultAsync(Promise.resolve(new Ok(value)));\r\n}\r\nfunction errAsync(err) {\r\n    return new ResultAsync(Promise.resolve(new Err(err)));\r\n}\r\nconst fromPromise = ResultAsync.fromPromise;\r\nconst fromSafePromise = ResultAsync.fromSafePromise;\r\nconst fromAsyncThrowable = ResultAsync.fromThrowable;\n\n/**\r\n * Short circuits on the FIRST Err value that we find\r\n */\r\nconst combineResultList = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr()) {\r\n            acc = err(result.error);\r\n            break;\r\n        }\r\n        else {\r\n            acc.map((list) => list.push(result.value));\r\n        }\r\n    }\r\n    return acc;\r\n};\r\n/* This is the typesafe version of Promise.all\r\n *\r\n * Takes a list of ResultAsync<T, E> and success if all inner results are Ok values\r\n * or fails if one (or more) of the inner results are Err values\r\n */\r\nconst combineResultAsyncList = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultList);\r\n/**\r\n * Give a list of all the errors we find\r\n */\r\nconst combineResultListWithAllErrors = (resultList) => {\r\n    let acc = ok([]);\r\n    for (const result of resultList) {\r\n        if (result.isErr() && acc.isErr()) {\r\n            acc.error.push(result.error);\r\n        }\r\n        else if (result.isErr() && acc.isOk()) {\r\n            acc = err([result.error]);\r\n        }\r\n        else if (result.isOk() && acc.isOk()) {\r\n            acc.value.push(result.value);\r\n        }\r\n        // do nothing when result.isOk() && acc.isErr()\r\n    }\r\n    return acc;\r\n};\r\nconst combineResultAsyncListWithAllErrors = (asyncResultList) => ResultAsync.fromSafePromise(Promise.all(asyncResultList)).andThen(combineResultListWithAllErrors);\n\n// eslint-disable-next-line @typescript-eslint/no-namespace\r\nvar Result;\r\n(function (Result) {\r\n    /**\r\n     * Wraps a function with a try catch, creating a new function with the same\r\n     * arguments but returning `Ok` if successful, `Err` if the function throws\r\n     *\r\n     * @param fn function to wrap with ok on success or err on failure\r\n     * @param errorFn when an error is thrown, this will wrap the error result if provided\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    function fromThrowable(fn, errorFn) {\r\n        return (...args) => {\r\n            try {\r\n                const result = fn(...args);\r\n                return ok(result);\r\n            }\r\n            catch (e) {\r\n                return err(errorFn ? errorFn(e) : e);\r\n            }\r\n        };\r\n    }\r\n    Result.fromThrowable = fromThrowable;\r\n    function combine(resultList) {\r\n        return combineResultList(resultList);\r\n    }\r\n    Result.combine = combine;\r\n    function combineWithAllErrors(resultList) {\r\n        return combineResultListWithAllErrors(resultList);\r\n    }\r\n    Result.combineWithAllErrors = combineWithAllErrors;\r\n})(Result || (Result = {}));\r\nfunction ok(value) {\r\n    return new Ok(value);\r\n}\r\nfunction err(err) {\r\n    return new Err(err);\r\n}\r\nfunction safeTry(body) {\r\n    const n = body().next();\r\n    if (n instanceof Promise) {\r\n        return new ResultAsync(n.then((r) => r.value));\r\n    }\r\n    return n.value;\r\n}\r\nclass Ok {\r\n    constructor(value) {\r\n        this.value = value;\r\n    }\r\n    isOk() {\r\n        return true;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    map(f) {\r\n        return ok(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    mapErr(_f) {\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThrough(f) {\r\n        return f(this.value).map((_value) => this.value);\r\n    }\r\n    andTee(f) {\r\n        try {\r\n            f(this.value);\r\n        }\r\n        catch (e) {\r\n            // Tee doesn't care about the error\r\n        }\r\n        return ok(this.value);\r\n    }\r\n    orTee(_f) {\r\n        return ok(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(_f) {\r\n        return ok(this.value);\r\n    }\r\n    asyncAndThen(f) {\r\n        return f(this.value);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    asyncAndThrough(f) {\r\n        return f(this.value).map(() => this.value);\r\n    }\r\n    asyncMap(f) {\r\n        return ResultAsync.fromSafePromise(f(this.value));\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    unwrapOr(_v) {\r\n        return this.value;\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    match(ok, _err) {\r\n        return ok(this.value);\r\n    }\r\n    safeUnwrap() {\r\n        const value = this.value;\r\n        /* eslint-disable-next-line require-yield */\r\n        return (function* () {\r\n            return value;\r\n        })();\r\n    }\r\n    _unsafeUnwrap(_) {\r\n        return this.value;\r\n    }\r\n    _unsafeUnwrapErr(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrapErr` on an Ok', this, config);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-this-alias, require-yield\r\n    *[Symbol.iterator]() {\r\n        return this.value;\r\n    }\r\n}\r\nclass Err {\r\n    constructor(error) {\r\n        this.error = error;\r\n    }\r\n    isOk() {\r\n        return false;\r\n    }\r\n    isErr() {\r\n        return !this.isOk();\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    map(_f) {\r\n        return err(this.error);\r\n    }\r\n    mapErr(f) {\r\n        return err(f(this.error));\r\n    }\r\n    andThrough(_f) {\r\n        return err(this.error);\r\n    }\r\n    andTee(_f) {\r\n        return err(this.error);\r\n    }\r\n    orTee(f) {\r\n        try {\r\n            f(this.error);\r\n        }\r\n        catch (e) {\r\n            // Tee doesn't care about the error\r\n        }\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    andThen(_f) {\r\n        return err(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/explicit-module-boundary-types\r\n    orElse(f) {\r\n        return f(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncAndThen(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    asyncAndThrough(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n    asyncMap(_f) {\r\n        return errAsync(this.error);\r\n    }\r\n    unwrapOr(v) {\r\n        return v;\r\n    }\r\n    match(_ok, err) {\r\n        return err(this.error);\r\n    }\r\n    safeUnwrap() {\r\n        const error = this.error;\r\n        return (function* () {\r\n            yield err(error);\r\n            throw new Error('Do not use this generator out of `safeTry`');\r\n        })();\r\n    }\r\n    _unsafeUnwrap(config) {\r\n        throw createNeverThrowError('Called `_unsafeUnwrap` on an Err', this, config);\r\n    }\r\n    _unsafeUnwrapErr(_) {\r\n        return this.error;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\r\n        const self = this;\r\n        // @ts-expect-error -- This is structurally equivalent and safe\r\n        yield self;\r\n        // @ts-expect-error -- This is structurally equivalent and safe\r\n        return self;\r\n    }\r\n}\r\nconst fromThrowable = Result.fromThrowable;\r\n//#endregion\n\nexport { Err, Ok, Result, ResultAsync, err, errAsync, fromAsyncThrowable, fromPromise, fromSafePromise, fromThrowable, ok, okAsync, safeTry };\n", "// Should be no imports here!\n\n/**\n * The sentinel value returned by producers to replace the draft with undefined.\n */\nexport const NOTHING: unique symbol = Symbol.for(\"immer-nothing\")\n\n/**\n * To let Immer treat your class instances as plain immutable objects\n * (albeit with a custom prototype), you must define either an instance property\n * or a static property on each of your custom classes.\n *\n * Otherwise, your class instance will never be drafted, which means it won't be\n * safe to mutate in a produce callback.\n */\nexport const DRAFTABLE: unique symbol = Symbol.for(\"immer-draftable\")\n\nexport const DRAFT_STATE: unique symbol = Symbol.for(\"immer-state\")\n", "export const errors =\n\tprocess.env.NODE_ENV !== \"production\"\n\t\t? [\n\t\t\t\t// All error codes, starting by 0:\n\t\t\t\tfunction(plugin: string) {\n\t\t\t\t\treturn `The plugin for '${plugin}' has not been loaded into Immer. To enable the plugin, import and call \\`enable${plugin}()\\` when initializing your application.`\n\t\t\t\t},\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${thing}'`\n\t\t\t\t},\n\t\t\t\t\"This object has been frozen and should not be mutated\",\n\t\t\t\tfunction(data: any) {\n\t\t\t\t\treturn (\n\t\t\t\t\t\t\"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n\t\t\t\t\t\tdata\n\t\t\t\t\t)\n\t\t\t\t},\n\t\t\t\t\"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\",\n\t\t\t\t\"Immer forbids circular references\",\n\t\t\t\t\"The first or second argument to `produce` must be a function\",\n\t\t\t\t\"The third argument to `produce` must be a function or undefined\",\n\t\t\t\t\"First argument to `createDraft` must be a plain object, an array, or an immerable object\",\n\t\t\t\t\"First argument to `finishDraft` must be a draft returned by `createDraft`\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'current' expects a draft, got: ${thing}`\n\t\t\t\t},\n\t\t\t\t\"Object.defineProperty() cannot be used on an Immer draft\",\n\t\t\t\t\"Object.setPrototypeOf() cannot be used on an Immer draft\",\n\t\t\t\t\"Immer only supports deleting array indices\",\n\t\t\t\t\"Immer only supports setting array indices and the 'length' property\",\n\t\t\t\tfunction(thing: string) {\n\t\t\t\t\treturn `'original' expects a draft, got: ${thing}`\n\t\t\t\t}\n\t\t\t\t// Note: if more errors are added, the errorOffset in Patches.ts should be increased\n\t\t\t\t// See Patches.ts for additional errors\n\t\t  ]\n\t\t: []\n\nexport function die(error: number, ...args: any[]): never {\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\tconst e = errors[error]\n\t\tconst msg = typeof e === \"function\" ? e.apply(null, args as any) : e\n\t\tthrow new Error(`[Immer] ${msg}`)\n\t}\n\tthrow new Error(\n\t\t`[Immer] minified error nr: ${error}. Full error at: https://bit.ly/3cXEKWf`\n\t)\n}\n", "import {\n\tDRAFT_STATE,\n\tDRAFTABLE,\n\tObjectish,\n\tDrafted,\n\tAnyObject,\n\tAnyMap,\n\tAnySet,\n\tImmerState,\n\tArchType,\n\tdie,\n\tStrictMode\n} from \"../internal\"\n\nexport const getPrototypeOf = Object.getPrototypeOf\n\n/** Returns true if the given value is an Immer draft */\n/*#__PURE__*/\nexport function isDraft(value: any): boolean {\n\treturn !!value && !!value[DRAFT_STATE]\n}\n\n/** Returns true if the given value can be drafted by Immer */\n/*#__PURE__*/\nexport function isDraftable(value: any): boolean {\n\tif (!value) return false\n\treturn (\n\t\tisPlainObject(value) ||\n\t\tArray.isArray(value) ||\n\t\t!!value[DRAFTABLE] ||\n\t\t!!value.constructor?.[DRAFTABLE] ||\n\t\tisMap(value) ||\n\t\tisSet(value)\n\t)\n}\n\nconst objectCtorString = Object.prototype.constructor.toString()\n/*#__PURE__*/\nexport function isPlainObject(value: any): boolean {\n\tif (!value || typeof value !== \"object\") return false\n\tconst proto = getPrototypeOf(value)\n\tif (proto === null) {\n\t\treturn true\n\t}\n\tconst Ctor =\n\t\tObject.hasOwnProperty.call(proto, \"constructor\") && proto.constructor\n\n\tif (Ctor === Object) return true\n\n\treturn (\n\t\ttypeof Ctor == \"function\" &&\n\t\tFunction.toString.call(Ctor) === objectCtorString\n\t)\n}\n\n/** Get the underlying object that is represented by the given draft */\n/*#__PURE__*/\nexport function original<T>(value: T): T | undefined\nexport function original(value: Drafted<any>): any {\n\tif (!isDraft(value)) die(15, value)\n\treturn value[DRAFT_STATE].base_\n}\n\n/**\n * Each iterates a map, set or array.\n * Or, if any other kind of object, all of its own properties.\n * Regardless whether they are enumerable or symbols\n */\nexport function each<T extends Objectish>(\n\tobj: T,\n\titer: (key: string | number, value: any, source: T) => void\n): void\nexport function each(obj: any, iter: any) {\n\tif (getArchtype(obj) === ArchType.Object) {\n\t\tReflect.ownKeys(obj).forEach(key => {\n\t\t\titer(key, obj[key], obj)\n\t\t})\n\t} else {\n\t\tobj.forEach((entry: any, index: any) => iter(index, entry, obj))\n\t}\n}\n\n/*#__PURE__*/\nexport function getArchtype(thing: any): ArchType {\n\tconst state: undefined | ImmerState = thing[DRAFT_STATE]\n\treturn state\n\t\t? state.type_\n\t\t: Array.isArray(thing)\n\t\t? ArchType.Array\n\t\t: isMap(thing)\n\t\t? ArchType.Map\n\t\t: isSet(thing)\n\t\t? ArchType.Set\n\t\t: ArchType.Object\n}\n\n/*#__PURE__*/\nexport function has(thing: any, prop: PropertyKey): boolean {\n\treturn getArchtype(thing) === ArchType.Map\n\t\t? thing.has(prop)\n\t\t: Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n/*#__PURE__*/\nexport function get(thing: AnyMap | AnyObject, prop: PropertyKey): any {\n\t// @ts-ignore\n\treturn getArchtype(thing) === ArchType.Map ? thing.get(prop) : thing[prop]\n}\n\n/*#__PURE__*/\nexport function set(thing: any, propOrOldValue: PropertyKey, value: any) {\n\tconst t = getArchtype(thing)\n\tif (t === ArchType.Map) thing.set(propOrOldValue, value)\n\telse if (t === ArchType.Set) {\n\t\tthing.add(value)\n\t} else thing[propOrOldValue] = value\n}\n\n/*#__PURE__*/\nexport function is(x: any, y: any): boolean {\n\t// From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n\tif (x === y) {\n\t\treturn x !== 0 || 1 / x === 1 / y\n\t} else {\n\t\treturn x !== x && y !== y\n\t}\n}\n\n/*#__PURE__*/\nexport function isMap(target: any): target is AnyMap {\n\treturn target instanceof Map\n}\n\n/*#__PURE__*/\nexport function isSet(target: any): target is AnySet {\n\treturn target instanceof Set\n}\n/*#__PURE__*/\nexport function latest(state: ImmerState): any {\n\treturn state.copy_ || state.base_\n}\n\n/*#__PURE__*/\nexport function shallowCopy(base: any, strict: StrictMode) {\n\tif (isMap(base)) {\n\t\treturn new Map(base)\n\t}\n\tif (isSet(base)) {\n\t\treturn new Set(base)\n\t}\n\tif (Array.isArray(base)) return Array.prototype.slice.call(base)\n\n\tconst isPlain = isPlainObject(base)\n\n\tif (strict === true || (strict === \"class_only\" && !isPlain)) {\n\t\t// Perform a strict copy\n\t\tconst descriptors = Object.getOwnPropertyDescriptors(base)\n\t\tdelete descriptors[DRAFT_STATE as any]\n\t\tlet keys = Reflect.ownKeys(descriptors)\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tconst key: any = keys[i]\n\t\t\tconst desc = descriptors[key]\n\t\t\tif (desc.writable === false) {\n\t\t\t\tdesc.writable = true\n\t\t\t\tdesc.configurable = true\n\t\t\t}\n\t\t\t// like object.assign, we will read any _own_, get/set accessors. This helps in dealing\n\t\t\t// with libraries that trap values, like mobx or vue\n\t\t\t// unlike object.assign, non-enumerables will be copied as well\n\t\t\tif (desc.get || desc.set)\n\t\t\t\tdescriptors[key] = {\n\t\t\t\t\tconfigurable: true,\n\t\t\t\t\twritable: true, // could live with !!desc.set as well here...\n\t\t\t\t\tenumerable: desc.enumerable,\n\t\t\t\t\tvalue: base[key]\n\t\t\t\t}\n\t\t}\n\t\treturn Object.create(getPrototypeOf(base), descriptors)\n\t} else {\n\t\t// perform a sloppy copy\n\t\tconst proto = getPrototypeOf(base)\n\t\tif (proto !== null && isPlain) {\n\t\t\treturn {...base} // assumption: better inner class optimization than the assign below\n\t\t}\n\t\tconst obj = Object.create(proto)\n\t\treturn Object.assign(obj, base)\n\t}\n}\n\n/**\n * Freezes draftable objects. Returns the original object.\n * By default freezes shallowly, but if the second argument is `true` it will freeze recursively.\n *\n * @param obj\n * @param deep\n */\nexport function freeze<T>(obj: T, deep?: boolean): T\nexport function freeze<T>(obj: any, deep: boolean = false): T {\n\tif (isFrozen(obj) || isDraft(obj) || !isDraftable(obj)) return obj\n\tif (getArchtype(obj) > 1 /* Map or Set */) {\n\t\t Object.defineProperties(obj, {\n                        set: {value: dontMutateFrozenCollections as any},\n                        add: {value: dontMutateFrozenCollections as any},\n                        clear: {value: dontMutateFrozenCollections as any},\n                        delete: {value: dontMutateFrozenCollections as any}\n                })\n\t}\n\tObject.freeze(obj)\n\tif (deep)\n\t\t// See #590, don't recurse into non-enumerable / Symbol properties when freezing\n\t\t// So use Object.values (only string-like, enumerables) instead of each()\n\t\tObject.values(obj).forEach(value => freeze(value, true))\n\treturn obj\n}\n\nfunction dontMutateFrozenCollections() {\n\tdie(2)\n}\n\nexport function isFrozen(obj: any): boolean {\n\treturn Object.isFrozen(obj)\n}\n", "import {\n\tImmerState,\n\tPatch,\n\tDrafted,\n\tImmerBaseState,\n\tAnyMap,\n\tAnySet,\n\tArchType,\n\tdie\n} from \"../internal\"\n\n/** Plugin utilities */\nconst plugins: {\n\tPatches?: {\n\t\tgeneratePatches_(\n\t\t\tstate: ImmerState,\n\t\t\tbasePath: PatchPath,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tgenerateReplacementPatches_(\n\t\t\tbase: any,\n\t\t\treplacement: any,\n\t\t\tpatches: Patch[],\n\t\t\tinversePatches: Patch[]\n\t\t): void\n\t\tapplyPatches_<T>(draft: T, patches: readonly Patch[]): T\n\t}\n\tMapSet?: {\n\t\tproxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T\n\t\tproxySet_<T extends AnySet>(target: T, parent?: ImmerState): T\n\t}\n} = {}\n\ntype Plugins = typeof plugins\n\nexport function getPlugin<K extends keyof Plugins>(\n\tpluginKey: K\n): Exclude<Plugins[K], undefined> {\n\tconst plugin = plugins[pluginKey]\n\tif (!plugin) {\n\t\tdie(0, pluginKey)\n\t}\n\t// @ts-ignore\n\treturn plugin\n}\n\nexport function loadPlugin<K extends keyof Plugins>(\n\tpluginKey: K,\n\timplementation: Plugins[K]\n): void {\n\tif (!plugins[pluginKey]) plugins[pluginKey] = implementation\n}\n/** Map / Set plugin */\n\nexport interface MapState extends ImmerBaseState {\n\ttype_: ArchType.Map\n\tcopy_: AnyMap | undefined\n\tassigned_: Map<any, boolean> | undefined\n\tbase_: AnyMap\n\trevoked_: boolean\n\tdraft_: Drafted<AnyMap, MapState>\n}\n\nexport interface SetState extends ImmerBaseState {\n\ttype_: ArchType.Set\n\tcopy_: AnySet | undefined\n\tbase_: AnySet\n\tdrafts_: Map<any, Drafted> // maps the original value to the draft value in the new set\n\trevoked_: boolean\n\tdraft_: Drafted<AnySet, SetState>\n}\n\n/** Patches plugin */\n\nexport type PatchPath = (string | number)[]\n", "import {\n\tPatch,\n\tPatchListener,\n\tDrafted,\n\tImmer,\n\tDRAFT_STATE,\n\tImmerState,\n\tArchType,\n\tgetPlugin\n} from \"../internal\"\n\n/** Each scope represents a `produce` call. */\n\nexport interface ImmerScope {\n\tpatches_?: Patch[]\n\tinversePatches_?: Patch[]\n\tcanAutoFreeze_: boolean\n\tdrafts_: any[]\n\tparent_?: ImmerScope\n\tpatchListener_?: PatchListener\n\timmer_: Immer\n\tunfinalizedDrafts_: number\n}\n\nlet currentScope: ImmerScope | undefined\n\nexport function getCurrentScope() {\n\treturn currentScope!\n}\n\nfunction createScope(\n\tparent_: ImmerScope | undefined,\n\timmer_: Immer\n): ImmerScope {\n\treturn {\n\t\tdrafts_: [],\n\t\tparent_,\n\t\timmer_,\n\t\t// Whenever the modified draft contains a draft from another scope, we\n\t\t// need to prevent auto-freezing so the unowned draft can be finalized.\n\t\tcanAutoFreeze_: true,\n\t\tunfinalizedDrafts_: 0\n\t}\n}\n\nexport function usePatchesInScope(\n\tscope: ImmerScope,\n\tpatchListener?: PatchListener\n) {\n\tif (patchListener) {\n\t\tgetPlugin(\"Patches\") // assert we have the plugin\n\t\tscope.patches_ = []\n\t\tscope.inversePatches_ = []\n\t\tscope.patchListener_ = patchListener\n\t}\n}\n\nexport function revokeScope(scope: ImmerScope) {\n\tleaveScope(scope)\n\tscope.drafts_.forEach(revokeDraft)\n\t// @ts-ignore\n\tscope.drafts_ = null\n}\n\nexport function leaveScope(scope: ImmerScope) {\n\tif (scope === currentScope) {\n\t\tcurrentScope = scope.parent_\n\t}\n}\n\nexport function enterScope(immer: Immer) {\n\treturn (currentScope = createScope(currentScope, immer))\n}\n\nfunction revokeDraft(draft: Drafted) {\n\tconst state: ImmerState = draft[DRAFT_STATE]\n\tif (state.type_ === ArchType.Object || state.type_ === ArchType.Array)\n\t\tstate.revoke_()\n\telse state.revoked_ = true\n}\n", "import {\n\tImmerScope,\n\tDRAFT_STATE,\n\tisDraftable,\n\tNOTHING,\n\tPatchPath,\n\teach,\n\thas,\n\tfreeze,\n\tImmerState,\n\tisDraft,\n\tSetState,\n\tset,\n\tArchType,\n\tgetPlugin,\n\tdie,\n\trevokeScope,\n\tisFrozen,\n\tisMap\n} from \"../internal\"\n\nexport function processResult(result: any, scope: ImmerScope) {\n\tscope.unfinalizedDrafts_ = scope.drafts_.length\n\tconst baseDraft = scope.drafts_![0]\n\tconst isReplaced = result !== undefined && result !== baseDraft\n\tif (isReplaced) {\n\t\tif (baseDraft[DRAFT_STATE].modified_) {\n\t\t\trevokeScope(scope)\n\t\t\tdie(4)\n\t\t}\n\t\tif (isDraftable(result)) {\n\t\t\t// Finalize the result in case it contains (or is) a subset of the draft.\n\t\t\tresult = finalize(scope, result)\n\t\t\tif (!scope.parent_) maybeFreeze(scope, result)\n\t\t}\n\t\tif (scope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(\n\t\t\t\tbaseDraft[DRAFT_STATE].base_,\n\t\t\t\tresult,\n\t\t\t\tscope.patches_,\n\t\t\t\tscope.inversePatches_!\n\t\t\t)\n\t\t}\n\t} else {\n\t\t// Finalize the base draft.\n\t\tresult = finalize(scope, baseDraft, [])\n\t}\n\trevokeScope(scope)\n\tif (scope.patches_) {\n\t\tscope.patchListener_!(scope.patches_, scope.inversePatches_!)\n\t}\n\treturn result !== NOTHING ? result : undefined\n}\n\nfunction finalize(rootScope: ImmerScope, value: any, path?: PatchPath) {\n\t// Don't recurse in tho recursive data structures\n\tif (isFrozen(value)) return value\n\n\tconst state: ImmerState = value[DRAFT_STATE]\n\t// A plain object, might need freezing, might contain drafts\n\tif (!state) {\n\t\teach(value, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, value, key, childValue, path)\n\t\t)\n\t\treturn value\n\t}\n\t// Never finalize drafts owned by another scope.\n\tif (state.scope_ !== rootScope) return value\n\t// Unmodified draft, return the (frozen) original\n\tif (!state.modified_) {\n\t\tmaybeFreeze(rootScope, state.base_, true)\n\t\treturn state.base_\n\t}\n\t// Not finalized yet, let's do that now\n\tif (!state.finalized_) {\n\t\tstate.finalized_ = true\n\t\tstate.scope_.unfinalizedDrafts_--\n\t\tconst result = state.copy_\n\t\t// Finalize all children of the copy\n\t\t// For sets we clone before iterating, otherwise we can get in endless loop due to modifying during iteration, see #628\n\t\t// To preserve insertion order in all cases we then clear the set\n\t\t// And we let finalizeProperty know it needs to re-add non-draft children back to the target\n\t\tlet resultEach = result\n\t\tlet isSet = false\n\t\tif (state.type_ === ArchType.Set) {\n\t\t\tresultEach = new Set(result)\n\t\t\tresult.clear()\n\t\t\tisSet = true\n\t\t}\n\t\teach(resultEach, (key, childValue) =>\n\t\t\tfinalizeProperty(rootScope, state, result, key, childValue, path, isSet)\n\t\t)\n\t\t// everything inside is frozen, we can freeze here\n\t\tmaybeFreeze(rootScope, result, false)\n\t\t// first time finalizing, let's create those patches\n\t\tif (path && rootScope.patches_) {\n\t\t\tgetPlugin(\"Patches\").generatePatches_(\n\t\t\t\tstate,\n\t\t\t\tpath,\n\t\t\t\trootScope.patches_,\n\t\t\t\trootScope.inversePatches_!\n\t\t\t)\n\t\t}\n\t}\n\treturn state.copy_\n}\n\nfunction finalizeProperty(\n\trootScope: ImmerScope,\n\tparentState: undefined | ImmerState,\n\ttargetObject: any,\n\tprop: string | number,\n\tchildValue: any,\n\trootPath?: PatchPath,\n\ttargetIsSet?: boolean\n) {\n\tif (process.env.NODE_ENV !== \"production\" && childValue === targetObject)\n\t\tdie(5)\n\tif (isDraft(childValue)) {\n\t\tconst path =\n\t\t\trootPath &&\n\t\t\tparentState &&\n\t\t\tparentState!.type_ !== ArchType.Set && // Set objects are atomic since they have no keys.\n\t\t\t!has((parentState as Exclude<ImmerState, SetState>).assigned_!, prop) // Skip deep patches for assigned keys.\n\t\t\t\t? rootPath!.concat(prop)\n\t\t\t\t: undefined\n\t\t// Drafts owned by `scope` are finalized here.\n\t\tconst res = finalize(rootScope, childValue, path)\n\t\tset(targetObject, prop, res)\n\t\t// Drafts from another scope must prevented to be frozen\n\t\t// if we got a draft back from finalize, we're in a nested produce and shouldn't freeze\n\t\tif (isDraft(res)) {\n\t\t\trootScope.canAutoFreeze_ = false\n\t\t} else return\n\t} else if (targetIsSet) {\n\t\ttargetObject.add(childValue)\n\t}\n\t// Search new objects for unfinalized drafts. Frozen objects should never contain drafts.\n\tif (isDraftable(childValue) && !isFrozen(childValue)) {\n\t\tif (!rootScope.immer_.autoFreeze_ && rootScope.unfinalizedDrafts_ < 1) {\n\t\t\t// optimization: if an object is not a draft, and we don't have to\n\t\t\t// deepfreeze everything, and we are sure that no drafts are left in the remaining object\n\t\t\t// cause we saw and finalized all drafts already; we can stop visiting the rest of the tree.\n\t\t\t// This benefits especially adding large data tree's without further processing.\n\t\t\t// See add-data.js perf test\n\t\t\treturn\n\t\t}\n\t\tfinalize(rootScope, childValue)\n\t\t// Immer deep freezes plain objects, so if there is no parent state, we freeze as well\n\t\t// Per #590, we never freeze symbolic properties. Just to make sure don't accidentally interfere\n\t\t// with other frameworks.\n\t\tif (\n\t\t\t(!parentState || !parentState.scope_.parent_) &&\n\t\t\ttypeof prop !== \"symbol\" &&\n\t\t\t(isMap(targetObject)\n\t\t\t\t? targetObject.has(prop)\n\t\t\t\t: Object.prototype.propertyIsEnumerable.call(targetObject, prop))\n\t\t)\n\t\t\tmaybeFreeze(rootScope, childValue)\n\t}\n}\n\nfunction maybeFreeze(scope: ImmerScope, value: any, deep = false) {\n\t// we never freeze for a non-root scope; as it would prevent pruning for drafts inside wrapping objects\n\tif (!scope.parent_ && scope.immer_.autoFreeze_ && scope.canAutoFreeze_) {\n\t\tfreeze(value, deep)\n\t}\n}\n", "import {\n\teach,\n\thas,\n\tis,\n\tisDraftable,\n\tshallowCopy,\n\tlatest,\n\tImmerBaseState,\n\tImmerState,\n\tDrafted,\n\tAnyObject,\n\tAnyArray,\n\tObjectish,\n\tgetCurrentScope,\n\tgetPrototypeOf,\n\tDRAFT_STATE,\n\tdie,\n\tcreateProxy,\n\tArchType,\n\tImmerScope\n} from \"../internal\"\n\ninterface ProxyBaseState extends ImmerBaseState {\n\tassigned_: {\n\t\t[property: string]: boolean\n\t}\n\tparent_?: ImmerState\n\trevoke_(): void\n}\n\nexport interface ProxyObjectState extends ProxyBaseState {\n\ttype_: ArchType.Object\n\tbase_: any\n\tcopy_: any\n\tdraft_: Drafted<AnyObject, ProxyObjectState>\n}\n\nexport interface ProxyArrayState extends ProxyBaseState {\n\ttype_: ArchType.Array\n\tbase_: AnyArray\n\tcopy_: AnyArray | null\n\tdraft_: Drafted<AnyArray, ProxyArrayState>\n}\n\ntype ProxyState = ProxyObjectState | ProxyArrayState\n\n/**\n * Returns a new draft of the `base` object.\n *\n * The second argument is the parent draft-state (used internally).\n */\nexport function createProxyProxy<T extends Objectish>(\n\tbase: T,\n\tparent?: ImmerState\n): Drafted<T, ProxyState> {\n\tconst isArray = Array.isArray(base)\n\tconst state: ProxyState = {\n\t\ttype_: isArray ? ArchType.Array : (ArchType.Object as any),\n\t\t// Track which produce call this is associated with.\n\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t// True for both shallow and deep changes.\n\t\tmodified_: false,\n\t\t// Used during finalization.\n\t\tfinalized_: false,\n\t\t// Track which properties have been assigned (true) or deleted (false).\n\t\tassigned_: {},\n\t\t// The parent draft state.\n\t\tparent_: parent,\n\t\t// The base state.\n\t\tbase_: base,\n\t\t// The base proxy.\n\t\tdraft_: null as any, // set below\n\t\t// The base copy with any updated values.\n\t\tcopy_: null,\n\t\t// Called by the `produce` function.\n\t\trevoke_: null as any,\n\t\tisManual_: false\n\t}\n\n\t// the traps must target something, a bit like the 'real' base.\n\t// but also, we need to be able to determine from the target what the relevant state is\n\t// (to avoid creating traps per instance to capture the state in closure,\n\t// and to avoid creating weird hidden properties as well)\n\t// So the trick is to use 'state' as the actual 'target'! (and make sure we intercept everything)\n\t// Note that in the case of an array, we put the state in an array to have better Reflect defaults ootb\n\tlet target: T = state as any\n\tlet traps: ProxyHandler<object | Array<any>> = objectTraps\n\tif (isArray) {\n\t\ttarget = [state] as any\n\t\ttraps = arrayTraps\n\t}\n\n\tconst {revoke, proxy} = Proxy.revocable(target, traps)\n\tstate.draft_ = proxy as any\n\tstate.revoke_ = revoke\n\treturn proxy as any\n}\n\n/**\n * Object drafts\n */\nexport const objectTraps: ProxyHandler<ProxyState> = {\n\tget(state, prop) {\n\t\tif (prop === DRAFT_STATE) return state\n\n\t\tconst source = latest(state)\n\t\tif (!has(source, prop)) {\n\t\t\t// non-existing or non-own property...\n\t\t\treturn readPropFromProto(state, source, prop)\n\t\t}\n\t\tconst value = source[prop]\n\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\treturn value\n\t\t}\n\t\t// Check for existing draft in modified state.\n\t\t// Assigned values are never drafted. This catches any drafts we created, too.\n\t\tif (value === peek(state.base_, prop)) {\n\t\t\tprepareCopy(state)\n\t\t\treturn (state.copy_![prop as any] = createProxy(value, state))\n\t\t}\n\t\treturn value\n\t},\n\thas(state, prop) {\n\t\treturn prop in latest(state)\n\t},\n\townKeys(state) {\n\t\treturn Reflect.ownKeys(latest(state))\n\t},\n\tset(\n\t\tstate: ProxyObjectState,\n\t\tprop: string /* strictly not, but helps TS */,\n\t\tvalue\n\t) {\n\t\tconst desc = getDescriptorFromProto(latest(state), prop)\n\t\tif (desc?.set) {\n\t\t\t// special case: if this write is captured by a setter, we have\n\t\t\t// to trigger it with the correct context\n\t\t\tdesc.set.call(state.draft_, value)\n\t\t\treturn true\n\t\t}\n\t\tif (!state.modified_) {\n\t\t\t// the last check is because we need to be able to distinguish setting a non-existing to undefined (which is a change)\n\t\t\t// from setting an existing property with value undefined to undefined (which is not a change)\n\t\t\tconst current = peek(latest(state), prop)\n\t\t\t// special case, if we assigning the original value to a draft, we can ignore the assignment\n\t\t\tconst currentState: ProxyObjectState = current?.[DRAFT_STATE]\n\t\t\tif (currentState && currentState.base_ === value) {\n\t\t\t\tstate.copy_![prop] = value\n\t\t\t\tstate.assigned_[prop] = false\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tif (is(value, current) && (value !== undefined || has(state.base_, prop)))\n\t\t\t\treturn true\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t}\n\n\t\tif (\n\t\t\t(state.copy_![prop] === value &&\n\t\t\t\t// special case: handle new props with value 'undefined'\n\t\t\t\t(value !== undefined || prop in state.copy_)) ||\n\t\t\t// special case: NaN\n\t\t\t(Number.isNaN(value) && Number.isNaN(state.copy_![prop]))\n\t\t)\n\t\t\treturn true\n\n\t\t// @ts-ignore\n\t\tstate.copy_![prop] = value\n\t\tstate.assigned_[prop] = true\n\t\treturn true\n\t},\n\tdeleteProperty(state, prop: string) {\n\t\t// The `undefined` check is a fast path for pre-existing keys.\n\t\tif (peek(state.base_, prop) !== undefined || prop in state.base_) {\n\t\t\tstate.assigned_[prop] = false\n\t\t\tprepareCopy(state)\n\t\t\tmarkChanged(state)\n\t\t} else {\n\t\t\t// if an originally not assigned property was deleted\n\t\t\tdelete state.assigned_[prop]\n\t\t}\n\t\tif (state.copy_) {\n\t\t\tdelete state.copy_[prop]\n\t\t}\n\t\treturn true\n\t},\n\t// Note: We never coerce `desc.value` into an Immer draft, because we can't make\n\t// the same guarantee in ES5 mode.\n\tgetOwnPropertyDescriptor(state, prop) {\n\t\tconst owner = latest(state)\n\t\tconst desc = Reflect.getOwnPropertyDescriptor(owner, prop)\n\t\tif (!desc) return desc\n\t\treturn {\n\t\t\twritable: true,\n\t\t\tconfigurable: state.type_ !== ArchType.Array || prop !== \"length\",\n\t\t\tenumerable: desc.enumerable,\n\t\t\tvalue: owner[prop]\n\t\t}\n\t},\n\tdefineProperty() {\n\t\tdie(11)\n\t},\n\tgetPrototypeOf(state) {\n\t\treturn getPrototypeOf(state.base_)\n\t},\n\tsetPrototypeOf() {\n\t\tdie(12)\n\t}\n}\n\n/**\n * Array drafts\n */\n\nconst arrayTraps: ProxyHandler<[ProxyArrayState]> = {}\neach(objectTraps, (key, fn) => {\n\t// @ts-ignore\n\tarrayTraps[key] = function() {\n\t\targuments[0] = arguments[0][0]\n\t\treturn fn.apply(this, arguments)\n\t}\n})\narrayTraps.deleteProperty = function(state, prop) {\n\tif (process.env.NODE_ENV !== \"production\" && isNaN(parseInt(prop as any)))\n\t\tdie(13)\n\t// @ts-ignore\n\treturn arrayTraps.set!.call(this, state, prop, undefined)\n}\narrayTraps.set = function(state, prop, value) {\n\tif (\n\t\tprocess.env.NODE_ENV !== \"production\" &&\n\t\tprop !== \"length\" &&\n\t\tisNaN(parseInt(prop as any))\n\t)\n\t\tdie(14)\n\treturn objectTraps.set!.call(this, state[0], prop, value, state[0])\n}\n\n// Access a property without creating an Immer draft.\nfunction peek(draft: Drafted, prop: PropertyKey) {\n\tconst state = draft[DRAFT_STATE]\n\tconst source = state ? latest(state) : draft\n\treturn source[prop]\n}\n\nfunction readPropFromProto(state: ImmerState, source: any, prop: PropertyKey) {\n\tconst desc = getDescriptorFromProto(source, prop)\n\treturn desc\n\t\t? `value` in desc\n\t\t\t? desc.value\n\t\t\t: // This is a very special case, if the prop is a getter defined by the\n\t\t\t  // prototype, we should invoke it with the draft as context!\n\t\t\t  desc.get?.call(state.draft_)\n\t\t: undefined\n}\n\nfunction getDescriptorFromProto(\n\tsource: any,\n\tprop: PropertyKey\n): PropertyDescriptor | undefined {\n\t// 'in' checks proto!\n\tif (!(prop in source)) return undefined\n\tlet proto = getPrototypeOf(source)\n\twhile (proto) {\n\t\tconst desc = Object.getOwnPropertyDescriptor(proto, prop)\n\t\tif (desc) return desc\n\t\tproto = getPrototypeOf(proto)\n\t}\n\treturn undefined\n}\n\nexport function markChanged(state: ImmerState) {\n\tif (!state.modified_) {\n\t\tstate.modified_ = true\n\t\tif (state.parent_) {\n\t\t\tmarkChanged(state.parent_)\n\t\t}\n\t}\n}\n\nexport function prepareCopy(state: {\n\tbase_: any\n\tcopy_: any\n\tscope_: ImmerScope\n}) {\n\tif (!state.copy_) {\n\t\tstate.copy_ = shallowCopy(\n\t\t\tstate.base_,\n\t\t\tstate.scope_.immer_.useStrictShallowCopy_\n\t\t)\n\t}\n}\n", "import {\n\tIProduceWithPatches,\n\tIProduce,\n\tImmerState,\n\tDrafted,\n\tisDraftable,\n\tprocessResult,\n\tPatch,\n\tObjectish,\n\tDRAFT_STATE,\n\tDraft,\n\tPatchListener,\n\tisDraft,\n\tisMap,\n\tisSet,\n\tcreateProxyProxy,\n\tgetPlugin,\n\tdie,\n\tenterScope,\n\trevokeScope,\n\tleaveScope,\n\tusePatchesInScope,\n\tgetCurrentScope,\n\tNOTHING,\n\tfreeze,\n\tcurrent\n} from \"../internal\"\n\ninterface ProducersFns {\n\tproduce: IProduce\n\tproduceWithPatches: IProduceWithPatches\n}\n\nexport type StrictMode = boolean | \"class_only\";\n\nexport class Immer implements ProducersFns {\n\tautoFreeze_: boolean = true\n\tuseStrictShallowCopy_: StrictMode = false\n\n\tconstructor(config?: {\n\t\tautoFreeze?: boolean\n\t\tuseStrictShallowCopy?: StrictMode\n\t}) {\n\t\tif (typeof config?.autoFreeze === \"boolean\")\n\t\t\tthis.setAutoFreeze(config!.autoFreeze)\n\t\tif (typeof config?.useStrictShallowCopy === \"boolean\")\n\t\t\tthis.setUseStrictShallowCopy(config!.useStrictShallowCopy)\n\t}\n\n\t/**\n\t * The `produce` function takes a value and a \"recipe function\" (whose\n\t * return value often depends on the base state). The recipe function is\n\t * free to mutate its first argument however it wants. All mutations are\n\t * only ever applied to a __copy__ of the base state.\n\t *\n\t * Pass only a function to create a \"curried producer\" which relieves you\n\t * from passing the recipe function every time.\n\t *\n\t * Only plain objects and arrays are made mutable. All other objects are\n\t * considered uncopyable.\n\t *\n\t * Note: This function is __bound__ to its `Immer` instance.\n\t *\n\t * @param {any} base - the initial state\n\t * @param {Function} recipe - function that receives a proxy of the base state as first argument and which can be freely modified\n\t * @param {Function} patchListener - optional function that will be called with all the patches produced here\n\t * @returns {any} a new state, or the initial state if nothing was modified\n\t */\n\tproduce: IProduce = (base: any, recipe?: any, patchListener?: any) => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\" && typeof recipe !== \"function\") {\n\t\t\tconst defaultBase = recipe\n\t\t\trecipe = base\n\n\t\t\tconst self = this\n\t\t\treturn function curriedProduce(\n\t\t\t\tthis: any,\n\t\t\t\tbase = defaultBase,\n\t\t\t\t...args: any[]\n\t\t\t) {\n\t\t\t\treturn self.produce(base, (draft: Drafted) => recipe.call(this, draft, ...args)) // prettier-ignore\n\t\t\t}\n\t\t}\n\n\t\tif (typeof recipe !== \"function\") die(6)\n\t\tif (patchListener !== undefined && typeof patchListener !== \"function\")\n\t\t\tdie(7)\n\n\t\tlet result\n\n\t\t// Only plain objects, arrays, and \"immerable classes\" are drafted.\n\t\tif (isDraftable(base)) {\n\t\t\tconst scope = enterScope(this)\n\t\t\tconst proxy = createProxy(base, undefined)\n\t\t\tlet hasError = true\n\t\t\ttry {\n\t\t\t\tresult = recipe(proxy)\n\t\t\t\thasError = false\n\t\t\t} finally {\n\t\t\t\t// finally instead of catch + rethrow better preserves original stack\n\t\t\t\tif (hasError) revokeScope(scope)\n\t\t\t\telse leaveScope(scope)\n\t\t\t}\n\t\t\tusePatchesInScope(scope, patchListener)\n\t\t\treturn processResult(result, scope)\n\t\t} else if (!base || typeof base !== \"object\") {\n\t\t\tresult = recipe(base)\n\t\t\tif (result === undefined) result = base\n\t\t\tif (result === NOTHING) result = undefined\n\t\t\tif (this.autoFreeze_) freeze(result, true)\n\t\t\tif (patchListener) {\n\t\t\t\tconst p: Patch[] = []\n\t\t\t\tconst ip: Patch[] = []\n\t\t\t\tgetPlugin(\"Patches\").generateReplacementPatches_(base, result, p, ip)\n\t\t\t\tpatchListener(p, ip)\n\t\t\t}\n\t\t\treturn result\n\t\t} else die(1, base)\n\t}\n\n\tproduceWithPatches: IProduceWithPatches = (base: any, recipe?: any): any => {\n\t\t// curried invocation\n\t\tif (typeof base === \"function\") {\n\t\t\treturn (state: any, ...args: any[]) =>\n\t\t\t\tthis.produceWithPatches(state, (draft: any) => base(draft, ...args))\n\t\t}\n\n\t\tlet patches: Patch[], inversePatches: Patch[]\n\t\tconst result = this.produce(base, recipe, (p: Patch[], ip: Patch[]) => {\n\t\t\tpatches = p\n\t\t\tinversePatches = ip\n\t\t})\n\t\treturn [result, patches!, inversePatches!]\n\t}\n\n\tcreateDraft<T extends Objectish>(base: T): Draft<T> {\n\t\tif (!isDraftable(base)) die(8)\n\t\tif (isDraft(base)) base = current(base)\n\t\tconst scope = enterScope(this)\n\t\tconst proxy = createProxy(base, undefined)\n\t\tproxy[DRAFT_STATE].isManual_ = true\n\t\tleaveScope(scope)\n\t\treturn proxy as any\n\t}\n\n\tfinishDraft<D extends Draft<any>>(\n\t\tdraft: D,\n\t\tpatchListener?: PatchListener\n\t): D extends Draft<infer T> ? T : never {\n\t\tconst state: ImmerState = draft && (draft as any)[DRAFT_STATE]\n\t\tif (!state || !state.isManual_) die(9)\n\t\tconst {scope_: scope} = state\n\t\tusePatchesInScope(scope, patchListener)\n\t\treturn processResult(undefined, scope)\n\t}\n\n\t/**\n\t * Pass true to automatically freeze all copies created by Immer.\n\t *\n\t * By default, auto-freezing is enabled.\n\t */\n\tsetAutoFreeze(value: boolean) {\n\t\tthis.autoFreeze_ = value\n\t}\n\n\t/**\n\t * Pass true to enable strict shallow copy.\n\t *\n\t * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n\t */\n\tsetUseStrictShallowCopy(value: StrictMode) {\n\t\tthis.useStrictShallowCopy_ = value\n\t}\n\n\tapplyPatches<T extends Objectish>(base: T, patches: readonly Patch[]): T {\n\t\t// If a patch replaces the entire state, take that replacement as base\n\t\t// before applying patches\n\t\tlet i: number\n\t\tfor (i = patches.length - 1; i >= 0; i--) {\n\t\t\tconst patch = patches[i]\n\t\t\tif (patch.path.length === 0 && patch.op === \"replace\") {\n\t\t\t\tbase = patch.value\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// If there was a patch that replaced the entire state, start from the\n\t\t// patch after that.\n\t\tif (i > -1) {\n\t\t\tpatches = patches.slice(i + 1)\n\t\t}\n\n\t\tconst applyPatchesImpl = getPlugin(\"Patches\").applyPatches_\n\t\tif (isDraft(base)) {\n\t\t\t// N.B: never hits if some patch a replacement, patches are never drafts\n\t\t\treturn applyPatchesImpl(base, patches)\n\t\t}\n\t\t// Otherwise, produce a copy of the base state.\n\t\treturn this.produce(base, (draft: Drafted) =>\n\t\t\tapplyPatchesImpl(draft, patches)\n\t\t)\n\t}\n}\n\nexport function createProxy<T extends Objectish>(\n\tvalue: T,\n\tparent?: ImmerState\n): Drafted<T, ImmerState> {\n\t// precondition: createProxy should be guarded by isDraftable, so we know we can safely draft\n\tconst draft: Drafted = isMap(value)\n\t\t? getPlugin(\"MapSet\").proxyMap_(value, parent)\n\t\t: isSet(value)\n\t\t? getPlugin(\"MapSet\").proxySet_(value, parent)\n\t\t: createProxyProxy(value, parent)\n\n\tconst scope = parent ? parent.scope_ : getCurrentScope()\n\tscope.drafts_.push(draft)\n\treturn draft\n}\n", "import {\n\tdie,\n\tisDraft,\n\tshallowCopy,\n\teach,\n\tDRAFT_STATE,\n\tset,\n\tImmerState,\n\tisDraftable,\n\tisFrozen\n} from \"../internal\"\n\n/** Takes a snapshot of the current state of a draft and finalizes it (but without freezing). This is a great utility to print the current state during debugging (no Proxies in the way). The output of current can also be safely leaked outside the producer. */\nexport function current<T>(value: T): T\nexport function current(value: any): any {\n\tif (!isDraft(value)) die(10, value)\n\treturn currentImpl(value)\n}\n\nfunction currentImpl(value: any): any {\n\tif (!isDraftable(value) || isFrozen(value)) return value\n\tconst state: ImmerState | undefined = value[DRAFT_STATE]\n\tlet copy: any\n\tif (state) {\n\t\tif (!state.modified_) return state.base_\n\t\t// Optimization: avoid generating new drafts during copying\n\t\tstate.finalized_ = true\n\t\tcopy = shallowCopy(value, state.scope_.immer_.useStrictShallowCopy_)\n\t} else {\n\t\tcopy = shallowCopy(value, true)\n\t}\n\t// recurse\n\teach(copy, (key, childValue) => {\n\t\tset(copy, key, currentImpl(childValue))\n\t})\n\tif (state) {\n\t\tstate.finalized_ = false\n\t}\n\treturn copy\n}\n", "import {immerable} from \"../immer\"\nimport {\n\tImmerState,\n\tPatch,\n\tSetState,\n\tProxyArrayState,\n\tMapState,\n\tProxyObjectState,\n\tPatchPath,\n\tget,\n\teach,\n\thas,\n\tgetArchtype,\n\tgetPrototypeOf,\n\tisSet,\n\tisMap,\n\tloadPlugin,\n\tArchType,\n\tdie,\n\tisDraft,\n\tisDraftable,\n\tNOTHING,\n\terrors\n} from \"../internal\"\n\nexport function enablePatches() {\n\tconst errorOffset = 16\n\tif (process.env.NODE_ENV !== \"production\") {\n\t\terrors.push(\n\t\t\t'Sets cannot have \"replace\" patches.',\n\t\t\tfunction(op: string) {\n\t\t\t\treturn \"Unsupported patch operation: \" + op\n\t\t\t},\n\t\t\tfunction(path: string) {\n\t\t\t\treturn \"Cannot apply patch, path doesn't resolve: \" + path\n\t\t\t},\n\t\t\t\"Patching reserved attributes like __proto__, prototype and constructor is not allowed\"\n\t\t)\n\t}\n\n\tconst REPLACE = \"replace\"\n\tconst ADD = \"add\"\n\tconst REMOVE = \"remove\"\n\n\tfunction generatePatches_(\n\t\tstate: ImmerState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tswitch (state.type_) {\n\t\t\tcase ArchType.Object:\n\t\t\tcase ArchType.Map:\n\t\t\t\treturn generatePatchesFromAssigned(\n\t\t\t\t\tstate,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t\tcase ArchType.Array:\n\t\t\t\treturn generateArrayPatches(state, basePath, patches, inversePatches)\n\t\t\tcase ArchType.Set:\n\t\t\t\treturn generateSetPatches(\n\t\t\t\t\t(state as any) as SetState,\n\t\t\t\t\tbasePath,\n\t\t\t\t\tpatches,\n\t\t\t\t\tinversePatches\n\t\t\t\t)\n\t\t}\n\t}\n\n\tfunction generateArrayPatches(\n\t\tstate: ProxyArrayState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, assigned_} = state\n\t\tlet copy_ = state.copy_!\n\n\t\t// Reduce complexity by ensuring `base` is never longer.\n\t\tif (copy_.length < base_.length) {\n\t\t\t// @ts-ignore\n\t\t\t;[base_, copy_] = [copy_, base_]\n\t\t\t;[patches, inversePatches] = [inversePatches, patches]\n\t\t}\n\n\t\t// Process replaced indices.\n\t\tfor (let i = 0; i < base_.length; i++) {\n\t\t\tif (assigned_[i] && copy_[i] !== base_[i]) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t\t})\n\t\t\t\tinversePatches.push({\n\t\t\t\t\top: REPLACE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue: clonePatchValueIfNeeded(base_[i])\n\t\t\t\t})\n\t\t\t}\n\t\t}\n\n\t\t// Process added indices.\n\t\tfor (let i = base_.length; i < copy_.length; i++) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tpatches.push({\n\t\t\t\top: ADD,\n\t\t\t\tpath,\n\t\t\t\t// Need to maybe clone it, as it can in fact be the original value\n\t\t\t\t// due to the base/copy inversion at the start of this function\n\t\t\t\tvalue: clonePatchValueIfNeeded(copy_[i])\n\t\t\t})\n\t\t}\n\t\tfor (let i = copy_.length - 1; base_.length <= i; --i) {\n\t\t\tconst path = basePath.concat([i])\n\t\t\tinversePatches.push({\n\t\t\t\top: REMOVE,\n\t\t\t\tpath\n\t\t\t})\n\t\t}\n\t}\n\n\t// This is used for both Map objects and normal objects.\n\tfunction generatePatchesFromAssigned(\n\t\tstate: MapState | ProxyObjectState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tconst {base_, copy_} = state\n\t\teach(state.assigned_!, (key, assignedValue) => {\n\t\t\tconst origValue = get(base_, key)\n\t\t\tconst value = get(copy_!, key)\n\t\t\tconst op = !assignedValue ? REMOVE : has(base_, key) ? REPLACE : ADD\n\t\t\tif (origValue === value && op === REPLACE) return\n\t\t\tconst path = basePath.concat(key as any)\n\t\t\tpatches.push(op === REMOVE ? {op, path} : {op, path, value})\n\t\t\tinversePatches.push(\n\t\t\t\top === ADD\n\t\t\t\t\t? {op: REMOVE, path}\n\t\t\t\t\t: op === REMOVE\n\t\t\t\t\t? {op: ADD, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t\t\t: {op: REPLACE, path, value: clonePatchValueIfNeeded(origValue)}\n\t\t\t)\n\t\t})\n\t}\n\n\tfunction generateSetPatches(\n\t\tstate: SetState,\n\t\tbasePath: PatchPath,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t) {\n\t\tlet {base_, copy_} = state\n\n\t\tlet i = 0\n\t\tbase_.forEach((value: any) => {\n\t\t\tif (!copy_!.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t\ti = 0\n\t\tcopy_!.forEach((value: any) => {\n\t\t\tif (!base_.has(value)) {\n\t\t\t\tconst path = basePath.concat([i])\n\t\t\t\tpatches.push({\n\t\t\t\t\top: ADD,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t\tinversePatches.unshift({\n\t\t\t\t\top: REMOVE,\n\t\t\t\t\tpath,\n\t\t\t\t\tvalue\n\t\t\t\t})\n\t\t\t}\n\t\t\ti++\n\t\t})\n\t}\n\n\tfunction generateReplacementPatches_(\n\t\tbaseValue: any,\n\t\treplacement: any,\n\t\tpatches: Patch[],\n\t\tinversePatches: Patch[]\n\t): void {\n\t\tpatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: replacement === NOTHING ? undefined : replacement\n\t\t})\n\t\tinversePatches.push({\n\t\t\top: REPLACE,\n\t\t\tpath: [],\n\t\t\tvalue: baseValue\n\t\t})\n\t}\n\n\tfunction applyPatches_<T>(draft: T, patches: readonly Patch[]): T {\n\t\tpatches.forEach(patch => {\n\t\t\tconst {path, op} = patch\n\n\t\t\tlet base: any = draft\n\t\t\tfor (let i = 0; i < path.length - 1; i++) {\n\t\t\t\tconst parentType = getArchtype(base)\n\t\t\t\tlet p = path[i]\n\t\t\t\tif (typeof p !== \"string\" && typeof p !== \"number\") {\n\t\t\t\t\tp = \"\" + p\n\t\t\t\t}\n\n\t\t\t\t// See #738, avoid prototype pollution\n\t\t\t\tif (\n\t\t\t\t\t(parentType === ArchType.Object || parentType === ArchType.Array) &&\n\t\t\t\t\t(p === \"__proto__\" || p === \"constructor\")\n\t\t\t\t)\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tif (typeof base === \"function\" && p === \"prototype\")\n\t\t\t\t\tdie(errorOffset + 3)\n\t\t\t\tbase = get(base, p)\n\t\t\t\tif (typeof base !== \"object\") die(errorOffset + 2, path.join(\"/\"))\n\t\t\t}\n\n\t\t\tconst type = getArchtype(base)\n\t\t\tconst value = deepClonePatchValue(patch.value) // used to clone patch to ensure original patch is not modified, see #411\n\t\t\tconst key = path[path.length - 1]\n\t\t\tswitch (op) {\n\t\t\t\tcase REPLACE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\tdie(errorOffset)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t// if value is an object, then it's assigned by reference\n\t\t\t\t\t\t\t// in the following add or remove ops, the value field inside the patch will also be modifyed\n\t\t\t\t\t\t\t// so we use value from the cloned patch\n\t\t\t\t\t\t\t// @ts-ignore\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase ADD:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn key === \"-\"\n\t\t\t\t\t\t\t\t? base.push(value)\n\t\t\t\t\t\t\t\t: base.splice(key as any, 0, value)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.set(key, value)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.add(value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn (base[key] = value)\n\t\t\t\t\t}\n\t\t\t\tcase REMOVE:\n\t\t\t\t\tswitch (type) {\n\t\t\t\t\t\tcase ArchType.Array:\n\t\t\t\t\t\t\treturn base.splice(key as any, 1)\n\t\t\t\t\t\tcase ArchType.Map:\n\t\t\t\t\t\t\treturn base.delete(key)\n\t\t\t\t\t\tcase ArchType.Set:\n\t\t\t\t\t\t\treturn base.delete(patch.value)\n\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\treturn delete base[key]\n\t\t\t\t\t}\n\t\t\t\tdefault:\n\t\t\t\t\tdie(errorOffset + 1, op)\n\t\t\t}\n\t\t})\n\n\t\treturn draft\n\t}\n\n\t// optimize: this is quite a performance hit, can we detect intelligently when it is needed?\n\t// E.g. auto-draft when new objects from outside are assigned and modified?\n\t// (See failing test when deepClone just returns obj)\n\tfunction deepClonePatchValue<T>(obj: T): T\n\tfunction deepClonePatchValue(obj: any) {\n\t\tif (!isDraftable(obj)) return obj\n\t\tif (Array.isArray(obj)) return obj.map(deepClonePatchValue)\n\t\tif (isMap(obj))\n\t\t\treturn new Map(\n\t\t\t\tArray.from(obj.entries()).map(([k, v]) => [k, deepClonePatchValue(v)])\n\t\t\t)\n\t\tif (isSet(obj)) return new Set(Array.from(obj).map(deepClonePatchValue))\n\t\tconst cloned = Object.create(getPrototypeOf(obj))\n\t\tfor (const key in obj) cloned[key] = deepClonePatchValue(obj[key])\n\t\tif (has(obj, immerable)) cloned[immerable] = obj[immerable]\n\t\treturn cloned\n\t}\n\n\tfunction clonePatchValueIfNeeded<T>(obj: T): T {\n\t\tif (isDraft(obj)) {\n\t\t\treturn deepClonePatchValue(obj)\n\t\t} else return obj\n\t}\n\n\tloadPlugin(\"Patches\", {\n\t\tapplyPatches_,\n\t\tgeneratePatches_,\n\t\tgenerateReplacementPatches_\n\t})\n}\n", "// types only!\nimport {\n\tImmerState,\n\tAnyMap,\n\tAnySet,\n\tMapState,\n\tSetState,\n\tDRAFT_STATE,\n\tgetCurrentScope,\n\tlatest,\n\tisDraftable,\n\tcreateProxy,\n\tloadPlugin,\n\tmarkChanged,\n\tdie,\n\tArchType,\n\teach\n} from \"../internal\"\n\nexport function enableMapSet() {\n\tclass DraftMap extends Map {\n\t\t[DRAFT_STATE]: MapState\n\n\t\tconstructor(target: AnyMap, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Map,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tassigned_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this as any,\n\t\t\t\tisManual_: false,\n\t\t\t\trevoked_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(key: any): boolean {\n\t\t\treturn latest(this[DRAFT_STATE]).has(key)\n\t\t}\n\n\t\tset(key: any, value: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!latest(state).has(key) || latest(state).get(key) !== value) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t\tstate.copy_!.set(key, value)\n\t\t\t\tstate.assigned_!.set(key, true)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(key: any): boolean {\n\t\t\tif (!this.has(key)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareMapCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\tif (state.base_.has(key)) {\n\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t} else {\n\t\t\t\tstate.assigned_!.delete(key)\n\t\t\t}\n\t\t\tstate.copy_!.delete(key)\n\t\t\treturn true\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareMapCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.assigned_ = new Map()\n\t\t\t\teach(state.base_, key => {\n\t\t\t\t\tstate.assigned_!.set(key, false)\n\t\t\t\t})\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tforEach(cb: (value: any, key: any, self: any) => void, thisArg?: any) {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tlatest(state).forEach((_value: any, key: any, _map: any) => {\n\t\t\t\tcb.call(thisArg, this.get(key), key, this)\n\t\t\t})\n\t\t}\n\n\t\tget(key: any): any {\n\t\t\tconst state: MapState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tconst value = latest(state).get(key)\n\t\t\tif (state.finalized_ || !isDraftable(value)) {\n\t\t\t\treturn value\n\t\t\t}\n\t\t\tif (value !== state.base_.get(key)) {\n\t\t\t\treturn value // either already drafted or reassigned\n\t\t\t}\n\t\t\t// despite what it looks, this creates a draft only once, see above condition\n\t\t\tconst draft = createProxy(value, state)\n\t\t\tprepareMapCopy(state)\n\t\t\tstate.copy_!.set(key, draft)\n\t\t\treturn draft\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn latest(this[DRAFT_STATE]).keys()\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.values(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst iterator = this.keys()\n\t\t\treturn {\n\t\t\t\t[Symbol.iterator]: () => this.entries(),\n\t\t\t\tnext: () => {\n\t\t\t\t\tconst r = iterator.next()\n\t\t\t\t\t/* istanbul ignore next */\n\t\t\t\t\tif (r.done) return r\n\t\t\t\t\tconst value = this.get(r.value)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tdone: false,\n\t\t\t\t\t\tvalue: [r.value, value]\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} as any\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.entries()\n\t\t}\n\t}\n\n\tfunction proxyMap_<T extends AnyMap>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftMap(target, parent)\n\t}\n\n\tfunction prepareMapCopy(state: MapState) {\n\t\tif (!state.copy_) {\n\t\t\tstate.assigned_ = new Map()\n\t\t\tstate.copy_ = new Map(state.base_)\n\t\t}\n\t}\n\n\tclass DraftSet extends Set {\n\t\t[DRAFT_STATE]: SetState\n\t\tconstructor(target: AnySet, parent?: ImmerState) {\n\t\t\tsuper()\n\t\t\tthis[DRAFT_STATE] = {\n\t\t\t\ttype_: ArchType.Set,\n\t\t\t\tparent_: parent,\n\t\t\t\tscope_: parent ? parent.scope_ : getCurrentScope()!,\n\t\t\t\tmodified_: false,\n\t\t\t\tfinalized_: false,\n\t\t\t\tcopy_: undefined,\n\t\t\t\tbase_: target,\n\t\t\t\tdraft_: this,\n\t\t\t\tdrafts_: new Map(),\n\t\t\t\trevoked_: false,\n\t\t\t\tisManual_: false\n\t\t\t}\n\t\t}\n\n\t\tget size(): number {\n\t\t\treturn latest(this[DRAFT_STATE]).size\n\t\t}\n\n\t\thas(value: any): boolean {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\t// bit of trickery here, to be able to recognize both the value, and the draft of its value\n\t\t\tif (!state.copy_) {\n\t\t\t\treturn state.base_.has(value)\n\t\t\t}\n\t\t\tif (state.copy_.has(value)) return true\n\t\t\tif (state.drafts_.has(value) && state.copy_.has(state.drafts_.get(value)))\n\t\t\t\treturn true\n\t\t\treturn false\n\t\t}\n\n\t\tadd(value: any): any {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (!this.has(value)) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.add(value)\n\t\t\t}\n\t\t\treturn this\n\t\t}\n\n\t\tdelete(value: any): any {\n\t\t\tif (!this.has(value)) {\n\t\t\t\treturn false\n\t\t\t}\n\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\tmarkChanged(state)\n\t\t\treturn (\n\t\t\t\tstate.copy_!.delete(value) ||\n\t\t\t\t(state.drafts_.has(value)\n\t\t\t\t\t? state.copy_!.delete(state.drafts_.get(value))\n\t\t\t\t\t: /* istanbul ignore next */ false)\n\t\t\t)\n\t\t}\n\n\t\tclear() {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tif (latest(state).size) {\n\t\t\t\tprepareSetCopy(state)\n\t\t\t\tmarkChanged(state)\n\t\t\t\tstate.copy_!.clear()\n\t\t\t}\n\t\t}\n\n\t\tvalues(): IterableIterator<any> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.values()\n\t\t}\n\n\t\tentries(): IterableIterator<[any, any]> {\n\t\t\tconst state: SetState = this[DRAFT_STATE]\n\t\t\tassertUnrevoked(state)\n\t\t\tprepareSetCopy(state)\n\t\t\treturn state.copy_!.entries()\n\t\t}\n\n\t\tkeys(): IterableIterator<any> {\n\t\t\treturn this.values()\n\t\t}\n\n\t\t[Symbol.iterator]() {\n\t\t\treturn this.values()\n\t\t}\n\n\t\tforEach(cb: any, thisArg?: any) {\n\t\t\tconst iterator = this.values()\n\t\t\tlet result = iterator.next()\n\t\t\twhile (!result.done) {\n\t\t\t\tcb.call(thisArg, result.value, result.value, this)\n\t\t\t\tresult = iterator.next()\n\t\t\t}\n\t\t}\n\t}\n\tfunction proxySet_<T extends AnySet>(target: T, parent?: ImmerState): T {\n\t\t// @ts-ignore\n\t\treturn new DraftSet(target, parent)\n\t}\n\n\tfunction prepareSetCopy(state: SetState) {\n\t\tif (!state.copy_) {\n\t\t\t// create drafts for all entries to preserve insertion order\n\t\t\tstate.copy_ = new Set()\n\t\t\tstate.base_.forEach(value => {\n\t\t\t\tif (isDraftable(value)) {\n\t\t\t\t\tconst draft = createProxy(value, state)\n\t\t\t\t\tstate.drafts_.set(value, draft)\n\t\t\t\t\tstate.copy_!.add(draft)\n\t\t\t\t} else {\n\t\t\t\t\tstate.copy_!.add(value)\n\t\t\t\t}\n\t\t\t})\n\t\t}\n\t}\n\n\tfunction assertUnrevoked(state: any /*ES5State | MapState | SetState*/) {\n\t\tif (state.revoked_) die(3, JSON.stringify(latest(state)))\n\t}\n\n\tloadPlugin(\"MapSet\", {proxyMap_, proxySet_})\n}\n", "import {\n\tIProduce,\n\tIProduceWithPatches,\n\tImmer,\n\tDraft,\n\tImmutable\n} from \"./internal\"\n\nexport {\n\tDraft,\n\tWritableDraft,\n\tImmutable,\n\tPatch,\n\tPatchListener,\n\tProducer,\n\toriginal,\n\tcurrent,\n\tisDraft,\n\tisDraftable,\n\tNOTHING as nothing,\n\tDRAFTABLE as immerable,\n\tfreeze,\n\tObjectish,\n\tStrictMode\n} from \"./internal\"\n\nconst immer = new Immer()\n\n/**\n * The `produce` function takes a value and a \"recipe function\" (whose\n * return value often depends on the base state). The recipe function is\n * free to mutate its first argument however it wants. All mutations are\n * only ever applied to a __copy__ of the base state.\n *\n * Pass only a function to create a \"curried producer\" which relieves you\n * from passing the recipe function every time.\n *\n * Only plain objects and arrays are made mutable. All other objects are\n * considered uncopyable.\n *\n * Note: This function is __bound__ to its `Immer` instance.\n *\n * @param {any} base - the initial state\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @param {Function} patchListener - optional function that will be called with all the patches produced here\n * @returns {any} a new state, or the initial state if nothing was modified\n */\nexport const produce: IProduce = /* @__PURE__ */ immer.produce\n\n/**\n * Like `produce`, but `produceWithPatches` always returns a tuple\n * [nextState, patches, inversePatches] (instead of just the next state)\n */\nexport const produceWithPatches: IProduceWithPatches = /* @__PURE__ */ immer.produceWithPatches.bind(\n\timmer\n)\n\n/**\n * Pass true to automatically freeze all copies created by Immer.\n *\n * Always freeze by default, even in production mode\n */\nexport const setAutoFreeze = /* @__PURE__ */ immer.setAutoFreeze.bind(immer)\n\n/**\n * Pass true to enable strict shallow copy.\n *\n * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.\n */\nexport const setUseStrictShallowCopy = /* @__PURE__ */ immer.setUseStrictShallowCopy.bind(\n\timmer\n)\n\n/**\n * Apply an array of Immer patches to the first argument.\n *\n * This function is a producer, which means copy-on-write is in effect.\n */\nexport const applyPatches = /* @__PURE__ */ immer.applyPatches.bind(immer)\n\n/**\n * Create an Immer draft from the given base state, which may be a draft itself.\n * The draft can be modified until you finalize it with the `finishDraft` function.\n */\nexport const createDraft = /* @__PURE__ */ immer.createDraft.bind(immer)\n\n/**\n * Finalize an Immer draft from a `createDraft` call, returning the base state\n * (if no changes were made) or a modified copy. The draft must *not* be\n * mutated afterwards.\n *\n * Pass a function as the 2nd argument to generate Immer patches based on the\n * changes that were made.\n */\nexport const finishDraft = /* @__PURE__ */ immer.finishDraft.bind(immer)\n\n/**\n * This function is actually a no-op, but can be used to cast an immutable type\n * to an draft type and make TypeScript happy\n *\n * @param value\n */\nexport function castDraft<T>(value: T): Draft<T> {\n\treturn value as any\n}\n\n/**\n * This function is actually a no-op, but can be used to cast a mutable type\n * to an immutable type and make TypeScript happy\n * @param value\n */\nexport function castImmutable<T>(value: T): Immutable<T> {\n\treturn value as any\n}\n\nexport {Immer}\n\nexport {enablePatches} from \"./plugins/patches\"\nexport {enableMapSet} from \"./plugins/mapset\"\n", "// src/actions/await/awaitAsync.ts\nfunction awaitAsync() {\n  return {\n    kind: \"transformation\",\n    type: \"await\",\n    reference: awaitAsync,\n    async: true,\n    async _run(dataset) {\n      dataset.value = await dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/regex.ts\nvar BASE64_REGEX = /^(?:[\\da-z+/]{4})*(?:[\\da-z+/]{2}==|[\\da-z+/]{3}=)?$/iu;\nvar BIC_REGEX = /^[A-Z]{6}(?!00)[\\dA-Z]{2}(?:[\\dA-Z]{3})?$/u;\nvar CUID2_REGEX = /^[a-z][\\da-z]*$/u;\nvar DECIMAL_REGEX = /^[+-]?\\d+(?:\\.\\d+)?$/u;\nvar DIGITS_REGEX = /^\\d+$/u;\nvar EMAIL_REGEX = /^[\\w+-]+(?:\\.[\\w+-]+)*@[\\da-z]+(?:[.-][\\da-z]+)*\\.[a-z]{2,}$/iu;\nvar EMOJI_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex, regexp/no-dupe-disjunctions -- false positives\n  /^(?:[\\u{1F1E6}-\\u{1F1FF}]{2}|\\u{1F3F4}[\\u{E0061}-\\u{E007A}]{2}[\\u{E0030}-\\u{E0039}\\u{E0061}-\\u{E007A}]{1,3}\\u{E007F}|(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation})(?:\\u200D(?:\\p{Emoji}\\uFE0F\\u20E3?|\\p{Emoji_Modifier_Base}\\p{Emoji_Modifier}?|\\p{Emoji_Presentation}))*)+$/u\n);\nvar HEXADECIMAL_REGEX = /^(?:0[hx])?[\\da-f]+$/iu;\nvar HEX_COLOR_REGEX = /^#(?:[\\da-f]{3,4}|[\\da-f]{6}|[\\da-f]{8})$/iu;\nvar IMEI_REGEX = /^\\d{15}$|^\\d{2}-\\d{6}-\\d{6}-\\d$/u;\nvar IPV4_REGEX = (\n  // eslint-disable-next-line redos-detector/no-unsafe-regex -- false positive\n  /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$/u\n);\nvar IPV6_REGEX = /^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar IP_REGEX = /^(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])(?:\\.(?:(?:[1-9]|1\\d|2[0-4])?\\d|25[0-5])){3}$|^(?:(?:[\\da-f]{1,4}:){7}[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,7}:|(?:[\\da-f]{1,4}:){1,6}:[\\da-f]{1,4}|(?:[\\da-f]{1,4}:){1,5}(?::[\\da-f]{1,4}){1,2}|(?:[\\da-f]{1,4}:){1,4}(?::[\\da-f]{1,4}){1,3}|(?:[\\da-f]{1,4}:){1,3}(?::[\\da-f]{1,4}){1,4}|(?:[\\da-f]{1,4}:){1,2}(?::[\\da-f]{1,4}){1,5}|[\\da-f]{1,4}:(?::[\\da-f]{1,4}){1,6}|:(?:(?::[\\da-f]{1,4}){1,7}|:)|fe80:(?::[\\da-f]{0,4}){0,4}%[\\da-z]+|::(?:f{4}(?::0{1,4})?:)?(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)|(?:[\\da-f]{1,4}:){1,4}:(?:(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d)\\.){3}(?:25[0-5]|(?:2[0-4]|1?\\d)?\\d))$/iu;\nvar ISO_DATE_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])$/u;\nvar ISO_DATE_TIME_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_REGEX = /^(?:0\\d|1\\d|2[0-3]):[0-5]\\d$/u;\nvar ISO_TIME_SECOND_REGEX = /^(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}$/u;\nvar ISO_TIMESTAMP_REGEX = /^\\d{4}-(?:0[1-9]|1[0-2])-(?:[12]\\d|0[1-9]|3[01])T(?:0\\d|1\\d|2[0-3])(?::[0-5]\\d){2}(?:\\.\\d{1,9})?(?:Z|[+-](?:0\\d|1\\d|2[0-3])(?::?[0-5]\\d)?)$/u;\nvar ISO_WEEK_REGEX = /^\\d{4}-W(?:0[1-9]|[1-4]\\d|5[0-3])$/u;\nvar MAC48_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$/iu;\nvar MAC64_REGEX = /^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar MAC_REGEX = /^(?:[\\da-f]{2}:){5}[\\da-f]{2}$|^(?:[\\da-f]{2}-){5}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){2}[\\da-f]{4}$|^(?:[\\da-f]{2}:){7}[\\da-f]{2}$|^(?:[\\da-f]{2}-){7}[\\da-f]{2}$|^(?:[\\da-f]{4}\\.){3}[\\da-f]{4}$|^(?:[\\da-f]{4}:){3}[\\da-f]{4}$/iu;\nvar NANO_ID_REGEX = /^[\\w-]+$/u;\nvar OCTAL_REGEX = /^(?:0o)?[0-7]+$/iu;\nvar ULID_REGEX = /^[\\da-hjkmnp-tv-z]{26}$/iu;\nvar UUID_REGEX = /^[\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12}$/iu;\n\n// src/storages/globalConfig/globalConfig.ts\nvar store;\nfunction setGlobalConfig(config2) {\n  store = { ...store, ...config2 };\n}\nfunction getGlobalConfig(config2) {\n  return {\n    lang: config2?.lang ?? store?.lang,\n    message: config2?.message,\n    abortEarly: config2?.abortEarly ?? store?.abortEarly,\n    abortPipeEarly: config2?.abortPipeEarly ?? store?.abortPipeEarly\n  };\n}\nfunction deleteGlobalConfig() {\n  store = void 0;\n}\n\n// src/storages/globalMessage/globalMessage.ts\nvar store2;\nfunction setGlobalMessage(message, lang) {\n  if (!store2) store2 = /* @__PURE__ */ new Map();\n  store2.set(lang, message);\n}\nfunction getGlobalMessage(lang) {\n  return store2?.get(lang);\n}\nfunction deleteGlobalMessage(lang) {\n  store2?.delete(lang);\n}\n\n// src/storages/schemaMessage/schemaMessage.ts\nvar store3;\nfunction setSchemaMessage(message, lang) {\n  if (!store3) store3 = /* @__PURE__ */ new Map();\n  store3.set(lang, message);\n}\nfunction getSchemaMessage(lang) {\n  return store3?.get(lang);\n}\nfunction deleteSchemaMessage(lang) {\n  store3?.delete(lang);\n}\n\n// src/storages/specificMessage/specificMessage.ts\nvar store4;\nfunction setSpecificMessage(reference, message, lang) {\n  if (!store4) store4 = /* @__PURE__ */ new Map();\n  if (!store4.get(reference)) store4.set(reference, /* @__PURE__ */ new Map());\n  store4.get(reference).set(lang, message);\n}\nfunction getSpecificMessage(reference, lang) {\n  return store4?.get(reference)?.get(lang);\n}\nfunction deleteSpecificMessage(reference, lang) {\n  store4?.get(reference)?.delete(lang);\n}\n\n// src/utils/_stringify/_stringify.ts\nfunction _stringify(input) {\n  const type = typeof input;\n  if (type === \"string\") {\n    return `\"${input}\"`;\n  }\n  if (type === \"number\" || type === \"bigint\" || type === \"boolean\") {\n    return `${input}`;\n  }\n  if (type === \"object\" || type === \"function\") {\n    return (input && Object.getPrototypeOf(input)?.constructor?.name) ?? \"null\";\n  }\n  return type;\n}\n\n// src/utils/_addIssue/_addIssue.ts\nfunction _addIssue(context, label, dataset, config2, other) {\n  const input = other && \"input\" in other ? other.input : dataset.value;\n  const expected = other?.expected ?? context.expects ?? null;\n  const received = other?.received ?? _stringify(input);\n  const issue = {\n    kind: context.kind,\n    type: context.type,\n    input,\n    expected,\n    received,\n    message: `Invalid ${label}: ${expected ? `Expected ${expected} but r` : \"R\"}eceived ${received}`,\n    requirement: context.requirement,\n    path: other?.path,\n    issues: other?.issues,\n    lang: config2.lang,\n    abortEarly: config2.abortEarly,\n    abortPipeEarly: config2.abortPipeEarly\n  };\n  const isSchema = context.kind === \"schema\";\n  const message = other?.message ?? context.message ?? getSpecificMessage(context.reference, issue.lang) ?? (isSchema ? getSchemaMessage(issue.lang) : null) ?? config2.message ?? getGlobalMessage(issue.lang);\n  if (message) {\n    issue.message = typeof message === \"function\" ? (\n      // @ts-expect-error\n      message(issue)\n    ) : message;\n  }\n  if (isSchema) {\n    dataset.typed = false;\n  }\n  if (dataset.issues) {\n    dataset.issues.push(issue);\n  } else {\n    dataset.issues = [issue];\n  }\n}\n\n// src/utils/_isLuhnAlgo/_isLuhnAlgo.ts\nvar NON_DIGIT_REGEX = /\\D/gu;\nfunction _isLuhnAlgo(input) {\n  const number2 = input.replace(NON_DIGIT_REGEX, \"\");\n  let length2 = number2.length;\n  let bit = 1;\n  let sum = 0;\n  while (length2) {\n    const value2 = +number2[--length2];\n    bit ^= 1;\n    sum += bit ? [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][value2] : value2;\n  }\n  return sum % 10 === 0;\n}\n\n// src/utils/_isValidObjectKey/_isValidObjectKey.ts\nfunction _isValidObjectKey(object2, key) {\n  return Object.hasOwn(object2, key) && key !== \"__proto__\" && key !== \"prototype\" && key !== \"constructor\";\n}\n\n// src/utils/_joinExpects/_joinExpects.ts\nfunction _joinExpects(values, separator) {\n  const list = [...new Set(values)];\n  if (list.length > 1) {\n    return `(${list.join(` ${separator} `)})`;\n  }\n  return list[0] ?? \"never\";\n}\n\n// src/utils/entriesFromList/entriesFromList.ts\nfunction entriesFromList(list, schema) {\n  const entries = {};\n  for (const key of list) {\n    entries[key] = schema;\n  }\n  return entries;\n}\n\n// src/utils/getDotPath/getDotPath.ts\nfunction getDotPath(issue) {\n  if (issue.path) {\n    let key = \"\";\n    for (const item of issue.path) {\n      if (typeof item.key === \"string\" || typeof item.key === \"number\") {\n        if (key) {\n          key += `.${item.key}`;\n        } else {\n          key += item.key;\n        }\n      } else {\n        return null;\n      }\n    }\n    return key;\n  }\n  return null;\n}\n\n// src/utils/isOfKind/isOfKind.ts\nfunction isOfKind(kind, object2) {\n  return object2.kind === kind;\n}\n\n// src/utils/isOfType/isOfType.ts\nfunction isOfType(type, object2) {\n  return object2.type === type;\n}\n\n// src/utils/isValiError/isValiError.ts\nfunction isValiError(error) {\n  return error instanceof ValiError;\n}\n\n// src/utils/ValiError/ValiError.ts\nvar ValiError = class extends Error {\n  /**\n   * The error issues.\n   */\n  issues;\n  /**\n   * Creates a Valibot error with useful information.\n   *\n   * @param issues The error issues.\n   */\n  constructor(issues) {\n    super(issues[0].message);\n    this.name = \"ValiError\";\n    this.issues = issues;\n  }\n};\n\n// src/actions/base64/base64.ts\nfunction base64(message) {\n  return {\n    kind: \"validation\",\n    type: \"base64\",\n    reference: base64,\n    async: false,\n    expects: null,\n    requirement: BASE64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Base64\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bic/bic.ts\nfunction bic(message) {\n  return {\n    kind: \"validation\",\n    type: \"bic\",\n    reference: bic,\n    async: false,\n    expects: null,\n    requirement: BIC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"BIC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/brand/brand.ts\nfunction brand(name) {\n  return {\n    kind: \"transformation\",\n    type: \"brand\",\n    reference: brand,\n    async: false,\n    name,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/bytes/bytes.ts\nfunction bytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"bytes\",\n    reference: bytes,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 !== this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/check.ts\nfunction check(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: check,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/check/checkAsync.ts\nfunction checkAsync(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check\",\n    reference: checkAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.typed && !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/checkItems/checkItems.ts\nfunction checkItems(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"check_items\",\n    reference: checkItems,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        for (let index = 0; index < dataset.value.length; index++) {\n          const item = dataset.value[index];\n          if (!this.requirement(item, index, dataset.value)) {\n            _addIssue(this, \"item\", dataset, config2, {\n              input: item,\n              path: [\n                {\n                  type: \"array\",\n                  origin: \"value\",\n                  input: dataset.value,\n                  key: index,\n                  value: item\n                }\n              ]\n            });\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/creditCard/creditCard.ts\nvar CREDIT_CARD_REGEX = /^(?:\\d{14,19}|\\d{4}(?: \\d{3,6}){2,4}|\\d{4}(?:-\\d{3,6}){2,4})$/u;\nvar SANITIZE_REGEX = /[- ]/gu;\nvar PROVIDER_REGEX_LIST = [\n  // American Express\n  /^3[47]\\d{13}$/u,\n  // Diners Club\n  /^3(?:0[0-5]|[68]\\d)\\d{11,13}$/u,\n  // Discover\n  /^6(?:011|5\\d{2})\\d{12,15}$/u,\n  // JCB\n  /^(?:2131|1800|35\\d{3})\\d{11}$/u,\n  // Mastercard\n  /^5[1-5]\\d{2}|(?:222\\d|22[3-9]\\d|2[3-6]\\d{2}|27[01]\\d|2720)\\d{12}$/u,\n  // UnionPay\n  /^(?:6[27]\\d{14,17}|81\\d{14,17})$/u,\n  // Visa\n  /^4\\d{12}(?:\\d{3,6})?$/u\n];\nfunction creditCard(message) {\n  return {\n    kind: \"validation\",\n    type: \"credit_card\",\n    reference: creditCard,\n    async: false,\n    expects: null,\n    requirement(input) {\n      let sanitized;\n      return CREDIT_CARD_REGEX.test(input) && // Remove any hyphens and blanks\n      (sanitized = input.replace(SANITIZE_REGEX, \"\")) && // Check if it matches a provider\n      PROVIDER_REGEX_LIST.some((regex2) => regex2.test(sanitized)) && // Check if passes luhn algorithm\n      _isLuhnAlgo(sanitized);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"credit card\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/cuid2/cuid2.ts\nfunction cuid2(message) {\n  return {\n    kind: \"validation\",\n    type: \"cuid2\",\n    reference: cuid2,\n    async: false,\n    expects: null,\n    requirement: CUID2_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Cuid2\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/decimal/decimal.ts\nfunction decimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"decimal\",\n    reference: decimal,\n    async: false,\n    expects: null,\n    requirement: DECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"decimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/description/description.ts\nfunction description(description_) {\n  return {\n    kind: \"metadata\",\n    type: \"description\",\n    reference: description,\n    description: description_\n  };\n}\n\n// src/actions/digits/digits.ts\nfunction digits(message) {\n  return {\n    kind: \"validation\",\n    type: \"digits\",\n    reference: digits,\n    async: false,\n    expects: null,\n    requirement: DIGITS_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"digits\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/email/email.ts\nfunction email(message) {\n  return {\n    kind: \"validation\",\n    type: \"email\",\n    reference: email,\n    expects: null,\n    async: false,\n    requirement: EMAIL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"email\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/emoji/emoji.ts\nfunction emoji(message) {\n  return {\n    kind: \"validation\",\n    type: \"emoji\",\n    reference: emoji,\n    async: false,\n    expects: null,\n    requirement: EMOJI_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"emoji\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/empty/empty.ts\nfunction empty(message) {\n  return {\n    kind: \"validation\",\n    type: \"empty\",\n    reference: empty,\n    async: false,\n    expects: \"0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/endsWith/endsWith.ts\nfunction endsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"ends_with\",\n    reference: endsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.endsWith(this.requirement)) {\n        _addIssue(this, \"end\", dataset, config2, {\n          received: `\"${dataset.value.slice(-this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/everyItem/everyItem.ts\nfunction everyItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"every_item\",\n    reference: everyItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.every(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/excludes/excludes.ts\nfunction excludes(requirement, message) {\n  const received = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"excludes\",\n    reference: excludes,\n    async: false,\n    expects: `!${received}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, { received });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/filterItems/filterItems.ts\nfunction filterItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"filter_items\",\n    reference: filterItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.filter(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/findItem/findItem.ts\nfunction findItem(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"find_item\",\n    reference: findItem,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.find(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/finite/finite.ts\nfunction finite(message) {\n  return {\n    kind: \"validation\",\n    type: \"finite\",\n    reference: finite,\n    async: false,\n    expects: null,\n    requirement: Number.isFinite,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"finite\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hash/hash.ts\nvar HASH_LENGTHS = {\n  md4: 32,\n  md5: 32,\n  sha1: 40,\n  sha256: 64,\n  sha384: 96,\n  sha512: 128,\n  ripemd128: 32,\n  ripemd160: 40,\n  tiger128: 32,\n  tiger160: 40,\n  tiger192: 48,\n  crc32: 8,\n  crc32b: 8,\n  adler32: 8\n};\nfunction hash(types, message) {\n  return {\n    kind: \"validation\",\n    type: \"hash\",\n    reference: hash,\n    expects: null,\n    async: false,\n    requirement: RegExp(\n      types.map((type) => `^[a-f0-9]{${HASH_LENGTHS[type]}}$`).join(\"|\"),\n      \"iu\"\n    ),\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hash\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexadecimal/hexadecimal.ts\nfunction hexadecimal(message) {\n  return {\n    kind: \"validation\",\n    type: \"hexadecimal\",\n    reference: hexadecimal,\n    async: false,\n    expects: null,\n    requirement: HEXADECIMAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hexadecimal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/hexColor/hexColor.ts\nfunction hexColor(message) {\n  return {\n    kind: \"validation\",\n    type: \"hex_color\",\n    reference: hexColor,\n    async: false,\n    expects: null,\n    requirement: HEX_COLOR_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"hex color\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/imei/imei.ts\nfunction imei(message) {\n  return {\n    kind: \"validation\",\n    type: \"imei\",\n    reference: imei,\n    async: false,\n    expects: null,\n    requirement(input) {\n      return IMEI_REGEX.test(input) && _isLuhnAlgo(input);\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"IMEI\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/includes/includes.ts\nfunction includes(requirement, message) {\n  const expects = _stringify(requirement);\n  return {\n    kind: \"validation\",\n    type: \"includes\",\n    reference: includes,\n    async: false,\n    expects,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.includes(this.requirement)) {\n        _addIssue(this, \"content\", dataset, config2, {\n          received: `!${expects}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/integer/integer.ts\nfunction integer(message) {\n  return {\n    kind: \"validation\",\n    type: \"integer\",\n    reference: integer,\n    async: false,\n    expects: null,\n    requirement: Number.isInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ip/ip.ts\nfunction ip(message) {\n  return {\n    kind: \"validation\",\n    type: \"ip\",\n    reference: ip,\n    async: false,\n    expects: null,\n    requirement: IP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IP\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv4/ipv4.ts\nfunction ipv4(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv4\",\n    reference: ipv4,\n    async: false,\n    expects: null,\n    requirement: IPV4_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv4\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ipv6/ipv6.ts\nfunction ipv6(message) {\n  return {\n    kind: \"validation\",\n    type: \"ipv6\",\n    reference: ipv6,\n    async: false,\n    expects: null,\n    requirement: IPV6_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"IPv6\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDate/isoDate.ts\nfunction isoDate(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date\",\n    reference: isoDate,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoDateTime/isoDateTime.ts\nfunction isoDateTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_date_time\",\n    reference: isoDateTime,\n    async: false,\n    expects: null,\n    requirement: ISO_DATE_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"date-time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTime/isoTime.ts\nfunction isoTime(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time\",\n    reference: isoTime,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimeSecond/isoTimeSecond.ts\nfunction isoTimeSecond(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_time_second\",\n    reference: isoTimeSecond,\n    async: false,\n    expects: null,\n    requirement: ISO_TIME_SECOND_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"time-second\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoTimestamp/isoTimestamp.ts\nfunction isoTimestamp(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_timestamp\",\n    reference: isoTimestamp,\n    async: false,\n    expects: null,\n    requirement: ISO_TIMESTAMP_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"timestamp\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/isoWeek/isoWeek.ts\nfunction isoWeek(message) {\n  return {\n    kind: \"validation\",\n    type: \"iso_week\",\n    reference: isoWeek,\n    async: false,\n    expects: null,\n    requirement: ISO_WEEK_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"week\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/length/length.ts\nfunction length(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"length\",\n    reference: length,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length !== this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac/mac.ts\nfunction mac(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac\",\n    reference: mac,\n    async: false,\n    expects: null,\n    requirement: MAC_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac48/mac48.ts\nfunction mac48(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac48\",\n    reference: mac48,\n    async: false,\n    expects: null,\n    requirement: MAC48_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"48-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mac64/mac64.ts\nfunction mac64(message) {\n  return {\n    kind: \"validation\",\n    type: \"mac64\",\n    reference: mac64,\n    async: false,\n    expects: null,\n    requirement: MAC64_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"64-bit MAC\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/mapItems/mapItems.ts\nfunction mapItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"map_items\",\n    reference: mapItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.map(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxBytes/maxBytes.ts\nfunction maxBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_bytes\",\n    reference: maxBytes,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 > this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxLength/maxLength.ts\nfunction maxLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_length\",\n    reference: maxLength,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length > this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxSize/maxSize.ts\nfunction maxSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_size\",\n    reference: maxSize,\n    async: false,\n    expects: `<=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size > this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/maxValue/maxValue.ts\nfunction maxValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"max_value\",\n    reference: maxValue,\n    async: false,\n    expects: `<=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value > this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/metadata/metadata.ts\nfunction metadata(metadata_) {\n  return {\n    kind: \"metadata\",\n    type: \"metadata\",\n    reference: metadata,\n    metadata: metadata_\n  };\n}\n\n// src/actions/mimeType/mimeType.ts\nfunction mimeType(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"mime_type\",\n    reference: mimeType,\n    async: false,\n    expects: _joinExpects(\n      requirement.map((option) => `\"${option}\"`),\n      \"|\"\n    ),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.includes(dataset.value.type)) {\n        _addIssue(this, \"MIME type\", dataset, config2, {\n          received: `\"${dataset.value.type}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minBytes/minBytes.ts\nfunction minBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_bytes\",\n    reference: minBytes,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 < this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minLength/minLength.ts\nfunction minLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_length\",\n    reference: minLength,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length < this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minSize/minSize.ts\nfunction minSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_size\",\n    reference: minSize,\n    async: false,\n    expects: `>=${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size < this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/minValue/minValue.ts\nfunction minValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"min_value\",\n    reference: minValue,\n    async: false,\n    expects: `>=${requirement instanceof Date ? requirement.toJSON() : _stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value < this.requirement) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/multipleOf/multipleOf.ts\nfunction multipleOf(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"multiple_of\",\n    reference: multipleOf,\n    async: false,\n    expects: `%${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value % this.requirement !== 0) {\n        _addIssue(this, \"multiple\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nanoid/nanoid.ts\nfunction nanoid(message) {\n  return {\n    kind: \"validation\",\n    type: \"nanoid\",\n    reference: nanoid,\n    async: false,\n    expects: null,\n    requirement: NANO_ID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"Nano ID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/nonEmpty/nonEmpty.ts\nfunction nonEmpty(message) {\n  return {\n    kind: \"validation\",\n    type: \"non_empty\",\n    reference: nonEmpty,\n    async: false,\n    expects: \"!0\",\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === 0) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: \"0\"\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/normalize/normalize.ts\nfunction normalize(form) {\n  return {\n    kind: \"transformation\",\n    type: \"normalize\",\n    reference: normalize,\n    async: false,\n    form,\n    _run(dataset) {\n      dataset.value = dataset.value.normalize(this.form);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notBytes/notBytes.ts\nfunction notBytes(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_bytes\",\n    reference: notBytes,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed) {\n        const length2 = new TextEncoder().encode(dataset.value).length;\n        if (length2 === this.requirement) {\n          _addIssue(this, \"bytes\", dataset, config2, {\n            received: `${length2}`\n          });\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notLength/notLength.ts\nfunction notLength(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_length\",\n    reference: notLength,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.length === this.requirement) {\n        _addIssue(this, \"length\", dataset, config2, {\n          received: `${dataset.value.length}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notSize/notSize.ts\nfunction notSize(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_size\",\n    reference: notSize,\n    async: false,\n    expects: `!${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size === this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/notValue/notValue.ts\nfunction notValue(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"not_value\",\n    reference: notValue,\n    async: false,\n    expects: requirement instanceof Date ? `!${requirement.toJSON()}` : `!${_stringify(requirement)}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && this.requirement <= dataset.value && this.requirement >= dataset.value) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/octal/octal.ts\nfunction octal(message) {\n  return {\n    kind: \"validation\",\n    type: \"octal\",\n    reference: octal,\n    async: false,\n    expects: null,\n    requirement: OCTAL_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"octal\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/utils/_isPartiallyTyped/_isPartiallyTyped.ts\nfunction _isPartiallyTyped(dataset, pathList) {\n  if (dataset.issues) {\n    for (const path of pathList) {\n      for (const issue of dataset.issues) {\n        let typed = false;\n        const bound = Math.min(path.length, issue.path?.length ?? 0);\n        for (let index = 0; index < bound; index++) {\n          if (path[index] !== issue.path[index].key) {\n            typed = true;\n            break;\n          }\n        }\n        if (!typed) {\n          return false;\n        }\n      }\n    }\n  }\n  return true;\n}\n\n// src/actions/partialCheck/partialCheck.ts\nfunction partialCheck(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheck,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/partialCheck/partialCheckAsync.ts\nfunction partialCheckAsync(pathList, requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"partial_check\",\n    reference: partialCheckAsync,\n    async: true,\n    expects: null,\n    requirement,\n    message,\n    async _run(dataset, config2) {\n      if (_isPartiallyTyped(dataset, pathList) && // @ts-expect-error\n      !await this.requirement(dataset.value)) {\n        _addIssue(this, \"input\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheck.ts\nfunction rawCheck(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheck,\n    async: false,\n    expects: null,\n    _run(dataset, config2) {\n      action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawCheck/rawCheckAsync.ts\nfunction rawCheckAsync(action) {\n  return {\n    kind: \"validation\",\n    type: \"raw_check\",\n    reference: rawCheckAsync,\n    async: true,\n    expects: null,\n    async _run(dataset, config2) {\n      await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info)\n      });\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransform.ts\nfunction rawTransform(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransform,\n    async: false,\n    _run(dataset, config2) {\n      const output = action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/rawTransform/rawTransformAsync.ts\nfunction rawTransformAsync(action) {\n  return {\n    kind: \"transformation\",\n    type: \"raw_transform\",\n    reference: rawTransformAsync,\n    async: true,\n    async _run(dataset, config2) {\n      const output = await action({\n        dataset,\n        config: config2,\n        addIssue: (info) => _addIssue(this, info?.label ?? \"input\", dataset, config2, info),\n        NEVER: null\n      });\n      if (dataset.issues) {\n        dataset.typed = false;\n      } else {\n        dataset.value = output;\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/readonly/readonly.ts\nfunction readonly() {\n  return {\n    kind: \"transformation\",\n    type: \"readonly\",\n    reference: readonly,\n    async: false,\n    _run(dataset) {\n      return dataset;\n    }\n  };\n}\n\n// src/actions/reduceItems/reduceItems.ts\nfunction reduceItems(operation, initial) {\n  return {\n    kind: \"transformation\",\n    type: \"reduce_items\",\n    reference: reduceItems,\n    async: false,\n    operation,\n    initial,\n    _run(dataset) {\n      dataset.value = dataset.value.reduce(this.operation, this.initial);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/regex/regex.ts\nfunction regex(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"regex\",\n    reference: regex,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"format\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/safeInteger/safeInteger.ts\nfunction safeInteger(message) {\n  return {\n    kind: \"validation\",\n    type: \"safe_integer\",\n    reference: safeInteger,\n    async: false,\n    expects: null,\n    requirement: Number.isSafeInteger,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"safe integer\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/size/size.ts\nfunction size(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"size\",\n    reference: size,\n    async: false,\n    expects: `${requirement}`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && dataset.value.size !== this.requirement) {\n        _addIssue(this, \"size\", dataset, config2, {\n          received: `${dataset.value.size}`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/someItem/someItem.ts\nfunction someItem(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"some_item\",\n    reference: someItem,\n    async: false,\n    expects: null,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.some(this.requirement)) {\n        _addIssue(this, \"item\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/sortItems/sortItems.ts\nfunction sortItems(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"sort_items\",\n    reference: sortItems,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = dataset.value.sort(this.operation);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/startsWith/startsWith.ts\nfunction startsWith(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"starts_with\",\n    reference: startsWith,\n    async: false,\n    expects: `\"${requirement}\"`,\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !dataset.value.startsWith(this.requirement)) {\n        _addIssue(this, \"start\", dataset, config2, {\n          received: `\"${dataset.value.slice(0, this.requirement.length)}\"`\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/title/title.ts\nfunction title(title_) {\n  return {\n    kind: \"metadata\",\n    type: \"title\",\n    reference: title,\n    title: title_\n  };\n}\n\n// src/actions/toLowerCase/toLowerCase.ts\nfunction toLowerCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_lower_case\",\n    reference: toLowerCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toLowerCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMaxValue/toMaxValue.ts\nfunction toMaxValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_max_value\",\n    reference: toMaxValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value > this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toMinValue/toMinValue.ts\nfunction toMinValue(requirement) {\n  return {\n    kind: \"transformation\",\n    type: \"to_min_value\",\n    reference: toMinValue,\n    async: false,\n    requirement,\n    _run(dataset) {\n      dataset.value = dataset.value < this.requirement ? this.requirement : dataset.value;\n      return dataset;\n    }\n  };\n}\n\n// src/actions/toUpperCase/toUpperCase.ts\nfunction toUpperCase() {\n  return {\n    kind: \"transformation\",\n    type: \"to_upper_case\",\n    reference: toUpperCase,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.toUpperCase();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transform.ts\nfunction transform(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transform,\n    async: false,\n    operation,\n    _run(dataset) {\n      dataset.value = this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/transform/transformAsync.ts\nfunction transformAsync(operation) {\n  return {\n    kind: \"transformation\",\n    type: \"transform\",\n    reference: transformAsync,\n    async: true,\n    operation,\n    async _run(dataset) {\n      dataset.value = await this.operation(dataset.value);\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trim/trim.ts\nfunction trim() {\n  return {\n    kind: \"transformation\",\n    type: \"trim\",\n    reference: trim,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trim();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimEnd/trimEnd.ts\nfunction trimEnd() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_end\",\n    reference: trimEnd,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimEnd();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/trimStart/trimStart.ts\nfunction trimStart() {\n  return {\n    kind: \"transformation\",\n    type: \"trim_start\",\n    reference: trimStart,\n    async: false,\n    _run(dataset) {\n      dataset.value = dataset.value.trimStart();\n      return dataset;\n    }\n  };\n}\n\n// src/actions/ulid/ulid.ts\nfunction ulid(message) {\n  return {\n    kind: \"validation\",\n    type: \"ulid\",\n    reference: ulid,\n    async: false,\n    expects: null,\n    requirement: ULID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"ULID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/url/url.ts\nfunction url(message) {\n  return {\n    kind: \"validation\",\n    type: \"url\",\n    reference: url,\n    async: false,\n    expects: null,\n    requirement(input) {\n      try {\n        new URL(input);\n        return true;\n      } catch {\n        return false;\n      }\n    },\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement(dataset.value)) {\n        _addIssue(this, \"URL\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/uuid/uuid.ts\nfunction uuid(message) {\n  return {\n    kind: \"validation\",\n    type: \"uuid\",\n    reference: uuid,\n    async: false,\n    expects: null,\n    requirement: UUID_REGEX,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !this.requirement.test(dataset.value)) {\n        _addIssue(this, \"UUID\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/actions/value/value.ts\nfunction value(requirement, message) {\n  return {\n    kind: \"validation\",\n    type: \"value\",\n    reference: value,\n    async: false,\n    expects: requirement instanceof Date ? requirement.toJSON() : _stringify(requirement),\n    requirement,\n    message,\n    _run(dataset, config2) {\n      if (dataset.typed && !(this.requirement <= dataset.value && this.requirement >= dataset.value)) {\n        _addIssue(this, \"value\", dataset, config2, {\n          received: dataset.value instanceof Date ? dataset.value.toJSON() : _stringify(dataset.value)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/config/config.ts\nfunction config(schema, config2) {\n  return {\n    ...schema,\n    _run(dataset, config_) {\n      return schema._run(dataset, { ...config_, ...config2 });\n    }\n  };\n}\n\n// src/methods/getFallback/getFallback.ts\nfunction getFallback(schema, dataset, config2) {\n  return typeof schema.fallback === \"function\" ? (\n    // @ts-expect-error\n    schema.fallback(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.fallback\n  );\n}\n\n// src/methods/fallback/fallback.ts\nfunction fallback(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    _run(dataset, config2) {\n      const outputDataset = schema._run(dataset, config2);\n      return outputDataset.issues ? { typed: true, value: getFallback(this, outputDataset, config2) } : outputDataset;\n    }\n  };\n}\n\n// src/methods/fallback/fallbackAsync.ts\nfunction fallbackAsync(schema, fallback2) {\n  return {\n    ...schema,\n    fallback: fallback2,\n    async: true,\n    async _run(dataset, config2) {\n      const outputDataset = await schema._run(dataset, config2);\n      return outputDataset.issues ? (\n        // @ts-expect-error\n        { typed: true, value: await getFallback(this, outputDataset, config2) }\n      ) : outputDataset;\n    }\n  };\n}\n\n// src/methods/flatten/flatten.ts\nfunction flatten(issues) {\n  const flatErrors = {};\n  for (const issue of issues) {\n    if (issue.path) {\n      const dotPath = getDotPath(issue);\n      if (dotPath) {\n        if (!flatErrors.nested) {\n          flatErrors.nested = {};\n        }\n        if (flatErrors.nested[dotPath]) {\n          flatErrors.nested[dotPath].push(issue.message);\n        } else {\n          flatErrors.nested[dotPath] = [issue.message];\n        }\n      } else {\n        if (flatErrors.other) {\n          flatErrors.other.push(issue.message);\n        } else {\n          flatErrors.other = [issue.message];\n        }\n      }\n    } else {\n      if (flatErrors.root) {\n        flatErrors.root.push(issue.message);\n      } else {\n        flatErrors.root = [issue.message];\n      }\n    }\n  }\n  return flatErrors;\n}\n\n// src/methods/forward/forward.ts\nfunction forward(action, pathKeys) {\n  return {\n    ...action,\n    _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/forward/forwardAsync.ts\nfunction forwardAsync(action, pathKeys) {\n  return {\n    ...action,\n    async: true,\n    async _run(dataset, config2) {\n      const prevIssues = dataset.issues && [...dataset.issues];\n      await action._run(dataset, config2);\n      if (dataset.issues) {\n        for (const issue of dataset.issues) {\n          if (!prevIssues?.includes(issue)) {\n            let pathInput = dataset.value;\n            for (const key of pathKeys) {\n              const pathValue = pathInput[key];\n              const pathItem = {\n                type: \"unknown\",\n                origin: \"value\",\n                input: pathInput,\n                key,\n                value: pathValue\n              };\n              if (issue.path) {\n                issue.path.push(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              if (!pathValue) {\n                break;\n              }\n              pathInput = pathValue;\n            }\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/getDefault/getDefault.ts\nfunction getDefault(schema, dataset, config2) {\n  return typeof schema.default === \"function\" ? (\n    // @ts-expect-error\n    schema.default(dataset, config2)\n  ) : (\n    // @ts-expect-error\n    schema.default\n  );\n}\n\n// src/methods/getDefaults/getDefaults.ts\nfunction getDefaults(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getDefaults(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getDefaults);\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getDefaults/getDefaultsAsync.ts\nasync function getDefaultsAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getDefaultsAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getDefaultsAsync));\n  }\n  return getDefault(schema);\n}\n\n// src/methods/getFallbacks/getFallbacks.ts\nfunction getFallbacks(schema) {\n  if (\"entries\" in schema) {\n    const object2 = {};\n    for (const key in schema.entries) {\n      object2[key] = getFallbacks(schema.entries[key]);\n    }\n    return object2;\n  }\n  if (\"items\" in schema) {\n    return schema.items.map(getFallbacks);\n  }\n  return getFallback(schema);\n}\n\n// src/methods/getFallbacks/getFallbacksAsync.ts\nasync function getFallbacksAsync(schema) {\n  if (\"entries\" in schema) {\n    return Object.fromEntries(\n      await Promise.all(\n        Object.entries(schema.entries).map(async ([key, value2]) => [\n          key,\n          await getFallbacksAsync(value2)\n        ])\n      )\n    );\n  }\n  if (\"items\" in schema) {\n    return Promise.all(schema.items.map(getFallbacksAsync));\n  }\n  return getFallback(schema);\n}\n\n// src/methods/is/is.ts\nfunction is(schema, input) {\n  return !schema._run({ typed: false, value: input }, { abortEarly: true }).issues;\n}\n\n// src/schemas/any/any.ts\nfunction any() {\n  return {\n    kind: \"schema\",\n    type: \"any\",\n    reference: any,\n    expects: \"any\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/array.ts\nfunction array(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: array,\n    expects: \"Array\",\n    async: false,\n    item,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < input.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.item._run({ typed: false, value: value2 }, config2);\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/array/arrayAsync.ts\nfunction arrayAsync(item, message) {\n  return {\n    kind: \"schema\",\n    type: \"array\",\n    reference: arrayAsync,\n    expects: \"Array\",\n    async: true,\n    item,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          input.map((value2) => this.item._run({ typed: false, value: value2 }, config2))\n        );\n        for (let key = 0; key < itemDatasets.length; key++) {\n          const itemDataset = itemDatasets[key];\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: input[key]\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/bigint/bigint.ts\nfunction bigint(message) {\n  return {\n    kind: \"schema\",\n    type: \"bigint\",\n    reference: bigint,\n    expects: \"bigint\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"bigint\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/blob/blob.ts\nfunction blob(message) {\n  return {\n    kind: \"schema\",\n    type: \"blob\",\n    reference: blob,\n    expects: \"Blob\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Blob) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/boolean/boolean.ts\nfunction boolean(message) {\n  return {\n    kind: \"schema\",\n    type: \"boolean\",\n    reference: boolean,\n    expects: \"boolean\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"boolean\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/custom.ts\nfunction custom(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: custom,\n    expects: \"unknown\",\n    async: false,\n    check: check2,\n    message,\n    _run(dataset, config2) {\n      if (this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/custom/customAsync.ts\nfunction customAsync(check2, message) {\n  return {\n    kind: \"schema\",\n    type: \"custom\",\n    reference: customAsync,\n    expects: \"unknown\",\n    async: true,\n    check: check2,\n    message,\n    async _run(dataset, config2) {\n      if (await this.check(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/date/date.ts\nfunction date(message) {\n  return {\n    kind: \"schema\",\n    type: \"date\",\n    reference: date,\n    expects: \"Date\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Date) {\n        if (!isNaN(dataset.value)) {\n          dataset.typed = true;\n        } else {\n          _addIssue(this, \"type\", dataset, config2, {\n            received: '\"Invalid Date\"'\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/enum/enum.ts\nfunction enum_(enum__, message) {\n  const options = Object.entries(enum__).filter(([key]) => isNaN(+key)).map(([, value2]) => value2);\n  return {\n    kind: \"schema\",\n    type: \"enum\",\n    reference: enum_,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    enum: enum__,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/file/file.ts\nfunction file(message) {\n  return {\n    kind: \"schema\",\n    type: \"file\",\n    reference: file,\n    expects: \"File\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof File) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/function/function.ts\nfunction function_(message) {\n  return {\n    kind: \"schema\",\n    type: \"function\",\n    reference: function_,\n    expects: \"Function\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"function\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/instance/instance.ts\nfunction instance(class_, message) {\n  return {\n    kind: \"schema\",\n    type: \"instance\",\n    reference: instance,\n    expects: class_.name,\n    async: false,\n    class: class_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof this.class) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/utils/_merge/_merge.ts\nfunction _merge(value1, value2) {\n  if (typeof value1 === typeof value2) {\n    if (value1 === value2 || value1 instanceof Date && value2 instanceof Date && +value1 === +value2) {\n      return { value: value1 };\n    }\n    if (value1 && value2 && value1.constructor === Object && value2.constructor === Object) {\n      for (const key in value2) {\n        if (key in value1) {\n          const dataset = _merge(value1[key], value2[key]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[key] = dataset.value;\n        } else {\n          value1[key] = value2[key];\n        }\n      }\n      return { value: value1 };\n    }\n    if (Array.isArray(value1) && Array.isArray(value2)) {\n      if (value1.length === value2.length) {\n        for (let index = 0; index < value1.length; index++) {\n          const dataset = _merge(value1[index], value2[index]);\n          if (dataset.issue) {\n            return dataset;\n          }\n          value1[index] = dataset.value;\n        }\n        return { value: value1 };\n      }\n    }\n  }\n  return { issue: true };\n}\n\n// src/schemas/intersect/intersect.ts\nfunction intersect(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersect,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        for (const schema of this.options) {\n          const optionDataset = schema._run(\n            { typed: false, value: input },\n            config2\n          );\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/intersect/intersectAsync.ts\nfunction intersectAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"intersect\",\n    reference: intersectAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"&\"\n    ),\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      if (this.options.length) {\n        const input = dataset.value;\n        let outputs;\n        dataset.typed = true;\n        const optionDatasets = await Promise.all(\n          this.options.map(\n            (schema) => schema._run({ typed: false, value: input }, config2)\n          )\n        );\n        for (const optionDataset of optionDatasets) {\n          if (optionDataset.issues) {\n            if (dataset.issues) {\n              dataset.issues.push(...optionDataset.issues);\n            } else {\n              dataset.issues = optionDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!optionDataset.typed) {\n            dataset.typed = false;\n          }\n          if (dataset.typed) {\n            if (outputs) {\n              outputs.push(optionDataset.value);\n            } else {\n              outputs = [optionDataset.value];\n            }\n          }\n        }\n        if (dataset.typed) {\n          dataset.value = outputs[0];\n          for (let index = 1; index < outputs.length; index++) {\n            const mergeDataset = _merge(dataset.value, outputs[index]);\n            if (mergeDataset.issue) {\n              _addIssue(this, \"type\", dataset, config2, {\n                received: \"unknown\"\n              });\n              break;\n            }\n            dataset.value = mergeDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/lazy/lazy.ts\nfunction lazy(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazy,\n    expects: \"unknown\",\n    async: false,\n    getter,\n    _run(dataset, config2) {\n      return this.getter(dataset.value)._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/lazy/lazyAsync.ts\nfunction lazyAsync(getter) {\n  return {\n    kind: \"schema\",\n    type: \"lazy\",\n    reference: lazyAsync,\n    expects: \"unknown\",\n    async: true,\n    getter,\n    async _run(dataset, config2) {\n      return (await this.getter(dataset.value))._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/literal/literal.ts\nfunction literal(literal_, message) {\n  return {\n    kind: \"schema\",\n    type: \"literal\",\n    reference: literal,\n    expects: _stringify(literal_),\n    async: false,\n    literal: literal_,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === this.literal) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObject.ts\nfunction looseObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseObject/looseObjectAsync.ts\nfunction looseObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_object\",\n    reference: looseObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              dataset.value[key] = input[key];\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTuple.ts\nfunction looseTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/looseTuple/looseTupleAsync.ts\nfunction looseTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"loose_tuple\",\n    reference: looseTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            dataset.value.push(input[key]);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/map.ts\nfunction map(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: map,\n    expects: \"Map\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        for (const [inputKey, inputValue] of input) {\n          const keyDataset = this.key._run(\n            { typed: false, value: inputKey },\n            config2\n          );\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/map/mapAsync.ts\nfunction mapAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"map\",\n    reference: mapAsync,\n    expects: \"Map\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Map) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Map();\n        const datasets = await Promise.all(\n          [...input].map(\n            ([inputKey, inputValue]) => Promise.all([\n              inputKey,\n              inputValue,\n              this.key._run({ typed: false, value: inputKey }, config2),\n              this.value._run({ typed: false, value: inputValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          inputKey,\n          inputValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"key\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of keyDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"map\",\n              origin: \"value\",\n              input,\n              key: inputKey,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.set(keyDataset.value, valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nan/nan.ts\nfunction nan(message) {\n  return {\n    kind: \"schema\",\n    type: \"nan\",\n    reference: nan,\n    expects: \"NaN\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (Number.isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/never/never.ts\nfunction never(message) {\n  return {\n    kind: \"schema\",\n    type: \"never\",\n    reference: never,\n    expects: \"never\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      _addIssue(this, \"type\", dataset, config2);\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullable.ts\nfunction nonNullable(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullable,\n    expects: \"!null\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullable/nonNullableAsync.ts\nfunction nonNullableAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullable\",\n    reference: nonNullableAsync,\n    expects: \"!null\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullish.ts\nfunction nonNullish(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullish,\n    expects: \"(!null & !undefined)\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonNullish/nonNullishAsync.ts\nfunction nonNullishAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_nullish\",\n    reference: nonNullishAsync,\n    expects: \"(!null & !undefined)\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptional.ts\nfunction nonOptional(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptional,\n    expects: \"!undefined\",\n    async: false,\n    wrapped,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/nonOptional/nonOptionalAsync.ts\nfunction nonOptionalAsync(wrapped, message) {\n  return {\n    kind: \"schema\",\n    type: \"non_optional\",\n    reference: nonOptionalAsync,\n    expects: \"!undefined\",\n    async: true,\n    wrapped,\n    message,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        _addIssue(this, \"type\", dataset, config2);\n        return dataset;\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n}\n\n// src/schemas/null/null.ts\nfunction null_(message) {\n  return {\n    kind: \"schema\",\n    type: \"null\",\n    reference: null_,\n    expects: \"null\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/nullable/nullable.ts\nfunction nullable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullable,\n    expects: `(${wrapped.expects} | null)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullable/nullableAsync.ts\nfunction nullableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullable\",\n    reference: nullableAsync,\n    expects: `(${wrapped.expects} | null)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullish.ts\nfunction nullish(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullish,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/nullish/nullishAsync.ts\nfunction nullishAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"nullish\",\n    reference: nullishAsync,\n    expects: `(${wrapped.expects} | null | undefined)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === null || dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === null || dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/number/number.ts\nfunction number(message) {\n  return {\n    kind: \"schema\",\n    type: \"number\",\n    reference: number,\n    expects: \"number\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"number\" && !isNaN(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/object.ts\nfunction object(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: object,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/object/objectAsync.ts\nfunction objectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"object\",\n    reference: objectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRest.ts\nfunction objectWithRest(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRest,\n    expects: \"Object\",\n    async: false,\n    entries,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (_isValidObjectKey(input, key) && !(key in this.entries)) {\n              const value2 = input[key];\n              const valueDataset = this.rest._run(\n                { typed: false, value: value2 },\n                config2\n              );\n              if (valueDataset.issues) {\n                const pathItem = {\n                  type: \"object\",\n                  origin: \"value\",\n                  input,\n                  key,\n                  value: value2\n                };\n                for (const issue of valueDataset.issues) {\n                  if (issue.path) {\n                    issue.path.unshift(pathItem);\n                  } else {\n                    issue.path = [pathItem];\n                  }\n                  dataset.issues?.push(issue);\n                }\n                if (!dataset.issues) {\n                  dataset.issues = valueDataset.issues;\n                }\n                if (config2.abortEarly) {\n                  dataset.typed = false;\n                  break;\n                }\n              }\n              if (!valueDataset.typed) {\n                dataset.typed = false;\n              }\n              dataset.value[key] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/objectWithRest/objectWithRestAsync.ts\nfunction objectWithRestAsync(entries, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"object_with_rest\",\n    reference: objectWithRestAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal entry\n          // Hint: We do not distinguish between missing and `undefined` entries.\n          // The reason for this decision is that it reduces the bundle size, and\n          // we also expect that most users will expect this behavior.\n          Promise.all(\n            Object.entries(this.entries).map(async ([key, schema]) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await schema._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other entries with rest schema\n          // Hint: We exclude specific keys for security reasons\n          Promise.all(\n            Object.entries(input).filter(\n              ([key]) => _isValidObjectKey(input, key) && !(key in this.entries)\n            ).map(\n              async ([key, value2]) => [\n                key,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ]\n            )\n          )\n        ]);\n        for (const [key, value2, valueDataset] of normalDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, valueDataset] of restDatasets) {\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!valueDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/optional/optional.ts\nfunction optional(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optional,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/optional/optionalAsync.ts\nfunction optionalAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"optional\",\n    reference: optionalAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/picklist/picklist.ts\nfunction picklist(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"picklist\",\n    reference: picklist,\n    expects: _joinExpects(options.map(_stringify), \"|\"),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      if (this.options.includes(dataset.value)) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/promise/promise.ts\nfunction promise(message) {\n  return {\n    kind: \"schema\",\n    type: \"promise\",\n    reference: promise,\n    expects: \"Promise\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value instanceof Promise) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/record.ts\nfunction record(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: record,\n    expects: \"Object\",\n    async: false,\n    key,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const entryKey in input) {\n          if (_isValidObjectKey(input, entryKey)) {\n            const entryValue = input[entryKey];\n            const keyDataset = this.key._run(\n              { typed: false, value: entryKey },\n              config2\n            );\n            if (keyDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"key\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of keyDataset.issues) {\n                issue.path = [pathItem];\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = keyDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            const valueDataset = this.value._run(\n              { typed: false, value: entryValue },\n              config2\n            );\n            if (valueDataset.issues) {\n              const pathItem = {\n                type: \"object\",\n                origin: \"value\",\n                input,\n                key: entryKey,\n                value: entryValue\n              };\n              for (const issue of valueDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = valueDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!keyDataset.typed || !valueDataset.typed) {\n              dataset.typed = false;\n            }\n            if (keyDataset.typed) {\n              dataset.value[keyDataset.value] = valueDataset.value;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/record/recordAsync.ts\nfunction recordAsync(key, value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"record\",\n    reference: recordAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const datasets = await Promise.all(\n          Object.entries(input).filter(([key2]) => _isValidObjectKey(input, key2)).map(\n            ([entryKey, entryValue]) => Promise.all([\n              entryKey,\n              entryValue,\n              this.key._run({ typed: false, value: entryKey }, config2),\n              this.value._run({ typed: false, value: entryValue }, config2)\n            ])\n          )\n        );\n        for (const [\n          entryKey,\n          entryValue,\n          keyDataset,\n          valueDataset\n        ] of datasets) {\n          if (keyDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"key\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of keyDataset.issues) {\n              issue.path = [pathItem];\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = keyDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: entryKey,\n              value: entryValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!keyDataset.typed || !valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (keyDataset.typed) {\n            dataset.value[keyDataset.value] = valueDataset.value;\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/set.ts\nfunction set(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: set,\n    expects: \"Set\",\n    async: false,\n    value: value2,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        for (const inputValue of input) {\n          const valueDataset = this.value._run(\n            { typed: false, value: inputValue },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/set/setAsync.ts\nfunction setAsync(value2, message) {\n  return {\n    kind: \"schema\",\n    type: \"set\",\n    reference: setAsync,\n    expects: \"Set\",\n    async: true,\n    value: value2,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input instanceof Set) {\n        dataset.typed = true;\n        dataset.value = /* @__PURE__ */ new Set();\n        const valueDatasets = await Promise.all(\n          [...input].map(\n            async (inputValue) => [\n              inputValue,\n              await this.value._run(\n                { typed: false, value: inputValue },\n                config2\n              )\n            ]\n          )\n        );\n        for (const [inputValue, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"set\",\n              origin: \"value\",\n              input,\n              key: null,\n              value: inputValue\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.add(valueDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObject.ts\nfunction strictObject(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObject,\n    expects: \"Object\",\n    async: false,\n    entries,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        for (const key in this.entries) {\n          const value2 = input[key];\n          const valueDataset = this.entries[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictObject/strictObjectAsync.ts\nfunction strictObjectAsync(entries, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_object\",\n    reference: strictObjectAsync,\n    expects: \"Object\",\n    async: true,\n    entries,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        dataset.typed = true;\n        dataset.value = {};\n        const valueDatasets = await Promise.all(\n          Object.entries(this.entries).map(async ([key, schema]) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await schema._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, valueDataset] of valueDatasets) {\n          if (valueDataset.issues) {\n            const pathItem = {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of valueDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = valueDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!valueDataset.typed) {\n            dataset.typed = false;\n          }\n          if (valueDataset.value !== void 0 || key in input) {\n            dataset.value[key] = valueDataset.value;\n          }\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const key in input) {\n            if (!(key in this.entries)) {\n              const value2 = input[key];\n              _addIssue(this, \"type\", dataset, config2, {\n                input: value2,\n                expected: \"never\",\n                path: [\n                  {\n                    type: \"object\",\n                    origin: \"value\",\n                    input,\n                    key,\n                    value: value2\n                  }\n                ]\n              });\n              break;\n            }\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTuple.ts\nfunction strictTuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/strictTuple/strictTupleAsync.ts\nfunction strictTupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"strict_tuple\",\n    reference: strictTupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!(dataset.issues && config2.abortEarly) && this.items.length < input.length) {\n          const value2 = input[items.length];\n          _addIssue(this, \"type\", dataset, config2, {\n            input: value2,\n            expected: \"never\",\n            path: [\n              {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key: this.items.length,\n                value: value2\n              }\n            ]\n          });\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/string/string.ts\nfunction string(message) {\n  return {\n    kind: \"schema\",\n    type: \"string\",\n    reference: string,\n    expects: \"string\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"string\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/symbol/symbol.ts\nfunction symbol(message) {\n  return {\n    kind: \"schema\",\n    type: \"symbol\",\n    reference: symbol,\n    expects: \"symbol\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (typeof dataset.value === \"symbol\") {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tuple.ts\nfunction tuple(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tuple,\n    expects: \"Array\",\n    async: false,\n    items,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tuple/tupleAsync.ts\nfunction tupleAsync(items, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple\",\n    reference: tupleAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const itemDatasets = await Promise.all(\n          this.items.map(async (item, key) => {\n            const value2 = input[key];\n            return [\n              key,\n              value2,\n              await item._run({ typed: false, value: value2 }, config2)\n            ];\n          })\n        );\n        for (const [key, value2, itemDataset] of itemDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRest.ts\nfunction tupleWithRest(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRest,\n    expects: \"Array\",\n    async: false,\n    items,\n    rest,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        for (let key = 0; key < this.items.length; key++) {\n          const value2 = input[key];\n          const itemDataset = this.items[key]._run(\n            { typed: false, value: value2 },\n            config2\n          );\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (let key = this.items.length; key < input.length; key++) {\n            const value2 = input[key];\n            const itemDataset = this.rest._run({ typed: false, value: value2 }, config2);\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/tupleWithRest/tupleWithRestAsync.ts\nfunction tupleWithRestAsync(items, rest, message) {\n  return {\n    kind: \"schema\",\n    type: \"tuple_with_rest\",\n    reference: tupleWithRestAsync,\n    expects: \"Array\",\n    async: true,\n    items,\n    rest,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (Array.isArray(input)) {\n        dataset.typed = true;\n        dataset.value = [];\n        const [normalDatasets, restDatasets] = await Promise.all([\n          // Parse schema of each normal item\n          Promise.all(\n            this.items.map(async (item, key) => {\n              const value2 = input[key];\n              return [\n                key,\n                value2,\n                await item._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          ),\n          // Parse other items with rest schema\n          Promise.all(\n            input.slice(this.items.length).map(async (value2, key) => {\n              return [\n                key + this.items.length,\n                value2,\n                await this.rest._run({ typed: false, value: value2 }, config2)\n              ];\n            })\n          )\n        ]);\n        for (const [key, value2, itemDataset] of normalDatasets) {\n          if (itemDataset.issues) {\n            const pathItem = {\n              type: \"array\",\n              origin: \"value\",\n              input,\n              key,\n              value: value2\n            };\n            for (const issue of itemDataset.issues) {\n              if (issue.path) {\n                issue.path.unshift(pathItem);\n              } else {\n                issue.path = [pathItem];\n              }\n              dataset.issues?.push(issue);\n            }\n            if (!dataset.issues) {\n              dataset.issues = itemDataset.issues;\n            }\n            if (config2.abortEarly) {\n              dataset.typed = false;\n              break;\n            }\n          }\n          if (!itemDataset.typed) {\n            dataset.typed = false;\n          }\n          dataset.value.push(itemDataset.value);\n        }\n        if (!dataset.issues || !config2.abortEarly) {\n          for (const [key, value2, itemDataset] of restDatasets) {\n            if (itemDataset.issues) {\n              const pathItem = {\n                type: \"array\",\n                origin: \"value\",\n                input,\n                key,\n                value: value2\n              };\n              for (const issue of itemDataset.issues) {\n                if (issue.path) {\n                  issue.path.unshift(pathItem);\n                } else {\n                  issue.path = [pathItem];\n                }\n                dataset.issues?.push(issue);\n              }\n              if (!dataset.issues) {\n                dataset.issues = itemDataset.issues;\n              }\n              if (config2.abortEarly) {\n                dataset.typed = false;\n                break;\n              }\n            }\n            if (!itemDataset.typed) {\n              dataset.typed = false;\n            }\n            dataset.value.push(itemDataset.value);\n          }\n        }\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefined/undefined.ts\nfunction undefined_(message) {\n  return {\n    kind: \"schema\",\n    type: \"undefined\",\n    reference: undefined_,\n    expects: \"undefined\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/undefinedable/undefinedable.ts\nfunction undefinedable(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedable,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: false,\n    wrapped,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/undefinedable/undefinedableAsync.ts\nfunction undefinedableAsync(wrapped, ...args) {\n  const schema = {\n    kind: \"schema\",\n    type: \"undefinedable\",\n    reference: undefinedableAsync,\n    expects: `(${wrapped.expects} | undefined)`,\n    async: true,\n    wrapped,\n    async _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        if (\"default\" in this) {\n          dataset.value = await getDefault(\n            this,\n            dataset,\n            config2\n          );\n        }\n        if (dataset.value === void 0) {\n          dataset.typed = true;\n          return dataset;\n        }\n      }\n      return this.wrapped._run(dataset, config2);\n    }\n  };\n  if (0 in args) {\n    schema.default = args[0];\n  }\n  return schema;\n}\n\n// src/schemas/union/utils/_subIssues/_subIssues.ts\nfunction _subIssues(datasets) {\n  let issues;\n  if (datasets) {\n    for (const dataset of datasets) {\n      if (issues) {\n        issues.push(...dataset.issues);\n      } else {\n        issues = dataset.issues;\n      }\n    }\n  }\n  return issues;\n}\n\n// src/schemas/union/union.ts\nfunction union(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: union,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: false,\n    options,\n    message,\n    _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/union/unionAsync.ts\nfunction unionAsync(options, message) {\n  return {\n    kind: \"schema\",\n    type: \"union\",\n    reference: unionAsync,\n    expects: _joinExpects(\n      options.map((option) => option.expects),\n      \"|\"\n    ),\n    async: true,\n    options,\n    message,\n    async _run(dataset, config2) {\n      let validDataset;\n      let typedDatasets;\n      let untypedDatasets;\n      for (const schema of this.options) {\n        const optionDataset = await schema._run(\n          { typed: false, value: dataset.value },\n          config2\n        );\n        if (optionDataset.typed) {\n          if (optionDataset.issues) {\n            if (typedDatasets) {\n              typedDatasets.push(optionDataset);\n            } else {\n              typedDatasets = [optionDataset];\n            }\n          } else {\n            validDataset = optionDataset;\n            break;\n          }\n        } else {\n          if (untypedDatasets) {\n            untypedDatasets.push(optionDataset);\n          } else {\n            untypedDatasets = [optionDataset];\n          }\n        }\n      }\n      if (validDataset) {\n        return validDataset;\n      }\n      if (typedDatasets) {\n        if (typedDatasets.length === 1) {\n          return typedDatasets[0];\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(typedDatasets)\n        });\n        dataset.typed = true;\n      } else if (untypedDatasets?.length === 1) {\n        return untypedDatasets[0];\n      } else {\n        _addIssue(this, \"type\", dataset, config2, {\n          issues: _subIssues(untypedDatasets)\n        });\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/unknown/unknown.ts\nfunction unknown() {\n  return {\n    kind: \"schema\",\n    type: \"unknown\",\n    reference: unknown,\n    expects: \"unknown\",\n    async: false,\n    _run(dataset) {\n      dataset.typed = true;\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variant.ts\nfunction variant(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variant,\n    expects: \"Object\",\n    async: false,\n    key,\n    options,\n    message,\n    _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if (schema.entries[currentKey]._run(\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                ).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = schema._run(\n                  { typed: false, value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/variant/variantAsync.ts\nfunction variantAsync(key, options, message) {\n  return {\n    kind: \"schema\",\n    type: \"variant\",\n    reference: variantAsync,\n    expects: \"Object\",\n    async: true,\n    key,\n    options,\n    message,\n    async _run(dataset, config2) {\n      const input = dataset.value;\n      if (input && typeof input === \"object\") {\n        let outputDataset;\n        let maxDiscriminatorPriority = 0;\n        let invalidDiscriminatorKey = this.key;\n        let expectedDiscriminators = [];\n        const parseOptions = async (variant2, allKeys) => {\n          for (const schema of variant2.options) {\n            if (schema.type === \"variant\") {\n              await parseOptions(schema, new Set(allKeys).add(schema.key));\n            } else {\n              let keysAreValid = true;\n              let currentPriority = 0;\n              for (const currentKey of allKeys) {\n                if ((await schema.entries[currentKey]._run(\n                  // @ts-expect-error\n                  { typed: false, value: input[currentKey] },\n                  config2\n                )).issues) {\n                  keysAreValid = false;\n                  if (invalidDiscriminatorKey !== currentKey && (maxDiscriminatorPriority < currentPriority || maxDiscriminatorPriority === currentPriority && currentKey in input && !(invalidDiscriminatorKey in input))) {\n                    maxDiscriminatorPriority = currentPriority;\n                    invalidDiscriminatorKey = currentKey;\n                    expectedDiscriminators = [];\n                  }\n                  if (invalidDiscriminatorKey === currentKey) {\n                    expectedDiscriminators.push(\n                      schema.entries[currentKey].expects\n                    );\n                  }\n                  break;\n                }\n                currentPriority++;\n              }\n              if (keysAreValid) {\n                const optionDataset = await schema._run(\n                  { typed: false, value: input },\n                  config2\n                );\n                if (!outputDataset || !outputDataset.typed && optionDataset.typed) {\n                  outputDataset = optionDataset;\n                }\n              }\n            }\n            if (outputDataset && !outputDataset.issues) {\n              break;\n            }\n          }\n        };\n        await parseOptions(this, /* @__PURE__ */ new Set([this.key]));\n        if (outputDataset) {\n          return outputDataset;\n        }\n        _addIssue(this, \"type\", dataset, config2, {\n          // @ts-expect-error\n          input: input[invalidDiscriminatorKey],\n          expected: _joinExpects(expectedDiscriminators, \"|\"),\n          path: [\n            {\n              type: \"object\",\n              origin: \"value\",\n              input,\n              key: invalidDiscriminatorKey,\n              // @ts-expect-error\n              value: input[invalidDiscriminatorKey]\n            }\n          ]\n        });\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/schemas/void/void.ts\nfunction void_(message) {\n  return {\n    kind: \"schema\",\n    type: \"void\",\n    reference: void_,\n    expects: \"void\",\n    async: false,\n    message,\n    _run(dataset, config2) {\n      if (dataset.value === void 0) {\n        dataset.typed = true;\n      } else {\n        _addIssue(this, \"type\", dataset, config2);\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/keyof/keyof.ts\nfunction keyof(schema, message) {\n  return picklist(Object.keys(schema.entries), message);\n}\n\n// src/methods/omit/omit.ts\nfunction omit(schema, keys) {\n  const entries = {\n    ...schema.entries\n  };\n  for (const key of keys) {\n    delete entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/parse/parse.ts\nfunction parse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parse/parseAsync.ts\nasync function parseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  if (dataset.issues) {\n    throw new ValiError(dataset.issues);\n  }\n  return dataset.value;\n}\n\n// src/methods/parser/parser.ts\nfunction parser(schema, config2) {\n  const func = (input) => parse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/parser/parserAsync.ts\nfunction parserAsync(schema, config2) {\n  const func = (input) => parseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/partial/partial.ts\nfunction partial(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optional(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/partial/partialAsync.ts\nfunction partialAsync(schema, keys) {\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? optionalAsync(schema.entries[key]) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pick/pick.ts\nfunction pick(schema, keys) {\n  const entries = {};\n  for (const key of keys) {\n    entries[key] = schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/pipe/pipe.ts\nfunction pipe(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/pipe/pipeAsync.ts\nfunction pipeAsync(...pipe2) {\n  return {\n    ...pipe2[0],\n    pipe: pipe2,\n    async: true,\n    async _run(dataset, config2) {\n      for (const item of pipe2) {\n        if (item.kind !== \"metadata\") {\n          if (dataset.issues && (item.kind === \"schema\" || item.kind === \"transformation\")) {\n            dataset.typed = false;\n            break;\n          }\n          if (!dataset.issues || !config2.abortEarly && !config2.abortPipeEarly) {\n            dataset = await item._run(dataset, config2);\n          }\n        }\n      }\n      return dataset;\n    }\n  };\n}\n\n// src/methods/required/required.ts\nfunction required(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptional(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/required/requiredAsync.ts\nfunction requiredAsync(schema, arg2, arg3) {\n  const keys = Array.isArray(arg2) ? arg2 : void 0;\n  const message = Array.isArray(arg2) ? arg3 : arg2;\n  const entries = {};\n  for (const key in schema.entries) {\n    entries[key] = !keys || keys.includes(key) ? nonOptionalAsync(schema.entries[key], message) : schema.entries[key];\n  }\n  return { ...schema, entries };\n}\n\n// src/methods/safeParse/safeParse.ts\nfunction safeParse(schema, input, config2) {\n  const dataset = schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParse/safeParseAsync.ts\nasync function safeParseAsync(schema, input, config2) {\n  const dataset = await schema._run(\n    { typed: false, value: input },\n    getGlobalConfig(config2)\n  );\n  return {\n    typed: dataset.typed,\n    success: !dataset.issues,\n    output: dataset.value,\n    issues: dataset.issues\n  };\n}\n\n// src/methods/safeParser/safeParser.ts\nfunction safeParser(schema, config2) {\n  const func = (input) => safeParse(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/safeParser/safeParserAsync.ts\nfunction safeParserAsync(schema, config2) {\n  const func = (input) => safeParseAsync(schema, input, config2);\n  func.schema = schema;\n  func.config = config2;\n  return func;\n}\n\n// src/methods/unwrap/unwrap.ts\nfunction unwrap(schema) {\n  return schema.wrapped;\n}\nexport {\n  BASE64_REGEX,\n  BIC_REGEX,\n  CUID2_REGEX,\n  DECIMAL_REGEX,\n  DIGITS_REGEX,\n  EMAIL_REGEX,\n  EMOJI_REGEX,\n  HEXADECIMAL_REGEX,\n  HEX_COLOR_REGEX,\n  IMEI_REGEX,\n  IPV4_REGEX,\n  IPV6_REGEX,\n  IP_REGEX,\n  ISO_DATE_REGEX,\n  ISO_DATE_TIME_REGEX,\n  ISO_TIMESTAMP_REGEX,\n  ISO_TIME_REGEX,\n  ISO_TIME_SECOND_REGEX,\n  ISO_WEEK_REGEX,\n  MAC48_REGEX,\n  MAC64_REGEX,\n  MAC_REGEX,\n  NANO_ID_REGEX,\n  OCTAL_REGEX,\n  ULID_REGEX,\n  UUID_REGEX,\n  ValiError,\n  _addIssue,\n  _isLuhnAlgo,\n  _isValidObjectKey,\n  _joinExpects,\n  _stringify,\n  any,\n  array,\n  arrayAsync,\n  awaitAsync,\n  base64,\n  bic,\n  bigint,\n  blob,\n  boolean,\n  brand,\n  bytes,\n  check,\n  checkAsync,\n  checkItems,\n  config,\n  creditCard,\n  cuid2,\n  custom,\n  customAsync,\n  date,\n  decimal,\n  deleteGlobalConfig,\n  deleteGlobalMessage,\n  deleteSchemaMessage,\n  deleteSpecificMessage,\n  description,\n  digits,\n  email,\n  emoji,\n  empty,\n  endsWith,\n  entriesFromList,\n  enum_ as enum,\n  enum_,\n  everyItem,\n  excludes,\n  fallback,\n  fallbackAsync,\n  file,\n  filterItems,\n  findItem,\n  finite,\n  flatten,\n  forward,\n  forwardAsync,\n  function_ as function,\n  function_,\n  getDefault,\n  getDefaults,\n  getDefaultsAsync,\n  getDotPath,\n  getFallback,\n  getFallbacks,\n  getFallbacksAsync,\n  getGlobalConfig,\n  getGlobalMessage,\n  getSchemaMessage,\n  getSpecificMessage,\n  hash,\n  hexColor,\n  hexadecimal,\n  imei,\n  includes,\n  instance,\n  integer,\n  intersect,\n  intersectAsync,\n  ip,\n  ipv4,\n  ipv6,\n  is,\n  isOfKind,\n  isOfType,\n  isValiError,\n  isoDate,\n  isoDateTime,\n  isoTime,\n  isoTimeSecond,\n  isoTimestamp,\n  isoWeek,\n  keyof,\n  lazy,\n  lazyAsync,\n  length,\n  literal,\n  looseObject,\n  looseObjectAsync,\n  looseTuple,\n  looseTupleAsync,\n  mac,\n  mac48,\n  mac64,\n  map,\n  mapAsync,\n  mapItems,\n  maxBytes,\n  maxLength,\n  maxSize,\n  maxValue,\n  metadata,\n  mimeType,\n  minBytes,\n  minLength,\n  minSize,\n  minValue,\n  multipleOf,\n  nan,\n  nanoid,\n  never,\n  nonEmpty,\n  nonNullable,\n  nonNullableAsync,\n  nonNullish,\n  nonNullishAsync,\n  nonOptional,\n  nonOptionalAsync,\n  normalize,\n  notBytes,\n  notLength,\n  notSize,\n  notValue,\n  null_ as null,\n  null_,\n  nullable,\n  nullableAsync,\n  nullish,\n  nullishAsync,\n  number,\n  object,\n  objectAsync,\n  objectWithRest,\n  objectWithRestAsync,\n  octal,\n  omit,\n  optional,\n  optionalAsync,\n  parse,\n  parseAsync,\n  parser,\n  parserAsync,\n  partial,\n  partialAsync,\n  partialCheck,\n  partialCheckAsync,\n  pick,\n  picklist,\n  pipe,\n  pipeAsync,\n  promise,\n  rawCheck,\n  rawCheckAsync,\n  rawTransform,\n  rawTransformAsync,\n  readonly,\n  record,\n  recordAsync,\n  reduceItems,\n  regex,\n  required,\n  requiredAsync,\n  safeInteger,\n  safeParse,\n  safeParseAsync,\n  safeParser,\n  safeParserAsync,\n  set,\n  setAsync,\n  setGlobalConfig,\n  setGlobalMessage,\n  setSchemaMessage,\n  setSpecificMessage,\n  size,\n  someItem,\n  sortItems,\n  startsWith,\n  strictObject,\n  strictObjectAsync,\n  strictTuple,\n  strictTupleAsync,\n  string,\n  symbol,\n  title,\n  toLowerCase,\n  toMaxValue,\n  toMinValue,\n  toUpperCase,\n  transform,\n  transformAsync,\n  trim,\n  trimEnd,\n  trimStart,\n  tuple,\n  tupleAsync,\n  tupleWithRest,\n  tupleWithRestAsync,\n  ulid,\n  undefined_ as undefined,\n  undefined_,\n  undefinedable,\n  undefinedableAsync,\n  union,\n  unionAsync,\n  unknown,\n  unwrap,\n  url,\n  uuid,\n  value,\n  variant,\n  variantAsync,\n  void_ as void,\n  void_\n};\n", "export default /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;", "import REGEX from './regex.js';\nfunction validate(uuid) {\n  return typeof uuid === 'string' && REGEX.test(uuid);\n}\nexport default validate;", "import validate from './validate.js';\nfunction parse(uuid) {\n  if (!validate(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n  var v;\n  var arr = new Uint8Array(16);\n\n  // Parse ########-....-....-....-............\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff;\n\n  // Parse ........-####-....-....-............\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff;\n\n  // Parse ........-....-####-....-............\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff;\n\n  // Parse ........-....-....-####-............\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff;\n\n  // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\nexport default parse;", "import validate from './validate.js';\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nvar byteToHex = [];\nfor (var i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).slice(1));\n}\nexport function unsafeStringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  //\n  // Note to future-self: No, you can't remove the `toLowerCase()` call.\n  // REF: https://github.com/uuidjs/uuid/pull/677#issuecomment-1757351351\n  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();\n}\nfunction stringify(arr, offset = 0) {\n  var uuid = unsafeStringify(arr, offset);\n  // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n  if (!validate(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n  return uuid;\n}\nexport default stringify;", "// Unique ID creation requires a high quality random # generator. In the browser we therefore\n// require the crypto API and do not support built-in fallback to lower quality random number\n// generators (like Math.random()).\n\nvar getRandomValues;\nvar rnds8 = new Uint8Array(16);\nexport default function rng() {\n  // lazy load so that environments that need to polyfill have a chance to do so\n  if (!getRandomValues) {\n    // getRandomValues needs to be invoked in a context where \"this\" is a Crypto implementation.\n    getRandomValues = typeof crypto !== 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);\n    if (!getRandomValues) {\n      throw new Error('crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported');\n    }\n  }\n  return getRandomValues(rnds8);\n}", "import { unsafeStringify } from './stringify.js';\nimport parse from './parse.js';\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  var bytes = [];\n  for (var i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n  return bytes;\n}\nexport var DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexport var URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexport default function v35(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    var _namespace;\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n    if (typeof namespace === 'string') {\n      namespace = parse(namespace);\n    }\n    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    }\n\n    // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n    var bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n    if (buf) {\n      offset = offset || 0;\n      for (var i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n      return buf;\n    }\n    return unsafeStringify(bytes);\n  }\n\n  // Function#name is not settable on some platforms (#270)\n  try {\n    generateUUID.name = name;\n  } catch (err) {}\n\n  // For CommonJS default export support\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}", "/*\n * Browser-compatible JavaScript MD5\n *\n * Modification of JavaScript MD5\n * https://github.com/blueimp/JavaScript-MD5\n *\n * Copyright 2011, Sebastian Tschan\n * https://blueimp.net\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n *\n * Based on\n * A JavaScript implementation of the RSA Data Security, Inc. MD5 Message\n * Digest Algorithm, as defined in RFC 1321.\n * Version 2.2 Copyright (C) Paul Johnston 1999 - 2009\n * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet\n * Distributed under the BSD License\n * See http://pajhome.org.uk/crypt/md5 for more info.\n */\nfunction md5(bytes) {\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = new Uint8Array(msg.length);\n    for (var i = 0; i < msg.length; ++i) {\n      bytes[i] = msg.charCodeAt(i);\n    }\n  }\n  return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));\n}\n\n/*\n * Convert an array of little-endian words to an array of bytes\n */\nfunction md5ToHexEncodedArray(input) {\n  var output = [];\n  var length32 = input.length * 32;\n  var hexTab = '0123456789abcdef';\n  for (var i = 0; i < length32; i += 8) {\n    var x = input[i >> 5] >>> i % 32 & 0xff;\n    var hex = parseInt(hexTab.charAt(x >>> 4 & 0x0f) + hexTab.charAt(x & 0x0f), 16);\n    output.push(hex);\n  }\n  return output;\n}\n\n/**\n * Calculate output length with padding and bit length\n */\nfunction getOutputLength(inputLength8) {\n  return (inputLength8 + 64 >>> 9 << 4) + 14 + 1;\n}\n\n/*\n * Calculate the MD5 of an array of little-endian words, and a bit length.\n */\nfunction wordsToMd5(x, len) {\n  /* append padding */\n  x[len >> 5] |= 0x80 << len % 32;\n  x[getOutputLength(len) - 1] = len;\n  var a = 1732584193;\n  var b = -271733879;\n  var c = -1732584194;\n  var d = 271733878;\n  for (var i = 0; i < x.length; i += 16) {\n    var olda = a;\n    var oldb = b;\n    var oldc = c;\n    var oldd = d;\n    a = md5ff(a, b, c, d, x[i], 7, -680876936);\n    d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);\n    c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);\n    b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);\n    a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);\n    d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);\n    c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);\n    b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);\n    a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);\n    d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);\n    c = md5ff(c, d, a, b, x[i + 10], 17, -42063);\n    b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);\n    a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);\n    d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);\n    c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);\n    b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);\n    a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);\n    d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);\n    c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);\n    b = md5gg(b, c, d, a, x[i], 20, -373897302);\n    a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);\n    d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);\n    c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);\n    b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);\n    a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);\n    d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);\n    c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);\n    b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);\n    a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);\n    d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);\n    c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);\n    b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);\n    a = md5hh(a, b, c, d, x[i + 5], 4, -378558);\n    d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);\n    c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);\n    b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);\n    a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);\n    d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);\n    c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);\n    b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);\n    a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);\n    d = md5hh(d, a, b, c, x[i], 11, -358537222);\n    c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);\n    b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);\n    a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);\n    d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);\n    c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);\n    b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);\n    a = md5ii(a, b, c, d, x[i], 6, -198630844);\n    d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);\n    c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);\n    b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);\n    a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);\n    d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);\n    c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);\n    b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);\n    a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);\n    d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);\n    c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);\n    b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);\n    a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);\n    d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);\n    c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);\n    b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);\n    a = safeAdd(a, olda);\n    b = safeAdd(b, oldb);\n    c = safeAdd(c, oldc);\n    d = safeAdd(d, oldd);\n  }\n  return [a, b, c, d];\n}\n\n/*\n * Convert an array bytes to an array of little-endian words\n * Characters >255 have their high-byte silently ignored.\n */\nfunction bytesToWords(input) {\n  if (input.length === 0) {\n    return [];\n  }\n  var length8 = input.length * 8;\n  var output = new Uint32Array(getOutputLength(length8));\n  for (var i = 0; i < length8; i += 8) {\n    output[i >> 5] |= (input[i / 8] & 0xff) << i % 32;\n  }\n  return output;\n}\n\n/*\n * Add integers, wrapping at 2^32. This uses 16-bit operations internally\n * to work around bugs in some JS interpreters.\n */\nfunction safeAdd(x, y) {\n  var lsw = (x & 0xffff) + (y & 0xffff);\n  var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n  return msw << 16 | lsw & 0xffff;\n}\n\n/*\n * Bitwise rotate a 32-bit number to the left.\n */\nfunction bitRotateLeft(num, cnt) {\n  return num << cnt | num >>> 32 - cnt;\n}\n\n/*\n * These functions implement the four basic operations the algorithm uses.\n */\nfunction md5cmn(q, a, b, x, s, t) {\n  return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);\n}\nfunction md5ff(a, b, c, d, x, s, t) {\n  return md5cmn(b & c | ~b & d, a, b, x, s, t);\n}\nfunction md5gg(a, b, c, d, x, s, t) {\n  return md5cmn(b & d | c & ~d, a, b, x, s, t);\n}\nfunction md5hh(a, b, c, d, x, s, t) {\n  return md5cmn(b ^ c ^ d, a, b, x, s, t);\n}\nfunction md5ii(a, b, c, d, x, s, t) {\n  return md5cmn(c ^ (b | ~d), a, b, x, s, t);\n}\nexport default md5;", "import v35 from './v35.js';\nimport md5 from './md5.js';\nvar v3 = v35('v3', 0x30, md5);\nexport default v3;", "var randomUUID = typeof crypto !== 'undefined' && crypto.randomUUID && crypto.randomUUID.bind(crypto);\nexport default {\n  randomUUID\n};", "import native from './native.js';\nimport rng from './rng.js';\nimport { unsafeStringify } from './stringify.js';\nfunction v4(options, buf, offset) {\n  if (native.randomUUID && !buf && !options) {\n    return native.randomUUID();\n  }\n  options = options || {};\n  var rnds = options.random || (options.rng || rng)();\n\n  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80;\n\n  // Copy bytes to buffer, if provided\n  if (buf) {\n    offset = offset || 0;\n    for (var i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n    return buf;\n  }\n  return unsafeStringify(rnds);\n}\nexport default v4;", "// Adapted from Chris Veness' SHA1 code at\n// http://www.movable-type.co.uk/scripts/sha1.html\nfunction f(s, x, y, z) {\n  switch (s) {\n    case 0:\n      return x & y ^ ~x & z;\n    case 1:\n      return x ^ y ^ z;\n    case 2:\n      return x & y ^ x & z ^ y & z;\n    case 3:\n      return x ^ y ^ z;\n  }\n}\nfunction ROTL(x, n) {\n  return x << n | x >>> 32 - n;\n}\nfunction sha1(bytes) {\n  var K = [0x5a827999, 0x6ed9eba1, 0x8f1bbcdc, 0xca62c1d6];\n  var H = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0];\n  if (typeof bytes === 'string') {\n    var msg = unescape(encodeURIComponent(bytes)); // UTF8 escape\n\n    bytes = [];\n    for (var i = 0; i < msg.length; ++i) {\n      bytes.push(msg.charCodeAt(i));\n    }\n  } else if (!Array.isArray(bytes)) {\n    // Convert Array-like to Array\n    bytes = Array.prototype.slice.call(bytes);\n  }\n  bytes.push(0x80);\n  var l = bytes.length / 4 + 2;\n  var N = Math.ceil(l / 16);\n  var M = new Array(N);\n  for (var _i = 0; _i < N; ++_i) {\n    var arr = new Uint32Array(16);\n    for (var j = 0; j < 16; ++j) {\n      arr[j] = bytes[_i * 64 + j * 4] << 24 | bytes[_i * 64 + j * 4 + 1] << 16 | bytes[_i * 64 + j * 4 + 2] << 8 | bytes[_i * 64 + j * 4 + 3];\n    }\n    M[_i] = arr;\n  }\n  M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);\n  M[N - 1][14] = Math.floor(M[N - 1][14]);\n  M[N - 1][15] = (bytes.length - 1) * 8 & 0xffffffff;\n  for (var _i2 = 0; _i2 < N; ++_i2) {\n    var W = new Uint32Array(80);\n    for (var t = 0; t < 16; ++t) {\n      W[t] = M[_i2][t];\n    }\n    for (var _t = 16; _t < 80; ++_t) {\n      W[_t] = ROTL(W[_t - 3] ^ W[_t - 8] ^ W[_t - 14] ^ W[_t - 16], 1);\n    }\n    var a = H[0];\n    var b = H[1];\n    var c = H[2];\n    var d = H[3];\n    var e = H[4];\n    for (var _t2 = 0; _t2 < 80; ++_t2) {\n      var s = Math.floor(_t2 / 20);\n      var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[_t2] >>> 0;\n      e = d;\n      d = c;\n      c = ROTL(b, 30) >>> 0;\n      b = a;\n      a = T;\n    }\n    H[0] = H[0] + a >>> 0;\n    H[1] = H[1] + b >>> 0;\n    H[2] = H[2] + c >>> 0;\n    H[3] = H[3] + d >>> 0;\n    H[4] = H[4] + e >>> 0;\n  }\n  return [H[0] >> 24 & 0xff, H[0] >> 16 & 0xff, H[0] >> 8 & 0xff, H[0] & 0xff, H[1] >> 24 & 0xff, H[1] >> 16 & 0xff, H[1] >> 8 & 0xff, H[1] & 0xff, H[2] >> 24 & 0xff, H[2] >> 16 & 0xff, H[2] >> 8 & 0xff, H[2] & 0xff, H[3] >> 24 & 0xff, H[3] >> 16 & 0xff, H[3] >> 8 & 0xff, H[3] & 0xff, H[4] >> 24 & 0xff, H[4] >> 16 & 0xff, H[4] >> 8 & 0xff, H[4] & 0xff];\n}\nexport default sha1;", "import v35 from './v35.js';\nimport sha1 from './sha1.js';\nvar v5 = v35('v5', 0x50, sha1);\nexport default v5;", "export const prettyLogStyles = {\n    reset: [0, 0],\n    bold: [1, 22],\n    dim: [2, 22],\n    italic: [3, 23],\n    underline: [4, 24],\n    overline: [53, 55],\n    inverse: [7, 27],\n    hidden: [8, 28],\n    strikethrough: [9, 29],\n    black: [30, 39],\n    red: [31, 39],\n    green: [32, 39],\n    yellow: [33, 39],\n    blue: [34, 39],\n    magenta: [35, 39],\n    cyan: [36, 39],\n    white: [37, 39],\n    blackBright: [90, 39],\n    redBright: [91, 39],\n    greenBright: [92, 39],\n    yellowBright: [93, 39],\n    blueBright: [94, 39],\n    magentaBright: [95, 39],\n    cyanBright: [96, 39],\n    whiteBright: [97, 39],\n    bgBlack: [40, 49],\n    bgRed: [41, 49],\n    bgGreen: [42, 49],\n    bgYellow: [43, 49],\n    bgBlue: [44, 49],\n    bgMagenta: [45, 49],\n    bgCyan: [46, 49],\n    bgWhite: [47, 49],\n    bgBlackBright: [100, 49],\n    bgRedBright: [101, 49],\n    bgGreenBright: [102, 49],\n    bgYellowBright: [103, 49],\n    bgBlueBright: [104, 49],\n    bgMagentaBright: [105, 49],\n    bgCyanBright: [106, 49],\n    bgWhiteBright: [107, 49],\n};\n", "import { prettyLogStyles } from \"./prettyLogStyles.js\";\nexport function formatTemplate(settings, template, values, hideUnsetPlaceholder = false) {\n    const templateString = String(template);\n    const ansiColorWrap = (placeholderValue, code) => `\\u001b[${code[0]}m${placeholderValue}\\u001b[${code[1]}m`;\n    const styleWrap = (value, style) => {\n        if (style != null && typeof style === \"string\") {\n            return ansiColorWrap(value, prettyLogStyles[style]);\n        }\n        else if (style != null && Array.isArray(style)) {\n            return style.reduce((prevValue, thisStyle) => styleWrap(prevValue, thisStyle), value);\n        }\n        else {\n            if (style != null && style[value.trim()] != null) {\n                return styleWrap(value, style[value.trim()]);\n            }\n            else if (style != null && style[\"*\"] != null) {\n                return styleWrap(value, style[\"*\"]);\n            }\n            else {\n                return value;\n            }\n        }\n    };\n    const defaultStyle = null;\n    return templateString.replace(/{{(.+?)}}/g, (_, placeholder) => {\n        const value = values[placeholder] != null ? String(values[placeholder]) : hideUnsetPlaceholder ? \"\" : _;\n        return settings.stylePrettyLogs\n            ? styleWrap(value, settings?.prettyLogStyles?.[placeholder] ?? defaultStyle) + ansiColorWrap(\"\", prettyLogStyles.reset)\n            : value;\n    });\n}\n", "export function formatNumberAddZeros(value, digits = 2, addNumber = 0) {\n    if (value != null && isNaN(value)) {\n        return \"\";\n    }\n    value = value != null ? value + addNumber : value;\n    return digits === 2\n        ? value == null\n            ? \"--\"\n            : value < 10\n                ? \"0\" + value\n                : value.toString()\n        : value == null\n            ? \"---\"\n            : value < 10\n                ? \"00\" + value\n                : value < 100\n                    ? \"0\" + value\n                    : value.toString();\n}\n", "export function urlToObject(url) {\n    return {\n        href: url.href,\n        protocol: url.protocol,\n        username: url.username,\n        password: url.password,\n        host: url.host,\n        hostname: url.hostname,\n        port: url.port,\n        pathname: url.pathname,\n        search: url.search,\n        searchParams: [...url.searchParams].map(([key, value]) => ({ key, value })),\n        hash: url.hash,\n        origin: url.origin,\n    };\n}\n", "export function jsonStringifyRecursive(obj) {\n    const cache = new Set();\n    return JSON.stringify(obj, (key, value) => {\n        if (typeof value === \"object\" && value !== null) {\n            if (cache.has(value)) {\n                return \"[Circular]\";\n            }\n            cache.add(value);\n        }\n        if (typeof value === \"bigint\") {\n            return `${value}`;\n        }\n        return value;\n    });\n}\n", "import { prettyLogStyles } from \"../../prettyLogStyles.js\";\nimport { jsonStringifyRecursive } from \"./helper.jsonStringifyRecursive.js\";\nexport function inspect(obj, opts) {\n    const ctx = {\n        seen: [],\n        stylize: stylizeNoColor,\n    };\n    if (opts != null) {\n        _extend(ctx, opts);\n    }\n    if (isUndefined(ctx.showHidden))\n        ctx.showHidden = false;\n    if (isUndefined(ctx.depth))\n        ctx.depth = 2;\n    if (isUndefined(ctx.colors))\n        ctx.colors = true;\n    if (isUndefined(ctx.customInspect))\n        ctx.customInspect = true;\n    if (ctx.colors)\n        ctx.stylize = stylizeWithColor;\n    return formatValue(ctx, obj, ctx.depth);\n}\ninspect.colors = prettyLogStyles;\ninspect.styles = {\n    special: \"cyan\",\n    number: \"yellow\",\n    boolean: \"yellow\",\n    undefined: \"grey\",\n    null: \"bold\",\n    string: \"green\",\n    date: \"magenta\",\n    regexp: \"red\",\n};\nfunction isBoolean(arg) {\n    return typeof arg === \"boolean\";\n}\nfunction isUndefined(arg) {\n    return arg === undefined;\n}\nfunction stylizeNoColor(str) {\n    return str;\n}\nfunction stylizeWithColor(str, styleType) {\n    const style = inspect.styles[styleType];\n    if (style != null && inspect?.colors?.[style]?.[0] != null && inspect?.colors?.[style]?.[1] != null) {\n        return \"\\u001b[\" + inspect.colors[style][0] + \"m\" + str + \"\\u001b[\" + inspect.colors[style][1] + \"m\";\n    }\n    else {\n        return str;\n    }\n}\nfunction isFunction(arg) {\n    return typeof arg === \"function\";\n}\nfunction isString(arg) {\n    return typeof arg === \"string\";\n}\nfunction isNumber(arg) {\n    return typeof arg === \"number\";\n}\nfunction isNull(arg) {\n    return arg === null;\n}\nfunction hasOwn(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction isRegExp(re) {\n    return isObject(re) && objectToString(re) === \"[object RegExp]\";\n}\nfunction isObject(arg) {\n    return typeof arg === \"object\" && arg !== null;\n}\nfunction isError(e) {\n    return isObject(e) && (objectToString(e) === \"[object Error]\" || e instanceof Error);\n}\nfunction isDate(d) {\n    return isObject(d) && objectToString(d) === \"[object Date]\";\n}\nfunction objectToString(o) {\n    return Object.prototype.toString.call(o);\n}\nfunction arrayToHash(array) {\n    const hash = {};\n    array.forEach((val) => {\n        hash[val] = true;\n    });\n    return hash;\n}\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n    const output = [];\n    for (let i = 0, l = value.length; i < l; ++i) {\n        if (hasOwn(value, String(i))) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));\n        }\n        else {\n            output.push(\"\");\n        }\n    }\n    keys.forEach((key) => {\n        if (!key.match(/^\\d+$/)) {\n            output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));\n        }\n    });\n    return output;\n}\nfunction formatError(value) {\n    return \"[\" + Error.prototype.toString.call(value) + \"]\";\n}\nexport function formatValue(ctx, value, recurseTimes = 0) {\n    if (ctx.customInspect &&\n        value != null &&\n        isFunction(value) &&\n        value?.inspect !== inspect &&\n        !(value?.constructor && value?.constructor.prototype === value)) {\n        if (typeof value.inspect !== \"function\" && value.toString != null) {\n            return value.toString();\n        }\n        let ret = value?.inspect(recurseTimes, ctx);\n        if (!isString(ret)) {\n            ret = formatValue(ctx, ret, recurseTimes);\n        }\n        return ret;\n    }\n    const primitive = formatPrimitive(ctx, value);\n    if (primitive) {\n        return primitive;\n    }\n    let keys = Object.keys(value);\n    const visibleKeys = arrayToHash(keys);\n    try {\n        if (ctx.showHidden && Object.getOwnPropertyNames) {\n            keys = Object.getOwnPropertyNames(value);\n        }\n    }\n    catch (e) {\n    }\n    if (isError(value) && (keys.indexOf(\"message\") >= 0 || keys.indexOf(\"description\") >= 0)) {\n        return formatError(value);\n    }\n    if (keys.length === 0) {\n        if (isFunction(ctx.stylize)) {\n            if (isFunction(value)) {\n                const name = value.name ? \": \" + value.name : \"\";\n                return ctx.stylize(\"[Function\" + name + \"]\", \"special\");\n            }\n            if (isRegExp(value)) {\n                return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n            }\n            if (isDate(value)) {\n                return ctx.stylize(Date.prototype.toISOString.call(value), \"date\");\n            }\n            if (isError(value)) {\n                return formatError(value);\n            }\n        }\n        else {\n            return value;\n        }\n    }\n    let base = \"\";\n    let array = false;\n    let braces = [\"{\\n\", \"\\n}\"];\n    if (Array.isArray(value)) {\n        array = true;\n        braces = [\"[\\n\", \"\\n]\"];\n    }\n    if (isFunction(value)) {\n        const n = value.name ? \": \" + value.name : \"\";\n        base = \" [Function\" + n + \"]\";\n    }\n    if (isRegExp(value)) {\n        base = \" \" + RegExp.prototype.toString.call(value);\n    }\n    if (isDate(value)) {\n        base = \" \" + Date.prototype.toUTCString.call(value);\n    }\n    if (isError(value)) {\n        base = \" \" + formatError(value);\n    }\n    if (keys.length === 0 && (!array || value.length == 0)) {\n        return braces[0] + base + braces[1];\n    }\n    if (recurseTimes < 0) {\n        if (isRegExp(value)) {\n            return ctx.stylize(RegExp.prototype.toString.call(value), \"regexp\");\n        }\n        else {\n            return ctx.stylize(\"[Object]\", \"special\");\n        }\n    }\n    ctx.seen.push(value);\n    let output;\n    if (array) {\n        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n    }\n    else {\n        output = keys.map((key) => {\n            return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n        });\n    }\n    ctx.seen.pop();\n    return reduceToSingleString(output, base, braces);\n}\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n    let name, str;\n    let desc = { value: void 0 };\n    try {\n        desc.value = value[key];\n    }\n    catch (e) {\n    }\n    try {\n        if (Object.getOwnPropertyDescriptor) {\n            desc = Object.getOwnPropertyDescriptor(value, key) || desc;\n        }\n    }\n    catch (e) {\n    }\n    if (desc.get) {\n        if (desc.set) {\n            str = ctx.stylize(\"[Getter/Setter]\", \"special\");\n        }\n        else {\n            str = ctx.stylize(\"[Getter]\", \"special\");\n        }\n    }\n    else {\n        if (desc.set) {\n            str = ctx.stylize(\"[Setter]\", \"special\");\n        }\n    }\n    if (!hasOwn(visibleKeys, key)) {\n        name = \"[\" + key + \"]\";\n    }\n    if (!str) {\n        if (ctx.seen.indexOf(desc.value) < 0) {\n            if (isNull(recurseTimes)) {\n                str = formatValue(ctx, desc.value, undefined);\n            }\n            else {\n                str = formatValue(ctx, desc.value, recurseTimes - 1);\n            }\n            if (str.indexOf(\"\\n\") > -1) {\n                if (array) {\n                    str = str\n                        .split(\"\\n\")\n                        .map((line) => {\n                        return \"  \" + line;\n                    })\n                        .join(\"\\n\")\n                        .substr(2);\n                }\n                else {\n                    str =\n                        \"\\n\" +\n                            str\n                                .split(\"\\n\")\n                                .map((line) => {\n                                return \"   \" + line;\n                            })\n                                .join(\"\\n\");\n                }\n            }\n        }\n        else {\n            str = ctx.stylize(\"[Circular]\", \"special\");\n        }\n    }\n    if (isUndefined(name)) {\n        if (array && key.match(/^\\d+$/)) {\n            return str;\n        }\n        name = JSON.stringify(\"\" + key);\n        if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n            name = name.substr(1, name.length - 2);\n            name = ctx.stylize(name, \"name\");\n        }\n        else {\n            name = name\n                .replace(/'/g, \"\\\\'\")\n                .replace(/\\\\\"/g, \"\\\\'\")\n                .replace(/(^\"|\"$)/g, \"'\");\n            name = ctx.stylize(name, \"string\");\n        }\n    }\n    return name + \": \" + str;\n}\nfunction formatPrimitive(ctx, value) {\n    if (isUndefined(value))\n        return ctx.stylize(\"undefined\", \"undefined\");\n    if (isString(value)) {\n        const simple = \"'\" + JSON.stringify(value).replace(/^\"|\"$/g, \"\").replace(/'/g, \"\\\\'\").replace(/\\\\\"/g, \"\\\\'\") + \"'\";\n        return ctx.stylize(simple, \"string\");\n    }\n    if (isNumber(value))\n        return ctx.stylize(\"\" + value, \"number\");\n    if (isBoolean(value))\n        return ctx.stylize(\"\" + value, \"boolean\");\n    if (isNull(value))\n        return ctx.stylize(\"null\", \"null\");\n}\nfunction reduceToSingleString(output, base, braces) {\n    return braces[0] + (base === \"\" ? \"\" : base + \"\\n\") + \"  \" + output.join(\",\\n  \") + \" \" + braces[1];\n}\nfunction _extend(origin, add) {\n    const typedOrigin = { ...origin };\n    if (!add || !isObject(add))\n        return origin;\n    const clonedAdd = { ...add };\n    const keys = Object.keys(add);\n    let i = keys.length;\n    while (i--) {\n        typedOrigin[keys[i]] = clonedAdd[keys[i]];\n    }\n    return typedOrigin;\n}\nexport function formatWithOptions(inspectOptions, ...args) {\n    const ctx = {\n        seen: [],\n        stylize: stylizeNoColor,\n    };\n    if (inspectOptions != null) {\n        _extend(ctx, inspectOptions);\n    }\n    const first = args[0];\n    let a = 0;\n    let str = \"\";\n    let join = \"\";\n    if (typeof first === \"string\") {\n        if (args.length === 1) {\n            return first;\n        }\n        let tempStr;\n        let lastPos = 0;\n        for (let i = 0; i < first.length - 1; i++) {\n            if (first.charCodeAt(i) === 37) {\n                const nextChar = first.charCodeAt(++i);\n                if (a + 1 !== args.length) {\n                    switch (nextChar) {\n                        case 115: {\n                            const tempArg = args[++a];\n                            if (typeof tempArg === \"number\") {\n                                tempStr = formatPrimitive(ctx, tempArg);\n                            }\n                            else if (typeof tempArg === \"bigint\") {\n                                tempStr = formatPrimitive(ctx, tempArg);\n                            }\n                            else if (typeof tempArg !== \"object\" || tempArg === null) {\n                                tempStr = String(tempArg);\n                            }\n                            else {\n                                tempStr = inspect(tempArg, {\n                                    ...inspectOptions,\n                                    compact: 3,\n                                    colors: false,\n                                    depth: 0,\n                                });\n                            }\n                            break;\n                        }\n                        case 106:\n                            tempStr = jsonStringifyRecursive(args[++a]);\n                            break;\n                        case 100: {\n                            const tempNum = args[++a];\n                            if (typeof tempNum === \"bigint\") {\n                                tempStr = formatPrimitive(ctx, tempNum);\n                            }\n                            else if (typeof tempNum === \"symbol\") {\n                                tempStr = \"NaN\";\n                            }\n                            else {\n                                tempStr = formatPrimitive(ctx, tempNum);\n                            }\n                            break;\n                        }\n                        case 79:\n                            tempStr = inspect(args[++a], inspectOptions);\n                            break;\n                        case 111:\n                            tempStr = inspect(args[++a], {\n                                ...inspectOptions,\n                                showHidden: true,\n                                showProxy: true,\n                                depth: 4,\n                            });\n                            break;\n                        case 105: {\n                            const tempInteger = args[++a];\n                            if (typeof tempInteger === \"bigint\") {\n                                tempStr = formatPrimitive(ctx, tempInteger);\n                            }\n                            else if (typeof tempInteger === \"symbol\") {\n                                tempStr = \"NaN\";\n                            }\n                            else {\n                                tempStr = formatPrimitive(ctx, parseInt(tempStr));\n                            }\n                            break;\n                        }\n                        case 102: {\n                            const tempFloat = args[++a];\n                            if (typeof tempFloat === \"symbol\") {\n                                tempStr = \"NaN\";\n                            }\n                            else {\n                                tempStr = formatPrimitive(ctx, parseInt(tempFloat));\n                            }\n                            break;\n                        }\n                        case 99:\n                            a += 1;\n                            tempStr = \"\";\n                            break;\n                        case 37:\n                            str += first.slice(lastPos, i);\n                            lastPos = i + 1;\n                            continue;\n                        default:\n                            continue;\n                    }\n                    if (lastPos !== i - 1) {\n                        str += first.slice(lastPos, i - 1);\n                    }\n                    str += tempStr;\n                    lastPos = i + 1;\n                }\n                else if (nextChar === 37) {\n                    str += first.slice(lastPos, i);\n                    lastPos = i + 1;\n                }\n            }\n        }\n        if (lastPos !== 0) {\n            a++;\n            join = \" \";\n            if (lastPos < first.length) {\n                str += first.slice(lastPos);\n            }\n        }\n    }\n    while (a < args.length) {\n        const value = args[a];\n        str += join;\n        str += typeof value !== \"string\" ? inspect(value, inspectOptions) : value;\n        join = \" \";\n        a++;\n    }\n    return str;\n}\n", "import { formatTemplate } from \"../../formatTemplate.js\";\nimport { formatWithOptions } from \"./util.inspect.polyfil.js\";\nimport { jsonStringifyRecursive } from \"./helper.jsonStringifyRecursive.js\";\nexport default {\n    getCallerStackFrame,\n    getErrorTrace,\n    getMeta,\n    transportJSON,\n    transportFormatted,\n    isBuffer,\n    isError,\n    prettyFormatLogObj,\n    prettyFormatErrorObj,\n};\nconst meta = {\n    runtime: ![typeof window, typeof document].includes(\"undefined\") ? \"Browser\" : \"Generic\",\n    browser: globalThis?.[\"navigator\"]?.userAgent,\n};\nconst pathRegex = /(?:(?:file|https?|global code|[^@]+)@)?(?:file:)?((?:\\/[^:/]+){2,})(?::(\\d+))?(?::(\\d+))?/;\nexport function getMeta(logLevelId, logLevelName, stackDepthLevel, hideLogPositionForPerformance, name, parentNames) {\n    return Object.assign({}, meta, {\n        name,\n        parentNames,\n        date: new Date(),\n        logLevelId,\n        logLevelName,\n        path: !hideLogPositionForPerformance ? getCallerStackFrame(stackDepthLevel) : undefined,\n    });\n}\nexport function getCallerStackFrame(stackDepthLevel, error = Error()) {\n    return stackLineToStackFrame(error?.stack?.split(\"\\n\")?.filter((line) => !line.includes(\"Error: \"))?.[stackDepthLevel]);\n}\nexport function getErrorTrace(error) {\n    return (error?.stack?.split(\"\\n\") ?? [])\n        ?.filter((line) => !line.includes(\"Error: \"))\n        ?.reduce((result, line) => {\n        result.push(stackLineToStackFrame(line));\n        return result;\n    }, []);\n}\nfunction stackLineToStackFrame(line) {\n    const href = globalThis?.location?.origin;\n    const pathResult = {\n        fullFilePath: undefined,\n        fileName: undefined,\n        fileNameWithLine: undefined,\n        fileColumn: undefined,\n        fileLine: undefined,\n        filePath: undefined,\n        filePathWithLine: undefined,\n        method: undefined,\n    };\n    if (line != null) {\n        const match = line.match(pathRegex);\n        if (match) {\n            pathResult.filePath = match[1].replace(/\\?.*$/, \"\");\n            pathResult.fullFilePath = `${href}${pathResult.filePath}`;\n            const pathParts = pathResult.filePath.split(\"/\");\n            pathResult.fileName = pathParts[pathParts.length - 1];\n            pathResult.fileLine = match[2];\n            pathResult.fileColumn = match[3];\n            pathResult.filePathWithLine = `${pathResult.filePath}:${pathResult.fileLine}`;\n            pathResult.fileNameWithLine = `${pathResult.fileName}:${pathResult.fileLine}`;\n        }\n    }\n    return pathResult;\n}\nexport function isError(e) {\n    return e instanceof Error;\n}\nexport function prettyFormatLogObj(maskedArgs, settings) {\n    return maskedArgs.reduce((result, arg) => {\n        isError(arg) ? result.errors.push(prettyFormatErrorObj(arg, settings)) : result.args.push(arg);\n        return result;\n    }, { args: [], errors: [] });\n}\nexport function prettyFormatErrorObj(error, settings) {\n    const errorStackStr = getErrorTrace(error).map((stackFrame) => {\n        return formatTemplate(settings, settings.prettyErrorStackTemplate, { ...stackFrame }, true);\n    });\n    const placeholderValuesError = {\n        errorName: ` ${error.name} `,\n        errorMessage: Object.getOwnPropertyNames(error)\n            .reduce((result, key) => {\n            if (key !== \"stack\") {\n                result.push(error[key]);\n            }\n            return result;\n        }, [])\n            .join(\", \"),\n        errorStack: errorStackStr.join(\"\\n\"),\n    };\n    return formatTemplate(settings, settings.prettyErrorTemplate, placeholderValuesError);\n}\nexport function transportFormatted(logMetaMarkup, logArgs, logErrors, settings) {\n    const logErrorsStr = (logErrors.length > 0 && logArgs.length > 0 ? \"\\n\" : \"\") + logErrors.join(\"\\n\");\n    settings.prettyInspectOptions.colors = settings.stylePrettyLogs;\n    console.log(logMetaMarkup + formatWithOptions(settings.prettyInspectOptions, ...logArgs) + logErrorsStr);\n}\nexport function transportJSON(json) {\n    console.log(jsonStringifyRecursive(json));\n}\nexport function isBuffer(arg) {\n    return arg ? false : false;\n}\n", "import { formatTemplate } from \"./formatTemplate.js\";\nimport { formatNumberAddZeros } from \"./formatNumberAddZeros.js\";\nimport { urlToObject } from \"./urlToObj.js\";\nimport Runtime from \"./runtime/nodejs/index.js\";\nexport * from \"./interfaces.js\";\nexport { Runtime };\nexport class BaseLogger {\n    constructor(settings, logObj, stackDepthLevel = 4) {\n        this.logObj = logObj;\n        this.stackDepthLevel = stackDepthLevel;\n        this.runtime = Runtime;\n        this.settings = {\n            type: settings?.type ?? \"pretty\",\n            name: settings?.name,\n            parentNames: settings?.parentNames,\n            minLevel: settings?.minLevel ?? 0,\n            argumentsArrayName: settings?.argumentsArrayName,\n            hideLogPositionForProduction: settings?.hideLogPositionForProduction ?? false,\n            prettyLogTemplate: settings?.prettyLogTemplate ??\n                \"{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}\\t{{logLevelName}}\\t{{filePathWithLine}}{{nameWithDelimiterPrefix}}\\t\",\n            prettyErrorTemplate: settings?.prettyErrorTemplate ?? \"\\n{{errorName}} {{errorMessage}}\\nerror stack:\\n{{errorStack}}\",\n            prettyErrorStackTemplate: settings?.prettyErrorStackTemplate ?? \"   {{fileName}}\\t{{method}}\\n\\t{{filePathWithLine}}\",\n            prettyErrorParentNamesSeparator: settings?.prettyErrorParentNamesSeparator ?? \":\",\n            prettyErrorLoggerNameDelimiter: settings?.prettyErrorLoggerNameDelimiter ?? \"\\t\",\n            stylePrettyLogs: settings?.stylePrettyLogs ?? true,\n            prettyLogTimeZone: settings?.prettyLogTimeZone ?? \"UTC\",\n            prettyLogStyles: settings?.prettyLogStyles ?? {\n                logLevelName: {\n                    \"*\": [\"bold\", \"black\", \"bgWhiteBright\", \"dim\"],\n                    SILLY: [\"bold\", \"white\"],\n                    TRACE: [\"bold\", \"whiteBright\"],\n                    DEBUG: [\"bold\", \"green\"],\n                    INFO: [\"bold\", \"blue\"],\n                    WARN: [\"bold\", \"yellow\"],\n                    ERROR: [\"bold\", \"red\"],\n                    FATAL: [\"bold\", \"redBright\"],\n                },\n                dateIsoStr: \"white\",\n                filePathWithLine: \"white\",\n                name: [\"white\", \"bold\"],\n                nameWithDelimiterPrefix: [\"white\", \"bold\"],\n                nameWithDelimiterSuffix: [\"white\", \"bold\"],\n                errorName: [\"bold\", \"bgRedBright\", \"whiteBright\"],\n                fileName: [\"yellow\"],\n                fileNameWithLine: \"white\",\n            },\n            prettyInspectOptions: settings?.prettyInspectOptions ?? {\n                colors: true,\n                compact: false,\n                depth: Infinity,\n            },\n            metaProperty: settings?.metaProperty ?? \"_meta\",\n            maskPlaceholder: settings?.maskPlaceholder ?? \"[***]\",\n            maskValuesOfKeys: settings?.maskValuesOfKeys ?? [\"password\"],\n            maskValuesOfKeysCaseInsensitive: settings?.maskValuesOfKeysCaseInsensitive ?? false,\n            maskValuesRegEx: settings?.maskValuesRegEx,\n            prefix: [...(settings?.prefix ?? [])],\n            attachedTransports: [...(settings?.attachedTransports ?? [])],\n            overwrite: {\n                mask: settings?.overwrite?.mask,\n                toLogObj: settings?.overwrite?.toLogObj,\n                addMeta: settings?.overwrite?.addMeta,\n                addPlaceholders: settings?.overwrite?.addPlaceholders,\n                formatMeta: settings?.overwrite?.formatMeta,\n                formatLogObj: settings?.overwrite?.formatLogObj,\n                transportFormatted: settings?.overwrite?.transportFormatted,\n                transportJSON: settings?.overwrite?.transportJSON,\n            },\n        };\n    }\n    log(logLevelId, logLevelName, ...args) {\n        if (logLevelId < this.settings.minLevel) {\n            return;\n        }\n        const logArgs = [...this.settings.prefix, ...args];\n        const maskedArgs = this.settings.overwrite?.mask != null\n            ? this.settings.overwrite?.mask(logArgs)\n            : this.settings.maskValuesOfKeys != null && this.settings.maskValuesOfKeys.length > 0\n                ? this._mask(logArgs)\n                : logArgs;\n        const thisLogObj = this.logObj != null ? this._recursiveCloneAndExecuteFunctions(this.logObj) : undefined;\n        const logObj = this.settings.overwrite?.toLogObj != null ? this.settings.overwrite?.toLogObj(maskedArgs, thisLogObj) : this._toLogObj(maskedArgs, thisLogObj);\n        const logObjWithMeta = this.settings.overwrite?.addMeta != null\n            ? this.settings.overwrite?.addMeta(logObj, logLevelId, logLevelName)\n            : this._addMetaToLogObj(logObj, logLevelId, logLevelName);\n        let logMetaMarkup;\n        let logArgsAndErrorsMarkup = undefined;\n        if (this.settings.overwrite?.formatMeta != null) {\n            logMetaMarkup = this.settings.overwrite?.formatMeta(logObjWithMeta?.[this.settings.metaProperty]);\n        }\n        if (this.settings.overwrite?.formatLogObj != null) {\n            logArgsAndErrorsMarkup = this.settings.overwrite?.formatLogObj(maskedArgs, this.settings);\n        }\n        if (this.settings.type === \"pretty\") {\n            logMetaMarkup = logMetaMarkup ?? this._prettyFormatLogObjMeta(logObjWithMeta?.[this.settings.metaProperty]);\n            logArgsAndErrorsMarkup = logArgsAndErrorsMarkup ?? this.runtime.prettyFormatLogObj(maskedArgs, this.settings);\n        }\n        if (logMetaMarkup != null && logArgsAndErrorsMarkup != null) {\n            this.settings.overwrite?.transportFormatted != null\n                ? this.settings.overwrite?.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, this.settings)\n                : this.runtime.transportFormatted(logMetaMarkup, logArgsAndErrorsMarkup.args, logArgsAndErrorsMarkup.errors, this.settings);\n        }\n        else {\n            this.settings.overwrite?.transportJSON != null\n                ? this.settings.overwrite?.transportJSON(logObjWithMeta)\n                : this.settings.type !== \"hidden\"\n                    ? this.runtime.transportJSON(logObjWithMeta)\n                    : undefined;\n        }\n        if (this.settings.attachedTransports != null && this.settings.attachedTransports.length > 0) {\n            this.settings.attachedTransports.forEach((transportLogger) => {\n                transportLogger(logObjWithMeta);\n            });\n        }\n        return logObjWithMeta;\n    }\n    attachTransport(transportLogger) {\n        this.settings.attachedTransports.push(transportLogger);\n    }\n    getSubLogger(settings, logObj) {\n        const subLoggerSettings = {\n            ...this.settings,\n            ...settings,\n            parentNames: this.settings?.parentNames != null && this.settings?.name != null\n                ? [...this.settings.parentNames, this.settings.name]\n                : this.settings?.name != null\n                    ? [this.settings.name]\n                    : undefined,\n            prefix: [...this.settings.prefix, ...(settings?.prefix ?? [])],\n        };\n        const subLogger = new this.constructor(subLoggerSettings, logObj ?? this.logObj, this.stackDepthLevel);\n        return subLogger;\n    }\n    _mask(args) {\n        const maskValuesOfKeys = this.settings.maskValuesOfKeysCaseInsensitive !== true ? this.settings.maskValuesOfKeys : this.settings.maskValuesOfKeys.map((key) => key.toLowerCase());\n        return args?.map((arg) => {\n            return this._recursiveCloneAndMaskValuesOfKeys(arg, maskValuesOfKeys);\n        });\n    }\n    _recursiveCloneAndMaskValuesOfKeys(source, keys, seen = []) {\n        if (seen.includes(source)) {\n            return { ...source };\n        }\n        if (typeof source === \"object\" && source !== null) {\n            seen.push(source);\n        }\n        if (this.runtime.isError(source) || this.runtime.isBuffer(source)) {\n            return source;\n        }\n        else if (source instanceof Map) {\n            return new Map(source);\n        }\n        else if (source instanceof Set) {\n            return new Set(source);\n        }\n        else if (Array.isArray(source)) {\n            return source.map((item) => this._recursiveCloneAndMaskValuesOfKeys(item, keys, seen));\n        }\n        else if (source instanceof Date) {\n            return new Date(source.getTime());\n        }\n        else if (source instanceof URL) {\n            return urlToObject(source);\n        }\n        else if (source !== null && typeof source === \"object\") {\n            const baseObject = this.runtime.isError(source) ? this._cloneError(source) : Object.create(Object.getPrototypeOf(source));\n            return Object.getOwnPropertyNames(source).reduce((o, prop) => {\n                o[prop] = keys.includes(this.settings?.maskValuesOfKeysCaseInsensitive !== true ? prop : prop.toLowerCase())\n                    ? this.settings.maskPlaceholder\n                    : (() => {\n                        try {\n                            return this._recursiveCloneAndMaskValuesOfKeys(source[prop], keys, seen);\n                        }\n                        catch (e) {\n                            return null;\n                        }\n                    })();\n                return o;\n            }, baseObject);\n        }\n        else {\n            if (typeof source === \"string\") {\n                let modifiedSource = source;\n                for (const regEx of this.settings?.maskValuesRegEx || []) {\n                    modifiedSource = modifiedSource.replace(regEx, this.settings?.maskPlaceholder || \"\");\n                }\n                return modifiedSource;\n            }\n            return source;\n        }\n    }\n    _recursiveCloneAndExecuteFunctions(source, seen = []) {\n        if (this.isObjectOrArray(source) && seen.includes(source)) {\n            return this.shallowCopy(source);\n        }\n        if (this.isObjectOrArray(source)) {\n            seen.push(source);\n        }\n        if (Array.isArray(source)) {\n            return source.map((item) => this._recursiveCloneAndExecuteFunctions(item, seen));\n        }\n        else if (source instanceof Date) {\n            return new Date(source.getTime());\n        }\n        else if (this.isObject(source)) {\n            return Object.getOwnPropertyNames(source).reduce((o, prop) => {\n                const descriptor = Object.getOwnPropertyDescriptor(source, prop);\n                if (descriptor) {\n                    Object.defineProperty(o, prop, descriptor);\n                    const value = source[prop];\n                    o[prop] = typeof value === \"function\" ? value() : this._recursiveCloneAndExecuteFunctions(value, seen);\n                }\n                return o;\n            }, Object.create(Object.getPrototypeOf(source)));\n        }\n        else {\n            return source;\n        }\n    }\n    isObjectOrArray(value) {\n        return typeof value === \"object\" && value !== null;\n    }\n    isObject(value) {\n        return typeof value === \"object\" && !Array.isArray(value) && value !== null;\n    }\n    shallowCopy(source) {\n        if (Array.isArray(source)) {\n            return [...source];\n        }\n        else {\n            return { ...source };\n        }\n    }\n    _toLogObj(args, clonedLogObj = {}) {\n        args = args?.map((arg) => (this.runtime.isError(arg) ? this._toErrorObject(arg) : arg));\n        if (this.settings.argumentsArrayName == null) {\n            if (args.length === 1 && !Array.isArray(args[0]) && this.runtime.isBuffer(args[0]) !== true && !(args[0] instanceof Date)) {\n                clonedLogObj = typeof args[0] === \"object\" && args[0] != null ? { ...args[0], ...clonedLogObj } : { 0: args[0], ...clonedLogObj };\n            }\n            else {\n                clonedLogObj = { ...clonedLogObj, ...args };\n            }\n        }\n        else {\n            clonedLogObj = {\n                ...clonedLogObj,\n                [this.settings.argumentsArrayName]: args,\n            };\n        }\n        return clonedLogObj;\n    }\n    _cloneError(error) {\n        const cloned = new error.constructor();\n        Object.getOwnPropertyNames(error).forEach((key) => {\n            cloned[key] = error[key];\n        });\n        return cloned;\n    }\n    _toErrorObject(error) {\n        return {\n            nativeError: error,\n            name: error.name ?? \"Error\",\n            message: error.message,\n            stack: this.runtime.getErrorTrace(error),\n        };\n    }\n    _addMetaToLogObj(logObj, logLevelId, logLevelName) {\n        return {\n            ...logObj,\n            [this.settings.metaProperty]: this.runtime.getMeta(logLevelId, logLevelName, this.stackDepthLevel, this.settings.hideLogPositionForProduction, this.settings.name, this.settings.parentNames),\n        };\n    }\n    _prettyFormatLogObjMeta(logObjMeta) {\n        if (logObjMeta == null) {\n            return \"\";\n        }\n        let template = this.settings.prettyLogTemplate;\n        const placeholderValues = {};\n        if (template.includes(\"{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}\")) {\n            template = template.replace(\"{{yyyy}}.{{mm}}.{{dd}} {{hh}}:{{MM}}:{{ss}}:{{ms}}\", \"{{dateIsoStr}}\");\n        }\n        else {\n            if (this.settings.prettyLogTimeZone === \"UTC\") {\n                placeholderValues[\"yyyy\"] = logObjMeta?.date?.getUTCFullYear() ?? \"----\";\n                placeholderValues[\"mm\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMonth(), 2, 1);\n                placeholderValues[\"dd\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCDate(), 2);\n                placeholderValues[\"hh\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCHours(), 2);\n                placeholderValues[\"MM\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMinutes(), 2);\n                placeholderValues[\"ss\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCSeconds(), 2);\n                placeholderValues[\"ms\"] = formatNumberAddZeros(logObjMeta?.date?.getUTCMilliseconds(), 3);\n            }\n            else {\n                placeholderValues[\"yyyy\"] = logObjMeta?.date?.getFullYear() ?? \"----\";\n                placeholderValues[\"mm\"] = formatNumberAddZeros(logObjMeta?.date?.getMonth(), 2, 1);\n                placeholderValues[\"dd\"] = formatNumberAddZeros(logObjMeta?.date?.getDate(), 2);\n                placeholderValues[\"hh\"] = formatNumberAddZeros(logObjMeta?.date?.getHours(), 2);\n                placeholderValues[\"MM\"] = formatNumberAddZeros(logObjMeta?.date?.getMinutes(), 2);\n                placeholderValues[\"ss\"] = formatNumberAddZeros(logObjMeta?.date?.getSeconds(), 2);\n                placeholderValues[\"ms\"] = formatNumberAddZeros(logObjMeta?.date?.getMilliseconds(), 3);\n            }\n        }\n        const dateInSettingsTimeZone = this.settings.prettyLogTimeZone === \"UTC\" ? logObjMeta?.date : new Date(logObjMeta?.date?.getTime() - logObjMeta?.date?.getTimezoneOffset() * 60000);\n        placeholderValues[\"rawIsoStr\"] = dateInSettingsTimeZone?.toISOString();\n        placeholderValues[\"dateIsoStr\"] = dateInSettingsTimeZone?.toISOString().replace(\"T\", \" \").replace(\"Z\", \"\");\n        placeholderValues[\"logLevelName\"] = logObjMeta?.logLevelName;\n        placeholderValues[\"fileNameWithLine\"] = logObjMeta?.path?.fileNameWithLine ?? \"\";\n        placeholderValues[\"filePathWithLine\"] = logObjMeta?.path?.filePathWithLine ?? \"\";\n        placeholderValues[\"fullFilePath\"] = logObjMeta?.path?.fullFilePath ?? \"\";\n        let parentNamesString = this.settings.parentNames?.join(this.settings.prettyErrorParentNamesSeparator);\n        parentNamesString = parentNamesString != null && logObjMeta?.name != null ? parentNamesString + this.settings.prettyErrorParentNamesSeparator : undefined;\n        placeholderValues[\"name\"] = logObjMeta?.name != null || parentNamesString != null ? (parentNamesString ?? \"\") + logObjMeta?.name ?? \"\" : \"\";\n        placeholderValues[\"nameWithDelimiterPrefix\"] =\n            placeholderValues[\"name\"].length > 0 ? this.settings.prettyErrorLoggerNameDelimiter + placeholderValues[\"name\"] : \"\";\n        placeholderValues[\"nameWithDelimiterSuffix\"] =\n            placeholderValues[\"name\"].length > 0 ? placeholderValues[\"name\"] + this.settings.prettyErrorLoggerNameDelimiter : \"\";\n        if (this.settings.overwrite?.addPlaceholders != null) {\n            this.settings.overwrite?.addPlaceholders(logObjMeta, placeholderValues);\n        }\n        return formatTemplate(this.settings, template, placeholderValues);\n    }\n}\n", "import { BaseLogger } from \"./BaseLogger.js\";\nexport * from \"./interfaces.js\";\nexport * from \"./BaseLogger.js\";\nexport class Logger extends BaseLogger {\n    constructor(settings, logObj) {\n        const isBrowser = typeof window !== \"undefined\" && typeof document !== \"undefined\";\n        const isBrowserBlinkEngine = isBrowser ? window.chrome !== undefined && window.CSS !== undefined && window.CSS.supports(\"color\", \"green\") : false;\n        const isSafari = isBrowser ? /^((?!chrome|android).)*safari/i.test(navigator.userAgent) : false;\n        settings = settings || {};\n        settings.stylePrettyLogs = settings.stylePrettyLogs && isBrowser && !isBrowserBlinkEngine ? false : settings.stylePrettyLogs;\n        super(settings, logObj, isSafari ? 4 : 5);\n    }\n    log(logLevelId, logLevelName, ...args) {\n        return super.log(logLevelId, logLevelName, ...args);\n    }\n    silly(...args) {\n        return super.log(0, \"SILLY\", ...args);\n    }\n    trace(...args) {\n        return super.log(1, \"TRACE\", ...args);\n    }\n    debug(...args) {\n        return super.log(2, \"DEBUG\", ...args);\n    }\n    info(...args) {\n        return super.log(3, \"INFO\", ...args);\n    }\n    warn(...args) {\n        return super.log(4, \"WARN\", ...args);\n    }\n    error(...args) {\n        return super.log(5, \"ERROR\", ...args);\n    }\n    fatal(...args) {\n        return super.log(6, \"FATAL\", ...args);\n    }\n    getSubLogger(settings, logObj) {\n        return super.getSubLogger(settings, logObj);\n    }\n}\n"],
  "mappings": "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;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAGD,QAAM,IAAI,IAAI,YAAY,EAAE;AAC5B,QAAM,IAAI,IAAI,YAAY,EAAE;AAC5B,aAAS,gBAAiB,KAAKC,OAAM;AACnC,UAAI,IAAI;AACR,WAAK,IAAI,GAAG,IAAI,GAAG,KAAK;AAEtB,UAAE,CAAC,IAAI,IAAI,EAAE,CAAC;AACd,UAAE,IAAI,CAAC,IAAI,WAAW,CAAC;AAAA,MACzB;AAEA,QAAE,EAAE,KAAK,IAAI;AACb,QAAE,EAAE,KAAK,IAAI,IAAI;AACjB,UAAIA,OAAM;AAER,UAAE,EAAE,IAAI,CAAC,EAAE,EAAE;AAAA,MACf;AAEA,WAAK,IAAI,GAAG,IAAI,IAAI,KAAK;AAEvB,UAAE,CAAC,IAAI,UAAU,IAAI,GAAG,IAAI,CAAC;AAAA,MAC/B;AAMA,WAAK,IAAI,GAAG,IAAI,IAAI,KAAK;AAEvB,cAAM,GAAG,GAAG,GAAG,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC;AAC7D,cAAM,GAAG,GAAG,GAAG,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC;AAC7D,cAAM,GAAG,GAAG,IAAI,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC;AAC9D,cAAM,GAAG,GAAG,IAAI,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC;AAC9D,cAAM,GAAG,GAAG,IAAI,IAAI,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,CAAC,CAAC,CAAC;AAC9D,cAAM,GAAG,GAAG,IAAI,IAAI,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,CAAC;AAChE,cAAM,GAAG,GAAG,GAAG,IAAI,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,CAAC;AAC/D,cAAM,GAAG,GAAG,GAAG,IAAI,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,GAAG,EAAE,MAAM,IAAI,KAAK,EAAE,CAAC,CAAC;AAAA,MACjE;AAGA,WAAK,IAAI,GAAG,IAAI,GAAG,KAAK;AACtB,YAAI,EAAE,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,IAAI,CAAC;AAAA,MAC5B;AAAA,IAEF;AAKA,aAAS,YAAa,QAAQ,KAAK;AACjC,UAAI,EAAE,SAAS,KAAK,UAAU,KAAK;AACjC,cAAM,IAAI,MAAM,+CAA+C;AAAA,MACjE;AACA,YAAM,SAAS,MAAM,IAAI,SAAS;AAClC,UAAI,OAAO,EAAE,SAAS,KAAK,UAAU,KAAK;AACxC,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC9D;AAEA,YAAM,MAAM;AAAA,QACV,GAAG,IAAI,YAAY,UAAU;AAAA;AAAA,QAC7B,GAAG,IAAI,WAAW,EAAE;AAAA;AAAA,QACpB,GAAG;AAAA;AAAA,QACH,GAAG;AAAA;AAAA,QACH;AAAA;AAAA,MACF;AACA,UAAI,EAAE,CAAC,KAAK,WAAc,UAAU,IAAK;AAEzC,UAAI,SAAS,GAAG;AACd,sBAAc,KAAK,GAAG;AACtB,YAAI,IAAI;AAAA,MACV;AAEA,aAAO;AAAA,IACT;AAIA,aAAS,cAAe,KAAK,OAAO;AAClC,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACrC,YAAI,IAAI,MAAM,IAAI;AAEhB,cAAI,KAAK,IAAI;AACb,0BAAgB,KAAK,KAAK;AAC1B,cAAI,IAAI;AAAA,QACV;AACA,YAAI,EAAE,IAAI,GAAG,IAAI,MAAM,CAAC;AAAA,MAC1B;AAAA,IACF;AAIA,aAAS,aAAc,KAAK;AAC1B,UAAI,KAAK,IAAI;AACb,aAAO,IAAI,IAAI,IAAI;AAEjB,YAAI,EAAE,IAAI,GAAG,IAAI;AAAA,MACnB;AACA,sBAAgB,KAAK,IAAI;AAGzB,YAAM,MAAM,IAAI,WAAW,IAAI,MAAM;AACrC,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACnC,YAAI,CAAC,IAAK,IAAI,EAAE,KAAK,CAAC,KAAM,KAAK,IAAI,KAAO;AAAA,MAC9C;AACA,aAAO;AAAA,IACT;AAUA,aAAS,QAAS,OAAO,KAAK,QAAQ;AAEpC,eAAS,UAAU;AACnB,cAAQ,KAAK,eAAe,KAAK;AAGjC,YAAM,MAAM,YAAY,QAAQ,GAAG;AACnC,oBAAc,KAAK,KAAK;AACxB,aAAO,aAAa,GAAG;AAAA,IACzB;AAUA,aAAS,WAAY,OAAO,KAAK,QAAQ;AACvC,YAAMC,UAAS,QAAQ,OAAO,KAAK,MAAM;AACzC,aAAO,KAAK,MAAMA,OAAM;AAAA,IAC1B;AAEA,WAAO,UAAU;AAAA,MACf;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA;AAAA;;;AChWA;AAAA;AAAA,QAAM,MAAM;AACZ,QAAM,MAAM;AAEZ,WAAO,UAAU;AAAA,MACf,SAAS,IAAI;AAAA,MACb,YAAY,IAAI;AAAA,MAChB,aAAa,IAAI;AAAA,MACjB,eAAe,IAAI;AAAA,MACnB,cAAc,IAAI;AAAA,MAClB,SAAS,IAAI;AAAA,MACb,YAAY,IAAI;AAAA,MAChB,aAAa,IAAI;AAAA,MACjB,eAAe,IAAI;AAAA,MACnB,cAAc,IAAI;AAAA,IACpB;AAAA;AAAA;;;ACdA;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,aAAS,UAAU,OAAO;AACtB,UAAI,gBAAgB;AACpB,UAAI,eAAe,MAAM;AACzB,UAAI,OAAO,eAAe;AAC1B,UAAI,CAAC,MAAM;AACP,eAAO;AAAA,MACX;AACA,UAAI,WAAW;AACf,UAAI,YAAY,gBAAgB;AAChC,UAAI,qBAAqB,eAAe;AACxC,UAAIC,UAAS,OAAO,MAAM,kBAAkB;AAC5C,MAAAA,QAAO,MAAM,KAAK;AAClB,aAAO,aAAa;AAChB,QAAAA,QAAO,MAAM,KAAK,UAAU;AAAA,MAChC;AACA,aAAOA,QAAO,SAAS;AAAA,IAC3B;AACA,YAAQ,UAAU;AAAA;AAAA;;;ACnBlB;AAAA;AAAA;AACA,WAAO,eAAe,SAAS,cAAc,EAAE,OAAO,KAAK,CAAC;AAC5D,QAAI,eAAe;AACnB,aAAS,OAAO,OAAO,UAAU;AAC7B,UAAI,aAAa,QAAQ;AAAE,mBAAW;AAAA,MAAQ;AAC9C,UAAI,OAAO,SAAS,KAAK,GAAG;AACxB,eAAO,WAAW,MAAM,SAAS,QAAQ,CAAC;AAAA,MAC9C;AACA,aAAO,WAAW,OAAO,KAAK,OAAO,QAAQ,EAAE,SAAS,QAAQ,CAAC;AAAA,IACrE;AAEA,aAAS,OAAOC,YAAW,UAAU;AACjC,UAAI,aAAa,QAAQ;AAAE,mBAAW;AAAA,MAAQ;AAC9C,aAAO,OAAO,KAAK,SAASA,UAAS,GAAG,QAAQ,EAAE,SAAS,QAAQ;AAAA,IACvE;AACA,aAAS,SAASA,YAAW;AACzB,MAAAA,aAAYA,WAAU,SAAS;AAC/B,aAAO,aAAa,QAAQA,UAAS,EAChC,QAAQ,OAAO,GAAG,EAClB,QAAQ,MAAM,GAAG;AAAA,IAC1B;AACA,aAAS,WAAW,QAAQ;AACxB,aAAO,OACF,QAAQ,MAAM,EAAE,EAChB,QAAQ,OAAO,GAAG,EAClB,QAAQ,OAAO,GAAG;AAAA,IAC3B;AACA,aAAS,SAASA,YAAW;AACzB,aAAO,OAAO,KAAK,SAASA,UAAS,GAAG,QAAQ;AAAA,IACpD;AACA,QAAIA,aAAY;AAChB,IAAAA,WAAU,SAAS;AACnB,IAAAA,WAAU,SAAS;AACnB,IAAAA,WAAU,WAAW;AACrB,IAAAA,WAAU,aAAa;AACvB,IAAAA,WAAU,WAAW;AACrB,YAAQ,UAAUA;AAAA;AAAA;;;ACpClB,IAAAC,qBAAA;AAAA;AAAA,WAAO,UAAU,oBAA4B;AAC7C,WAAO,QAAQ,UAAU,OAAO;AAAA;AAAA;;;ACAhC,IAAAC,iBAAkC;;;ACG5B,SAAU,WAAW,OAAU;AACnC,SAAO,OAAO,UAAU;AAC1B;;;ACGM,SAAU,iBAAoB,YAAgC;AAClE,MAAM,SAAS,SAAC,UAAa;AAC3B,UAAM,KAAK,QAAQ;AACnB,aAAS,QAAQ,IAAI,MAAK,EAAG;EAC/B;AAEA,MAAM,WAAW,WAAW,MAAM;AAClC,WAAS,YAAY,OAAO,OAAO,MAAM,SAAS;AAClD,WAAS,UAAU,cAAc;AACjC,SAAO;AACT;;;ACDO,IAAM,sBAA+C,iBAC1D,SAAC,QAAM;AACL,SAAA,SAAS,wBAAmCC,SAA0B;AACpE,WAAO,IAAI;AACX,SAAK,UAAUA,UACRA,QAAO,SAAM,8CACxBA,QAAO,IAAI,SAACC,MAAK,GAAC;AAAK,aAAG,IAAI,IAAC,OAAKA,KAAI,SAAQ;IAAzB,CAA6B,EAAE,KAAK,MAAM,IACzD;AACJ,SAAK,OAAO;AACZ,SAAK,SAASD;EAChB;AARA,CAQC;;;ACvBC,SAAU,UAAa,KAA6B,MAAO;AAC/D,MAAI,KAAK;AACP,QAAM,QAAQ,IAAI,QAAQ,IAAI;AAC9B,SAAK,SAAS,IAAI,OAAO,OAAO,CAAC;;AAErC;;;ACKA,IAAA,eAAA,WAAA;AAwBE,WAAAE,cAAoB,iBAA4B;AAA5B,SAAA,kBAAA;AAdb,SAAA,SAAS;AAER,SAAA,aAAmD;AAMnD,SAAA,cAAqD;EAMV;AAOnD,EAAAA,cAAA,UAAA,cAAA,WAAA;;AACE,QAAIC;AAEJ,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,SAAS;AAGN,UAAA,aAAe,KAAI;AAC3B,UAAI,YAAY;AACd,aAAK,aAAa;AAClB,YAAI,MAAM,QAAQ,UAAU,GAAG;;AAC7B,qBAAqB,eAAA,SAAA,UAAU,GAAA,iBAAA,aAAA,KAAA,GAAA,CAAA,eAAA,MAAA,iBAAA,aAAA,KAAA,GAAE;AAA5B,kBAAM,WAAM,eAAA;AACf,uBAAO,OAAO,IAAI;;;;;;;;;;;eAEf;AACL,qBAAW,OAAO,IAAI;;;AAIlB,UAAiB,mBAAqB,KAAI;AAClD,UAAI,WAAW,gBAAgB,GAAG;AAChC,YAAI;AACF,2BAAgB;iBACT,GAAG;AACV,UAAAA,UAAS,aAAa,sBAAsB,EAAE,SAAS,CAAC,CAAC;;;AAIrD,UAAA,cAAgB,KAAI;AAC5B,UAAI,aAAa;AACf,aAAK,cAAc;;AACnB,mBAAwB,gBAAA,SAAA,WAAW,GAAA,kBAAA,cAAA,KAAA,GAAA,CAAA,gBAAA,MAAA,kBAAA,cAAA,KAAA,GAAE;AAAhC,gBAAM,YAAS,gBAAA;AAClB,gBAAI;AACF,4BAAc,SAAS;qBAChBC,MAAK;AACZ,cAAAD,UAASA,YAAM,QAANA,YAAM,SAANA,UAAU,CAAA;AACnB,kBAAIC,gBAAe,qBAAqB;AACtC,gBAAAD,UAAM,cAAA,cAAA,CAAA,GAAA,OAAOA,OAAM,CAAA,GAAA,OAAKC,KAAI,MAAM,CAAA;qBAC7B;AACL,gBAAAD,QAAO,KAAKC,IAAG;;;;;;;;;;;;;;AAMvB,UAAID,SAAQ;AACV,cAAM,IAAI,oBAAoBA,OAAM;;;EAG1C;AAoBA,EAAAD,cAAA,UAAA,MAAA,SAAI,UAAuB;;AAGzB,QAAI,YAAY,aAAa,MAAM;AACjC,UAAI,KAAK,QAAQ;AAGf,sBAAc,QAAQ;aACjB;AACL,YAAI,oBAAoBA,eAAc;AAGpC,cAAI,SAAS,UAAU,SAAS,WAAW,IAAI,GAAG;AAChD;;AAEF,mBAAS,WAAW,IAAI;;AAE1B,SAAC,KAAK,eAAcG,MAAA,KAAK,iBAAW,QAAAA,QAAA,SAAAA,MAAI,CAAA,GAAI,KAAK,QAAQ;;;EAG/D;AAOQ,EAAAH,cAAA,UAAA,aAAR,SAAmB,QAAoB;AAC7B,QAAA,aAAe,KAAI;AAC3B,WAAO,eAAe,UAAW,MAAM,QAAQ,UAAU,KAAK,WAAW,SAAS,MAAM;EAC1F;AASQ,EAAAA,cAAA,UAAA,aAAR,SAAmB,QAAoB;AAC7B,QAAA,aAAe,KAAI;AAC3B,SAAK,aAAa,MAAM,QAAQ,UAAU,KAAK,WAAW,KAAK,MAAM,GAAG,cAAc,aAAa,CAAC,YAAY,MAAM,IAAI;EAC5H;AAMQ,EAAAA,cAAA,UAAA,gBAAR,SAAsB,QAAoB;AAChC,QAAA,aAAe,KAAI;AAC3B,QAAI,eAAe,QAAQ;AACzB,WAAK,aAAa;eACT,MAAM,QAAQ,UAAU,GAAG;AACpC,gBAAU,YAAY,MAAM;;EAEhC;AAgBA,EAAAA,cAAA,UAAA,SAAA,SAAO,UAAsC;AACnC,QAAA,cAAgB,KAAI;AAC5B,mBAAe,UAAU,aAAa,QAAQ;AAE9C,QAAI,oBAAoBA,eAAc;AACpC,eAAS,cAAc,IAAI;;EAE/B;AAjLc,EAAAA,cAAA,QAAS,WAAA;AACrB,QAAMI,SAAQ,IAAIJ,cAAY;AAC9B,IAAAI,OAAM,SAAS;AACf,WAAOA;EACT,EAAE;AA8KJ,SAAAJ;EAnLA;AAqLO,IAAM,qBAAqB,aAAa;AAEzC,SAAU,eAAe,OAAU;AACvC,SACE,iBAAiB,gBAChB,SAAS,YAAY,SAAS,WAAW,MAAM,MAAM,KAAK,WAAW,MAAM,GAAG,KAAK,WAAW,MAAM,WAAW;AAEpH;AAEA,SAAS,cAAc,WAAwC;AAC7D,MAAI,WAAW,SAAS,GAAG;AACzB,cAAS;SACJ;AACL,cAAU,YAAW;;AAEzB;;;AC5MO,IAAM,SAAuB;EAClC,kBAAkB;EAClB,uBAAuB;EACvB,SAAS;EACT,uCAAuC;EACvC,0BAA0B;;;;ACGrB,IAAM,kBAAmC;EAG9C,YAAA,SAAW,SAAqBK,UAAgB;AAAE,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAO;AAAP,WAAA,KAAA,CAAA,IAAA,UAAA,EAAA;;AACxC,QAAA,WAAa,gBAAe;AACpC,QAAI,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,YAAY;AACxB,aAAO,SAAS,WAAU,MAAnB,UAAQ,cAAA,CAAY,SAASA,QAAO,GAAA,OAAK,IAAI,CAAA,CAAA;;AAEtD,WAAO,WAAU,MAAA,QAAA,cAAA,CAAC,SAASA,QAAO,GAAA,OAAK,IAAI,CAAA,CAAA;EAC7C;EACA,cAAA,SAAa,QAAM;AACT,QAAA,WAAa,gBAAe;AACpC,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,iBAAgB,cAAc,MAAa;EAC/D;EACA,UAAU;;;;ACjBN,SAAU,qBAAqBC,MAAQ;AAC3C,kBAAgB,WAAW,WAAA;AACjB,QAAA,mBAAqB,OAAM;AACnC,QAAI,kBAAkB;AAEpB,uBAAiBA,IAAG;WACf;AAEL,YAAMA;;EAEV,CAAC;AACH;;;ACtBM,SAAU,OAAI;AAAK;;;ACMlB,IAAM,wBAAyB,WAAA;AAAM,SAAA,mBAAmB,KAAK,QAAW,MAAS;AAA5C,EAAsE;AAO5G,SAAU,kBAAkB,OAAU;AAC1C,SAAO,mBAAmB,KAAK,QAAW,KAAK;AACjD;AAOM,SAAU,iBAAoB,OAAQ;AAC1C,SAAO,mBAAmB,KAAK,OAAO,MAAS;AACjD;AAQM,SAAU,mBAAmB,MAAuB,OAAY,OAAU;AAC9E,SAAO;IACL;IACA;IACA;;AAEJ;;;ACrCA,IAAI,UAAuD;AASrD,SAAU,aAAa,IAAc;AACzC,MAAI,OAAO,uCAAuC;AAChD,QAAM,SAAS,CAAC;AAChB,QAAI,QAAQ;AACV,gBAAU,EAAE,aAAa,OAAO,OAAO,KAAI;;AAE7C,OAAE;AACF,QAAI,QAAQ;AACJ,UAAAC,MAAyB,SAAvB,cAAWA,IAAA,aAAE,QAAKA,IAAA;AAC1B,gBAAU;AACV,UAAI,aAAa;AACf,cAAM;;;SAGL;AAGL,OAAE;;AAEN;AAMM,SAAU,aAAaC,MAAQ;AACnC,MAAI,OAAO,yCAAyC,SAAS;AAC3D,YAAQ,cAAc;AACtB,YAAQ,QAAQA;;AAEpB;;;ACvBA,IAAA,aAAA,SAAA,QAAA;AAAmC,YAAAC,aAAA,MAAA;AA4BjC,WAAAA,YAAY,aAA6C;AAAzD,QAAA,QACE,OAAA,KAAA,IAAA,KAAO;AATC,UAAA,YAAqB;AAU7B,QAAI,aAAa;AACf,YAAK,cAAc;AAGnB,UAAI,eAAe,WAAW,GAAG;AAC/B,oBAAY,IAAI,KAAI;;WAEjB;AACL,YAAK,cAAc;;;EAEvB;AAzBO,EAAAA,YAAA,SAAP,SAAiB,MAAwB,OAA2B,UAAqB;AACvF,WAAO,IAAI,eAAe,MAAM,OAAO,QAAQ;EACjD;AA+BA,EAAAA,YAAA,UAAA,OAAA,SAAK,OAAQ;AACX,QAAI,KAAK,WAAW;AAClB,gCAA0B,iBAAiB,KAAK,GAAG,IAAI;WAClD;AACL,WAAK,MAAM,KAAM;;EAErB;AAQA,EAAAA,YAAA,UAAA,QAAA,SAAMC,MAAS;AACb,QAAI,KAAK,WAAW;AAClB,gCAA0B,kBAAkBA,IAAG,GAAG,IAAI;WACjD;AACL,WAAK,YAAY;AACjB,WAAK,OAAOA,IAAG;;EAEnB;AAOA,EAAAD,YAAA,UAAA,WAAA,WAAA;AACE,QAAI,KAAK,WAAW;AAClB,gCAA0B,uBAAuB,IAAI;WAChD;AACL,WAAK,YAAY;AACjB,WAAK,UAAS;;EAElB;AAEA,EAAAA,YAAA,UAAA,cAAA,WAAA;AACE,QAAI,CAAC,KAAK,QAAQ;AAChB,WAAK,YAAY;AACjB,aAAA,UAAM,YAAW,KAAA,IAAA;AACjB,WAAK,cAAc;;EAEvB;AAEU,EAAAA,YAAA,UAAA,QAAV,SAAgB,OAAQ;AACtB,SAAK,YAAY,KAAK,KAAK;EAC7B;AAEU,EAAAA,YAAA,UAAA,SAAV,SAAiBC,MAAQ;AACvB,QAAI;AACF,WAAK,YAAY,MAAMA,IAAG;;AAE1B,WAAK,YAAW;;EAEpB;AAEU,EAAAD,YAAA,UAAA,YAAV,WAAA;AACE,QAAI;AACF,WAAK,YAAY,SAAQ;;AAEzB,WAAK,YAAW;;EAEpB;AACF,SAAAA;AAAA,EAhHmC,YAAY;AAuH/C,IAAM,QAAQ,SAAS,UAAU;AAEjC,SAAS,KAAyC,IAAQ,SAAY;AACpE,SAAO,MAAM,KAAK,IAAI,OAAO;AAC/B;AAMA,IAAA,mBAAA,WAAA;AACE,WAAAE,kBAAoB,iBAAqC;AAArC,SAAA,kBAAA;EAAwC;AAE5D,EAAAA,kBAAA,UAAA,OAAA,SAAK,OAAQ;AACH,QAAA,kBAAoB,KAAI;AAChC,QAAI,gBAAgB,MAAM;AACxB,UAAI;AACF,wBAAgB,KAAK,KAAK;eACnB,OAAO;AACd,6BAAqB,KAAK;;;EAGhC;AAEA,EAAAA,kBAAA,UAAA,QAAA,SAAMC,MAAQ;AACJ,QAAA,kBAAoB,KAAI;AAChC,QAAI,gBAAgB,OAAO;AACzB,UAAI;AACF,wBAAgB,MAAMA,IAAG;eAClB,OAAO;AACd,6BAAqB,KAAK;;WAEvB;AACL,2BAAqBA,IAAG;;EAE5B;AAEA,EAAAD,kBAAA,UAAA,WAAA,WAAA;AACU,QAAA,kBAAoB,KAAI;AAChC,QAAI,gBAAgB,UAAU;AAC5B,UAAI;AACF,wBAAgB,SAAQ;eACjB,OAAO;AACd,6BAAqB,KAAK;;;EAGhC;AACF,SAAAA;AAAA,EArCA;AAuCA,IAAA,iBAAA,SAAA,QAAA;AAAuC,YAAAE,iBAAA,MAAA;AACrC,WAAAA,gBACE,gBACA,OACA,UAA8B;AAHhC,QAAA,QAKE,OAAA,KAAA,IAAA,KAAO;AAEP,QAAI;AACJ,QAAI,WAAW,cAAc,KAAK,CAAC,gBAAgB;AAGjD,wBAAkB;QAChB,MAAO,mBAAc,QAAd,mBAAc,SAAd,iBAAkB;QACzB,OAAO,UAAK,QAAL,UAAK,SAAL,QAAS;QAChB,UAAU,aAAQ,QAAR,aAAQ,SAAR,WAAY;;WAEnB;AAEL,UAAI;AACJ,UAAI,SAAQ,OAAO,0BAA0B;AAI3C,oBAAU,OAAO,OAAO,cAAc;AACtC,kBAAQ,cAAc,WAAA;AAAM,iBAAA,MAAK,YAAW;QAAhB;AAC5B,0BAAkB;UAChB,MAAM,eAAe,QAAQ,KAAK,eAAe,MAAM,SAAO;UAC9D,OAAO,eAAe,SAAS,KAAK,eAAe,OAAO,SAAO;UACjE,UAAU,eAAe,YAAY,KAAK,eAAe,UAAU,SAAO;;aAEvE;AAEL,0BAAkB;;;AAMtB,UAAK,cAAc,IAAI,iBAAiB,eAAe;;EACzD;AACF,SAAAA;AAAA,EAzCuC,UAAU;AA2CjD,SAAS,qBAAqB,OAAU;AACtC,MAAI,OAAO,uCAAuC;AAChD,iBAAa,KAAK;SACb;AAGL,yBAAqB,KAAK;;AAE9B;AAQA,SAAS,oBAAoBC,MAAQ;AACnC,QAAMA;AACR;AAOA,SAAS,0BAA0B,cAA2C,YAA2B;AAC/F,MAAA,wBAA0B,OAAM;AACxC,2BAAyB,gBAAgB,WAAW,WAAA;AAAM,WAAA,sBAAsB,cAAc,UAAU;EAA9C,CAA+C;AAC3G;AAOO,IAAM,iBAA6D;EACxE,QAAQ;EACR,MAAM;EACN,OAAO;EACP,UAAU;;;;ACtQL,IAAM,aAA+B,WAAA;AAAM,SAAC,OAAO,WAAW,cAAc,OAAO,cAAe;AAAvD,EAAsE;;;ACoClH,SAAU,SAAY,GAAI;AAC9B,SAAO;AACT;;;ACsCM,SAAU,cAAoB,KAA+B;AACjE,MAAI,IAAI,WAAW,GAAG;AACpB,WAAO;;AAGT,MAAI,IAAI,WAAW,GAAG;AACpB,WAAO,IAAI,CAAC;;AAGd,SAAO,SAAS,MAAM,OAAQ;AAC5B,WAAO,IAAI,OAAO,SAAC,MAAW,IAAuB;AAAK,aAAA,GAAG,IAAI;IAAP,GAAU,KAAY;EAClF;AACF;;;AChFA,IAAA,aAAA,WAAA;AAiBE,WAAAC,YAAY,WAA6E;AACvF,QAAI,WAAW;AACb,WAAK,aAAa;;EAEtB;AAwBA,EAAAA,YAAA,UAAA,OAAA,SAAQ,UAAyB;AAC/B,QAAMC,cAAa,IAAID,YAAU;AACjC,IAAAC,YAAW,SAAS;AACpB,IAAAA,YAAW,WAAW;AACtB,WAAOA;EACT;AA2IA,EAAAD,YAAA,UAAA,YAAA,SACE,gBACA,OACA,UAA8B;AAHhC,QAAA,QAAA;AAKE,QAAM,aAAa,aAAa,cAAc,IAAI,iBAAiB,IAAI,eAAe,gBAAgB,OAAO,QAAQ;AAErH,iBAAa,WAAA;AACL,UAAAE,MAAuB,OAArB,WAAQA,IAAA,UAAE,SAAMA,IAAA;AACxB,iBAAW,IACT,WAGI,SAAS,KAAK,YAAY,MAAM,IAChC,SAIA,MAAK,WAAW,UAAU,IAG1B,MAAK,cAAc,UAAU,CAAC;IAEtC,CAAC;AAED,WAAO;EACT;AAGU,EAAAF,YAAA,UAAA,gBAAV,SAAwB,MAAmB;AACzC,QAAI;AACF,aAAO,KAAK,WAAW,IAAI;aACpBG,MAAK;AAIZ,WAAK,MAAMA,IAAG;;EAElB;AA6DA,EAAAH,YAAA,UAAA,UAAA,SAAQ,MAA0B,aAAoC;AAAtE,QAAA,QAAA;AACE,kBAAc,eAAe,WAAW;AAExC,WAAO,IAAI,YAAkB,SAAC,SAAS,QAAM;AAC3C,UAAM,aAAa,IAAI,eAAkB;QACvC,MAAM,SAAC,OAAK;AACV,cAAI;AACF,iBAAK,KAAK;mBACHG,MAAK;AACZ,mBAAOA,IAAG;AACV,uBAAW,YAAW;;QAE1B;QACA,OAAO;QACP,UAAU;OACX;AACD,YAAK,UAAU,UAAU;IAC3B,CAAC;EACH;AAGU,EAAAH,YAAA,UAAA,aAAV,SAAqB,YAA2B;;AAC9C,YAAOE,MAAA,KAAK,YAAM,QAAAA,QAAA,SAAA,SAAAA,IAAE,UAAU,UAAU;EAC1C;AAMA,EAAAF,YAAA,UAAC,UAAiB,IAAlB,WAAA;AACE,WAAO;EACT;AA4FA,EAAAA,YAAA,UAAA,OAAA,WAAA;AAAK,QAAA,aAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAA2C;AAA3C,iBAAA,EAAA,IAAA,UAAA,EAAA;;AACH,WAAO,cAAc,UAAU,EAAE,IAAI;EACvC;AA4BA,EAAAA,YAAA,UAAA,YAAA,SAAU,aAAoC;AAA9C,QAAA,QAAA;AACE,kBAAc,eAAe,WAAW;AAExC,WAAO,IAAI,YAAY,SAAC,SAAS,QAAM;AACrC,UAAI;AACJ,YAAK,UACH,SAAC,GAAI;AAAK,eAAC,QAAQ;MAAT,GACV,SAACG,MAAQ;AAAK,eAAA,OAAOA,IAAG;MAAV,GACd,WAAA;AAAM,eAAA,QAAQ,KAAK;MAAb,CAAc;IAExB,CAAC;EACH;AAraO,EAAAH,YAAA,SAAkC,SAAI,WAAwD;AACnG,WAAO,IAAIA,YAAc,SAAS;EACpC;AAoaF,SAAAA;EArcA;AA8cA,SAAS,eAAe,aAA+C;;AACrE,UAAOI,MAAA,gBAAW,QAAX,gBAAW,SAAX,cAAe,OAAO,aAAO,QAAAA,QAAA,SAAAA,MAAI;AAC1C;AAEA,SAAS,WAAc,OAAU;AAC/B,SAAO,SAAS,WAAW,MAAM,IAAI,KAAK,WAAW,MAAM,KAAK,KAAK,WAAW,MAAM,QAAQ;AAChG;AAEA,SAAS,aAAgB,OAAU;AACjC,SAAQ,SAAS,iBAAiB,cAAgB,WAAW,KAAK,KAAK,eAAe,KAAK;AAC7F;;;AC9dM,SAAU,QAAQ,QAAW;AACjC,SAAO,WAAW,WAAM,QAAN,WAAM,SAAA,SAAN,OAAQ,IAAI;AAChC;AAMM,SAAU,QACd,MAAqF;AAErF,SAAO,SAAC,QAAqB;AAC3B,QAAI,QAAQ,MAAM,GAAG;AACnB,aAAO,OAAO,KAAK,SAA+B,cAA2B;AAC3E,YAAI;AACF,iBAAO,KAAK,cAAc,IAAI;iBACvBC,MAAK;AACZ,eAAK,MAAMA,IAAG;;MAElB,CAAC;;AAEH,UAAM,IAAI,UAAU,wCAAwC;EAC9D;AACF;;;ACjBM,SAAU,yBACd,aACA,QACA,YACA,SACA,YAAuB;AAEvB,SAAO,IAAI,mBAAmB,aAAa,QAAQ,YAAY,SAAS,UAAU;AACpF;AAMA,IAAA,qBAAA,SAAA,QAAA;AAA2C,YAAAC,qBAAA,MAAA;AAiBzC,WAAAA,oBACE,aACA,QACA,YACA,SACQ,YACA,mBAAiC;AAN3C,QAAA,QAoBE,OAAA,KAAA,MAAM,WAAW,KAAC;AAfV,UAAA,aAAA;AACA,UAAA,oBAAA;AAeR,UAAK,QAAQ,SACT,SAAuC,OAAQ;AAC7C,UAAI;AACF,eAAO,KAAK;eACLC,MAAK;AACZ,oBAAY,MAAMA,IAAG;;IAEzB,IACA,OAAA,UAAM;AACV,UAAK,SAAS,UACV,SAAuCA,MAAQ;AAC7C,UAAI;AACF,gBAAQA,IAAG;eACJA,MAAK;AAEZ,oBAAY,MAAMA,IAAG;;AAGrB,aAAK,YAAW;;IAEpB,IACA,OAAA,UAAM;AACV,UAAK,YAAY,aACb,WAAA;AACE,UAAI;AACF,mBAAU;eACHA,MAAK;AAEZ,oBAAY,MAAMA,IAAG;;AAGrB,aAAK,YAAW;;IAEpB,IACA,OAAA,UAAM;;EACZ;AAEA,EAAAD,oBAAA,UAAA,cAAA,WAAA;;AACE,QAAI,CAAC,KAAK,qBAAqB,KAAK,kBAAiB,GAAI;AAC/C,UAAA,WAAW,KAAI;AACvB,aAAA,UAAM,YAAW,KAAA,IAAA;AAEjB,OAAC,cAAUE,MAAA,KAAK,gBAAU,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAAf,IAAI;;EAEnB;AACF,SAAAF;AAAA,EAnF2C,UAAU;;;ACoC/C,SAAU,WAAQ;AACtB,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,QAAI,aAAkC;AAErC,WAAe;AAEhB,QAAM,aAAa,yBAAyB,YAAY,QAAW,QAAW,QAAW,WAAA;AACvF,UAAI,CAAC,UAAW,OAAe,aAAa,KAAK,IAAI,EAAG,OAAe,WAAW;AAChF,qBAAa;AACb;;AA4BF,UAAM,mBAAoB,OAAe;AACzC,UAAM,OAAO;AACb,mBAAa;AAEb,UAAI,qBAAqB,CAAC,QAAQ,qBAAqB,OAAO;AAC5D,yBAAiB,YAAW;;AAG9B,iBAAW,YAAW;IACxB,CAAC;AAED,WAAO,UAAU,UAAU;AAE3B,QAAI,CAAC,WAAW,QAAQ;AACtB,mBAAc,OAAoC,QAAO;;EAE7D,CAAC;AACH;;;ACvGA,IAAA,wBAAA,SAAA,QAAA;AAA8C,YAAAG,wBAAA,MAAA;AAgB5C,WAAAA,uBAAmB,QAAiC,gBAAgC;AAApF,QAAA,QACE,OAAA,KAAA,IAAA,KAAO;AADU,UAAA,SAAA;AAAiC,UAAA,iBAAA;AAf1C,UAAA,WAA8B;AAC9B,UAAA,YAAoB;AACpB,UAAA,cAAmC;AAkB3C,QAAI,QAAQ,MAAM,GAAG;AACnB,YAAK,OAAO,OAAO;;;EAEvB;AAGU,EAAAA,uBAAA,UAAA,aAAV,SAAqB,YAAyB;AAC5C,WAAO,KAAK,WAAU,EAAG,UAAU,UAAU;EAC/C;AAEU,EAAAA,uBAAA,UAAA,aAAV,WAAA;AACE,QAAM,UAAU,KAAK;AACrB,QAAI,CAAC,WAAW,QAAQ,WAAW;AACjC,WAAK,WAAW,KAAK,eAAc;;AAErC,WAAO,KAAK;EACd;AAEU,EAAAA,uBAAA,UAAA,YAAV,WAAA;AACE,SAAK,YAAY;AACT,QAAA,cAAgB,KAAI;AAC5B,SAAK,WAAW,KAAK,cAAc;AACnC,oBAAW,QAAX,gBAAW,SAAA,SAAX,YAAa,YAAW;EAC1B;AAMA,EAAAA,uBAAA,UAAA,UAAA,WAAA;AAAA,QAAA,QAAA;AACE,QAAI,aAAa,KAAK;AACtB,QAAI,CAAC,YAAY;AACf,mBAAa,KAAK,cAAc,IAAI,aAAY;AAChD,UAAM,YAAU,KAAK,WAAU;AAC/B,iBAAW,IACT,KAAK,OAAO,UACV,yBACE,WACA,QACA,WAAA;AACE,cAAK,UAAS;AACd,kBAAQ,SAAQ;MAClB,GACA,SAACC,MAAG;AACF,cAAK,UAAS;AACd,kBAAQ,MAAMA,IAAG;MACnB,GACA,WAAA;AAAM,eAAA,MAAK,UAAS;MAAd,CAAgB,CACvB,CACF;AAGH,UAAI,WAAW,QAAQ;AACrB,aAAK,cAAc;AACnB,qBAAa,aAAa;;;AAG9B,WAAO;EACT;AAMA,EAAAD,uBAAA,UAAA,WAAA,WAAA;AACE,WAAO,SAAmB,EAAG,IAAI;EACnC;AACF,SAAAA;AAAA,EAxF8C,UAAU;;;ACTjD,IAAM,+BAA6D;EACxE,KAAG,WAAA;AAGD,YAAQ,6BAA6B,YAAY,aAAa,IAAG;EACnE;EACA,UAAU;;;;ACEL,IAAM,yBAAiD;EAG5D,UAAA,SAAS,UAAQ;AACf,QAAI,UAAU;AACd,QAAI,SAAkD;AAC9C,QAAA,WAAa,uBAAsB;AAC3C,QAAI,UAAU;AACZ,gBAAU,SAAS;AACnB,eAAS,SAAS;;AAEpB,QAAM,SAAS,QAAQ,SAACE,YAAS;AAI/B,eAAS;AACT,eAASA,UAAS;IACpB,CAAC;AACD,WAAO,IAAI,aAAa,WAAA;AAAM,aAAA,WAAM,QAAN,WAAM,SAAA,SAAN,OAAS,MAAM;IAAf,CAAgB;EAChD;EACA,uBAAqB,WAAA;AAAC,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAO;AAAP,WAAA,EAAA,IAAA,UAAA,EAAA;;AACZ,QAAA,WAAa,uBAAsB;AAC3C,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,0BAAyB,uBAAsB,MAAA,QAAA,cAAA,CAAA,GAAA,OAAI,IAAI,CAAA,CAAA;EAC3E;EACA,sBAAoB,WAAA;AAAC,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAO;AAAP,WAAA,EAAA,IAAA,UAAA,EAAA;;AACX,QAAA,WAAa,uBAAsB;AAC3C,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,yBAAwB,sBAAqB,MAAA,QAAA,cAAA,CAAA,GAAA,OAAI,IAAI,CAAA,CAAA;EACzE;EACA,UAAU;;;;ACwCZ,SAAS,uBAAuB,mBAAqC;AACnE,SAAO,IAAI,WAAmD,SAAC,YAAU;AAIvE,QAAM,WAAW,qBAAqB;AAMtC,QAAM,QAAQ,SAAS,IAAG;AAE1B,QAAI,KAAK;AACT,QAAM,MAAM,WAAA;AACV,UAAI,CAAC,WAAW,QAAQ;AACtB,aAAK,uBAAuB,sBAAsB,SAACC,YAAuC;AACxF,eAAK;AAQL,cAAM,MAAM,SAAS,IAAG;AACxB,qBAAW,KAAK;YACd,WAAW,oBAAoB,MAAMA;YACrC,SAAS,MAAM;WAChB;AACD,cAAG;QACL,CAAC;;IAEL;AAEA,QAAG;AAEH,WAAO,WAAA;AACL,UAAI,IAAI;AACN,+BAAuB,qBAAqB,EAAE;;IAElD;EACF,CAAC;AACH;AAMA,IAAM,2BAA2B,uBAAsB;;;AC9GhD,IAAM,0BAAuD,iBAClE,SAAC,QAAM;AACL,SAAA,SAAS,8BAA2B;AAClC,WAAO,IAAI;AACX,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AAJA,CAIC;;;ACXL,IAAA,UAAA,SAAA,QAAA;AAAgC,YAAAC,UAAA,MAAA;AAuB9B,WAAAA,WAAA;AAAA,QAAA,QAEE,OAAA,KAAA,IAAA,KAAO;AAxBT,UAAA,SAAS;AAED,UAAA,mBAAyC;AAGjD,UAAA,YAA2B,CAAA;AAE3B,UAAA,YAAY;AAEZ,UAAA,WAAW;AAEX,UAAA,cAAmB;;EAcnB;AAGA,EAAAA,SAAA,UAAA,OAAA,SAAQ,UAAwB;AAC9B,QAAM,UAAU,IAAI,iBAAiB,MAAM,IAAI;AAC/C,YAAQ,WAAW;AACnB,WAAO;EACT;AAGU,EAAAA,SAAA,UAAA,iBAAV,WAAA;AACE,QAAI,KAAK,QAAQ;AACf,YAAM,IAAI,wBAAuB;;EAErC;AAEA,EAAAA,SAAA,UAAA,OAAA,SAAK,OAAQ;AAAb,QAAA,QAAA;AACE,iBAAa,WAAA;;AACX,YAAK,eAAc;AACnB,UAAI,CAAC,MAAK,WAAW;AACnB,YAAI,CAAC,MAAK,kBAAkB;AAC1B,gBAAK,mBAAmB,MAAM,KAAK,MAAK,SAAS;;;AAEnD,mBAAuB,KAAA,SAAA,MAAK,gBAAgB,GAAA,KAAA,GAAA,KAAA,GAAA,CAAA,GAAA,MAAA,KAAA,GAAA,KAAA,GAAE;AAAzC,gBAAM,WAAQ,GAAA;AACjB,qBAAS,KAAK,KAAK;;;;;;;;;;;;IAGzB,CAAC;EACH;AAEA,EAAAA,SAAA,UAAA,QAAA,SAAMC,MAAQ;AAAd,QAAA,QAAA;AACE,iBAAa,WAAA;AACX,YAAK,eAAc;AACnB,UAAI,CAAC,MAAK,WAAW;AACnB,cAAK,WAAW,MAAK,YAAY;AACjC,cAAK,cAAcA;AACX,YAAA,YAAc,MAAI;AAC1B,eAAO,UAAU,QAAQ;AACvB,oBAAU,MAAK,EAAI,MAAMA,IAAG;;;IAGlC,CAAC;EACH;AAEA,EAAAD,SAAA,UAAA,WAAA,WAAA;AAAA,QAAA,QAAA;AACE,iBAAa,WAAA;AACX,YAAK,eAAc;AACnB,UAAI,CAAC,MAAK,WAAW;AACnB,cAAK,YAAY;AACT,YAAA,YAAc,MAAI;AAC1B,eAAO,UAAU,QAAQ;AACvB,oBAAU,MAAK,EAAI,SAAQ;;;IAGjC,CAAC;EACH;AAEA,EAAAA,SAAA,UAAA,cAAA,WAAA;AACE,SAAK,YAAY,KAAK,SAAS;AAC/B,SAAK,YAAY,KAAK,mBAAmB;EAC3C;AAEA,SAAA,eAAIA,SAAA,WAAA,YAAQ;SAAZ,WAAA;;AACE,eAAOE,MAAA,KAAK,eAAS,QAAAA,QAAA,SAAA,SAAAA,IAAE,UAAS;IAClC;;;;AAGU,EAAAF,SAAA,UAAA,gBAAV,SAAwB,YAAyB;AAC/C,SAAK,eAAc;AACnB,WAAO,OAAA,UAAM,cAAa,KAAA,MAAC,UAAU;EACvC;AAGU,EAAAA,SAAA,UAAA,aAAV,SAAqB,YAAyB;AAC5C,SAAK,eAAc;AACnB,SAAK,wBAAwB,UAAU;AACvC,WAAO,KAAK,gBAAgB,UAAU;EACxC;AAGU,EAAAA,SAAA,UAAA,kBAAV,SAA0B,YAA2B;AAArD,QAAA,QAAA;AACQ,QAAAE,MAAqC,MAAnC,WAAQA,IAAA,UAAE,YAASA,IAAA,WAAE,YAASA,IAAA;AACtC,QAAI,YAAY,WAAW;AACzB,aAAO;;AAET,SAAK,mBAAmB;AACxB,cAAU,KAAK,UAAU;AACzB,WAAO,IAAI,aAAa,WAAA;AACtB,YAAK,mBAAmB;AACxB,gBAAU,WAAW,UAAU;IACjC,CAAC;EACH;AAGU,EAAAF,SAAA,UAAA,0BAAV,SAAkC,YAA2B;AACrD,QAAAE,MAAuC,MAArC,WAAQA,IAAA,UAAE,cAAWA,IAAA,aAAE,YAASA,IAAA;AACxC,QAAI,UAAU;AACZ,iBAAW,MAAM,WAAW;eACnB,WAAW;AACpB,iBAAW,SAAQ;;EAEvB;AAQA,EAAAF,SAAA,UAAA,eAAA,WAAA;AACE,QAAMG,cAAkB,IAAI,WAAU;AACtC,IAAAA,YAAW,SAAS;AACpB,WAAOA;EACT;AAxHO,EAAAH,SAAA,SAAkC,SAAI,aAA0B,QAAqB;AAC1F,WAAO,IAAI,iBAAoB,aAAa,MAAM;EACpD;AAuHF,SAAAA;EA5IgC,UAAU;AA8I1C,IAAA,mBAAA,SAAA,QAAA;AAAyC,YAAAI,mBAAA,MAAA;AACvC,WAAAA,kBAES,aACP,QAAsB;AAHxB,QAAA,QAKE,OAAA,KAAA,IAAA,KAAO;AAHA,UAAA,cAAA;AAIP,UAAK,SAAS;;EAChB;AAEA,EAAAA,kBAAA,UAAA,OAAA,SAAK,OAAQ;;AACX,KAAA,MAAAC,MAAA,KAAK,iBAAW,QAAAA,QAAA,SAAA,SAAAA,IAAE,UAAI,QAAA,OAAA,SAAA,SAAA,GAAA,KAAAA,KAAG,KAAK;EAChC;AAEA,EAAAD,kBAAA,UAAA,QAAA,SAAME,MAAQ;;AACZ,KAAA,MAAAD,MAAA,KAAK,iBAAW,QAAAA,QAAA,SAAA,SAAAA,IAAE,WAAK,QAAA,OAAA,SAAA,SAAA,GAAA,KAAAA,KAAGC,IAAG;EAC/B;AAEA,EAAAF,kBAAA,UAAA,WAAA,WAAA;;AACE,KAAA,MAAAC,MAAA,KAAK,iBAAW,QAAAA,QAAA,SAAA,SAAAA,IAAE,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAA,KAAAA,GAAA;EAC5B;AAGU,EAAAD,kBAAA,UAAA,aAAV,SAAqB,YAAyB;;AAC5C,YAAO,MAAAC,MAAA,KAAK,YAAM,QAAAA,QAAA,SAAA,SAAAA,IAAE,UAAU,UAAU,OAAC,QAAA,OAAA,SAAA,KAAI;EAC/C;AACF,SAAAD;AAAA,EA1ByC,OAAO;;;ACtJhD,IAAA,kBAAA,SAAA,QAAA;AAAwC,YAAAG,kBAAA,MAAA;AACtC,WAAAA,iBAAoB,QAAS;AAA7B,QAAA,QACE,OAAA,KAAA,IAAA,KAAO;AADW,UAAA,SAAA;;EAEpB;AAEA,SAAA,eAAIA,iBAAA,WAAA,SAAK;SAAT,WAAA;AACE,aAAO,KAAK,SAAQ;IACtB;;;;AAGU,EAAAA,iBAAA,UAAA,aAAV,SAAqB,YAAyB;AAC5C,QAAM,eAAe,OAAA,UAAM,WAAU,KAAA,MAAC,UAAU;AAChD,KAAC,aAAa,UAAU,WAAW,KAAK,KAAK,MAAM;AACnD,WAAO;EACT;AAEA,EAAAA,iBAAA,UAAA,WAAA,WAAA;AACQ,QAAAC,MAAoC,MAAlC,WAAQA,IAAA,UAAE,cAAWA,IAAA,aAAE,SAAMA,IAAA;AACrC,QAAI,UAAU;AACZ,YAAM;;AAER,SAAK,eAAc;AACnB,WAAO;EACT;AAEA,EAAAD,iBAAA,UAAA,OAAA,SAAK,OAAQ;AACX,WAAA,UAAM,KAAI,KAAA,MAAE,KAAK,SAAS,KAAM;EAClC;AACF,SAAAA;AAAA,EA5BwC,OAAO;;;ACFxC,IAAM,wBAA+C;EAC1D,KAAG,WAAA;AAGD,YAAQ,sBAAsB,YAAY,MAAM,IAAG;EACrD;EACA,UAAU;;;;ACwBZ,IAAA,gBAAA,SAAA,QAAA;AAAsC,YAAAE,gBAAA,MAAA;AAUpC,WAAAA,eACU,aACA,aACA,oBAA6D;AAF7D,QAAA,gBAAA,QAAA;AAAA,oBAAA;IAAsB;AACtB,QAAA,gBAAA,QAAA;AAAA,oBAAA;IAAsB;AACtB,QAAA,uBAAA,QAAA;AAAA,2BAAA;IAA6D;AAHvE,QAAA,QAKE,OAAA,KAAA,IAAA,KAAO;AAJC,UAAA,cAAA;AACA,UAAA,cAAA;AACA,UAAA,qBAAA;AAZF,UAAA,UAA0B,CAAA;AAC1B,UAAA,sBAAsB;AAc5B,UAAK,sBAAsB,gBAAgB;AAC3C,UAAK,cAAc,KAAK,IAAI,GAAG,WAAW;AAC1C,UAAK,cAAc,KAAK,IAAI,GAAG,WAAW;;EAC5C;AAEA,EAAAA,eAAA,UAAA,OAAA,SAAK,OAAQ;AACL,QAAAC,MAA+E,MAA7E,YAASA,IAAA,WAAE,UAAOA,IAAA,SAAE,sBAAmBA,IAAA,qBAAE,qBAAkBA,IAAA,oBAAE,cAAWA,IAAA;AAChF,QAAI,CAAC,WAAW;AACd,cAAQ,KAAK,KAAK;AAClB,OAAC,uBAAuB,QAAQ,KAAK,mBAAmB,IAAG,IAAK,WAAW;;AAE7E,SAAK,YAAW;AAChB,WAAA,UAAM,KAAI,KAAA,MAAC,KAAK;EAClB;AAGU,EAAAD,eAAA,UAAA,aAAV,SAAqB,YAAyB;AAC5C,SAAK,eAAc;AACnB,SAAK,YAAW;AAEhB,QAAM,eAAe,KAAK,gBAAgB,UAAU;AAE9C,QAAAC,MAAmC,MAAjC,sBAAmBA,IAAA,qBAAE,UAAOA,IAAA;AAGpC,QAAM,OAAO,QAAQ,MAAK;AAC1B,aAAS,IAAI,GAAG,IAAI,KAAK,UAAU,CAAC,WAAW,QAAQ,KAAK,sBAAsB,IAAI,GAAG;AACvF,iBAAW,KAAK,KAAK,CAAC,CAAM;;AAG9B,SAAK,wBAAwB,UAAU;AAEvC,WAAO;EACT;AAEQ,EAAAD,eAAA,UAAA,cAAR,WAAA;AACQ,QAAAC,MAAoE,MAAlE,cAAWA,IAAA,aAAE,qBAAkBA,IAAA,oBAAE,UAAOA,IAAA,SAAE,sBAAmBA,IAAA;AAKrE,QAAM,sBAAsB,sBAAsB,IAAI,KAAK;AAC3D,kBAAc,YAAY,qBAAqB,QAAQ,UAAU,QAAQ,OAAO,GAAG,QAAQ,SAAS,kBAAkB;AAItH,QAAI,CAAC,qBAAqB;AACxB,UAAM,MAAM,mBAAmB,IAAG;AAClC,UAAIC,QAAO;AAGX,eAAS,IAAI,GAAG,IAAI,QAAQ,UAAW,QAAQ,CAAC,KAAgB,KAAK,KAAK,GAAG;AAC3E,QAAAA,QAAO;;AAET,MAAAA,SAAQ,QAAQ,OAAO,GAAGA,QAAO,CAAC;;EAEtC;AACF,SAAAF;AAAA,EAzEsC,OAAO;;;AC7B7C,IAAA,eAAA,SAAA,QAAA;AAAqC,YAAAG,eAAA,MAAA;AAArC,WAAAA,gBAAA;AAAA,QAAA,QAAA,WAAA,QAAA,OAAA,MAAA,MAAA,SAAA,KAAA;AACU,UAAA,SAAmB;AACnB,UAAA,YAAY;AACZ,UAAA,cAAc;;EA4BxB;AAzBY,EAAAA,cAAA,UAAA,0BAAV,SAAkC,YAAyB;AACnD,QAAAC,MAAuE,MAArE,WAAQA,IAAA,UAAE,YAASA,IAAA,WAAE,SAAMA,IAAA,QAAE,cAAWA,IAAA,aAAE,YAASA,IAAA,WAAE,cAAWA,IAAA;AACxE,QAAI,UAAU;AACZ,iBAAW,MAAM,WAAW;eACnB,aAAa,aAAa;AACnC,mBAAa,WAAW,KAAK,MAAO;AACpC,iBAAW,SAAQ;;EAEvB;AAEA,EAAAD,cAAA,UAAA,OAAA,SAAK,OAAQ;AACX,QAAI,CAAC,KAAK,WAAW;AACnB,WAAK,SAAS;AACd,WAAK,YAAY;;EAErB;AAEA,EAAAA,cAAA,UAAA,WAAA,WAAA;AACQ,QAAAC,MAAqC,MAAnC,YAASA,IAAA,WAAE,SAAMA,IAAA,QAAE,cAAWA,IAAA;AACtC,QAAI,CAAC,aAAa;AAChB,WAAK,cAAc;AACnB,mBAAa,OAAA,UAAM,KAAI,KAAA,MAAC,MAAO;AAC/B,aAAA,UAAM,SAAQ,KAAA,IAAA;;EAElB;AACF,SAAAD;AAAA,EA/BqC,OAAO;;;ACS5C,IAAA,SAAA,SAAA,QAAA;AAA+B,YAAAE,SAAA,MAAA;AAC7B,WAAAA,QAAY,WAAsB,MAAmD;WACnF,OAAA,KAAA,IAAA,KAAO;EACT;AAWO,EAAAA,QAAA,UAAA,WAAP,SAAgB,OAAWC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAC1C,WAAO;EACT;AACF,SAAAD;AAAA,EAjB+B,YAAY;;;ACDpC,IAAM,mBAAqC;EAGhD,aAAA,SAAY,SAAqBE,UAAgB;AAAE,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAO;AAAP,WAAA,KAAA,CAAA,IAAA,UAAA,EAAA;;AACzC,QAAA,WAAa,iBAAgB;AACrC,QAAI,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,aAAa;AACzB,aAAO,SAAS,YAAW,MAApB,UAAQ,cAAA,CAAa,SAASA,QAAO,GAAA,OAAK,IAAI,CAAA,CAAA;;AAEvD,WAAO,YAAW,MAAA,QAAA,cAAA,CAAC,SAASA,QAAO,GAAA,OAAK,IAAI,CAAA,CAAA;EAC9C;EACA,eAAA,SAAc,QAAM;AACV,QAAA,WAAa,iBAAgB;AACrC,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,kBAAiB,eAAe,MAAa;EACjE;EACA,UAAU;;;;ACrBZ,IAAA,cAAA,SAAA,QAAA;AAAoC,YAAAC,cAAA,MAAA;AAOlC,WAAAA,aAAsB,WAAqC,MAAmD;AAA9G,QAAA,QACE,OAAA,KAAA,MAAM,WAAW,IAAI,KAAC;AADF,UAAA,YAAA;AAAqC,UAAA,OAAA;AAFjD,UAAA,UAAmB;;EAI7B;AAEO,EAAAA,aAAA,UAAA,WAAP,SAAgB,OAAWC,QAAiB;;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAC1C,QAAI,KAAK,QAAQ;AACf,aAAO;;AAIT,SAAK,QAAQ;AAEb,QAAM,KAAK,KAAK;AAChB,QAAM,YAAY,KAAK;AAuBvB,QAAI,MAAM,MAAM;AACd,WAAK,KAAK,KAAK,eAAe,WAAW,IAAIA,MAAK;;AAKpD,SAAK,UAAU;AAEf,SAAK,QAAQA;AAEb,SAAK,MAAKC,MAAA,KAAK,QAAE,QAAAA,QAAA,SAAAA,MAAI,KAAK,eAAe,WAAW,KAAK,IAAID,MAAK;AAElE,WAAO;EACT;AAEU,EAAAD,aAAA,UAAA,iBAAV,SAAyB,WAA2B,KAAmBC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AACtF,WAAO,iBAAiB,YAAY,UAAU,MAAM,KAAK,WAAW,IAAI,GAAGA,MAAK;EAClF;AAEU,EAAAD,aAAA,UAAA,iBAAV,SAAyB,YAA4B,IAAkBC,QAAwB;AAAxB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAwB;AAE7F,QAAIA,UAAS,QAAQ,KAAK,UAAUA,UAAS,KAAK,YAAY,OAAO;AACnE,aAAO;;AAIT,QAAI,MAAM,MAAM;AACd,uBAAiB,cAAc,EAAE;;AAGnC,WAAO;EACT;AAKO,EAAAD,aAAA,UAAA,UAAP,SAAe,OAAUC,QAAa;AACpC,QAAI,KAAK,QAAQ;AACf,aAAO,IAAI,MAAM,8BAA8B;;AAGjD,SAAK,UAAU;AACf,QAAM,QAAQ,KAAK,SAAS,OAAOA,MAAK;AACxC,QAAI,OAAO;AACT,aAAO;eACE,KAAK,YAAY,SAAS,KAAK,MAAM,MAAM;AAcpD,WAAK,KAAK,KAAK,eAAe,KAAK,WAAW,KAAK,IAAI,IAAI;;EAE/D;AAEU,EAAAD,aAAA,UAAA,WAAV,SAAmB,OAAU,QAAc;AACzC,QAAI,UAAmB;AACvB,QAAI;AACJ,QAAI;AACF,WAAK,KAAK,KAAK;aACR,GAAG;AACV,gBAAU;AAIV,mBAAa,IAAI,IAAI,IAAI,MAAM,oCAAoC;;AAErE,QAAI,SAAS;AACX,WAAK,YAAW;AAChB,aAAO;;EAEX;AAEA,EAAAA,aAAA,UAAA,cAAA,WAAA;AACE,QAAI,CAAC,KAAK,QAAQ;AACV,UAAAE,MAAoB,MAAlB,KAAEA,IAAA,IAAE,YAASA,IAAA;AACb,UAAA,UAAY,UAAS;AAE7B,WAAK,OAAO,KAAK,QAAQ,KAAK,YAAY;AAC1C,WAAK,UAAU;AAEf,gBAAU,SAAS,IAAI;AACvB,UAAI,MAAM,MAAM;AACd,aAAK,KAAK,KAAK,eAAe,WAAW,IAAI,IAAI;;AAGnD,WAAK,QAAQ;AACb,aAAA,UAAM,YAAW,KAAA,IAAA;;EAErB;AACF,SAAAF;AAAA,EA7IoC,MAAM;;;ACR1C,IAAI,aAAa;AAEjB,IAAI;AACJ,IAAM,gBAAwC,CAAA;AAO9C,SAAS,mBAAmB,QAAc;AACxC,MAAI,UAAU,eAAe;AAC3B,WAAO,cAAc,MAAM;AAC3B,WAAO;;AAET,SAAO;AACT;AAKO,IAAM,YAAY;EACvB,cAAA,SAAa,IAAc;AACzB,QAAM,SAAS;AACf,kBAAc,MAAM,IAAI;AACxB,QAAI,CAAC,UAAU;AACb,iBAAW,QAAQ,QAAO;;AAE5B,aAAS,KAAK,WAAA;AAAM,aAAA,mBAAmB,MAAM,KAAK,GAAE;IAAhC,CAAkC;AACtD,WAAO;EACT;EAEA,gBAAA,SAAe,QAAc;AAC3B,uBAAmB,MAAM;EAC3B;;;;AChCM,IAAA,eAAiC,UAAS;AAA1C,IAAc,iBAAmB,UAAS;AAgB3C,IAAM,oBAAuC;EAGlD,cAAY,WAAA;AAAC,QAAA,OAAA,CAAA;aAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAO;AAAP,WAAA,EAAA,IAAA,UAAA,EAAA;;AACH,QAAA,WAAa,kBAAiB;AACtC,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,iBAAgB,cAAa,MAAA,QAAA,cAAA,CAAA,GAAA,OAAI,IAAI,CAAA,CAAA;EACzD;EACA,gBAAA,SAAe,QAAM;AACX,QAAA,WAAa,kBAAiB;AACtC,aAAQ,aAAQ,QAAR,aAAQ,SAAA,SAAR,SAAU,mBAAkB,gBAAgB,MAAa;EACnE;EACA,UAAU;;;;ACvBZ,IAAA,aAAA,SAAA,QAAA;AAAmC,YAAAG,aAAA,MAAA;AACjC,WAAAA,YAAsB,WAAoC,MAAmD;AAA7G,QAAA,QACE,OAAA,KAAA,MAAM,WAAW,IAAI,KAAC;AADF,UAAA,YAAA;AAAoC,UAAA,OAAA;;EAE1D;AAEU,EAAAA,YAAA,UAAA,iBAAV,SAAyB,WAA0B,IAAkBC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAEpF,QAAIA,WAAU,QAAQA,SAAQ,GAAG;AAC/B,aAAO,OAAA,UAAM,eAAc,KAAA,MAAC,WAAW,IAAIA,MAAK;;AAGlD,cAAU,QAAQ,KAAK,IAAI;AAI3B,WAAO,UAAU,eAAe,UAAU,aAAa,kBAAkB,aAAa,UAAU,MAAM,KAAK,WAAW,MAAS,CAAC;EAClI;AAEU,EAAAD,YAAA,UAAA,iBAAV,SAAyB,WAA0B,IAAkBC,QAAiB;;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAIpF,QAAIA,UAAS,OAAOA,SAAQ,IAAI,KAAK,QAAQ,GAAG;AAC9C,aAAO,OAAA,UAAM,eAAc,KAAA,MAAC,WAAW,IAAIA,MAAK;;AAK1C,QAAA,UAAY,UAAS;AAC7B,QAAI,MAAM,UAAQC,MAAA,QAAQ,QAAQ,SAAS,CAAC,OAAC,QAAAA,QAAA,SAAA,SAAAA,IAAE,QAAO,IAAI;AACxD,wBAAkB,eAAe,EAAE;AACnC,UAAI,UAAU,eAAe,IAAI;AAC/B,kBAAU,aAAa;;;AAI3B,WAAO;EACT;AACF,SAAAF;AAAA,EAtCmC,WAAW;;;ACiB9C,IAAA,YAAA,WAAA;AAGE,WAAAG,WAAoB,qBAAoC,KAAiC;AAAjC,QAAA,QAAA,QAAA;AAAA,YAAoBA,WAAU;IAAG;AAArE,SAAA,sBAAA;AAClB,SAAK,MAAM;EACb;AA4BO,EAAAA,WAAA,UAAA,WAAP,SAAmB,MAAqDC,QAAmB,OAAS;AAA5B,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AACvF,WAAO,IAAI,KAAK,oBAAuB,MAAM,IAAI,EAAE,SAAS,OAAOA,MAAK;EAC1E;AAlCc,EAAAD,WAAA,MAAoB,sBAAsB;AAmC1D,SAAAA;EApCA;;;AClBA,IAAA,iBAAA,SAAA,QAAA;AAAoC,YAAAE,iBAAA,MAAA;AAgBlC,WAAAA,gBAAY,iBAAgC,KAAiC;AAAjC,QAAA,QAAA,QAAA;AAAA,YAAoB,UAAU;IAAG;AAA7E,QAAA,QACE,OAAA,KAAA,MAAM,iBAAiB,GAAG,KAAC;AAhBtB,UAAA,UAAmC,CAAA;AAMnC,UAAA,UAAmB;;EAW1B;AAEO,EAAAA,gBAAA,UAAA,QAAP,SAAa,QAAwB;AAC3B,QAAA,UAAY,KAAI;AAExB,QAAI,KAAK,SAAS;AAChB,cAAQ,KAAK,MAAM;AACnB;;AAGF,QAAI;AACJ,SAAK,UAAU;AAEf,OAAG;AACD,UAAK,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,KAAK,GAAI;AACxD;;aAEM,SAAS,QAAQ,MAAK;AAEhC,SAAK,UAAU;AAEf,QAAI,OAAO;AACT,aAAQ,SAAS,QAAQ,MAAK,GAAM;AAClC,eAAO,YAAW;;AAEpB,YAAM;;EAEV;AACF,SAAAA;AAAA,EA9CoC,SAAS;;;ACF7C,IAAA,gBAAA,SAAA,QAAA;AAAmC,YAAAC,gBAAA,MAAA;AAAnC,WAAAA,iBAAA;;EAkCA;AAjCS,EAAAA,eAAA,UAAA,QAAP,SAAa,QAAyB;AACpC,SAAK,UAAU;AAUf,QAAM,UAAU,KAAK;AACrB,SAAK,aAAa;AAEV,QAAA,UAAY,KAAI;AACxB,QAAI;AACJ,aAAS,UAAU,QAAQ,MAAK;AAEhC,OAAG;AACD,UAAK,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,KAAK,GAAI;AACxD;;cAEM,SAAS,QAAQ,CAAC,MAAM,OAAO,OAAO,WAAW,QAAQ,MAAK;AAExE,SAAK,UAAU;AAEf,QAAI,OAAO;AACT,cAAQ,SAAS,QAAQ,CAAC,MAAM,OAAO,OAAO,WAAW,QAAQ,MAAK,GAAI;AACxE,eAAO,YAAW;;AAEpB,YAAM;;EAEV;AACF,SAAAA;AAAA,EAlCmC,cAAc;;;ACmC1C,IAAM,gBAAgB,IAAI,cAAc,UAAU;;;ACYlD,IAAM,iBAAiB,IAAI,eAAe,WAAW;AAKrD,IAAM,QAAQ;;;ACjDrB,IAAA,cAAA,SAAA,QAAA;AAAoC,YAAAC,cAAA,MAAA;AAClC,WAAAA,aAAsB,WAAqC,MAAmD;AAA9G,QAAA,QACE,OAAA,KAAA,MAAM,WAAW,IAAI,KAAC;AADF,UAAA,YAAA;AAAqC,UAAA,OAAA;;EAE3D;AAEO,EAAAA,aAAA,UAAA,WAAP,SAAgB,OAAWC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAC1C,QAAIA,SAAQ,GAAG;AACb,aAAO,OAAA,UAAM,SAAQ,KAAA,MAAC,OAAOA,MAAK;;AAEpC,SAAK,QAAQA;AACb,SAAK,QAAQ;AACb,SAAK,UAAU,MAAM,IAAI;AACzB,WAAO;EACT;AAEO,EAAAD,aAAA,UAAA,UAAP,SAAe,OAAUC,QAAa;AACpC,WAAOA,SAAQ,KAAK,KAAK,SAAS,OAAA,UAAM,QAAO,KAAA,MAAC,OAAOA,MAAK,IAAI,KAAK,SAAS,OAAOA,MAAK;EAC5F;AAEU,EAAAD,aAAA,UAAA,iBAAV,SAAyB,WAA2B,IAAkBC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAKrF,QAAKA,UAAS,QAAQA,SAAQ,KAAOA,UAAS,QAAQ,KAAK,QAAQ,GAAI;AACrE,aAAO,OAAA,UAAM,eAAc,KAAA,MAAC,WAAW,IAAIA,MAAK;;AAIlD,cAAU,MAAM,IAAI;AAMpB,WAAO;EACT;AACF,SAAAD;AAAA,EArCoC,WAAW;;;ACJ/C,IAAA,iBAAA,SAAA,QAAA;AAAoC,YAAAE,iBAAA,MAAA;AAApC,WAAAA,kBAAA;;EACA;AAAA,SAAAA;AAAA,EADoC,cAAc;;;ACgE3C,IAAM,iBAAiB,IAAI,eAAe,WAAW;;;AC5D5D,IAAA,uBAAA,SAAA,QAAA;AAA6C,YAAAC,uBAAA,MAAA;AAC3C,WAAAA,sBAAsB,WAA8C,MAAmD;AAAvH,QAAA,QACE,OAAA,KAAA,MAAM,WAAW,IAAI,KAAC;AADF,UAAA,YAAA;AAA8C,UAAA,OAAA;;EAEpE;AAEU,EAAAA,sBAAA,UAAA,iBAAV,SAAyB,WAAoC,IAAkBC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAE9F,QAAIA,WAAU,QAAQA,SAAQ,GAAG;AAC/B,aAAO,OAAA,UAAM,eAAc,KAAA,MAAC,WAAW,IAAIA,MAAK;;AAGlD,cAAU,QAAQ,KAAK,IAAI;AAI3B,WAAO,UAAU,eAAe,UAAU,aAAa,uBAAuB,sBAAsB,WAAA;AAAM,aAAA,UAAU,MAAM,MAAS;IAAzB,CAA0B;EACtI;AAEU,EAAAD,sBAAA,UAAA,iBAAV,SAAyB,WAAoC,IAAkBC,QAAiB;;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAI9F,QAAIA,UAAS,OAAOA,SAAQ,IAAI,KAAK,QAAQ,GAAG;AAC9C,aAAO,OAAA,UAAM,eAAc,KAAA,MAAC,WAAW,IAAIA,MAAK;;AAK1C,QAAA,UAAY,UAAS;AAC7B,QAAI,MAAM,QAAQ,OAAO,UAAU,gBAAcC,MAAA,QAAQ,QAAQ,SAAS,CAAC,OAAC,QAAAA,QAAA,SAAA,SAAAA,IAAE,QAAO,IAAI;AACvF,6BAAuB,qBAAqB,EAAY;AACxD,gBAAU,aAAa;;AAGzB,WAAO;EACT;AACF,SAAAF;AAAA,EApC6C,WAAW;;;ACHxD,IAAA,0BAAA,SAAA,QAAA;AAA6C,YAAAG,0BAAA,MAAA;AAA7C,WAAAA,2BAAA;;EAuCA;AAtCS,EAAAA,yBAAA,UAAA,QAAP,SAAa,QAAyB;AACpC,SAAK,UAAU;AAUf,QAAI;AACJ,QAAI,QAAQ;AACV,gBAAU,OAAO;WACZ;AACL,gBAAU,KAAK;AACf,WAAK,aAAa;;AAGZ,QAAA,UAAY,KAAI;AACxB,QAAI;AACJ,aAAS,UAAU,QAAQ,MAAK;AAEhC,OAAG;AACD,UAAK,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,KAAK,GAAI;AACxD;;cAEM,SAAS,QAAQ,CAAC,MAAM,OAAO,OAAO,WAAW,QAAQ,MAAK;AAExE,SAAK,UAAU;AAEf,QAAI,OAAO;AACT,cAAQ,SAAS,QAAQ,CAAC,MAAM,OAAO,OAAO,WAAW,QAAQ,MAAK,GAAI;AACxE,eAAO,YAAW;;AAEpB,YAAM;;EAEV;AACF,SAAAA;AAAA,EAvC6C,cAAc;;;ACgCpD,IAAM,0BAA0B,IAAI,wBAAwB,oBAAoB;;;AC7BvF,IAAA,uBAAA,SAAA,QAAA;AAA0C,YAAAC,uBAAA,MAAA;AAyBxC,WAAAA,sBAAY,qBAAuE,WAA4B;AAAnG,QAAA,wBAAA,QAAA;AAAA,4BAA0C;IAAoB;AAAS,QAAA,cAAA,QAAA;AAAA,kBAAA;IAA4B;AAA/G,QAAA,QACE,OAAA,KAAA,MAAM,qBAAqB,WAAA;AAAM,aAAA,MAAK;IAAL,CAAU,KAAC;AADqC,UAAA,YAAA;AAf5E,UAAA,QAAgB;AAMhB,UAAA,QAAgB;;EAWvB;AAMO,EAAAA,sBAAA,UAAA,QAAP,WAAA;AACQ,QAAAC,MAAyB,MAAvB,UAAOA,IAAA,SAAE,YAASA,IAAA;AAC1B,QAAI;AACJ,QAAI;AAEJ,YAAQ,SAAS,QAAQ,CAAC,MAAM,OAAO,SAAS,WAAW;AACzD,cAAQ,MAAK;AACb,WAAK,QAAQ,OAAO;AAEpB,UAAK,QAAQ,OAAO,QAAQ,OAAO,OAAO,OAAO,KAAK,GAAI;AACxD;;;AAIJ,QAAI,OAAO;AACT,aAAQ,SAAS,QAAQ,MAAK,GAAK;AACjC,eAAO,YAAW;;AAEpB,YAAM;;EAEV;AAnDO,EAAAD,sBAAA,kBAAkB;AAoD3B,SAAAA;EAtD0C,cAAc;AAwDxD,IAAA,gBAAA,SAAA,QAAA;AAAsC,YAAAE,gBAAA,MAAA;AAGpC,WAAAA,eACY,WACA,MACA,OAAsC;AAAtC,QAAA,UAAA,QAAA;AAAA,cAAiB,UAAU,SAAS;IAAE;AAHlD,QAAA,QAKE,OAAA,KAAA,MAAM,WAAW,IAAI,KAAC;AAJZ,UAAA,YAAA;AACA,UAAA,OAAA;AACA,UAAA,QAAA;AALF,UAAA,SAAkB;AAQ1B,UAAK,QAAQ,UAAU,QAAQ;;EACjC;AAEO,EAAAA,eAAA,UAAA,WAAP,SAAgB,OAAWC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AAC1C,QAAI,OAAO,SAASA,MAAK,GAAG;AAC1B,UAAI,CAAC,KAAK,IAAI;AACZ,eAAO,OAAA,UAAM,SAAQ,KAAA,MAAC,OAAOA,MAAK;;AAEpC,WAAK,SAAS;AAKd,UAAM,SAAS,IAAID,eAAc,KAAK,WAAW,KAAK,IAAI;AAC1D,WAAK,IAAI,MAAM;AACf,aAAO,OAAO,SAAS,OAAOC,MAAK;WAC9B;AAGL,aAAO,aAAa;;EAExB;AAEU,EAAAD,eAAA,UAAA,iBAAV,SAAyB,WAAiC,IAAUC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AACnF,SAAK,QAAQ,UAAU,QAAQA;AACvB,QAAA,UAAY,UAAS;AAC7B,YAAQ,KAAK,IAAI;AAChB,YAAoC,KAAKD,eAAc,WAAW;AACnE,WAAO;EACT;AAEU,EAAAA,eAAA,UAAA,iBAAV,SAAyB,WAAiC,IAAUC,QAAiB;AAAjB,QAAAA,WAAA,QAAA;AAAA,MAAAA,SAAA;IAAiB;AACnF,WAAO;EACT;AAEU,EAAAD,eAAA,UAAA,WAAV,SAAmB,OAAUC,QAAa;AACxC,QAAI,KAAK,WAAW,MAAM;AACxB,aAAO,OAAA,UAAM,SAAQ,KAAA,MAAC,OAAOA,MAAK;;EAEtC;AAEe,EAAAD,eAAA,cAAf,SAA8B,GAAqB,GAAmB;AACpE,QAAI,EAAE,UAAU,EAAE,OAAO;AACvB,UAAI,EAAE,UAAU,EAAE,OAAO;AACvB,eAAO;iBACE,EAAE,QAAQ,EAAE,OAAO;AAC5B,eAAO;aACF;AACL,eAAO;;eAEA,EAAE,QAAQ,EAAE,OAAO;AAC5B,aAAO;WACF;AACL,aAAO;;EAEX;AACF,SAAAA;AAAA,EAjEsC,WAAW;;;ACG1C,IAAM,QAAQ,IAAI,WAAkB,SAAC,YAAU;AAAK,SAAA,WAAW,SAAQ;AAAnB,CAAqB;;;AC9D1E,SAAU,YAAY,OAAU;AACpC,SAAO,SAAS,WAAW,MAAM,QAAQ;AAC3C;;;ACDA,SAAS,KAAQ,KAAQ;AACvB,SAAO,IAAI,IAAI,SAAS,CAAC;AAC3B;AAMM,SAAU,aAAa,MAAW;AACtC,SAAO,YAAY,KAAK,IAAI,CAAC,IAAI,KAAK,IAAG,IAAK;AAChD;AAEM,SAAU,UAAU,MAAa,cAAoB;AACzD,SAAO,OAAO,KAAK,IAAI,MAAM,WAAW,KAAK,IAAG,IAAM;AACxD;;;AClBO,IAAM,cAAe,SAAI,GAAM;AAAwB,SAAA,KAAK,OAAO,EAAE,WAAW,YAAY,OAAO,MAAM;AAAlD;;;ACMxD,SAAU,UAAU,OAAU;AAClC,SAAO,WAAW,UAAK,QAAL,UAAK,SAAA,SAAL,MAAO,IAAI;AAC/B;;;ACHM,SAAU,oBAAoB,OAAU;AAC5C,SAAO,WAAW,MAAM,UAAiB,CAAC;AAC5C;;;ACLM,SAAU,gBAAmB,KAAQ;AACzC,SAAO,OAAO,iBAAiB,WAAW,QAAG,QAAH,QAAG,SAAA,SAAH,IAAM,OAAO,aAAa,CAAC;AACvE;;;ACAM,SAAU,iCAAiC,OAAU;AAEzD,SAAO,IAAI,UACT,mBACE,UAAU,QAAQ,OAAO,UAAU,WAAW,sBAAsB,MAAI,QAAK,OAAG,0HACwC;AAE9H;;;ACXM,SAAU,oBAAiB;AAC/B,MAAI,OAAO,WAAW,cAAc,CAAC,OAAO,UAAU;AACpD,WAAO;;AAGT,SAAO,OAAO;AAChB;AAEO,IAAM,WAAW,kBAAiB;;;ACJnC,SAAU,WAAW,OAAU;AACnC,SAAO,WAAW,UAAK,QAAL,UAAK,SAAA,SAAL,MAAQ,QAAe,CAAC;AAC5C;;;ACHM,SAAiB,mCAAsC,gBAAqC;;;;;;AAC1F,mBAAS,eAAe,UAAS;;;;;;oBAE1B,QAAA,CAAA,GAAA,CAAA;AACe,iBAAA,CAAA,GAAA,QAAM,OAAO,KAAI,CAAE,CAAA;;AAArC,UAAAE,MAAkB,GAAA,KAAA,GAAhB,QAAKA,IAAA,OAAE,OAAIA,IAAA;eACf,KAAA,QAAA,CAAA,GAAA,CAAA;;;AACF,iBAAA,CAAA,GAAA,GAAA,KAAA,CAAA;;6BAEI,KAAM,CAAA;;AAAZ,iBAAA,CAAA,GAAA,GAAA,KAAA,CAAA;;AAAA,aAAA,KAAA;;;;;AAGF,iBAAO,YAAW;;;;;;;;AAIhB,SAAU,qBAAwB,KAAQ;AAG9C,SAAO,WAAW,QAAG,QAAH,QAAG,SAAA,SAAH,IAAK,SAAS;AAClC;;;ACPM,SAAU,UAAa,OAAyB;AACpD,MAAI,iBAAiB,YAAY;AAC/B,WAAO;;AAET,MAAI,SAAS,MAAM;AACjB,QAAI,oBAAoB,KAAK,GAAG;AAC9B,aAAO,sBAAsB,KAAK;;AAEpC,QAAI,YAAY,KAAK,GAAG;AACtB,aAAO,cAAc,KAAK;;AAE5B,QAAI,UAAU,KAAK,GAAG;AACpB,aAAO,YAAY,KAAK;;AAE1B,QAAI,gBAAgB,KAAK,GAAG;AAC1B,aAAO,kBAAkB,KAAK;;AAEhC,QAAI,WAAW,KAAK,GAAG;AACrB,aAAO,aAAa,KAAK;;AAE3B,QAAI,qBAAqB,KAAK,GAAG;AAC/B,aAAO,uBAAuB,KAAK;;;AAIvC,QAAM,iCAAiC,KAAK;AAC9C;AAMM,SAAU,sBAAyB,KAAQ;AAC/C,SAAO,IAAI,WAAW,SAAC,YAAyB;AAC9C,QAAM,MAAM,IAAI,UAAiB,EAAC;AAClC,QAAI,WAAW,IAAI,SAAS,GAAG;AAC7B,aAAO,IAAI,UAAU,UAAU;;AAGjC,UAAM,IAAI,UAAU,gEAAgE;EACtF,CAAC;AACH;AASM,SAAU,cAAiBC,QAAmB;AAClD,SAAO,IAAI,WAAW,SAAC,YAAyB;AAU9C,aAAS,IAAI,GAAG,IAAIA,OAAM,UAAU,CAAC,WAAW,QAAQ,KAAK;AAC3D,iBAAW,KAAKA,OAAM,CAAC,CAAC;;AAE1B,eAAW,SAAQ;EACrB,CAAC;AACH;AAEM,SAAU,YAAe,SAAuB;AACpD,SAAO,IAAI,WAAW,SAAC,YAAyB;AAC9C,YACG,KACC,SAAC,OAAK;AACJ,UAAI,CAAC,WAAW,QAAQ;AACtB,mBAAW,KAAK,KAAK;AACrB,mBAAW,SAAQ;;IAEvB,GACA,SAACC,MAAQ;AAAK,aAAA,WAAW,MAAMA,IAAG;IAApB,CAAqB,EAEpC,KAAK,MAAM,oBAAoB;EACpC,CAAC;AACH;AAEM,SAAU,aAAgB,UAAqB;AACnD,SAAO,IAAI,WAAW,SAAC,YAAyB;;;AAC9C,eAAoB,aAAA,SAAA,QAAQ,GAAA,eAAA,WAAA,KAAA,GAAA,CAAA,aAAA,MAAA,eAAA,WAAA,KAAA,GAAE;AAAzB,YAAM,QAAK,aAAA;AACd,mBAAW,KAAK,KAAK;AACrB,YAAI,WAAW,QAAQ;AACrB;;;;;;;;;;;;AAGJ,eAAW,SAAQ;EACrB,CAAC;AACH;AAEM,SAAU,kBAAqB,eAA+B;AAClE,SAAO,IAAI,WAAW,SAAC,YAAyB;AAC9C,IAAAC,SAAQ,eAAe,UAAU,EAAE,MAAM,SAACD,MAAG;AAAK,aAAA,WAAW,MAAMA,IAAG;IAApB,CAAqB;EACzE,CAAC;AACH;AAEM,SAAU,uBAA0B,gBAAqC;AAC7E,SAAO,kBAAkB,mCAAmC,cAAc,CAAC;AAC7E;AAEA,SAAeC,SAAW,eAAiC,YAAyB;;;;;;;;;AACxD,4BAAA,cAAA,aAAa;;;;;;AAAtB,kBAAK,kBAAA;AACpB,qBAAW,KAAK,KAAK;AAGrB,cAAI,WAAW,QAAQ;AACrB,mBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;AAGJ,qBAAW,SAAQ;;;;;;;;AChHf,SAAU,gBACd,oBACA,WACA,MACAC,QACAC,SAAc;AADd,MAAAD,WAAA,QAAA;AAAA,IAAAA,SAAA;EAAS;AACT,MAAAC,YAAA,QAAA;AAAA,IAAAA,UAAA;EAAc;AAEd,MAAM,uBAAuB,UAAU,SAAS,WAAA;AAC9C,SAAI;AACJ,QAAIA,SAAQ;AACV,yBAAmB,IAAI,KAAK,SAAS,MAAMD,MAAK,CAAC;WAC5C;AACL,WAAK,YAAW;;EAEpB,GAAGA,MAAK;AAER,qBAAmB,IAAI,oBAAoB;AAE3C,MAAI,CAACC,SAAQ;AAKX,WAAO;;AAEX;;;ACeM,SAAU,UAAa,WAA0BC,QAAS;AAAT,MAAAA,WAAA,QAAA;AAAA,IAAAA,SAAA;EAAS;AAC9D,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,WAAO,UACL,yBACE,YACA,SAAC,OAAK;AAAK,aAAA,gBAAgB,YAAY,WAAW,WAAA;AAAM,eAAA,WAAW,KAAK,KAAK;MAArB,GAAwBA,MAAK;IAA1E,GACX,WAAA;AAAM,aAAA,gBAAgB,YAAY,WAAW,WAAA;AAAM,eAAA,WAAW,SAAQ;MAAnB,GAAuBA,MAAK;IAAzE,GACN,SAACC,MAAG;AAAK,aAAA,gBAAgB,YAAY,WAAW,WAAA;AAAM,eAAA,WAAW,MAAMA,IAAG;MAApB,GAAuBD,MAAK;IAAzE,CAA0E,CACpF;EAEL,CAAC;AACH;;;ACPM,SAAU,YAAe,WAA0BE,QAAiB;AAAjB,MAAAA,WAAA,QAAA;AAAA,IAAAA,SAAA;EAAiB;AACxE,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,eAAW,IAAI,UAAU,SAAS,WAAA;AAAM,aAAA,OAAO,UAAU,UAAU;IAA3B,GAA8BA,MAAK,CAAC;EAC9E,CAAC;AACH;;;AC7DM,SAAU,mBAAsB,OAA6B,WAAwB;AACzF,SAAO,UAAU,KAAK,EAAE,KAAK,YAAY,SAAS,GAAG,UAAU,SAAS,CAAC;AAC3E;;;ACFM,SAAU,gBAAmB,OAAuB,WAAwB;AAChF,SAAO,UAAU,KAAK,EAAE,KAAK,YAAY,SAAS,GAAG,UAAU,SAAS,CAAC;AAC3E;;;ACJM,SAAU,cAAiB,OAAqB,WAAwB;AAC5E,SAAO,IAAI,WAAc,SAAC,YAAU;AAElC,QAAI,IAAI;AAER,WAAO,UAAU,SAAS,WAAA;AACxB,UAAI,MAAM,MAAM,QAAQ;AAGtB,mBAAW,SAAQ;aACd;AAGL,mBAAW,KAAK,MAAM,GAAG,CAAC;AAI1B,YAAI,CAAC,WAAW,QAAQ;AACtB,eAAK,SAAQ;;;IAGnB,CAAC;EACH,CAAC;AACH;;;ACfM,SAAU,iBAAoB,OAAoB,WAAwB;AAC9E,SAAO,IAAI,WAAc,SAAC,YAAU;AAClC,QAAIC;AAKJ,oBAAgB,YAAY,WAAW,WAAA;AAErC,MAAAA,YAAY,MAAc,QAAe,EAAC;AAE1C,sBACE,YACA,WACA,WAAA;;AACE,YAAI;AACJ,YAAI;AACJ,YAAI;AAEF,UAACC,MAAkBD,UAAS,KAAI,GAA7B,QAAKC,IAAA,OAAE,OAAIA,IAAA;iBACPC,MAAK;AAEZ,qBAAW,MAAMA,IAAG;AACpB;;AAGF,YAAI,MAAM;AAKR,qBAAW,SAAQ;eACd;AAEL,qBAAW,KAAK,KAAK;;MAEzB,GACA,GACA,IAAI;IAER,CAAC;AAMD,WAAO,WAAA;AAAM,aAAA,WAAWF,cAAQ,QAARA,cAAQ,SAAA,SAARA,UAAU,MAAM,KAAKA,UAAS,OAAM;IAA/C;EACf,CAAC;AACH;;;ACvDM,SAAU,sBAAyB,OAAyB,WAAwB;AACxF,MAAI,CAAC,OAAO;AACV,UAAM,IAAI,MAAM,yBAAyB;;AAE3C,SAAO,IAAI,WAAc,SAAC,YAAU;AAClC,oBAAgB,YAAY,WAAW,WAAA;AACrC,UAAMG,YAAW,MAAM,OAAO,aAAa,EAAC;AAC5C,sBACE,YACA,WACA,WAAA;AACE,QAAAA,UAAS,KAAI,EAAG,KAAK,SAAC,QAAM;AAC1B,cAAI,OAAO,MAAM;AAGf,uBAAW,SAAQ;iBACd;AACL,uBAAW,KAAK,OAAO,KAAK;;QAEhC,CAAC;MACH,GACA,GACA,IAAI;IAER,CAAC;EACH,CAAC;AACH;;;ACzBM,SAAU,2BAA8B,OAA8B,WAAwB;AAClG,SAAO,sBAAsB,mCAAmC,KAAK,GAAG,SAAS;AACnF;;;ACoBM,SAAU,UAAa,OAA2B,WAAwB;AAC9E,MAAI,SAAS,MAAM;AACjB,QAAI,oBAAoB,KAAK,GAAG;AAC9B,aAAO,mBAAmB,OAAO,SAAS;;AAE5C,QAAI,YAAY,KAAK,GAAG;AACtB,aAAO,cAAc,OAAO,SAAS;;AAEvC,QAAI,UAAU,KAAK,GAAG;AACpB,aAAO,gBAAgB,OAAO,SAAS;;AAEzC,QAAI,gBAAgB,KAAK,GAAG;AAC1B,aAAO,sBAAsB,OAAO,SAAS;;AAE/C,QAAI,WAAW,KAAK,GAAG;AACrB,aAAO,iBAAiB,OAAO,SAAS;;AAE1C,QAAI,qBAAqB,KAAK,GAAG;AAC/B,aAAO,2BAA2B,OAAO,SAAS;;;AAGtD,QAAM,iCAAiC,KAAK;AAC9C;;;ACoDM,SAAU,KAAQ,OAA2B,WAAyB;AAC1E,SAAO,YAAY,UAAU,OAAO,SAAS,IAAI,UAAU,KAAK;AAClE;;;ACxBM,SAAU,KAAE;AAAI,MAAA,OAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAiC;AAAjC,SAAA,EAAA,IAAA,UAAA,EAAA;;AACpB,MAAM,YAAY,aAAa,IAAI;AACnC,SAAO,KAAK,MAAa,SAAS;AACpC;;;ACsCM,SAAU,WAAW,qBAA0B,WAAyB;AAC5E,MAAM,eAAe,WAAW,mBAAmB,IAAI,sBAAsB,WAAA;AAAM,WAAA;EAAA;AACnF,MAAM,OAAO,SAAC,YAA6B;AAAK,WAAA,WAAW,MAAM,aAAY,CAAE;EAA/B;AAChD,SAAO,IAAI,WAAW,YAAY,SAAC,YAAU;AAAK,WAAA,UAAU,SAAS,MAAa,GAAG,UAAU;EAA7C,IAAiD,IAAI;AACzG;;;AChHA,IAAY;CAAZ,SAAYC,mBAAgB;AAC1B,EAAAA,kBAAA,MAAA,IAAA;AACA,EAAAA,kBAAA,OAAA,IAAA;AACA,EAAAA,kBAAA,UAAA,IAAA;AACF,GAJY,qBAAA,mBAAgB,CAAA,EAAA;AAsB5B,IAAA,eAAA,WAAA;AA6BE,WAAAC,cAA4B,MAAuC,OAA2B,OAAW;AAA7E,SAAA,OAAA;AAAuC,SAAA,QAAA;AAA2B,SAAA,QAAA;AAC5F,SAAK,WAAW,SAAS;EAC3B;AAQA,EAAAA,cAAA,UAAA,UAAA,SAAQ,UAA4B;AAClC,WAAO,oBAAoB,MAAmC,QAAQ;EACxE;AA4BA,EAAAA,cAAA,UAAA,KAAA,SAAG,aAAiC,cAAmC,iBAA4B;AAC3F,QAAAC,MAAyB,MAAvB,OAAIA,IAAA,MAAE,QAAKA,IAAA,OAAE,QAAKA,IAAA;AAC1B,WAAO,SAAS,MAAM,gBAAW,QAAX,gBAAW,SAAA,SAAX,YAAc,KAAM,IAAI,SAAS,MAAM,iBAAY,QAAZ,iBAAY,SAAA,SAAZ,aAAe,KAAK,IAAI,oBAAe,QAAf,oBAAe,SAAA,SAAf,gBAAe;EACtG;AAqCA,EAAAD,cAAA,UAAA,SAAA,SAAO,gBAA2D,OAA4B,UAAqB;;AACjH,WAAO,YAAWC,MAAC,oBAAsB,QAAAA,QAAA,SAAA,SAAAA,IAAE,IAAI,IAC3C,KAAK,QAAQ,cAAoC,IACjD,KAAK,GAAG,gBAAsC,OAAc,QAAe;EACjF;AASA,EAAAD,cAAA,UAAA,eAAA,WAAA;AACQ,QAAAC,MAAyB,MAAvB,OAAIA,IAAA,MAAE,QAAKA,IAAA,OAAE,QAAKA,IAAA;AAE1B,QAAM,SACJ,SAAS,MAEL,GAAG,KAAM,IAEX,SAAS,MAEP,WAAW,WAAA;AAAM,aAAA;IAAA,CAAK,IAExB,SAAS,MAEP,QAEA;AACN,QAAI,CAAC,QAAQ;AAIX,YAAM,IAAI,UAAU,kCAAgC,IAAM;;AAE5D,WAAO;EACT;AAaO,EAAAD,cAAA,aAAP,SAAqB,OAAQ;AAC3B,WAAO,IAAIA,cAAa,KAAK,KAAK;EACpC;AAYO,EAAAA,cAAA,cAAP,SAAmBE,MAAS;AAC1B,WAAO,IAAIF,cAAa,KAAK,QAAWE,IAAG;EAC7C;AAUO,EAAAF,cAAA,iBAAP,WAAA;AACE,WAAOA,cAAa;EACtB;AAvCe,EAAAA,cAAA,uBAAuB,IAAIA,cAAa,GAAG;AAwC5D,SAAAA;EA5LA;AAqMM,SAAU,oBAAuB,cAAyC,UAA4B;;AACpG,MAAA,KAAyB,cAAvB,OAAI,GAAA,MAAE,QAAK,GAAA,OAAE,QAAK,GAAA;AAC1B,MAAI,OAAO,SAAS,UAAU;AAC5B,UAAM,IAAI,UAAU,sCAAsC;;AAE5D,WAAS,OAAMG,MAAA,SAAS,UAAI,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAAb,UAAgB,KAAM,IAAI,SAAS,OAAM,KAAA,SAAS,WAAK,QAAA,OAAA,SAAA,SAAA,GAAA,KAAd,UAAiB,KAAK,KAAI,KAAA,SAAS,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAA,KAAjB,QAAQ;AAC5F;;;ACvNO,IAAM,aAA6B,iBACxC,SAAC,QAAM;AACL,SAAA,SAAS,iBAAc;AACrB,WAAO,IAAI;AACX,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AAJA,CAIC;;;AC2BC,SAAU,eAAqB,QAAuBC,SAAgC;AAC1F,MAAM,YAAY,OAAOA,YAAW;AACpC,SAAO,IAAI,QAAe,SAAC,SAAS,QAAM;AACxC,QAAM,aAAa,IAAI,eAAkB;MACvC,MAAM,SAAC,OAAK;AACV,gBAAQ,KAAK;AACb,mBAAW,YAAW;MACxB;MACA,OAAO;MACP,UAAU,WAAA;AACR,YAAI,WAAW;AACb,kBAAQA,QAAQ,YAAY;eACvB;AACL,iBAAO,IAAI,WAAU,CAAE;;MAE3B;KACD;AACD,WAAO,UAAU,UAAU;EAC7B,CAAC;AACH;;;ACtDO,IAAM,0BAAuD,iBAClE,SAAC,QAAM;AACL,SAAA,SAAS,8BAA2B;AAClC,WAAO,IAAI;AACX,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AAJA,CAIC;;;ACRE,IAAM,gBAAmC,iBAC9C,SAAC,QAAM;AACL,SAAA,SAAS,kBAA6B,SAAe;AACnD,WAAO,IAAI;AACX,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AAJA,CAIC;;;ACNE,IAAM,gBAAmC,iBAC9C,SAAC,QAAM;AACL,SAAA,SAAS,kBAA6B,SAAe;AACnD,WAAO,IAAI;AACX,SAAK,OAAO;AACZ,SAAK,UAAU;EACjB;AAJA,CAIC;;;ACjBC,SAAU,YAAY,OAAU;AACpC,SAAO,iBAAiB,QAAQ,CAAC,MAAM,KAAY;AACrD;;;AC4EO,IAAM,eAAiC,iBAC5C,SAAC,QAAM;AACL,SAAA,SAAS,iBAA4B,MAAoC;AAApC,QAAA,SAAA,QAAA;AAAA,aAAA;IAAoC;AACvE,WAAO,IAAI;AACX,SAAK,UAAU;AACf,SAAK,OAAO;AACZ,SAAK,OAAO;EACd;AALA,CAKC;;;AC9CC,SAAU,IAAU,SAAyC,SAAa;AAC9E,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAEhC,QAAI,QAAQ;AAGZ,WAAO,UACL,yBAAyB,YAAY,SAAC,OAAQ;AAG5C,iBAAW,KAAK,QAAQ,KAAK,SAAS,OAAO,OAAO,CAAC;IACvD,CAAC,CAAC;EAEN,CAAC;AACH;;;ACzDQ,IAAA,UAAY,MAAK;AAEzB,SAAS,YAAkB,IAA6B,MAAW;AAC/D,SAAO,QAAQ,IAAI,IAAI,GAAE,MAAA,QAAA,cAAA,CAAA,GAAA,OAAI,IAAI,CAAA,CAAA,IAAI,GAAG,IAAI;AAChD;AAMM,SAAU,iBAAuB,IAA2B;AAC9D,SAAO,IAAI,SAAA,MAAI;AAAI,WAAA,YAAY,IAAI,IAAI;EAApB,CAAqB;AAC5C;;;ACfQ,IAAAC,WAAY,MAAK;AACjB,IAA2B,cAA+B,OAAM;;;ACmBlE,SAAU,eACd,QACA,YACA,SACA,YACA,cACAC,SACA,mBACA,qBAAgC;AAGhC,MAAMC,UAAc,CAAA;AAEpB,MAAI,SAAS;AAEb,MAAI,QAAQ;AAEZ,MAAI,aAAa;AAKjB,MAAM,gBAAgB,WAAA;AAIpB,QAAI,cAAc,CAACA,QAAO,UAAU,CAAC,QAAQ;AAC3C,iBAAW,SAAQ;;EAEvB;AAGA,MAAM,YAAY,SAAC,OAAQ;AAAK,WAAC,SAAS,aAAa,WAAW,KAAK,IAAIA,QAAO,KAAK,KAAK;EAA5D;AAEhC,MAAM,aAAa,SAAC,OAAQ;AAI1B,IAAAD,WAAU,WAAW,KAAK,KAAY;AAItC;AAKA,QAAI,gBAAgB;AAGpB,cAAU,QAAQ,OAAO,OAAO,CAAC,EAAE,UACjC,yBACE,YACA,SAAC,YAAU;AAGT,uBAAY,QAAZ,iBAAY,SAAA,SAAZ,aAAe,UAAU;AAEzB,UAAIA,SAAQ;AAGV,kBAAU,UAAiB;aACtB;AAEL,mBAAW,KAAK,UAAU;;IAE9B,GACA,WAAA;AAGE,sBAAgB;IAClB,GAEA,QACA,WAAA;AAIE,UAAI,eAAe;AAKjB,YAAI;AAIF;;AAME,gBAAM,gBAAgBC,QAAO,MAAK;AAIlC,gBAAI,mBAAmB;AACrB,8BAAgB,YAAY,mBAAmB,WAAA;AAAM,uBAAA,WAAW,aAAa;cAAxB,CAAyB;mBACzE;AACL,yBAAW,aAAa;;;AAR5B,iBAAOA,QAAO,UAAU,SAAS,YAAU;;;AAY3C,wBAAa;iBACNC,MAAK;AACZ,qBAAW,MAAMA,IAAG;;;IAG1B,CAAC,CACF;EAEL;AAGA,SAAO,UACL,yBAAyB,YAAY,WAAW,WAAA;AAE9C,iBAAa;AACb,kBAAa;EACf,CAAC,CAAC;AAKJ,SAAO,WAAA;AACL,4BAAmB,QAAnB,wBAAmB,SAAA,SAAnB,oBAAmB;EACrB;AACF;;;ACpEM,SAAU,SACd,SACA,gBACA,YAA6B;AAA7B,MAAA,eAAA,QAAA;AAAA,iBAAA;EAA6B;AAE7B,MAAI,WAAW,cAAc,GAAG;AAE9B,WAAO,SAAS,SAAC,GAAG,GAAC;AAAK,aAAA,IAAI,SAAC,GAAQ,IAAU;AAAK,eAAA,eAAe,GAAG,GAAG,GAAG,EAAE;MAA1B,CAA2B,EAAE,UAAU,QAAQ,GAAG,CAAC,CAAC,CAAC;IAAjF,GAAoF,UAAU;aAC/G,OAAO,mBAAmB,UAAU;AAC7C,iBAAa;;AAGf,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAAK,WAAA,eAAe,QAAQ,YAAY,SAAS,UAAU;EAAtD,CAAuD;AAChG;;;AC9BM,SAAU,SAAyC,YAA6B;AAA7B,MAAA,eAAA,QAAA;AAAA,iBAAA;EAA6B;AACpF,SAAO,SAAS,UAAU,UAAU;AACtC;;;ACNM,SAAU,YAAS;AACvB,SAAO,SAAS,CAAC;AACnB;;;ACmDM,SAAU,SAAM;AAAC,MAAA,OAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,SAAA,EAAA,IAAA,UAAA,EAAA;;AACrB,SAAO,UAAS,EAAG,KAAK,MAAM,aAAa,IAAI,CAAC,CAAC;AACnD;;;AC1GA,IAAM,0BAA0B,CAAC,eAAe,gBAAgB;AAChE,IAAM,qBAAqB,CAAC,oBAAoB,qBAAqB;AACrE,IAAM,gBAAgB,CAAC,MAAM,KAAK;AAqO5B,SAAU,UACd,QACA,WACA,SACA,gBAAsC;AAEtC,MAAI,WAAW,OAAO,GAAG;AACvB,qBAAiB;AACjB,cAAU;;AAEZ,MAAI,gBAAgB;AAClB,WAAO,UAAa,QAAQ,WAAW,OAA+B,EAAE,KAAK,iBAAiB,cAAc,CAAC;;AAUzG,MAAAC,MAAA,OAEJ,cAAc,MAAM,IAChB,mBAAmB,IAAI,SAAC,YAAU;AAAK,WAAA,SAAC,SAAY;AAAK,aAAA,OAAO,UAAU,EAAE,WAAW,SAAS,OAA+B;IAAtE;EAAlB,CAAyF,IAElI,wBAAwB,MAAM,IAC5B,wBAAwB,IAAI,wBAAwB,QAAQ,SAAS,CAAC,IACtE,0BAA0B,MAAM,IAChC,cAAc,IAAI,wBAAwB,QAAQ,SAAS,CAAC,IAC5D,CAAA,GAAE,CAAA,GATDC,OAAGD,IAAA,CAAA,GAAE,SAAMA,IAAA,CAAA;AAgBlB,MAAI,CAACC,MAAK;AACR,QAAI,YAAY,MAAM,GAAG;AACvB,aAAO,SAAS,SAAC,WAAc;AAAK,eAAA,UAAU,WAAW,WAAW,OAA+B;MAA/D,CAAgE,EAClG,UAAU,MAAM,CAAC;;;AAOvB,MAAI,CAACA,MAAK;AACR,UAAM,IAAI,UAAU,sBAAsB;;AAG5C,SAAO,IAAI,WAAc,SAAC,YAAU;AAIlC,QAAM,UAAU,WAAA;AAAC,UAAA,OAAA,CAAA;eAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAc;AAAd,aAAA,EAAA,IAAA,UAAA,EAAA;;AAAmB,aAAA,WAAW,KAAK,IAAI,KAAK,SAAS,OAAO,KAAK,CAAC,CAAC;IAAhD;AAEpC,IAAAA,KAAI,OAAO;AAEX,WAAO,WAAA;AAAM,aAAA,OAAQ,OAAO;IAAf;EACf,CAAC;AACH;AASA,SAAS,wBAAwB,QAAa,WAAiB;AAC7D,SAAO,SAAC,YAAkB;AAAK,WAAA,SAAC,SAAY;AAAK,aAAA,OAAO,UAAU,EAAE,WAAW,OAAO;IAArC;EAAlB;AACjC;AAOA,SAAS,wBAAwB,QAAW;AAC1C,SAAO,WAAW,OAAO,WAAW,KAAK,WAAW,OAAO,cAAc;AAC3E;AAOA,SAAS,0BAA0B,QAAW;AAC5C,SAAO,WAAW,OAAO,EAAE,KAAK,WAAW,OAAO,GAAG;AACvD;AAOA,SAAS,cAAc,QAAW;AAChC,SAAO,WAAW,OAAO,gBAAgB,KAAK,WAAW,OAAO,mBAAmB;AACrF;;;AC9MM,SAAU,MACd,SACA,qBACA,WAAyC;AAFzC,MAAA,YAAA,QAAA;AAAA,cAAA;EAA0B;AAE1B,MAAA,cAAA,QAAA;AAAA,gBAAA;EAAyC;AAIzC,MAAI,mBAAmB;AAEvB,MAAI,uBAAuB,MAAM;AAI/B,QAAI,YAAY,mBAAmB,GAAG;AACpC,kBAAY;WACP;AAGL,yBAAmB;;;AAIvB,SAAO,IAAI,WAAW,SAAC,YAAU;AAI/B,QAAI,MAAM,YAAY,OAAO,IAAI,CAAC,UAAU,UAAW,IAAG,IAAK;AAE/D,QAAI,MAAM,GAAG;AAEX,YAAM;;AAIR,QAAI,IAAI;AAGR,WAAO,UAAU,SAAS,WAAA;AACxB,UAAI,CAAC,WAAW,QAAQ;AAEtB,mBAAW,KAAK,GAAG;AAEnB,YAAI,KAAK,kBAAkB;AAGzB,eAAK,SAAS,QAAW,gBAAgB;eACpC;AAEL,qBAAW,SAAQ;;;IAGzB,GAAG,GAAG;EACR,CAAC;AACH;;;AClGM,SAAU,QAAK;AAAC,MAAA,OAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAA8D;AAA9D,SAAA,EAAA,IAAA,UAAA,EAAA;;AACpB,MAAM,YAAY,aAAa,IAAI;AACnC,MAAM,aAAa,UAAU,MAAM,QAAQ;AAC3C,MAAM,UAAU;AAChB,SAAO,CAAC,QAAQ,SAEZ,QACA,QAAQ,WAAW,IAEnB,UAAU,QAAQ,CAAC,CAAC,IAEpB,SAAS,UAAU,EAAE,KAAK,SAAS,SAAS,CAAC;AACnD;;;AC/DO,IAAM,QAAQ,IAAI,WAAkB,IAAI;;;ACpCvC,IAAAC,WAAY,MAAK;AAMnB,SAAU,eAAkB,MAAiB;AACjD,SAAO,KAAK,WAAW,KAAKA,SAAQ,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC,IAAK;AAC5D;;;ACoDM,SAAU,OAAU,WAAiD,SAAa;AACtF,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAEhC,QAAI,QAAQ;AAIZ,WAAO,UAIL,yBAAyB,YAAY,SAAC,OAAK;AAAK,aAAA,UAAU,KAAK,SAAS,OAAO,OAAO,KAAK,WAAW,KAAK,KAAK;IAAhE,CAAiE,CAAC;EAEtH,CAAC;AACH;;;ACxBM,SAAU,OAAI;AAAI,MAAA,UAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAyD;AAAzD,YAAA,EAAA,IAAA,UAAA,EAAA;;AACtB,YAAU,eAAe,OAAO;AAEhC,SAAO,QAAQ,WAAW,IAAI,UAAU,QAAQ,CAAC,CAAuB,IAAI,IAAI,WAAc,SAAS,OAA+B,CAAC;AACzI;AAOM,SAAU,SAAY,SAA6B;AACvD,SAAO,SAAC,YAAyB;AAC/B,QAAI,gBAAgC,CAAA;2BAM3BC,IAAC;AACR,oBAAc,KACZ,UAAU,QAAQA,EAAC,CAAuB,EAAE,UAC1C,yBAAyB,YAAY,SAAC,OAAK;AACzC,YAAI,eAAe;AAGjB,mBAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK;AAC7C,kBAAMA,MAAK,cAAc,CAAC,EAAE,YAAW;;AAEzC,0BAAgB;;AAElB,mBAAW,KAAK,KAAK;MACvB,CAAC,CAAC,CACH;;AAdL,aAAS,IAAI,GAAG,iBAAiB,CAAC,WAAW,UAAU,IAAI,QAAQ,QAAQ,KAAG;cAArE,CAAC;;EAiBZ;AACF;;;ACVM,SAAU,UACd,SACA,gBAA6G;AAE7G,SAAO,WAAW,cAAc,IAAI,SAAS,SAAS,gBAAgB,CAAC,IAAI,SAAS,SAAS,CAAC;AAChG;;;AC3CM,SAAU,eAAqB,cAAe;AAClD,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,QAAI,WAAW;AACf,WAAO,UACL,yBACE,YACA,SAAC,OAAK;AACJ,iBAAW;AACX,iBAAW,KAAK,KAAK;IACvB,GACA,WAAA;AACE,UAAI,CAAC,UAAU;AACb,mBAAW,KAAK,YAAa;;AAE/B,iBAAW,SAAQ;IACrB,CAAC,CACF;EAEL,CAAC;AACH;;;ACXM,SAAU,KAAQC,QAAa;AACnC,SAAOA,UAAS,IAEZ,WAAA;AAAM,WAAA;EAAA,IACN,QAAQ,SAAC,QAAQ,YAAU;AACzB,QAAI,OAAO;AACX,WAAO,UACL,yBAAyB,YAAY,SAAC,OAAK;AAIzC,UAAI,EAAE,QAAQA,QAAO;AACnB,mBAAW,KAAK,KAAK;AAIrB,YAAIA,UAAS,MAAM;AACjB,qBAAW,SAAQ;;;IAGzB,CAAC,CAAC;EAEN,CAAC;AACP;;;AC9BM,SAAU,iBAAc;AAC5B,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,WAAO,UAAU,yBAAyB,YAAY,IAAI,CAAC;EAC7D,CAAC;AACH;;;ACCM,SAAU,MAAS,OAAQ;AAC/B,SAAO,IAAI,WAAA;AAAM,WAAA;EAAA,CAAK;AACxB;;;AC4CM,SAAU,UACd,uBACA,mBAAmC;AAEnC,MAAI,mBAAmB;AAErB,WAAO,SAAC,QAAqB;AAC3B,aAAA,OAAO,kBAAkB,KAAK,KAAK,CAAC,GAAG,eAAc,CAAE,GAAG,OAAO,KAAK,UAAU,qBAAqB,CAAC,CAAC;IAAvG;;AAGJ,SAAO,SAAS,SAAC,OAAO,OAAK;AAAK,WAAA,UAAU,sBAAsB,OAAO,KAAK,CAAC,EAAE,KAAK,KAAK,CAAC,GAAG,MAAM,KAAK,CAAC;EAAzE,CAA0E;AAC9G;;;ACzCM,SAAU,MAAS,KAAoB,WAAyC;AAAzC,MAAA,cAAA,QAAA;AAAA,gBAAA;EAAyC;AACpF,MAAM,WAAW,MAAM,KAAK,SAAS;AACrC,SAAO,UAAU,WAAA;AAAM,WAAA;EAAA,CAAQ;AACjC;;;ACvBM,SAAU,aAAgB,cAA6C;AAA7C,MAAA,iBAAA,QAAA;AAAA,mBAAA;EAA6C;AAC3E,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,QAAI,WAAW;AACf,WAAO,UACL,yBACE,YACA,SAAC,OAAK;AACJ,iBAAW;AACX,iBAAW,KAAK,KAAK;IACvB,GACA,WAAA;AAAM,aAAC,WAAW,WAAW,SAAQ,IAAK,WAAW,MAAM,aAAY,CAAE;IAAnE,CAAqE,CAC5E;EAEL,CAAC;AACH;AAEA,SAAS,sBAAmB;AAC1B,SAAO,IAAI,WAAU;AACvB;;;ACKM,SAAU,SAAY,UAAoB;AAC9C,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAGhC,QAAI;AACF,aAAO,UAAU,UAAU;;AAE3B,iBAAW,IAAI,QAAQ;;EAE3B,CAAC;AACH;;;ACOM,SAAU,MACd,WACA,cAAgB;AAEhB,MAAM,kBAAkB,UAAU,UAAU;AAC5C,SAAO,SAAC,QAAqB;AAC3B,WAAA,OAAO,KACL,YAAY,OAAO,SAAC,GAAG,GAAC;AAAK,aAAA,UAAU,GAAG,GAAG,MAAM;IAAtB,CAAuB,IAAI,UACxD,KAAK,CAAC,GACN,kBAAkB,eAAe,YAAa,IAAI,aAAa,WAAA;AAAM,aAAA,IAAI,WAAU;IAAd,CAAgB,CAAC;EAHxF;AAKJ;;;ACiDM,SAAU,MAAS,SAA4B;AAA5B,MAAA,YAAA,QAAA;AAAA,cAAA,CAAA;EAA4B;AAC3C,MAAAC,MAAgH,QAAO,WAAvH,YAASA,QAAA,SAAG,WAAA;AAAM,WAAA,IAAI,QAAO;EAAX,IAAgBA,KAAE,KAA4E,QAAO,cAAnF,eAAY,OAAA,SAAG,OAAI,IAAE,KAAuD,QAAO,iBAA9D,kBAAe,OAAA,SAAG,OAAI,IAAE,KAA+B,QAAO,qBAAtC,sBAAmB,OAAA,SAAG,OAAI;AAUnH,SAAO,SAAC,eAAa;AACnB,QAAI;AACJ,QAAI;AACJ,QAAI;AACJ,QAAIC,YAAW;AACf,QAAI,eAAe;AACnB,QAAI,aAAa;AAEjB,QAAM,cAAc,WAAA;AAClB,0BAAe,QAAf,oBAAe,SAAA,SAAf,gBAAiB,YAAW;AAC5B,wBAAkB;IACpB;AAGA,QAAM,QAAQ,WAAA;AACZ,kBAAW;AACX,mBAAa,UAAU;AACvB,qBAAe,aAAa;IAC9B;AACA,QAAM,sBAAsB,WAAA;AAG1B,UAAM,OAAO;AACb,YAAK;AACL,eAAI,QAAJ,SAAI,SAAA,SAAJ,KAAM,YAAW;IACnB;AAEA,WAAO,QAAc,SAAC,QAAQ,YAAU;AACtC,MAAAA;AACA,UAAI,CAAC,cAAc,CAAC,cAAc;AAChC,oBAAW;;AAOb,UAAM,OAAQ,UAAU,YAAO,QAAP,YAAO,SAAP,UAAW,UAAS;AAO5C,iBAAW,IAAI,WAAA;AACb,QAAAA;AAKA,YAAIA,cAAa,KAAK,CAAC,cAAc,CAAC,cAAc;AAClD,4BAAkB,YAAY,qBAAqB,mBAAmB;;MAE1E,CAAC;AAID,WAAK,UAAU,UAAU;AAEzB,UACE,CAAC,cAIDA,YAAW,GACX;AAMA,qBAAa,IAAI,eAAe;UAC9B,MAAM,SAAC,OAAK;AAAK,mBAAA,KAAK,KAAK,KAAK;UAAf;UACjB,OAAO,SAACC,MAAG;AACT,yBAAa;AACb,wBAAW;AACX,8BAAkB,YAAY,OAAO,cAAcA,IAAG;AACtD,iBAAK,MAAMA,IAAG;UAChB;UACA,UAAU,WAAA;AACR,2BAAe;AACf,wBAAW;AACX,8BAAkB,YAAY,OAAO,eAAe;AACpD,iBAAK,SAAQ;UACf;SACD;AACD,kBAAU,MAAM,EAAE,UAAU,UAAU;;IAE1C,CAAC,EAAE,aAAa;EAClB;AACF;AAEA,SAAS,YACP,OACA,IAAoD;AACpD,MAAA,OAAA,CAAA;WAAA,KAAA,GAAA,KAAA,UAAA,QAAA,MAAU;AAAV,SAAA,KAAA,CAAA,IAAA,UAAA,EAAA;;AAEA,MAAI,OAAO,MAAM;AACf,UAAK;AACL;;AAGF,MAAI,OAAO,OAAO;AAChB;;AAGF,MAAM,eAAe,IAAI,eAAe;IACtC,MAAM,WAAA;AACJ,mBAAa,YAAW;AACxB,YAAK;IACP;GACD;AAED,SAAO,UAAU,GAAE,MAAA,QAAA,cAAA,CAAA,GAAA,OAAI,IAAI,CAAA,CAAA,CAAA,EAAG,UAAU,YAAY;AACtD;;;AChHM,SAAU,YACd,oBACAC,aACA,WAAyB;;AAEzB,MAAI;AACJ,MAAIC,YAAW;AACf,MAAI,sBAAsB,OAAO,uBAAuB,UAAU;AAChE,IAAGC,MAA8E,mBAAkB,YAAhG,aAAUA,QAAA,SAAG,WAAQA,KAAE,KAAuD,mBAAkB,YAAzEF,cAAU,OAAA,SAAG,WAAQ,IAAE,KAAgC,mBAAkB,UAAlDC,YAAQ,OAAA,SAAG,QAAK,IAAE,YAAc,mBAAkB;SAC9F;AACL,iBAAc,uBAAkB,QAAlB,uBAAkB,SAAlB,qBAAsB;;AAEtC,SAAO,MAAS;IACd,WAAW,WAAA;AAAM,aAAA,IAAI,cAAc,YAAYD,aAAY,SAAS;IAAnD;IACjB,cAAc;IACd,iBAAiB;IACjB,qBAAqBC;GACtB;AACH;;;ACxFM,SAAU,UACd,SACA,gBAA6G;AAE7G,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,QAAI,kBAAyD;AAC7D,QAAI,QAAQ;AAEZ,QAAI,aAAa;AAIjB,QAAM,gBAAgB,WAAA;AAAM,aAAA,cAAc,CAAC,mBAAmB,WAAW,SAAQ;IAArD;AAE5B,WAAO,UACL,yBACE,YACA,SAAC,OAAK;AAEJ,0BAAe,QAAf,oBAAe,SAAA,SAAf,gBAAiB,YAAW;AAC5B,UAAI,aAAa;AACjB,UAAM,aAAa;AAEnB,gBAAU,QAAQ,OAAO,UAAU,CAAC,EAAE,UACnC,kBAAkB,yBACjB,YAIA,SAAC,YAAU;AAAK,eAAA,WAAW,KAAK,iBAAiB,eAAe,OAAO,YAAY,YAAY,YAAY,IAAI,UAAU;MAAzG,GAChB,WAAA;AAIE,0BAAkB;AAClB,sBAAa;MACf,CAAC,CACD;IAEN,GACA,WAAA;AACE,mBAAa;AACb,oBAAa;IACf,CAAC,CACF;EAEL,CAAC;AACH;;;ACvFM,SAAU,UAAa,UAA8B;AACzD,SAAO,QAAQ,SAAC,QAAQ,YAAU;AAChC,cAAU,QAAQ,EAAE,UAAU,yBAAyB,YAAY,WAAA;AAAM,aAAA,WAAW,SAAQ;IAAnB,GAAuB,IAAI,CAAC;AACrG,KAAC,WAAW,UAAU,OAAO,UAAU,UAAU;EACnD,CAAC;AACH;;;ACqHM,SAAU,IACd,gBACA,OACA,UAA8B;AAK9B,MAAM,cACJ,WAAW,cAAc,KAAK,SAAS,WAElC,EAAE,MAAM,gBAA2E,OAAO,SAAQ,IACnG;AAEN,SAAO,cACH,QAAQ,SAAC,QAAQ,YAAU;;AACzB,KAAAE,MAAA,YAAY,eAAS,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAArB,WAAW;AACX,QAAI,UAAU;AACd,WAAO,UACL,yBACE,YACA,SAAC,OAAK;;AACJ,OAAAA,MAAA,YAAY,UAAI,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAAhB,aAAmB,KAAK;AACxB,iBAAW,KAAK,KAAK;IACvB,GACA,WAAA;;AACE,gBAAU;AACV,OAAAA,MAAA,YAAY,cAAQ,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAApB,WAAW;AACX,iBAAW,SAAQ;IACrB,GACA,SAACC,MAAG;;AACF,gBAAU;AACV,OAAAD,MAAA,YAAY,WAAK,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAAjB,aAAoBC,IAAG;AACvB,iBAAW,MAAMA,IAAG;IACtB,GACA,WAAA;;AACE,UAAI,SAAS;AACX,SAAAD,MAAA,YAAY,iBAAW,QAAAA,QAAA,SAAA,SAAAA,IAAA,KAAvB,WAAW;;AAEb,OAAA,KAAA,YAAY,cAAQ,QAAA,OAAA,SAAA,SAAA,GAAA,KAApB,WAAW;IACb,CAAC,CACF;EAEL,CAAC,IAID;AACN;;;AC/MO,IAAME,UACX,OAAO,eAAe,YAAY,YAAY,aAAa,WAAW,SAAS;;;ACO3E,SAAU,QAAQ,GAAU;AAChC,SAAO,aAAa,cAAe,YAAY,OAAO,CAAC,KAAK,EAAE,YAAY,SAAS;AACrF;AAGM,SAAU,QAAQ,GAAS;AAC/B,MAAI,CAAC,OAAO,cAAc,CAAC,KAAK,IAAI;AAAG,UAAM,IAAI,MAAM,oCAAoC,CAAC;AAC9F;AAGM,SAAU,OAAO,MAA8B,SAAiB;AACpE,MAAI,CAAC,QAAQ,CAAC;AAAG,UAAM,IAAI,MAAM,qBAAqB;AACtD,MAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,SAAS,EAAE,MAAM;AAClD,UAAM,IAAI,MAAM,mCAAmC,UAAU,kBAAkB,EAAE,MAAM;AAC3F;AAWM,SAAU,QAAQ,UAAe,gBAAgB,MAAI;AACzD,MAAI,SAAS;AAAW,UAAM,IAAI,MAAM,kCAAkC;AAC1E,MAAI,iBAAiB,SAAS;AAAU,UAAM,IAAI,MAAM,uCAAuC;AACjG;AAGM,SAAU,QAAQ,KAAU,UAAa;AAC7C,SAAO,GAAG;AACV,QAAMC,OAAM,SAAS;AACrB,MAAI,IAAI,SAASA,MAAK;AACpB,UAAM,IAAI,MAAM,2DAA2DA,IAAG;EAChF;AACF;AAkBM,SAAU,SAAS,QAAoB;AAC3C,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,WAAO,CAAC,EAAE,KAAK,CAAC;EAClB;AACF;AAGM,SAAU,WAAW,KAAe;AACxC,SAAO,IAAI,SAAS,IAAI,QAAQ,IAAI,YAAY,IAAI,UAAU;AAChE;AAGM,SAAU,KAAK,MAAc,OAAa;AAC9C,SAAQ,QAAS,KAAK,QAAW,SAAS;AAC5C;AAQO,IAAM,QAAiC,MAC5C,IAAI,WAAW,IAAI,YAAY,CAAC,SAAU,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM,IAAK;AA+BnE,IAAM,iBAA0C;;EAE9C,OAAO,WAAW,KAAK,CAAA,CAAE,EAAE,UAAU,cAAc,OAAO,WAAW,YAAY;GAAW;AAG9F,IAAM,QAAwB,MAAM,KAAK,EAAE,QAAQ,IAAG,GAAI,CAAC,GAAG,MAC5D,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC;AAO3B,SAAU,WAAWC,QAAiB;AAC1C,SAAOA,MAAK;AAEZ,MAAI;AAAe,WAAOA,OAAM,MAAK;AAErC,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAIA,OAAM,QAAQ,KAAK;AACrC,WAAO,MAAMA,OAAM,CAAC,CAAC;EACvB;AACA,SAAO;AACT;AAGA,IAAM,SAAS,EAAE,IAAI,IAAI,IAAI,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAG;AAC5D,SAAS,cAAc,IAAU;AAC/B,MAAI,MAAM,OAAO,MAAM,MAAM,OAAO;AAAI,WAAO,KAAK,OAAO;AAC3D,MAAI,MAAM,OAAO,KAAK,MAAM,OAAO;AAAG,WAAO,MAAM,OAAO,IAAI;AAC9D,MAAI,MAAM,OAAO,KAAK,MAAM,OAAO;AAAG,WAAO,MAAM,OAAO,IAAI;AAC9D;AACF;AAMM,SAAU,WAAW,KAAW;AACpC,MAAI,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,8BAA8B,OAAO,GAAG;AAErF,MAAI;AAAe,WAAO,WAAW,QAAQ,GAAG;AAChD,QAAM,KAAK,IAAI;AACf,QAAM,KAAK,KAAK;AAChB,MAAI,KAAK;AAAG,UAAM,IAAI,MAAM,qDAAqD,EAAE;AACnF,QAAMC,SAAQ,IAAI,WAAW,EAAE;AAC/B,WAAS,KAAK,GAAG,KAAK,GAAG,KAAK,IAAI,MAAM,MAAM,GAAG;AAC/C,UAAM,KAAK,cAAc,IAAI,WAAW,EAAE,CAAC;AAC3C,UAAM,KAAK,cAAc,IAAI,WAAW,KAAK,CAAC,CAAC;AAC/C,QAAI,OAAO,UAAa,OAAO,QAAW;AACxC,YAAM,OAAO,IAAI,EAAE,IAAI,IAAI,KAAK,CAAC;AACjC,YAAM,IAAI,MAAM,iDAAiD,OAAO,gBAAgB,EAAE;IAC5F;AACA,IAAAA,OAAM,EAAE,IAAI,KAAK,KAAK;EACxB;AACA,SAAOA;AACT;AAkCM,SAAU,YAAY,KAAW;AACrC,MAAI,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,iBAAiB;AAC9D,SAAO,IAAI,WAAW,IAAI,YAAW,EAAG,OAAO,GAAG,CAAC;AACrD;AAiBM,SAAU,QAAQ,MAAW;AACjC,MAAI,OAAO,SAAS;AAAU,WAAO,YAAY,IAAI;AACrD,SAAO,IAAI;AACX,SAAO;AACT;AAeM,SAAU,eAAe,QAAoB;AACjD,MAAI,MAAM;AACV,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACtC,UAAM,IAAI,OAAO,CAAC;AAClB,WAAO,CAAC;AACR,WAAO,EAAE;EACX;AACA,QAAM,MAAM,IAAI,WAAW,GAAG;AAC9B,WAAS,IAAI,GAAG,MAAM,GAAG,IAAI,OAAO,QAAQ,KAAK;AAC/C,UAAM,IAAI,OAAO,CAAC;AAClB,QAAI,IAAI,GAAG,GAAG;AACd,WAAO,EAAE;EACX;AACA,SAAO;AACT;AAsBM,IAAgB,OAAhB,MAAoB;;AA4CpB,SAAU,aACd,UAAuB;AAOvB,QAAM,QAAQ,CAAC,QAA2B,SAAQ,EAAG,OAAO,QAAQ,GAAG,CAAC,EAAE,OAAM;AAChF,QAAM,MAAM,SAAQ;AACpB,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,MAAM,SAAQ;AAC7B,SAAO;AACT;AAsCM,SAAU,YAAY,cAAc,IAAE;AAC1C,MAAIC,WAAU,OAAOA,QAAO,oBAAoB,YAAY;AAC1D,WAAOA,QAAO,gBAAgB,IAAI,WAAW,WAAW,CAAC;EAC3D;AAEA,MAAIA,WAAU,OAAOA,QAAO,gBAAgB,YAAY;AACtD,WAAO,WAAW,KAAKA,QAAO,YAAY,WAAW,CAAC;EACxD;AACA,QAAM,IAAI,MAAM,wCAAwC;AAC1D;;;ACnYM,SAAU,aACd,MACA,YACA,OACAC,OAAa;AAEb,MAAI,OAAO,KAAK,iBAAiB;AAAY,WAAO,KAAK,aAAa,YAAY,OAAOA,KAAI;AAC7F,QAAMC,QAAO,OAAO,EAAE;AACtB,QAAM,WAAW,OAAO,UAAU;AAClC,QAAM,KAAK,OAAQ,SAASA,QAAQ,QAAQ;AAC5C,QAAM,KAAK,OAAO,QAAQ,QAAQ;AAClC,QAAM,IAAID,QAAO,IAAI;AACrB,QAAM,IAAIA,QAAO,IAAI;AACrB,OAAK,UAAU,aAAa,GAAG,IAAIA,KAAI;AACvC,OAAK,UAAU,aAAa,GAAG,IAAIA,KAAI;AACzC;AAGM,SAAU,IAAI,GAAW,GAAW,GAAS;AACjD,SAAQ,IAAI,IAAM,CAAC,IAAI;AACzB;AAGM,SAAU,IAAI,GAAW,GAAW,GAAS;AACjD,SAAQ,IAAI,IAAM,IAAI,IAAM,IAAI;AAClC;AAMM,IAAgB,SAAhB,cAAoD,KAAO;EAoB/D,YAAY,UAAkB,WAAmB,WAAmBA,OAAa;AAC/E,UAAK;AANG,SAAA,WAAW;AACX,SAAA,SAAS;AACT,SAAA,MAAM;AACN,SAAA,YAAY;AAIpB,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,OAAOA;AACZ,SAAK,SAAS,IAAI,WAAW,QAAQ;AACrC,SAAK,OAAO,WAAW,KAAK,MAAM;EACpC;EACA,OAAO,MAAW;AAChB,YAAQ,IAAI;AACZ,WAAO,QAAQ,IAAI;AACnB,WAAO,IAAI;AACX,UAAM,EAAE,MAAM,QAAAE,SAAQ,SAAQ,IAAK;AACnC,UAAM,MAAM,KAAK;AACjB,aAAS,MAAM,GAAG,MAAM,OAAO;AAC7B,YAAMC,QAAO,KAAK,IAAI,WAAW,KAAK,KAAK,MAAM,GAAG;AAEpD,UAAIA,UAAS,UAAU;AACrB,cAAM,WAAW,WAAW,IAAI;AAChC,eAAO,YAAY,MAAM,KAAK,OAAO;AAAU,eAAK,QAAQ,UAAU,GAAG;AACzE;MACF;AACA,MAAAD,QAAO,IAAI,KAAK,SAAS,KAAK,MAAMC,KAAI,GAAG,KAAK,GAAG;AACnD,WAAK,OAAOA;AACZ,aAAOA;AACP,UAAI,KAAK,QAAQ,UAAU;AACzB,aAAK,QAAQ,MAAM,CAAC;AACpB,aAAK,MAAM;MACb;IACF;AACA,SAAK,UAAU,KAAK;AACpB,SAAK,WAAU;AACf,WAAO;EACT;EACA,WAAW,KAAe;AACxB,YAAQ,IAAI;AACZ,YAAQ,KAAK,IAAI;AACjB,SAAK,WAAW;AAIhB,UAAM,EAAE,QAAAD,SAAQ,MAAM,UAAU,MAAAF,MAAI,IAAK;AACzC,QAAI,EAAE,IAAG,IAAK;AAEd,IAAAE,QAAO,KAAK,IAAI;AAChB,UAAM,KAAK,OAAO,SAAS,GAAG,CAAC;AAG/B,QAAI,KAAK,YAAY,WAAW,KAAK;AACnC,WAAK,QAAQ,MAAM,CAAC;AACpB,YAAM;IACR;AAEA,aAAS,IAAI,KAAK,IAAI,UAAU;AAAK,MAAAA,QAAO,CAAC,IAAI;AAIjD,iBAAa,MAAM,WAAW,GAAG,OAAO,KAAK,SAAS,CAAC,GAAGF,KAAI;AAC9D,SAAK,QAAQ,MAAM,CAAC;AACpB,UAAM,QAAQ,WAAW,GAAG;AAC5B,UAAM,MAAM,KAAK;AAEjB,QAAI,MAAM;AAAG,YAAM,IAAI,MAAM,6CAA6C;AAC1E,UAAM,SAAS,MAAM;AACrB,UAAM,QAAQ,KAAK,IAAG;AACtB,QAAI,SAAS,MAAM;AAAQ,YAAM,IAAI,MAAM,oCAAoC;AAC/E,aAAS,IAAI,GAAG,IAAI,QAAQ;AAAK,YAAM,UAAU,IAAI,GAAG,MAAM,CAAC,GAAGA,KAAI;EACxE;EACA,SAAM;AACJ,UAAM,EAAE,QAAAE,SAAQ,UAAS,IAAK;AAC9B,SAAK,WAAWA,OAAM;AACtB,UAAM,MAAMA,QAAO,MAAM,GAAG,SAAS;AACrC,SAAK,QAAO;AACZ,WAAO;EACT;EACA,WAAW,IAAM;AACf,WAAA,KAAO,IAAK,KAAK,YAAmB;AACpC,OAAG,IAAI,GAAG,KAAK,IAAG,CAAE;AACpB,UAAM,EAAE,UAAU,QAAAA,SAAQ,QAAQ,UAAU,WAAW,IAAG,IAAK;AAC/D,OAAG,YAAY;AACf,OAAG,WAAW;AACd,OAAG,SAAS;AACZ,OAAG,MAAM;AACT,QAAI,SAAS;AAAU,SAAG,OAAO,IAAIA,OAAM;AAC3C,WAAO;EACT;EACA,QAAK;AACH,WAAO,KAAK,WAAU;EACxB;;AASK,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGM,IAAM,YAAyC,YAAY,KAAK;EACrE;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;;;AC1KD,IAAM,aAA6B,OAAO,KAAK,KAAK,CAAC;AACrD,IAAM,OAAuB,OAAO,EAAE;AAEtC,SAAS,QACP,GACA,KAAK,OAAK;AAKV,MAAI;AAAI,WAAO,EAAE,GAAG,OAAO,IAAI,UAAU,GAAG,GAAG,OAAQ,KAAK,OAAQ,UAAU,EAAC;AAC/E,SAAO,EAAE,GAAG,OAAQ,KAAK,OAAQ,UAAU,IAAI,GAAG,GAAG,OAAO,IAAI,UAAU,IAAI,EAAC;AACjF;AAEA,SAAS,MAAM,KAAe,KAAK,OAAK;AACtC,QAAM,MAAM,IAAI;AAChB,MAAI,KAAK,IAAI,YAAY,GAAG;AAC5B,MAAI,KAAK,IAAI,YAAY,GAAG;AAC5B,WAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC5B,UAAM,EAAE,GAAG,EAAC,IAAK,QAAQ,IAAI,CAAC,GAAG,EAAE;AACnC,KAAC,GAAG,CAAC,GAAG,GAAG,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC;EACxB;AACA,SAAO,CAAC,IAAI,EAAE;AAChB;AAIA,IAAM,QAAQ,CAAC,GAAW,IAAY,MAAsB,MAAM;AAClE,IAAM,QAAQ,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAM;AAEpF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,MAAM,IAAM,KAAM,KAAK;AACpF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAM;AAErF,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,KAAM,KAAK,IAAO,MAAO,IAAI;AAC1F,IAAM,SAAS,CAAC,GAAW,GAAW,MAAuB,MAAO,IAAI,KAAQ,KAAM,KAAK;AAa3F,SAAS,IACP,IACA,IACA,IACA,IAAU;AAKV,QAAM,KAAK,OAAO,MAAM,OAAO;AAC/B,SAAO,EAAE,GAAI,KAAK,MAAO,IAAI,KAAK,KAAM,KAAM,GAAG,GAAG,IAAI,EAAC;AAC3D;AAEA,IAAM,QAAQ,CAAC,IAAY,IAAY,QAAwB,OAAO,MAAM,OAAO,MAAM,OAAO;AAChG,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,OACjD,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;AAC3C,IAAM,QAAQ,CAAC,IAAY,IAAY,IAAY,QAChD,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO;AACjD,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,IAAY,OAC7D,KAAK,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;AAChD,IAAM,QAAQ,CAAC,IAAY,IAAY,IAAY,IAAY,QAC5D,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO,MAAM,OAAO;AAC9D,IAAM,QAAQ,CAAC,KAAa,IAAY,IAAY,IAAY,IAAY,OACzE,KAAK,KAAK,KAAK,KAAK,MAAO,MAAM,KAAK,KAAM,KAAM;;;AC3DrD,IAAM,WAA2B,YAAY,KAAK;EAChD;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGD,IAAM,WAA2B,IAAI,YAAY,EAAE;AAC7C,IAAO,SAAP,cAAsB,OAAc;EAYxC,YAAY,YAAoB,IAAE;AAChC,UAAM,IAAI,WAAW,GAAG,KAAK;AAVrB,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;EAIrC;EACU,MAAG;AACX,UAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC,IAAK;AACnC,WAAO,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EAChC;;EAEU,IACR,GAAW,GAAW,GAAW,GAAW,GAAW,GAAW,GAAW,GAAS;AAEtF,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;EACf;EACU,QAAQ,MAAgB,QAAc;AAE9C,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,UAAU;AAAG,eAAS,CAAC,IAAI,KAAK,UAAU,QAAQ,KAAK;AACpF,aAAS,IAAI,IAAI,IAAI,IAAI,KAAK;AAC5B,YAAM,MAAM,SAAS,IAAI,EAAE;AAC3B,YAAM,KAAK,SAAS,IAAI,CAAC;AACzB,YAAM,KAAK,KAAK,KAAK,CAAC,IAAI,KAAK,KAAK,EAAE,IAAK,QAAQ;AACnD,YAAM,KAAK,KAAK,IAAI,EAAE,IAAI,KAAK,IAAI,EAAE,IAAK,OAAO;AACjD,eAAS,CAAC,IAAK,KAAK,SAAS,IAAI,CAAC,IAAI,KAAK,SAAS,IAAI,EAAE,IAAK;IACjE;AAEA,QAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAC,IAAK;AACjC,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,SAAS,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,EAAE,IAAI,KAAK,GAAG,EAAE;AACpD,YAAM,KAAM,IAAI,SAAS,IAAI,GAAG,GAAG,CAAC,IAAI,SAAS,CAAC,IAAI,SAAS,CAAC,IAAK;AACrE,YAAM,SAAS,KAAK,GAAG,CAAC,IAAI,KAAK,GAAG,EAAE,IAAI,KAAK,GAAG,EAAE;AACpD,YAAM,KAAM,SAAS,IAAI,GAAG,GAAG,CAAC,IAAK;AACrC,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAK,IAAI,KAAM;AACf,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAK,KAAK,KAAM;IAClB;AAEA,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,QAAK,IAAI,KAAK,IAAK;AACnB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EACjC;EACU,aAAU;AAClB,UAAM,QAAQ;EAChB;EACA,UAAO;AACL,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC/B,UAAM,KAAK,MAAM;EACnB;;AAGI,IAAO,SAAP,cAAsB,OAAM;EAShC,cAAA;AACE,UAAM,EAAE;AATA,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;AAC3B,SAAA,IAAY,UAAU,CAAC,IAAI;EAGrC;;AAQF,IAAM,QAAwB,MAAU,MAAM;EAC5C;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE;EAAsB;EAAsB;EAAsB;EAClE,IAAI,OAAK,OAAO,CAAC,CAAC,CAAC,GAAE;AACvB,IAAM,aAA6B,MAAM,KAAK,CAAC,GAAE;AACjD,IAAM,aAA6B,MAAM,KAAK,CAAC,GAAE;AAGjD,IAAM,aAA6B,IAAI,YAAY,EAAE;AACrD,IAAM,aAA6B,IAAI,YAAY,EAAE;AAE/C,IAAO,SAAP,cAAsB,OAAc;EAqBxC,YAAY,YAAoB,IAAE;AAChC,UAAM,KAAK,WAAW,IAAI,KAAK;AAlBvB,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;EAIvC;;EAEU,MAAG;AAIX,UAAM,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAE,IAAK;AAC3E,WAAO,CAAC,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;EACxE;;EAEU,IACR,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IACpF,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAY,IAAU;AAE9F,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;AACf,SAAK,KAAK,KAAK;EACjB;EACU,QAAQ,MAAgB,QAAc;AAE9C,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,UAAU,GAAG;AACxC,iBAAW,CAAC,IAAI,KAAK,UAAU,MAAM;AACrC,iBAAW,CAAC,IAAI,KAAK,UAAW,UAAU,CAAE;IAC9C;AACA,aAAS,IAAI,IAAI,IAAI,IAAI,KAAK;AAE5B,YAAM,OAAO,WAAW,IAAI,EAAE,IAAI;AAClC,YAAM,OAAO,WAAW,IAAI,EAAE,IAAI;AAClC,YAAM,MAAU,OAAO,MAAM,MAAM,CAAC,IAAQ,OAAO,MAAM,MAAM,CAAC,IAAQ,MAAM,MAAM,MAAM,CAAC;AAC3F,YAAM,MAAU,OAAO,MAAM,MAAM,CAAC,IAAQ,OAAO,MAAM,MAAM,CAAC,IAAQ,MAAM,MAAM,MAAM,CAAC;AAE3F,YAAM,MAAM,WAAW,IAAI,CAAC,IAAI;AAChC,YAAM,MAAM,WAAW,IAAI,CAAC,IAAI;AAChC,YAAM,MAAU,OAAO,KAAK,KAAK,EAAE,IAAQ,OAAO,KAAK,KAAK,EAAE,IAAQ,MAAM,KAAK,KAAK,CAAC;AACvF,YAAM,MAAU,OAAO,KAAK,KAAK,EAAE,IAAQ,OAAO,KAAK,KAAK,EAAE,IAAQ,MAAM,KAAK,KAAK,CAAC;AAEvF,YAAM,OAAW,MAAM,KAAK,KAAK,WAAW,IAAI,CAAC,GAAG,WAAW,IAAI,EAAE,CAAC;AACtE,YAAM,OAAW,MAAM,MAAM,KAAK,KAAK,WAAW,IAAI,CAAC,GAAG,WAAW,IAAI,EAAE,CAAC;AAC5E,iBAAW,CAAC,IAAI,OAAO;AACvB,iBAAW,CAAC,IAAI,OAAO;IACzB;AACA,QAAI,EAAE,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,GAAE,IAAK;AAEzE,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAE3B,YAAM,UAAc,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE;AACvF,YAAM,UAAc,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE;AAEvF,YAAM,OAAQ,KAAK,KAAO,CAAC,KAAK;AAChC,YAAM,OAAQ,KAAK,KAAO,CAAC,KAAK;AAGhC,YAAM,OAAW,MAAM,IAAI,SAAS,MAAM,UAAU,CAAC,GAAG,WAAW,CAAC,CAAC;AACrE,YAAM,MAAU,MAAM,MAAM,IAAI,SAAS,MAAM,UAAU,CAAC,GAAG,WAAW,CAAC,CAAC;AAC1E,YAAM,MAAM,OAAO;AAEnB,YAAM,UAAc,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE;AACvF,YAAM,UAAc,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE,IAAQ,OAAO,IAAI,IAAI,EAAE;AACvF,YAAM,OAAQ,KAAK,KAAO,KAAK,KAAO,KAAK;AAC3C,YAAM,OAAQ,KAAK,KAAO,KAAK,KAAO,KAAK;AAC3C,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,OAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,GAAG,KAAK,GAAG,MAAM,GAAG,MAAM,CAAC;AAC5D,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,WAAK,KAAK;AACV,YAAM,MAAU,MAAM,KAAK,SAAS,IAAI;AACxC,WAAS,MAAM,KAAK,KAAK,SAAS,IAAI;AACtC,WAAK,MAAM;IACb;AAEA,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,KAAC,EAAE,GAAG,IAAI,GAAG,GAAE,IAAS,IAAI,KAAK,KAAK,GAAG,KAAK,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC;AACpE,SAAK,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI,EAAE;EACzE;EACU,aAAU;AAClB,UAAM,YAAY,UAAU;EAC9B;EACA,UAAO;AACL,UAAM,KAAK,MAAM;AACjB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;EACzD;;AAGI,IAAO,SAAP,cAAsB,OAAM;EAkBhC,cAAA;AACE,UAAM,EAAE;AAlBA,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,CAAC,IAAI;AAC5B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;AAC7B,SAAA,KAAa,UAAU,EAAE,IAAI;EAIvC;;AAWF,IAAM,UAA0B,YAAY,KAAK;EAC/C;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAGD,IAAM,UAA0B,YAAY,KAAK;EAC/C;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EACpF;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;EAAY;CACrF;AAEK,IAAO,aAAP,cAA0B,OAAM;EAkBpC,cAAA;AACE,UAAM,EAAE;AAlBA,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;EAIrC;;AAGI,IAAO,aAAP,cAA0B,OAAM;EAkBpC,cAAA;AACE,UAAM,EAAE;AAlBA,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,CAAC,IAAI;AAC1B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;AAC3B,SAAA,KAAa,QAAQ,EAAE,IAAI;EAIrC;;AAUK,IAAM,SAAgC,aAAa,MAAM,IAAI,OAAM,CAAE;AAErE,IAAM,SAAgC,aAAa,MAAM,IAAI,OAAM,CAAE;AAGrE,IAAM,SAAgC,aAAa,MAAM,IAAI,OAAM,CAAE;AAErE,IAAM,SAAgC,aAAa,MAAM,IAAI,OAAM,CAAE;AAMrE,IAAM,aAAoC,aAAa,MAAM,IAAI,WAAU,CAAE;AAK7E,IAAM,aAAoC,aAAa,MAAM,IAAI,WAAU,CAAE;;;AC1XpF,IAAM,MAAsB,OAAO,CAAC;AACpC,IAAM,MAAsB,OAAO,CAAC;AAgB9B,SAAU,QAAQ,OAAgB,QAAgB,IAAE;AACxD,MAAI,OAAO,UAAU,WAAW;AAC9B,UAAM,SAAS,SAAS,IAAI,KAAK;AACjC,UAAM,IAAI,MAAM,SAAS,gCAAgC,OAAO,KAAK;EACvE;AACA,SAAO;AACT;AAIM,SAAU,SAAS,OAAmB,QAAiB,QAAgB,IAAE;AAC7E,QAAME,SAAQ,QAAS,KAAK;AAC5B,QAAM,MAAM,+BAAO;AACnB,QAAM,WAAW,WAAW;AAC5B,MAAI,CAACA,UAAU,YAAY,QAAQ,QAAS;AAC1C,UAAM,SAAS,SAAS,IAAI,KAAK;AACjC,UAAM,QAAQ,WAAW,cAAc,MAAM,KAAK;AAClD,UAAM,MAAMA,SAAQ,UAAU,GAAG,KAAK,QAAQ,OAAO,KAAK;AAC1D,UAAM,IAAI,MAAM,SAAS,wBAAwB,QAAQ,WAAW,GAAG;EACzE;AACA,SAAO;AACT;AAQM,SAAU,YAAY,KAAW;AACrC,MAAI,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,8BAA8B,OAAO,GAAG;AACrF,SAAO,QAAQ,KAAK,MAAM,OAAO,OAAO,GAAG;AAC7C;AAGM,SAAU,gBAAgBC,QAAiB;AAC/C,SAAO,YAAY,WAAYA,MAAK,CAAC;AACvC;AACM,SAAU,gBAAgBA,QAAiB;AAC/C,SAAQA,MAAK;AACb,SAAO,YAAY,WAAY,WAAW,KAAKA,MAAK,EAAE,QAAO,CAAE,CAAC;AAClE;AAEM,SAAU,gBAAgB,GAAoB,KAAW;AAC7D,SAAO,WAAY,EAAE,SAAS,EAAE,EAAE,SAAS,MAAM,GAAG,GAAG,CAAC;AAC1D;AACM,SAAU,gBAAgB,GAAoB,KAAW;AAC7D,SAAO,gBAAgB,GAAG,GAAG,EAAE,QAAO;AACxC;AAeM,SAAU,YAAY,OAAe,KAAU,gBAAuB;AAC1E,MAAI;AACJ,MAAI,OAAO,QAAQ,UAAU;AAC3B,QAAI;AACF,YAAM,WAAY,GAAG;IACvB,SAAS,GAAG;AACV,YAAM,IAAI,MAAM,QAAQ,+CAA+C,CAAC;IAC1E;EACF,WAAW,QAAS,GAAG,GAAG;AAGxB,UAAM,WAAW,KAAK,GAAG;EAC3B,OAAO;AACL,UAAM,IAAI,MAAM,QAAQ,mCAAmC;EAC7D;AACA,QAAM,MAAM,IAAI;AAChB,MAAI,OAAO,mBAAmB,YAAY,QAAQ;AAChD,UAAM,IAAI,MAAM,QAAQ,gBAAgB,iBAAiB,oBAAoB,GAAG;AAClF,SAAO;AACT;AAGM,SAAU,WAAW,GAAe,GAAa;AACrD,MAAI,EAAE,WAAW,EAAE;AAAQ,WAAO;AAClC,MAAI,OAAO;AACX,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ;AAAK,YAAQ,EAAE,CAAC,IAAI,EAAE,CAAC;AACrD,SAAO,SAAS;AAClB;AAKM,SAAU,UAAUC,QAAiB;AACzC,SAAO,WAAW,KAAKA,MAAK;AAC9B;AA8BA,IAAM,WAAW,CAAC,MAAc,OAAO,MAAM,YAAY,OAAO;AAE1D,SAAU,QAAQ,GAAWC,MAAaC,MAAW;AACzD,SAAO,SAAS,CAAC,KAAK,SAASD,IAAG,KAAK,SAASC,IAAG,KAAKD,QAAO,KAAK,IAAIC;AAC1E;AAOM,SAAU,SAAS,OAAe,GAAWD,MAAaC,MAAW;AAMzE,MAAI,CAAC,QAAQ,GAAGD,MAAKC,IAAG;AACtB,UAAM,IAAI,MAAM,oBAAoB,QAAQ,OAAOD,OAAM,aAAaC,OAAM,WAAW,CAAC;AAC5F;AASM,SAAU,OAAO,GAAS;AAC9B,MAAI;AACJ,OAAK,MAAM,GAAG,IAAI,KAAK,MAAM,KAAK,OAAO;AAAE;AAC3C,SAAO;AACT;AAsBO,IAAM,UAAU,CAAC,OAAuB,OAAO,OAAO,CAAC,KAAK;AA+G7D,SAAU,OAAO,KAAU;AAC/B,SAAO,OAAO,QAAQ,cAAc,OAAO,cAAc,IAAI,SAAS;AACxE;AACM,SAAU,gBACdC,SACA,QACA,YAAoC,CAAA,GAAE;AAEtC,MAAI,CAACA,WAAU,OAAOA,YAAW;AAAU,UAAM,IAAI,MAAM,+BAA+B;AAE1F,WAAS,WAAW,WAAiB,cAAsB,OAAc;AACvE,UAAM,MAAMA,QAAO,SAAS;AAC5B,QAAI,SAAS,QAAQ;AAAW;AAChC,UAAMC,WAAU,OAAO;AACvB,QAAIA,aAAY,gBAAgB,QAAQ;AACtC,YAAM,IAAI,MAAM,UAAU,SAAS,0BAA0B,YAAY,SAASA,QAAO,EAAE;EAC/F;AACA,SAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM,WAAW,GAAG,GAAG,KAAK,CAAC;AAClE,SAAO,QAAQ,SAAS,EAAE,QAAQ,CAAC,CAAC,GAAG,CAAC,MAAM,WAAW,GAAG,GAAG,IAAI,CAAC;AACtE;AAKO,IAAM,iBAAiB,MAAY;AACxC,QAAM,IAAI,MAAM,iBAAiB;AACnC;AAMM,SAAU,SACd,IAA6B;AAE7B,QAAMC,OAAM,oBAAI,QAAO;AACvB,SAAO,CAAC,QAAW,SAAc;AAC/B,UAAM,MAAMA,KAAI,IAAI,GAAG;AACvB,QAAI,QAAQ;AAAW,aAAO;AAC9B,UAAM,WAAW,GAAG,KAAK,GAAG,IAAI;AAChC,IAAAA,KAAI,IAAI,KAAK,QAAQ;AACrB,WAAO;EACT;AACF;;;ACpWA,IAAMC,OAAM,OAAO,CAAC;AAApB,IAAuBC,OAAM,OAAO,CAAC;AAArC,IAAwC,MAAsB,OAAO,CAAC;AAAtE,IAAyE,MAAsB,OAAO,CAAC;AAEvG,IAAM,MAAsB,OAAO,CAAC;AAApC,IAAuC,MAAsB,OAAO,CAAC;AAArE,IAAwE,MAAsB,OAAO,CAAC;AAEtG,IAAM,MAAsB,OAAO,CAAC;AAApC,IAAuC,MAAsB,OAAO,CAAC;AAArE,IAAwE,OAAuB,OAAO,EAAE;AAGlG,SAAU,IAAI,GAAW,GAAS;AACtC,QAAM,SAAS,IAAI;AACnB,SAAO,UAAUD,OAAM,SAAS,IAAI;AACtC;AAYM,SAAU,KAAK,GAAW,OAAe,QAAc;AAC3D,MAAI,MAAM;AACV,SAAO,UAAUE,MAAK;AACpB,WAAO;AACP,WAAO;EACT;AACA,SAAO;AACT;AAMM,SAAU,OAAOC,SAAgB,QAAc;AACnD,MAAIA,YAAWD;AAAK,UAAM,IAAI,MAAM,kCAAkC;AACtE,MAAI,UAAUA;AAAK,UAAM,IAAI,MAAM,4CAA4C,MAAM;AAErF,MAAI,IAAI,IAAIC,SAAQ,MAAM;AAC1B,MAAI,IAAI;AAER,MAAI,IAAID,MAAK,IAAIE,MAAK,IAAIA,MAAK,IAAIF;AACnC,SAAO,MAAMA,MAAK;AAEhB,UAAM,IAAI,IAAI;AACd,UAAM,IAAI,IAAI;AACd,UAAM,IAAI,IAAI,IAAI;AAClB,UAAM,IAAI,IAAI,IAAI;AAElB,QAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI;EACzC;AACA,QAAM,MAAM;AACZ,MAAI,QAAQE;AAAK,UAAM,IAAI,MAAM,wBAAwB;AACzD,SAAO,IAAI,GAAG,MAAM;AACtB;AAEA,SAAS,eAAkBC,KAAe,MAAS,GAAI;AACrD,MAAI,CAACA,IAAG,IAAIA,IAAG,IAAI,IAAI,GAAG,CAAC;AAAG,UAAM,IAAI,MAAM,yBAAyB;AACzE;AAMA,SAAS,UAAaA,KAAe,GAAI;AACvC,QAAM,UAAUA,IAAG,QAAQD,QAAO;AAClC,QAAM,OAAOC,IAAG,IAAI,GAAG,MAAM;AAC7B,iBAAeA,KAAI,MAAM,CAAC;AAC1B,SAAO;AACT;AAEA,SAAS,UAAaA,KAAe,GAAI;AACvC,QAAM,UAAUA,IAAG,QAAQ,OAAO;AAClC,QAAM,KAAKA,IAAG,IAAI,GAAG,GAAG;AACxB,QAAM,IAAIA,IAAG,IAAI,IAAI,MAAM;AAC3B,QAAM,KAAKA,IAAG,IAAI,GAAG,CAAC;AACtB,QAAM,IAAIA,IAAG,IAAIA,IAAG,IAAI,IAAI,GAAG,GAAG,CAAC;AACnC,QAAM,OAAOA,IAAG,IAAI,IAAIA,IAAG,IAAI,GAAGA,IAAG,GAAG,CAAC;AACzC,iBAAeA,KAAI,MAAM,CAAC;AAC1B,SAAO;AACT;AAIA,SAAS,WAAW,GAAS;AAC3B,QAAM,MAAM,MAAM,CAAC;AACnB,QAAM,KAAK,cAAc,CAAC;AAC1B,QAAM,KAAK,GAAG,KAAK,IAAI,IAAI,IAAI,GAAG,CAAC;AACnC,QAAM,KAAK,GAAG,KAAK,EAAE;AACrB,QAAM,KAAK,GAAG,KAAK,IAAI,IAAI,EAAE,CAAC;AAC9B,QAAM,MAAM,IAAI,OAAO;AACvB,SAAO,CAAIA,KAAe,MAAQ;AAChC,QAAI,MAAMA,IAAG,IAAI,GAAG,EAAE;AACtB,QAAI,MAAMA,IAAG,IAAI,KAAK,EAAE;AACxB,UAAM,MAAMA,IAAG,IAAI,KAAK,EAAE;AAC1B,UAAM,MAAMA,IAAG,IAAI,KAAK,EAAE;AAC1B,UAAM,KAAKA,IAAG,IAAIA,IAAG,IAAI,GAAG,GAAG,CAAC;AAChC,UAAM,KAAKA,IAAG,IAAIA,IAAG,IAAI,GAAG,GAAG,CAAC;AAChC,UAAMA,IAAG,KAAK,KAAK,KAAK,EAAE;AAC1B,UAAMA,IAAG,KAAK,KAAK,KAAK,EAAE;AAC1B,UAAM,KAAKA,IAAG,IAAIA,IAAG,IAAI,GAAG,GAAG,CAAC;AAChC,UAAM,OAAOA,IAAG,KAAK,KAAK,KAAK,EAAE;AACjC,mBAAeA,KAAI,MAAM,CAAC;AAC1B,WAAO;EACT;AACF;AASM,SAAU,cAAc,GAAS;AAGrC,MAAI,IAAI;AAAK,UAAM,IAAI,MAAM,qCAAqC;AAElE,MAAI,IAAI,IAAID;AACZ,MAAI,IAAI;AACR,SAAO,IAAI,QAAQF,MAAK;AACtB,SAAK;AACL;EACF;AAGA,MAAI,IAAI;AACR,QAAM,MAAM,MAAM,CAAC;AACnB,SAAO,WAAW,KAAK,CAAC,MAAM,GAAG;AAG/B,QAAI,MAAM;AAAM,YAAM,IAAI,MAAM,+CAA+C;EACjF;AAEA,MAAI,MAAM;AAAG,WAAO;AAIpB,MAAI,KAAK,IAAI,IAAI,GAAG,CAAC;AACrB,QAAM,UAAU,IAAIE,QAAO;AAC3B,SAAO,SAAS,YAAeC,KAAe,GAAI;AAChD,QAAIA,IAAG,IAAI,CAAC;AAAG,aAAO;AAEtB,QAAI,WAAWA,KAAI,CAAC,MAAM;AAAG,YAAM,IAAI,MAAM,yBAAyB;AAGtE,QAAI,IAAI;AACR,QAAI,IAAIA,IAAG,IAAIA,IAAG,KAAK,EAAE;AACzB,QAAI,IAAIA,IAAG,IAAI,GAAG,CAAC;AACnB,QAAI,IAAIA,IAAG,IAAI,GAAG,MAAM;AAIxB,WAAO,CAACA,IAAG,IAAI,GAAGA,IAAG,GAAG,GAAG;AACzB,UAAIA,IAAG,IAAI,CAAC;AAAG,eAAOA,IAAG;AACzB,UAAI,IAAI;AAGR,UAAI,QAAQA,IAAG,IAAI,CAAC;AACpB,aAAO,CAACA,IAAG,IAAI,OAAOA,IAAG,GAAG,GAAG;AAC7B;AACA,gBAAQA,IAAG,IAAI,KAAK;AACpB,YAAI,MAAM;AAAG,gBAAM,IAAI,MAAM,yBAAyB;MACxD;AAGA,YAAM,WAAWD,QAAO,OAAO,IAAI,IAAI,CAAC;AACxC,YAAM,IAAIC,IAAG,IAAI,GAAG,QAAQ;AAG5B,UAAI;AACJ,UAAIA,IAAG,IAAI,CAAC;AACZ,UAAIA,IAAG,IAAI,GAAG,CAAC;AACf,UAAIA,IAAG,IAAI,GAAG,CAAC;IACjB;AACA,WAAO;EACT;AACF;AAaM,SAAU,OAAO,GAAS;AAE9B,MAAI,IAAI,QAAQ;AAAK,WAAO;AAE5B,MAAI,IAAI,QAAQ;AAAK,WAAO;AAE5B,MAAI,IAAI,SAAS;AAAK,WAAO,WAAW,CAAC;AAEzC,SAAO,cAAc,CAAC;AACxB;AAGO,IAAM,eAAe,CAAC,KAAa,YACvC,IAAI,KAAK,MAAM,IAAID,UAASA;AA+C/B,IAAM,eAAe;EACnB;EAAU;EAAW;EAAO;EAAO;EAAO;EAAQ;EAClD;EAAO;EAAO;EAAO;EAAO;EAAO;EACnC;EAAQ;EAAQ;EAAQ;;AAEpB,SAAU,cAAiB,OAAgB;AAC/C,QAAM,UAAU;IACd,OAAO;IACP,MAAM;IACN,OAAO;IACP,MAAM;;AAER,QAAM,OAAO,aAAa,OAAO,CAACE,MAAK,QAAe;AACpD,IAAAA,KAAI,GAAG,IAAI;AACX,WAAOA;EACT,GAAG,OAAO;AACV,kBAAgB,OAAO,IAAI;AAI3B,SAAO;AACT;AAQM,SAAU,MAASD,KAAe,KAAQ,OAAa;AAC3D,MAAI,QAAQH;AAAK,UAAM,IAAI,MAAM,yCAAyC;AAC1E,MAAI,UAAUA;AAAK,WAAOG,IAAG;AAC7B,MAAI,UAAUD;AAAK,WAAO;AAC1B,MAAI,IAAIC,IAAG;AACX,MAAI,IAAI;AACR,SAAO,QAAQH,MAAK;AAClB,QAAI,QAAQE;AAAK,UAAIC,IAAG,IAAI,GAAG,CAAC;AAChC,QAAIA,IAAG,IAAI,CAAC;AACZ,cAAUD;EACZ;AACA,SAAO;AACT;AAOM,SAAU,cAAiBC,KAAe,MAAW,WAAW,OAAK;AACzE,QAAM,WAAW,IAAI,MAAM,KAAK,MAAM,EAAE,KAAK,WAAWA,IAAG,OAAO,MAAS;AAE3E,QAAM,gBAAgB,KAAK,OAAO,CAAC,KAAK,KAAK,MAAK;AAChD,QAAIA,IAAG,IAAI,GAAG;AAAG,aAAO;AACxB,aAAS,CAAC,IAAI;AACd,WAAOA,IAAG,IAAI,KAAK,GAAG;EACxB,GAAGA,IAAG,GAAG;AAET,QAAM,cAAcA,IAAG,IAAI,aAAa;AAExC,OAAK,YAAY,CAAC,KAAK,KAAK,MAAK;AAC/B,QAAIA,IAAG,IAAI,GAAG;AAAG,aAAO;AACxB,aAAS,CAAC,IAAIA,IAAG,IAAI,KAAK,SAAS,CAAC,CAAC;AACrC,WAAOA,IAAG,IAAI,KAAK,GAAG;EACxB,GAAG,WAAW;AACd,SAAO;AACT;AAgBM,SAAU,WAAcE,KAAe,GAAI;AAG/C,QAAM,UAAUA,IAAG,QAAQC,QAAO;AAClC,QAAM,UAAUD,IAAG,IAAI,GAAG,MAAM;AAChC,QAAM,MAAMA,IAAG,IAAI,SAASA,IAAG,GAAG;AAClC,QAAM,OAAOA,IAAG,IAAI,SAASA,IAAG,IAAI;AACpC,QAAM,KAAKA,IAAG,IAAI,SAASA,IAAG,IAAIA,IAAG,GAAG,CAAC;AACzC,MAAI,CAAC,OAAO,CAAC,QAAQ,CAAC;AAAI,UAAM,IAAI,MAAM,gCAAgC;AAC1E,SAAO,MAAM,IAAI,OAAO,IAAI;AAC9B;AAUM,SAAU,QAAQ,GAAW,YAAmB;AAEpD,MAAI,eAAe;AAAW,YAAQ,UAAU;AAChD,QAAM,cAAc,eAAe,SAAY,aAAa,EAAE,SAAS,CAAC,EAAE;AAC1E,QAAM,cAAc,KAAK,KAAK,cAAc,CAAC;AAC7C,SAAO,EAAE,YAAY,aAAa,YAAW;AAC/C;AA8BM,SAAU,MACd,OACA,cACAE,QAAO,OACP,OAA0B,CAAA,GAAE;AAE5B,MAAI,SAASC;AAAK,UAAM,IAAI,MAAM,4CAA4C,KAAK;AACnF,MAAI,cAAkC;AACtC,MAAI,QAA4B;AAChC,MAAI,eAAwB;AAC5B,MAAI,iBAAgD;AACpD,MAAI,OAAO,iBAAiB,YAAY,gBAAgB,MAAM;AAC5D,QAAI,KAAK,QAAQD;AAAM,YAAM,IAAI,MAAM,sCAAsC;AAC7E,UAAM,QAAQ;AACd,QAAI,MAAM;AAAM,oBAAc,MAAM;AACpC,QAAI,MAAM;AAAM,cAAQ,MAAM;AAC9B,QAAI,OAAO,MAAM,SAAS;AAAW,MAAAA,QAAO,MAAM;AAClD,QAAI,OAAO,MAAM,iBAAiB;AAAW,qBAAe,MAAM;AAClE,qBAAiB,MAAM;EACzB,OAAO;AACL,QAAI,OAAO,iBAAiB;AAAU,oBAAc;AACpD,QAAI,KAAK;AAAM,cAAQ,KAAK;EAC9B;AACA,QAAM,EAAE,YAAY,MAAM,aAAa,MAAK,IAAK,QAAQ,OAAO,WAAW;AAC3E,MAAI,QAAQ;AAAM,UAAM,IAAI,MAAM,gDAAgD;AAClF,MAAI;AACJ,QAAME,KAAuB,OAAO,OAAO;IACzC;IACA,MAAAF;IACA;IACA;IACA,MAAM,QAAQ,IAAI;IAClB,MAAMC;IACN,KAAKE;IACL;IACA,QAAQ,CAAC,QAAQ,IAAI,KAAK,KAAK;IAC/B,SAAS,CAAC,QAAO;AACf,UAAI,OAAO,QAAQ;AACjB,cAAM,IAAI,MAAM,iDAAiD,OAAO,GAAG;AAC7E,aAAOF,QAAO,OAAO,MAAM;IAC7B;IACA,KAAK,CAAC,QAAQ,QAAQA;;IAEtB,aAAa,CAAC,QAAgB,CAACC,GAAE,IAAI,GAAG,KAAKA,GAAE,QAAQ,GAAG;IAC1D,OAAO,CAAC,SAAS,MAAMC,UAASA;IAChC,KAAK,CAAC,QAAQ,IAAI,CAAC,KAAK,KAAK;IAC7B,KAAK,CAAC,KAAK,QAAQ,QAAQ;IAE3B,KAAK,CAAC,QAAQ,IAAI,MAAM,KAAK,KAAK;IAClC,KAAK,CAAC,KAAK,QAAQ,IAAI,MAAM,KAAK,KAAK;IACvC,KAAK,CAAC,KAAK,QAAQ,IAAI,MAAM,KAAK,KAAK;IACvC,KAAK,CAAC,KAAK,QAAQ,IAAI,MAAM,KAAK,KAAK;IACvC,KAAK,CAAC,KAAK,UAAU,MAAMD,IAAG,KAAK,KAAK;IACxC,KAAK,CAAC,KAAK,QAAQ,IAAI,MAAM,OAAO,KAAK,KAAK,GAAG,KAAK;;IAGtD,MAAM,CAAC,QAAQ,MAAM;IACrB,MAAM,CAAC,KAAK,QAAQ,MAAM;IAC1B,MAAM,CAAC,KAAK,QAAQ,MAAM;IAC1B,MAAM,CAAC,KAAK,QAAQ,MAAM;IAE1B,KAAK,CAAC,QAAQ,OAAO,KAAK,KAAK;IAC/B,MACE,UACC,CAAC,MAAK;AACL,UAAI,CAAC;AAAO,gBAAQ,OAAO,KAAK;AAChC,aAAO,MAAMA,IAAG,CAAC;IACnB;IACF,SAAS,CAAC,QAASF,QAAO,gBAAgB,KAAK,KAAK,IAAI,gBAAgB,KAAK,KAAK;IAClF,WAAW,CAACI,QAAO,iBAAiB,SAAQ;AAC1C,UAAI,gBAAgB;AAClB,YAAI,CAAC,eAAe,SAASA,OAAM,MAAM,KAAKA,OAAM,SAAS,OAAO;AAClE,gBAAM,IAAI,MACR,+BAA+B,iBAAiB,iBAAiBA,OAAM,MAAM;QAEjF;AACA,cAAM,SAAS,IAAI,WAAW,KAAK;AAEnC,eAAO,IAAIA,QAAOJ,QAAO,IAAI,OAAO,SAASI,OAAM,MAAM;AACzD,QAAAA,SAAQ;MACV;AACA,UAAIA,OAAM,WAAW;AACnB,cAAM,IAAI,MAAM,+BAA+B,QAAQ,iBAAiBA,OAAM,MAAM;AACtF,UAAI,SAASJ,QAAO,gBAAgBI,MAAK,IAAI,gBAAgBA,MAAK;AAClE,UAAI;AAAc,iBAAS,IAAI,QAAQ,KAAK;AAC5C,UAAI,CAAC;AACH,YAAI,CAACF,GAAE,QAAQ,MAAM;AAAG,gBAAM,IAAI,MAAM,kDAAkD;;AAG5F,aAAO;IACT;;IAEA,aAAa,CAAC,QAAQ,cAAcA,IAAG,GAAG;;;IAG1C,MAAM,CAAC,GAAG,GAAG,MAAO,IAAI,IAAI;GAClB;AACZ,SAAO,OAAO,OAAOA,EAAC;AACxB;AAsBM,SAAU,WAAcG,KAAe,KAAM;AACjD,MAAI,CAACA,IAAG;AAAO,UAAM,IAAI,MAAM,0BAA0B;AACzD,QAAM,OAAOA,IAAG,KAAK,GAAG;AACxB,SAAOA,IAAG,MAAM,IAAI,IAAIA,IAAG,IAAI,IAAI,IAAI;AACzC;;;AC3gBA,IAAMC,OAAM,OAAO,CAAC;AACpB,IAAMC,OAAM,OAAO,CAAC;AA0Id,SAAU,SAAwC,WAAoB,MAAO;AACjF,QAAM,MAAM,KAAK,OAAM;AACvB,SAAO,YAAY,MAAM;AAC3B;AAQM,SAAU,WACd,GACA,QAAW;AAEX,QAAM,aAAa,cACjB,EAAE,IACF,OAAO,IAAI,CAAC,MAAM,EAAE,CAAE,CAAC;AAEzB,SAAO,OAAO,IAAI,CAAC,GAAG,MAAM,EAAE,WAAW,EAAE,SAAS,WAAW,CAAC,CAAC,CAAC,CAAC;AACrE;AAEA,SAAS,UAAU,GAAW,MAAY;AACxC,MAAI,CAAC,OAAO,cAAc,CAAC,KAAK,KAAK,KAAK,IAAI;AAC5C,UAAM,IAAI,MAAM,uCAAuC,OAAO,cAAc,CAAC;AACjF;AAWA,SAAS,UAAU,GAAW,YAAkB;AAC9C,YAAU,GAAG,UAAU;AACvB,QAAM,UAAU,KAAK,KAAK,aAAa,CAAC,IAAI;AAC5C,QAAM,aAAa,MAAM,IAAI;AAC7B,QAAM,YAAY,KAAK;AACvB,QAAM,OAAO,QAAQ,CAAC;AACtB,QAAM,UAAU,OAAO,CAAC;AACxB,SAAO,EAAE,SAAS,YAAY,MAAM,WAAW,QAAO;AACxD;AAEA,SAAS,YAAY,GAAWC,SAAgB,OAAY;AAC1D,QAAM,EAAE,YAAY,MAAM,WAAW,QAAO,IAAK;AACjD,MAAI,QAAQ,OAAO,IAAI,IAAI;AAC3B,MAAI,QAAQ,KAAK;AAQjB,MAAI,QAAQ,YAAY;AAEtB,aAAS;AACT,aAASD;EACX;AACA,QAAM,cAAcC,UAAS;AAC7B,QAAM,SAAS,cAAc,KAAK,IAAI,KAAK,IAAI;AAC/C,QAAM,SAAS,UAAU;AACzB,QAAM,QAAQ,QAAQ;AACtB,QAAM,SAASA,UAAS,MAAM;AAC9B,QAAM,UAAU;AAChB,SAAO,EAAE,OAAO,QAAQ,QAAQ,OAAO,QAAQ,QAAO;AACxD;AAEA,SAAS,kBAAkB,QAAe,GAAM;AAC9C,MAAI,CAAC,MAAM,QAAQ,MAAM;AAAG,UAAM,IAAI,MAAM,gBAAgB;AAC5D,SAAO,QAAQ,CAAC,GAAG,MAAK;AACtB,QAAI,EAAE,aAAa;AAAI,YAAM,IAAI,MAAM,4BAA4B,CAAC;EACtE,CAAC;AACH;AACA,SAAS,mBAAmB,SAAgB,OAAU;AACpD,MAAI,CAAC,MAAM,QAAQ,OAAO;AAAG,UAAM,IAAI,MAAM,2BAA2B;AACxE,UAAQ,QAAQ,CAAC,GAAG,MAAK;AACvB,QAAI,CAAC,MAAM,QAAQ,CAAC;AAAG,YAAM,IAAI,MAAM,6BAA6B,CAAC;EACvE,CAAC;AACH;AAKA,IAAM,mBAAmB,oBAAI,QAAO;AACpC,IAAM,mBAAmB,oBAAI,QAAO;AAEpC,SAAS,KAAK,GAAM;AAGlB,SAAO,iBAAiB,IAAI,CAAC,KAAK;AACpC;AAEA,SAAS,QAAQ,GAAS;AACxB,MAAI,MAAMF;AAAK,UAAM,IAAI,MAAM,cAAc;AAC/C;AAoBM,IAAO,OAAP,MAAW;;EAOf,YAAY,OAAW,MAAY;AACjC,SAAK,OAAO,MAAM;AAClB,SAAK,OAAO,MAAM;AAClB,SAAK,KAAK,MAAM;AAChB,SAAK,OAAO;EACd;;EAGA,cAAc,KAAe,GAAW,IAAc,KAAK,MAAI;AAC7D,QAAI,IAAc;AAClB,WAAO,IAAIA,MAAK;AACd,UAAI,IAAIC;AAAK,YAAI,EAAE,IAAI,CAAC;AACxB,UAAI,EAAE,OAAM;AACZ,YAAMA;IACR;AACA,WAAO;EACT;;;;;;;;;;;;;EAcQ,iBAAiB,OAAiB,GAAS;AACjD,UAAM,EAAE,SAAS,WAAU,IAAK,UAAU,GAAG,KAAK,IAAI;AACtD,UAAM,SAAqB,CAAA;AAC3B,QAAI,IAAc;AAClB,QAAI,OAAO;AACX,aAASC,UAAS,GAAGA,UAAS,SAASA,WAAU;AAC/C,aAAO;AACP,aAAO,KAAK,IAAI;AAEhB,eAAS,IAAI,GAAG,IAAI,YAAY,KAAK;AACnC,eAAO,KAAK,IAAI,CAAC;AACjB,eAAO,KAAK,IAAI;MAClB;AACA,UAAI,KAAK,OAAM;IACjB;AACA,WAAO;EACT;;;;;;;EAQQ,KAAK,GAAW,aAAyB,GAAS;AAExD,QAAI,CAAC,KAAK,GAAG,QAAQ,CAAC;AAAG,YAAM,IAAI,MAAM,gBAAgB;AAEzD,QAAI,IAAI,KAAK;AACb,QAAIC,KAAI,KAAK;AAMb,UAAM,KAAK,UAAU,GAAG,KAAK,IAAI;AACjC,aAASD,UAAS,GAAGA,UAAS,GAAG,SAASA,WAAU;AAElD,YAAM,EAAE,OAAO,QAAQ,QAAQ,OAAO,QAAQ,QAAO,IAAK,YAAY,GAAGA,SAAQ,EAAE;AACnF,UAAI;AACJ,UAAI,QAAQ;AAGV,QAAAC,KAAIA,GAAE,IAAI,SAAS,QAAQ,YAAY,OAAO,CAAC,CAAC;MAClD,OAAO;AAEL,YAAI,EAAE,IAAI,SAAS,OAAO,YAAY,MAAM,CAAC,CAAC;MAChD;IACF;AACA,YAAQ,CAAC;AAIT,WAAO,EAAE,GAAG,GAAAA,GAAC;EACf;;;;;;EAOQ,WACN,GACA,aACA,GACA,MAAgB,KAAK,MAAI;AAEzB,UAAM,KAAK,UAAU,GAAG,KAAK,IAAI;AACjC,aAASD,UAAS,GAAGA,UAAS,GAAG,SAASA,WAAU;AAClD,UAAI,MAAMF;AAAK;AACf,YAAM,EAAE,OAAO,QAAQ,QAAQ,MAAK,IAAK,YAAY,GAAGE,SAAQ,EAAE;AAClE,UAAI;AACJ,UAAI,QAAQ;AAGV;MACF,OAAO;AACL,cAAM,OAAO,YAAY,MAAM;AAC/B,cAAM,IAAI,IAAI,QAAQ,KAAK,OAAM,IAAK,IAAI;MAC5C;IACF;AACA,YAAQ,CAAC;AACT,WAAO;EACT;EAEQ,eAAe,GAAW,OAAiB,WAA4B;AAE7E,QAAI,OAAO,iBAAiB,IAAI,KAAK;AACrC,QAAI,CAAC,MAAM;AACT,aAAO,KAAK,iBAAiB,OAAO,CAAC;AACrC,UAAI,MAAM,GAAG;AAEX,YAAI,OAAO,cAAc;AAAY,iBAAO,UAAU,IAAI;AAC1D,yBAAiB,IAAI,OAAO,IAAI;MAClC;IACF;AACA,WAAO;EACT;EAEA,OACE,OACA,QACA,WAA4B;AAE5B,UAAM,IAAI,KAAK,KAAK;AACpB,WAAO,KAAK,KAAK,GAAG,KAAK,eAAe,GAAG,OAAO,SAAS,GAAG,MAAM;EACtE;EAEA,OAAO,OAAiB,QAAgB,WAA8B,MAAe;AACnF,UAAM,IAAI,KAAK,KAAK;AACpB,QAAI,MAAM;AAAG,aAAO,KAAK,cAAc,OAAO,QAAQ,IAAI;AAC1D,WAAO,KAAK,WAAW,GAAG,KAAK,eAAe,GAAG,OAAO,SAAS,GAAG,QAAQ,IAAI;EAClF;;;;EAKA,YAAY,GAAa,GAAS;AAChC,cAAU,GAAG,KAAK,IAAI;AACtB,qBAAiB,IAAI,GAAG,CAAC;AACzB,qBAAiB,OAAO,CAAC;EAC3B;EAEA,SAAS,KAAa;AACpB,WAAO,KAAK,GAAG,MAAM;EACvB;;AAoCI,SAAU,UACd,GACA,QACA,QACA,SAAiB;AAQjB,oBAAkB,QAAQ,CAAC;AAC3B,qBAAmB,SAAS,MAAM;AAClC,QAAM,UAAU,OAAO;AACvB,QAAM,UAAU,QAAQ;AACxB,MAAI,YAAY;AAAS,UAAM,IAAI,MAAM,qDAAqD;AAE9F,QAAM,OAAO,EAAE;AACf,QAAM,QAAQ,OAAO,OAAO,OAAO,CAAC;AACpC,MAAI,aAAa;AACjB,MAAI,QAAQ;AAAI,iBAAa,QAAQ;WAC5B,QAAQ;AAAG,iBAAa,QAAQ;WAChC,QAAQ;AAAG,iBAAa;AACjC,QAAM,OAAO,QAAQ,UAAU;AAC/B,QAAM,UAAU,IAAI,MAAM,OAAO,IAAI,IAAI,CAAC,EAAE,KAAK,IAAI;AACrD,QAAM,WAAW,KAAK,OAAO,OAAO,OAAO,KAAK,UAAU,IAAI;AAC9D,MAAI,MAAM;AACV,WAAS,IAAI,UAAU,KAAK,GAAG,KAAK,YAAY;AAC9C,YAAQ,KAAK,IAAI;AACjB,aAAS,IAAI,GAAG,IAAI,SAAS,KAAK;AAChC,YAAM,SAAS,QAAQ,CAAC;AACxB,YAAME,SAAQ,OAAQ,UAAU,OAAO,CAAC,IAAK,IAAI;AACjD,cAAQA,MAAK,IAAI,QAAQA,MAAK,EAAE,IAAI,OAAO,CAAC,CAAC;IAC/C;AACA,QAAI,OAAO;AAEX,aAAS,IAAI,QAAQ,SAAS,GAAG,OAAO,MAAM,IAAI,GAAG,KAAK;AACxD,aAAO,KAAK,IAAI,QAAQ,CAAC,CAAC;AAC1B,aAAO,KAAK,IAAI,IAAI;IACtB;AACA,UAAM,IAAI,IAAI,IAAI;AAClB,QAAI,MAAM;AAAG,eAAS,IAAI,GAAG,IAAI,YAAY;AAAK,cAAM,IAAI,OAAM;EACpE;AACA,SAAO;AACT;AAkJA,SAAS,YAAe,OAAe,OAAmBC,OAAc;AACtE,MAAI,OAAO;AACT,QAAI,MAAM,UAAU;AAAO,YAAM,IAAI,MAAM,gDAAgD;AAC3F,kBAAc,KAAK;AACnB,WAAO;EACT,OAAO;AACL,WAAO,MAAM,OAAO,EAAE,MAAAA,MAAI,CAAE;EAC9B;AACF;AAIM,SAAU,mBACd,MACA,OACA,YAA8B,CAAA,GAC9B,QAAgB;AAEhB,MAAI,WAAW;AAAW,aAAS,SAAS;AAC5C,MAAI,CAAC,SAAS,OAAO,UAAU;AAAU,UAAM,IAAI,MAAM,kBAAkB,IAAI,eAAe;AAC9F,aAAW,KAAK,CAAC,KAAK,KAAK,GAAG,GAAY;AACxC,UAAM,MAAM,MAAM,CAAC;AACnB,QAAI,EAAE,OAAO,QAAQ,YAAY,MAAMC;AACrC,YAAM,IAAI,MAAM,SAAS,CAAC,0BAA0B;EACxD;AACA,QAAMC,MAAK,YAAY,MAAM,GAAG,UAAU,IAAI,MAAM;AACpD,QAAMC,MAAK,YAAY,MAAM,GAAG,UAAU,IAAI,MAAM;AACpD,QAAM,KAAgB,SAAS,gBAAgB,MAAM;AACrD,QAAM,SAAS,CAAC,MAAM,MAAM,KAAK,EAAE;AACnC,aAAW,KAAK,QAAQ;AAEtB,QAAI,CAACD,IAAG,QAAQ,MAAM,CAAC,CAAC;AACtB,YAAM,IAAI,MAAM,SAAS,CAAC,0CAA0C;EACxE;AACA,UAAQ,OAAO,OAAO,OAAO,OAAO,CAAA,GAAI,KAAK,CAAC;AAC9C,SAAO,EAAE,OAAO,IAAAA,KAAI,IAAAC,IAAE;AACxB;;;AC5oBA,IAAMC,OAAM,OAAO,CAAC;AAApB,IAAuBC,OAAM,OAAO,CAAC;AAArC,IAAwCC,OAAM,OAAO,CAAC;AAAtD,IAAyDC,OAAM,OAAO,CAAC;AA8JvE,SAAS,YAAYC,KAAoB,OAAoB,GAAW,GAAS;AAC/E,QAAM,KAAKA,IAAG,IAAI,CAAC;AACnB,QAAM,KAAKA,IAAG,IAAI,CAAC;AACnB,QAAM,OAAOA,IAAG,IAAIA,IAAG,IAAI,MAAM,GAAG,EAAE,GAAG,EAAE;AAC3C,QAAM,QAAQA,IAAG,IAAIA,IAAG,KAAKA,IAAG,IAAI,MAAM,GAAGA,IAAG,IAAI,IAAI,EAAE,CAAC,CAAC;AAC5D,SAAOA,IAAG,IAAI,MAAM,KAAK;AAC3B;AAEM,SAAU,QAAQ,QAAqB,YAA8B,CAAA,GAAE;AAC3E,QAAM,YAAY,mBAAmB,WAAW,QAAQ,WAAW,UAAU,MAAM;AACnF,QAAM,EAAE,IAAAA,KAAI,IAAAC,IAAE,IAAK;AACnB,MAAI,QAAQ,UAAU;AACtB,QAAM,EAAE,GAAG,SAAQ,IAAK;AACxB,kBAAgB,WAAW,CAAA,GAAI,EAAE,SAAS,WAAU,CAAE;AAMtD,QAAM,OAAOH,QAAQ,OAAOG,IAAG,QAAQ,CAAC,IAAIJ;AAC5C,QAAM,OAAO,CAAC,MAAcG,IAAG,OAAO,CAAC;AAGvC,QAAME,WACJ,UAAU,YACT,CAAC,GAAW,MAAa;AACxB,QAAI;AACF,aAAO,EAAE,SAAS,MAAM,OAAOF,IAAG,KAAKA,IAAG,IAAI,GAAG,CAAC,CAAC,EAAC;IACtD,SAAS,GAAG;AACV,aAAO,EAAE,SAAS,OAAO,OAAOJ,KAAG;IACrC;EACF;AAIF,MAAI,CAAC,YAAYI,KAAI,OAAO,MAAM,IAAI,MAAM,EAAE;AAC5C,UAAM,IAAI,MAAM,mCAAmC;AAMrD,WAAS,OAAO,OAAe,GAAW,UAAU,OAAK;AACvD,UAAMG,OAAM,UAAUN,OAAMD;AAC5B,aAAS,gBAAgB,OAAO,GAAGO,MAAK,IAAI;AAC5C,WAAO;EACT;AAEA,WAAS,UAAU,OAAc;AAC/B,QAAI,EAAE,iBAAiB;AAAQ,YAAM,IAAI,MAAM,wBAAwB;EACzE;AAGA,QAAM,eAAe,SAAS,CAAC,GAAU,OAAoC;AAC3E,UAAM,EAAE,GAAG,GAAG,EAAC,IAAK;AACpB,UAAM,MAAM,EAAE,IAAG;AACjB,QAAI,MAAM;AAAM,WAAK,MAAMJ,OAAOC,IAAG,IAAI,CAAC;AAC1C,UAAM,IAAI,KAAK,IAAI,EAAE;AACrB,UAAM,IAAI,KAAK,IAAI,EAAE;AACrB,UAAM,KAAKA,IAAG,IAAI,GAAG,EAAE;AACvB,QAAI;AAAK,aAAO,EAAE,GAAGJ,MAAK,GAAGC,KAAG;AAChC,QAAI,OAAOA;AAAK,YAAM,IAAI,MAAM,kBAAkB;AAClD,WAAO,EAAE,GAAG,EAAC;EACf,CAAC;AACD,QAAM,kBAAkB,SAAS,CAAC,MAAY;AAC5C,UAAM,EAAE,GAAG,EAAC,IAAK;AACjB,QAAI,EAAE,IAAG;AAAI,YAAM,IAAI,MAAM,iBAAiB;AAG9C,UAAM,EAAE,GAAG,GAAG,GAAG,EAAC,IAAK;AACvB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,KAAK,EAAE;AACvB,UAAM,MAAM,KAAK,KAAK,CAAC;AACvB,UAAM,OAAO,KAAK,KAAK,KAAK,MAAM,EAAE,CAAC;AACrC,UAAM,QAAQ,KAAK,KAAK,KAAK,IAAI,KAAK,KAAK,EAAE,CAAC,CAAC;AAC/C,QAAI,SAAS;AAAO,YAAM,IAAI,MAAM,uCAAuC;AAE3E,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,UAAM,KAAK,KAAK,IAAI,CAAC;AACrB,QAAI,OAAO;AAAI,YAAM,IAAI,MAAM,uCAAuC;AACtE,WAAO;EACT,CAAC;EAID,MAAM,MAAK;IAeT,YAAY,GAAW,GAAW,GAAW,GAAS;AACpD,WAAK,IAAI,OAAO,KAAK,CAAC;AACtB,WAAK,IAAI,OAAO,KAAK,CAAC;AACtB,WAAK,IAAI,OAAO,KAAK,GAAG,IAAI;AAC5B,WAAK,IAAI,OAAO,KAAK,CAAC;AACtB,aAAO,OAAO,IAAI;IACpB;IAEA,OAAO,QAAK;AACV,aAAO;IACT;IAEA,OAAO,WAAW,GAAsB;AACtC,UAAI,aAAa;AAAO,cAAM,IAAI,MAAM,4BAA4B;AACpE,YAAM,EAAE,GAAG,EAAC,IAAK,KAAK,CAAA;AACtB,aAAO,KAAK,CAAC;AACb,aAAO,KAAK,CAAC;AACb,aAAO,IAAI,MAAM,GAAG,GAAGA,MAAK,KAAK,IAAI,CAAC,CAAC;IACzC;;IAGA,OAAO,UAAUO,QAAmB,SAAS,OAAK;AAChD,YAAM,MAAMJ,IAAG;AACf,YAAM,EAAE,GAAG,EAAC,IAAK;AACjB,MAAAI,SAAQ,UAAU,SAAOA,QAAO,KAAK,OAAO,CAAC;AAC7C,cAAM,QAAQ,QAAQ;AACtB,YAAM,SAAS,UAAUA,MAAK;AAC9B,YAAM,WAAWA,OAAM,MAAM,CAAC;AAC9B,aAAO,MAAM,CAAC,IAAI,WAAW,CAAC;AAC9B,YAAM,IAAI,gBAAgB,MAAM;AAMhC,YAAMC,OAAM,SAAS,OAAOL,IAAG;AAC/B,eAAS,WAAW,GAAGJ,MAAKS,IAAG;AAI/B,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,IAAI,KAAK,KAAKR,IAAG;AACvB,YAAM,IAAI,KAAK,IAAI,KAAK,CAAC;AACzB,UAAI,EAAE,SAAS,OAAO,EAAC,IAAKK,SAAQ,GAAG,CAAC;AACxC,UAAI,CAAC;AAAS,cAAM,IAAI,MAAM,iCAAiC;AAC/D,YAAM,UAAU,IAAIL,UAASA;AAC7B,YAAM,iBAAiB,WAAW,SAAU;AAC5C,UAAI,CAAC,UAAU,MAAMD,QAAO;AAE1B,cAAM,IAAI,MAAM,0BAA0B;AAC5C,UAAI,kBAAkB;AAAQ,YAAI,KAAK,CAAC,CAAC;AACzC,aAAO,MAAM,WAAW,EAAE,GAAG,EAAC,CAAE;IAClC;IACA,OAAO,QAAQQ,QAAmB,SAAS,OAAK;AAC9C,aAAO,MAAM,UAAU,YAAY,SAASA,MAAK,GAAG,MAAM;IAC5D;IAEA,IAAI,IAAC;AACH,aAAO,KAAK,SAAQ,EAAG;IACzB;IACA,IAAI,IAAC;AACH,aAAO,KAAK,SAAQ,EAAG;IACzB;IAEA,WAAW,aAAqB,GAAG,SAAS,MAAI;AAC9C,WAAK,YAAY,MAAM,UAAU;AACjC,UAAI,CAAC;AAAQ,aAAK,SAASN,IAAG;AAC9B,aAAO;IACT;;IAGA,iBAAc;AACZ,sBAAgB,IAAI;IACtB;;IAGA,OAAO,OAAY;AACjB,gBAAU,KAAK;AACf,YAAM,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE,IAAK;AAChC,YAAM,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE,IAAK;AAChC,YAAM,OAAO,KAAK,KAAK,EAAE;AACzB,YAAM,OAAO,KAAK,KAAK,EAAE;AACzB,YAAM,OAAO,KAAK,KAAK,EAAE;AACzB,YAAM,OAAO,KAAK,KAAK,EAAE;AACzB,aAAO,SAAS,QAAQ,SAAS;IACnC;IAEA,MAAG;AACD,aAAO,KAAK,OAAO,MAAM,IAAI;IAC/B;IAEA,SAAM;AAEJ,aAAO,IAAI,MAAM,KAAK,CAAC,KAAK,CAAC,GAAG,KAAK,GAAG,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC,CAAC;IAC/D;;;;IAKA,SAAM;AACJ,YAAM,EAAE,EAAC,IAAK;AACd,YAAM,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE,IAAK;AAChC,YAAM,IAAI,KAAK,KAAK,EAAE;AACtB,YAAM,IAAI,KAAK,KAAK,EAAE;AACtB,YAAM,IAAI,KAAKA,OAAM,KAAK,KAAK,EAAE,CAAC;AAClC,YAAM,IAAI,KAAK,IAAI,CAAC;AACpB,YAAM,OAAO,KAAK;AAClB,YAAM,IAAI,KAAK,KAAK,OAAO,IAAI,IAAI,IAAI,CAAC;AACxC,YAAM,IAAI,IAAI;AACd,YAAM,IAAI,IAAI;AACd,YAAM,IAAI,IAAI;AACd,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,aAAO,IAAI,MAAM,IAAI,IAAI,IAAI,EAAE;IACjC;;;;IAKA,IAAI,OAAY;AACd,gBAAU,KAAK;AACf,YAAM,EAAE,GAAG,EAAC,IAAK;AACjB,YAAM,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE,IAAK;AACvC,YAAM,EAAE,GAAG,IAAI,GAAG,IAAI,GAAG,IAAI,GAAG,GAAE,IAAK;AACvC,YAAM,IAAI,KAAK,KAAK,EAAE;AACtB,YAAM,IAAI,KAAK,KAAK,EAAE;AACtB,YAAM,IAAI,KAAK,KAAK,IAAI,EAAE;AAC1B,YAAM,IAAI,KAAK,KAAK,EAAE;AACtB,YAAM,IAAI,MAAM,KAAK,OAAO,KAAK,MAAM,IAAI,CAAC;AAC5C,YAAM,IAAI,IAAI;AACd,YAAM,IAAI,IAAI;AACd,YAAM,IAAI,KAAK,IAAI,IAAI,CAAC;AACxB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,aAAO,IAAI,MAAM,IAAI,IAAI,IAAI,EAAE;IACjC;IAEA,SAAS,OAAY;AACnB,aAAO,KAAK,IAAI,MAAM,OAAM,CAAE;IAChC;;IAGA,SAAS,QAAc;AAErB,UAAI,CAACG,IAAG,YAAY,MAAM;AAAG,cAAM,IAAI,MAAM,4CAA4C;AACzF,YAAM,EAAE,GAAG,GAAAK,GAAC,IAAK,KAAK,OAAO,MAAM,QAAQ,CAACC,OAAM,WAAW,OAAOA,EAAC,CAAC;AACtE,aAAO,WAAW,OAAO,CAAC,GAAGD,EAAC,CAAC,EAAE,CAAC;IACpC;;;;;;IAOA,eAAe,QAAgB,MAAM,MAAM,MAAI;AAE7C,UAAI,CAACL,IAAG,QAAQ,MAAM;AAAG,cAAM,IAAI,MAAM,4CAA4C;AACrF,UAAI,WAAWL;AAAK,eAAO,MAAM;AACjC,UAAI,KAAK,IAAG,KAAM,WAAWC;AAAK,eAAO;AACzC,aAAO,KAAK,OAAO,MAAM,QAAQ,CAAC,MAAM,WAAW,OAAO,CAAC,GAAG,GAAG;IACnE;;;;;IAMA,eAAY;AACV,aAAO,KAAK,eAAe,QAAQ,EAAE,IAAG;IAC1C;;;IAIA,gBAAa;AACX,aAAO,KAAK,OAAO,MAAM,MAAM,CAAC,EAAE,IAAG;IACvC;;;IAIA,SAAS,WAAkB;AACzB,aAAO,aAAa,MAAM,SAAS;IACrC;IAEA,gBAAa;AACX,UAAI,aAAaA;AAAK,eAAO;AAC7B,aAAO,KAAK,eAAe,QAAQ;IACrC;IAEA,UAAO;AACL,YAAM,EAAE,GAAG,EAAC,IAAK,KAAK,SAAQ;AAE9B,YAAMO,SAAQJ,IAAG,QAAQ,CAAC;AAG1B,MAAAI,OAAMA,OAAM,SAAS,CAAC,KAAK,IAAIP,OAAM,MAAO;AAC5C,aAAOO;IACT;IACA,QAAK;AACH,aAAO,WAAW,KAAK,QAAO,CAAE;IAClC;IAEA,WAAQ;AACN,aAAO,UAAU,KAAK,IAAG,IAAK,SAAS,KAAK,MAAK,CAAE;IACrD;;IAGA,IAAI,KAAE;AACJ,aAAO,KAAK;IACd;IACA,IAAI,KAAE;AACJ,aAAO,KAAK;IACd;IACA,IAAI,KAAE;AACJ,aAAO,KAAK;IACd;IACA,IAAI,KAAE;AACJ,aAAO,KAAK;IACd;IACA,OAAO,WAAW,QAAe;AAC/B,aAAO,WAAW,OAAO,MAAM;IACjC;IACA,OAAO,IAAI,QAAiB,SAAiB;AAC3C,aAAO,UAAU,OAAOH,KAAI,QAAQ,OAAO;IAC7C;IACA,eAAe,YAAkB;AAC/B,WAAK,WAAW,UAAU;IAC5B;IACA,aAAU;AACR,aAAO,KAAK,QAAO;IACrB;;AArPgB,QAAA,OAAO,IAAI,MAAM,MAAM,IAAI,MAAM,IAAIJ,MAAK,KAAK,MAAM,KAAK,MAAM,EAAE,CAAC;AAEnE,QAAA,OAAO,IAAI,MAAMD,MAAKC,MAAKA,MAAKD,IAAG;AAEnC,QAAA,KAAKI;AAEL,QAAA,KAAKC;AAiPvB,QAAM,OAAO,IAAI,KAAK,OAAOA,IAAG,IAAI;AACpC,QAAM,KAAK,WAAW,CAAC;AACvB,SAAO;AACT;AAOM,IAAgB,oBAAhB,MAAiC;EAUrC,YAAY,IAAgB;AAC1B,SAAK,KAAK;EACZ;;EAOA,OAAO,UAAU,QAAkB;AACjC,mBAAc;EAChB;EAEA,OAAO,QAAQ,MAAS;AACtB,mBAAc;EAChB;EAEA,IAAI,IAAC;AACH,WAAO,KAAK,SAAQ,EAAG;EACzB;EACA,IAAI,IAAC;AACH,WAAO,KAAK,SAAQ,EAAG;EACzB;;EAGA,gBAAa;AAEX,WAAO;EACT;EAEA,iBAAc;AACZ,SAAK,GAAG,eAAc;EACxB;EAEA,SAAS,WAAkB;AACzB,WAAO,KAAK,GAAG,SAAS,SAAS;EACnC;EAEA,QAAK;AACH,WAAO,WAAW,KAAK,QAAO,CAAE;EAClC;EAEA,WAAQ;AACN,WAAO,KAAK,MAAK;EACnB;EAEA,gBAAa;AACX,WAAO;EACT;EAEA,eAAY;AACV,WAAO;EACT;EAEA,IAAI,OAAQ;AACV,SAAK,WAAW,KAAK;AACrB,WAAO,KAAK,KAAK,KAAK,GAAG,IAAI,MAAM,EAAE,CAAC;EACxC;EAEA,SAAS,OAAQ;AACf,SAAK,WAAW,KAAK;AACrB,WAAO,KAAK,KAAK,KAAK,GAAG,SAAS,MAAM,EAAE,CAAC;EAC7C;EAEA,SAAS,QAAc;AACrB,WAAO,KAAK,KAAK,KAAK,GAAG,SAAS,MAAM,CAAC;EAC3C;EAEA,eAAe,QAAc;AAC3B,WAAO,KAAK,KAAK,KAAK,GAAG,eAAe,MAAM,CAAC;EACjD;EAEA,SAAM;AACJ,WAAO,KAAK,KAAK,KAAK,GAAG,OAAM,CAAE;EACnC;EAEA,SAAM;AACJ,WAAO,KAAK,KAAK,KAAK,GAAG,OAAM,CAAE;EACnC;EAEA,WAAW,YAAqB,QAAgB;AAC9C,WAAO,KAAK,KAAK,KAAK,GAAG,WAAW,YAAY,MAAM,CAAC;EACzD;;EAQA,aAAU;AACR,WAAO,KAAK,QAAO;EACrB;;AAMI,SAAU,MAAM,OAAyB,OAAc,YAAuB,CAAA,GAAE;AACpF,MAAI,OAAO,UAAU;AAAY,UAAM,IAAI,MAAM,mCAAmC;AACpF,kBACE,WACA,CAAA,GACA;IACE,mBAAmB;IACnB,aAAa;IACb,QAAQ;IACR,SAAS;IACT,YAAY;GACb;AAGH,QAAM,EAAE,QAAO,IAAK;AACpB,QAAM,EAAE,MAAM,IAAAD,KAAI,IAAAC,IAAE,IAAK;AAEzB,QAAMO,eAAc,UAAU,eAAe;AAC7C,QAAMC,qBAAoB,UAAU,sBAAsB,CAACL,WAAsBA;AACjF,QAAM,SACJ,UAAU,WACT,CAAC,MAAkB,KAAiB,WAAmB;AACtD,YAAM,QAAQ,QAAQ;AACtB,QAAI,IAAI,UAAU;AAAQ,YAAM,IAAI,MAAM,qCAAqC;AAC/E,WAAO;EACT;AAGF,WAAS,QAAQM,OAAgB;AAC/B,WAAOT,IAAG,OAAO,gBAAgBS,KAAI,CAAC;EACxC;AAGA,WAAS,iBAAiB,KAAQ;AAChC,UAAM,MAAM,QAAQ;AACpB,UAAM,YAAY,eAAe,KAAK,GAAG;AAGzC,UAAM,SAAS,YAAY,sBAAsB,MAAM,GAAG,GAAG,IAAI,GAAG;AACpE,UAAM,OAAOD,mBAAkB,OAAO,MAAM,GAAG,GAAG,CAAC;AACnD,UAAM,SAAS,OAAO,MAAM,KAAK,IAAI,GAAG;AACxC,UAAM,SAAS,QAAQ,IAAI;AAC3B,WAAO,EAAE,MAAM,QAAQ,OAAM;EAC/B;AAGA,WAAS,qBAAqB,WAAc;AAC1C,UAAM,EAAE,MAAM,QAAQ,OAAM,IAAK,iBAAiB,SAAS;AAC3D,UAAM,QAAQ,KAAK,SAAS,MAAM;AAClC,UAAM,aAAa,MAAM,QAAO;AAChC,WAAO,EAAE,MAAM,QAAQ,QAAQ,OAAO,WAAU;EAClD;AAGA,WAAS,aAAa,WAAc;AAClC,WAAO,qBAAqB,SAAS,EAAE;EACzC;AAGA,WAAS,mBAAmBE,WAAe,WAAW,GAAE,MAAO,MAAkB;AAC/E,UAAM,MAAM,YAAY,GAAG,IAAI;AAC/B,WAAO,QAAQ,MAAM,OAAO,KAAK,YAAY,WAAWA,QAAO,GAAG,CAAC,CAAC,OAAO,CAAC,CAAC;EAC/E;AAGA,WAAS,KAAK,KAAU,WAAgB,UAA6B,CAAA,GAAE;AACrE,UAAM,YAAY,WAAW,GAAG;AAChC,QAAI;AAAS,YAAM,QAAQ,GAAG;AAC9B,UAAM,EAAE,QAAQ,QAAQ,WAAU,IAAK,qBAAqB,SAAS;AACrE,UAAM,IAAI,mBAAmB,QAAQ,SAAS,QAAQ,GAAG;AACzD,UAAM,IAAI,KAAK,SAAS,CAAC,EAAE,QAAO;AAClC,UAAM,IAAI,mBAAmB,QAAQ,SAAS,GAAG,YAAY,GAAG;AAChE,UAAM,IAAIV,IAAG,OAAO,IAAI,IAAI,MAAM;AAClC,QAAI,CAACA,IAAG,QAAQ,CAAC;AAAG,YAAM,IAAI,MAAM,wBAAwB;AAC5D,UAAM,KAAK,YAAY,GAAGA,IAAG,QAAQ,CAAC,CAAC;AACvC,WAAO,SAAO,IAAI,QAAQ,WAAW,QAAQ;EAC/C;AAGA,QAAM,aAAkD,EAAE,QAAQ,KAAI;AAMtE,WAAS,OAAO,KAAU,KAAU,WAAgB,UAAU,YAAU;AACtE,UAAM,EAAE,SAAAU,UAAS,OAAM,IAAK;AAC5B,UAAM,MAAM,QAAQ;AACpB,UAAM,YAAY,aAAa,KAAK,GAAG;AACvC,UAAM,YAAY,WAAW,GAAG;AAChC,gBAAY,YAAY,aAAa,WAAW,QAAQ,SAAS;AACjE,QAAI,WAAW;AAAW,cAAM,QAAQ,QAAQ;AAChD,QAAI;AAAS,YAAM,QAAQ,GAAG;AAE9B,UAAM,MAAM,MAAM;AAClB,UAAM,IAAI,IAAI,SAAS,GAAG,GAAG;AAC7B,UAAM,IAAI,gBAAgB,IAAI,SAAS,KAAK,GAAG,CAAC;AAChD,QAAI,GAAG,GAAG;AACV,QAAI;AAIF,UAAI,MAAM,UAAU,WAAW,MAAM;AACrC,UAAI,MAAM,UAAU,GAAG,MAAM;AAC7B,WAAK,KAAK,eAAe,CAAC;IAC5B,SAAS,OAAO;AACd,aAAO;IACT;AACA,QAAI,CAAC,UAAU,EAAE,aAAY;AAAI,aAAO;AAExC,UAAM,IAAI,mBAAmBA,UAAS,EAAE,QAAO,GAAI,EAAE,QAAO,GAAI,GAAG;AACnE,UAAM,MAAM,EAAE,IAAI,EAAE,eAAe,CAAC,CAAC;AAGrC,WAAO,IAAI,SAAS,EAAE,EAAE,cAAa,EAAG,IAAG;EAC7C;AAEA,QAAM,QAAQX,IAAG;AACjB,QAAM,UAAU;IACd,WAAW;IACX,WAAW;IACX,WAAW,IAAI;IACf,MAAM;;AAER,WAAS,gBAAgB,OAAOQ,aAAY,QAAQ,IAAI,GAAC;AACvD,WAAO,SAAO,MAAM,QAAQ,MAAM,MAAM;EAC1C;AACA,WAAS,OAAO,MAAiB;AAC/B,UAAM,YAAY,MAAM,gBAAgB,IAAI;AAC5C,WAAO,EAAE,WAAW,WAAW,aAAa,SAAS,EAAC;EACxD;AACA,WAAS,iBAAiB,KAAe;AACvC,WAAO,QAAQ,GAAG,KAAK,IAAI,WAAWP,IAAG;EAC3C;AACA,WAAS,iBAAiB,KAAiB,QAAgB;AACzD,QAAI;AACF,aAAO,CAAC,CAAC,MAAM,UAAU,KAAK,MAAM;IACtC,SAAS,OAAO;AACd,aAAO;IACT;EACF;AAEA,QAAM,QAAQ;IACZ;IACA;IACA;IACA;;;;;;;;;;IAUA,aAAa,WAAqB;AAChC,YAAM,EAAE,EAAC,IAAK,MAAM,UAAU,SAAS;AACvC,YAAM,OAAO,QAAQ;AACrB,YAAM,UAAU,SAAS;AACzB,UAAI,CAAC,WAAW,SAAS;AAAI,cAAM,IAAI,MAAM,gCAAgC;AAC7E,YAAM,IAAI,UAAUD,IAAG,IAAIH,OAAM,GAAGA,OAAM,CAAC,IAAIG,IAAG,IAAI,IAAIH,MAAK,IAAIA,IAAG;AACtE,aAAOG,IAAG,QAAQ,CAAC;IACrB;IAEA,mBAAmB,WAAqB;AACtC,YAAM,OAAO,QAAQ;AACrB,eAAO,WAAW,IAAI;AACtB,YAAM,SAAS,MAAM,UAAU,SAAS,GAAG,IAAI,CAAC;AAChD,aAAOS,mBAAkB,MAAM,EAAE,SAAS,GAAG,IAAI;IACnD;;IAGA,kBAAkB;;IAElB,WAAW,aAAa,GAAG,QAAsB,MAAM,MAAI;AACzD,aAAO,MAAM,WAAW,YAAY,KAAK;IAC3C;;AAGF,SAAO,OAAO,OAAO;IACnB;IACA;IACA;IACA;IACA;IACA;IACA;GACD;AACH;AAmCA,SAAS,0BAA0B,GAAsB;AACvD,QAAM,QAAqB;IACzB,GAAG,EAAE;IACL,GAAG,EAAE;IACL,GAAG,EAAE,GAAG;IACR,GAAG,EAAE;IACL,GAAG,EAAE;IACL,IAAI,EAAE;IACN,IAAI,EAAE;;AAER,QAAMT,MAAK,EAAE;AACb,QAAMC,MAAK,MAAM,MAAM,GAAG,EAAE,YAAY,IAAI;AAC5C,QAAM,YAA8B,EAAE,IAAAD,KAAI,IAAAC,KAAI,SAAS,EAAE,QAAO;AAChE,QAAM,YAAuB;IAC3B,aAAa,EAAE;IACf,mBAAmB,EAAE;IACrB,QAAQ,EAAE;IACV,SAAS,EAAE;IACX,YAAY,EAAE;;AAEhB,SAAO,EAAE,OAAO,WAAW,MAAM,EAAE,MAAM,UAAS;AACpD;AACA,SAAS,4BAA4B,GAAwBW,QAAY;AACvE,QAAM,QAAQA,OAAM;AACpB,QAAM,SAAS,OAAO,OAAO,CAAA,GAAIA,QAAO;IACtC,eAAe;IACf,OAAO;IACP,YAAY,MAAM,GAAG;IACrB,aAAa,MAAM,GAAG;GACvB;AACD,SAAO;AACT;AAEM,SAAU,eAAe,GAAsB;AACnD,QAAM,EAAE,OAAO,WAAW,MAAAF,OAAM,UAAS,IAAK,0BAA0B,CAAC;AACzE,QAAM,QAAQ,QAAQ,OAAO,SAAS;AACtC,QAAM,QAAQ,MAAM,OAAOA,OAAM,SAAS;AAC1C,SAAO,4BAA4B,GAAG,KAAK;AAC7C;;;ACn2BA,IAAM,QAAQ;AAGd,SAAS,MAAM,OAAe,QAAc;AAC1C,OAAK,KAAK;AACV,OAAK,MAAM;AACX,MAAI,QAAQ,KAAK,SAAS,KAAM,IAAI;AAAS,UAAM,IAAI,MAAM,0BAA0B,KAAK;AAC5F,QAAM,MAAM,MAAM,KAAK,EAAE,OAAM,CAAE,EAAE,KAAK,CAAC;AACzC,WAAS,IAAI,SAAS,GAAG,KAAK,GAAG,KAAK;AACpC,QAAI,CAAC,IAAI,QAAQ;AACjB,eAAW;EACb;AACA,SAAO,IAAI,WAAW,GAAG;AAC3B;AAEA,SAAS,OAAO,GAAe,GAAa;AAC1C,QAAM,MAAM,IAAI,WAAW,EAAE,MAAM;AACnC,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK;AACjC,QAAI,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;EACrB;AACA,SAAO;AACT;AAEA,SAAS,KAAK,MAAa;AACzB,MAAI,CAAC,OAAO,cAAc,IAAI;AAAG,UAAM,IAAI,MAAM,iBAAiB;AACpE;AAEA,SAAS,QAAQ,KAAmB;AAClC,MAAI,CAAC,QAAQ,GAAG,KAAK,OAAO,QAAQ;AAAU,UAAM,IAAI,MAAM,kCAAkC;AAChG,SAAO,OAAO,QAAQ,WAAW,YAAY,GAAG,IAAI;AACtD;AAMM,SAAU,mBACd,KACA,KACA,YACA,GAAQ;AAER,SAAO,GAAG;AACV,OAAK,UAAU;AACf,QAAM,QAAQ,GAAG;AAEjB,MAAI,IAAI,SAAS;AAAK,UAAM,EAAE,YAAY,YAAY,mBAAmB,GAAG,GAAG,CAAC;AAChF,QAAM,EAAE,WAAW,YAAY,UAAU,WAAU,IAAK;AACxD,QAAM,MAAM,KAAK,KAAK,aAAa,UAAU;AAC7C,MAAI,aAAa,SAAS,MAAM;AAAK,UAAM,IAAI,MAAM,wCAAwC;AAC7F,QAAM,YAAY,YAAY,KAAK,MAAM,IAAI,QAAQ,CAAC,CAAC;AACvD,QAAM,QAAQ,MAAM,GAAG,UAAU;AACjC,QAAM,YAAY,MAAM,YAAY,CAAC;AACrC,QAAM,IAAI,IAAI,MAAkB,GAAG;AACnC,QAAM,MAAM,EAAE,YAAY,OAAO,KAAK,WAAW,MAAM,GAAG,CAAC,GAAG,SAAS,CAAC;AACxE,IAAE,CAAC,IAAI,EAAE,YAAY,KAAK,MAAM,GAAG,CAAC,GAAG,SAAS,CAAC;AACjD,WAAS,IAAI,GAAG,KAAK,KAAK,KAAK;AAC7B,UAAM,OAAO,CAAC,OAAO,KAAK,EAAE,IAAI,CAAC,CAAC,GAAG,MAAM,IAAI,GAAG,CAAC,GAAG,SAAS;AAC/D,MAAE,CAAC,IAAI,EAAE,YAAY,GAAG,IAAI,CAAC;EAC/B;AACA,QAAM,sBAAsB,YAAY,GAAG,CAAC;AAC5C,SAAO,oBAAoB,MAAM,GAAG,UAAU;AAChD;AASM,SAAU,mBACd,KACA,KACA,YACA,GACA,GAAQ;AAER,SAAO,GAAG;AACV,OAAK,UAAU;AACf,QAAM,QAAQ,GAAG;AAGjB,MAAI,IAAI,SAAS,KAAK;AACpB,UAAM,QAAQ,KAAK,KAAM,IAAI,IAAK,CAAC;AACnC,UAAM,EAAE,OAAO,EAAE,MAAK,CAAE,EAAE,OAAO,YAAY,mBAAmB,CAAC,EAAE,OAAO,GAAG,EAAE,OAAM;EACvF;AACA,MAAI,aAAa,SAAS,IAAI,SAAS;AACrC,UAAM,IAAI,MAAM,wCAAwC;AAC1D,SACE,EAAE,OAAO,EAAE,OAAO,WAAU,CAAE,EAC3B,OAAO,GAAG,EACV,OAAO,MAAM,YAAY,CAAC,CAAC,EAE3B,OAAO,GAAG,EACV,OAAO,MAAM,IAAI,QAAQ,CAAC,CAAC,EAC3B,OAAM;AAEb;AAUM,SAAU,cAAc,KAAiBG,QAAe,SAAgB;AAC5E,kBAAgB,SAAS;IACvB,GAAG;IACH,GAAG;IACH,GAAG;IACH,MAAM;GACP;AACD,QAAM,EAAE,GAAG,GAAG,GAAG,MAAAC,OAAM,QAAAC,SAAQ,IAAG,IAAK;AACvC,MAAI,CAAC,OAAO,QAAQ,IAAI;AAAG,UAAM,IAAI,MAAM,qBAAqB;AAChE,SAAO,GAAG;AACV,OAAKF,MAAK;AACV,QAAM,QAAQ,EAAE,SAAS,CAAC,EAAE;AAC5B,QAAM,IAAI,KAAK,MAAM,QAAQ,KAAK,CAAC;AACnC,QAAM,eAAeA,SAAQ,IAAI;AACjC,MAAI;AACJ,MAAIE,YAAW,OAAO;AACpB,UAAM,mBAAmB,KAAK,KAAK,cAAcD,KAAI;EACvD,WAAWC,YAAW,OAAO;AAC3B,UAAM,mBAAmB,KAAK,KAAK,cAAc,GAAGD,KAAI;EAC1D,WAAWC,YAAW,kBAAkB;AAEtC,UAAM;EACR,OAAO;AACL,UAAM,IAAI,MAAM,+BAA+B;EACjD;AACA,QAAM,IAAI,IAAI,MAAMF,MAAK;AACzB,WAAS,IAAI,GAAG,IAAIA,QAAO,KAAK;AAC9B,UAAM,IAAI,IAAI,MAAM,CAAC;AACrB,aAAS,IAAI,GAAG,IAAI,GAAG,KAAK;AAC1B,YAAM,aAAa,KAAK,IAAI,IAAI;AAChC,YAAM,KAAK,IAAI,SAAS,YAAY,aAAa,CAAC;AAClD,QAAE,CAAC,IAAI,IAAI,MAAM,EAAE,GAAG,CAAC;IACzB;AACA,MAAE,CAAC,IAAI;EACT;AACA,SAAO;AACT;AA8DO,IAAM,cAA0B,YAAY,eAAe;AAG5D,SAAUG,cACd,OACA,YACA,UAAkD;AAElD,MAAI,OAAO,eAAe;AAAY,UAAM,IAAI,MAAM,8BAA8B;AACpF,WAASC,KAAI,KAAa;AACxB,WAAO,MAAM,WAAW,WAAW,GAAG,CAAC;EACzC;AACA,WAAS,MAAM,SAAoB;AACjC,UAAM,IAAI,QAAQ,cAAa;AAC/B,QAAI,EAAE,OAAO,MAAM,IAAI;AAAG,aAAO,MAAM;AACvC,MAAE,eAAc;AAChB,WAAO;EACT;AAEA,SAAO;IACL;IAEA,YAAY,KAAiB,SAAsB;AACjD,YAAM,OAAO,OAAO,OAAO,CAAA,GAAI,UAAU,OAAO;AAChD,YAAM,IAAI,cAAc,KAAK,GAAG,IAAI;AACpC,YAAM,KAAKA,KAAI,EAAE,CAAC,CAAC;AACnB,YAAM,KAAKA,KAAI,EAAE,CAAC,CAAC;AACnB,aAAO,MAAM,GAAG,IAAI,EAAE,CAAC;IACzB;IACA,cAAc,KAAiB,SAAsB;AACnD,YAAM,UAAU,SAAS,YAAY,EAAE,KAAK,SAAS,UAAS,IAAK,CAAA;AACnE,YAAM,OAAO,OAAO,OAAO,CAAA,GAAI,UAAU,SAAS,OAAO;AACzD,YAAM,IAAI,cAAc,KAAK,GAAG,IAAI;AACpC,YAAM,KAAKA,KAAI,EAAE,CAAC,CAAC;AACnB,aAAO,MAAM,EAAE;IACjB;;IAEA,WAAW,SAAiB;AAC1B,UAAI,CAAC,MAAM,QAAQ,OAAO;AAAG,cAAM,IAAI,MAAM,2BAA2B;AACxE,iBAAW,KAAK;AACd,YAAI,OAAO,MAAM;AAAU,gBAAM,IAAI,MAAM,2BAA2B;AACxE,aAAO,MAAMA,KAAI,OAAO,CAAC;IAC3B;;;IAIA,aAAa,KAAiB,SAAsB;AAElD,YAAM,IAAI,MAAM,GAAG;AACnB,YAAM,OAAO,OAAO,OAAO,CAAA,GAAI,UAAU,EAAE,GAAG,GAAG,GAAG,GAAG,KAAK,YAAW,GAAI,OAAO;AAClF,aAAO,cAAc,KAAK,GAAG,IAAI,EAAE,CAAC,EAAE,CAAC;IACzC;;AAEJ;;;AC9RA,IAAMC,OAAM,OAAO,CAAC;AACpB,IAAMC,OAAM,OAAO,CAAC;AACpB,IAAMC,OAAM,OAAO,CAAC;AA2BpB,SAAS,aAAa,OAAgB;AACpC,kBAAgB,OAAO;IACrB,mBAAmB;IACnB,YAAY;GACb;AACD,SAAO,OAAO,OAAO,EAAE,GAAG,MAAK,CAAW;AAC5C;AAEM,SAAU,WAAW,UAAmB;AAC5C,QAAM,QAAQ,aAAa,QAAQ;AACnC,QAAM,EAAE,GAAG,MAAM,mBAAAC,oBAAmB,YAAY,aAAa,KAAI,IAAK;AACtE,QAAM,UAAU,SAAS;AACzB,MAAI,CAAC,WAAW,SAAS;AAAQ,UAAM,IAAI,MAAM,cAAc;AAC/D,QAAM,eAAe,QAAQ;AAE7B,QAAM,iBAAiB,UAAU,MAAM;AACvC,QAAM,WAAW,UAAU,KAAK;AAChC,QAAM,KAAK,UAAU,OAAO,CAAC,IAAI,OAAO,CAAC;AAKzC,QAAM,MAAM,UAAU,OAAO,MAAM,IAAI,OAAO,KAAK;AAInD,QAAM,YAAY,UAAUD,QAAO,OAAO,GAAG,IAAIA,QAAO,OAAO,GAAG;AAClE,QAAM,WAAW,UACb,OAAO,CAAC,IAAIA,QAAO,OAAO,GAAG,IAAID,OACjC,OAAO,CAAC,IAAIC,QAAO,OAAO,GAAG,IAAID;AACrC,QAAM,YAAY,YAAY,WAAWA;AACzC,QAAM,OAAO,CAAC,MAAc,IAAI,GAAG,CAAC;AACpC,QAAM,UAAU,QAAQ,EAAE;AAC1B,WAAS,QAAQ,GAAS;AACxB,WAAO,gBAAgB,KAAK,CAAC,GAAG,QAAQ;EAC1C;AACA,WAAS,QAAQ,GAAM;AACrB,UAAM,KAAK,YAAY,gBAAgB,GAAG,QAAQ;AAGlD,QAAI;AAAS,SAAG,EAAE,KAAK;AAKvB,WAAO,KAAK,gBAAgB,EAAE,CAAC;EACjC;AACA,WAAS,aAAa,QAAW;AAC/B,WAAO,gBAAgBE,mBAAkB,YAAY,UAAU,QAAQ,QAAQ,CAAC,CAAC;EACnF;AACA,WAAS,WAAW,QAAa,GAAM;AACrC,UAAM,KAAK,iBAAiB,QAAQ,CAAC,GAAG,aAAa,MAAM,CAAC;AAI5D,QAAI,OAAOH;AAAK,YAAM,IAAI,MAAM,wCAAwC;AACxE,WAAO,QAAQ,EAAE;EACnB;AAEA,WAAS,eAAe,QAAW;AACjC,WAAO,WAAW,QAAQ,OAAO;EACnC;AAGA,WAAS,MAAM,MAAc,KAAa,KAAW;AAInD,UAAM,QAAQ,KAAK,QAAQ,MAAM,IAAI;AACrC,UAAM,KAAK,MAAM,KAAK;AACtB,UAAM,KAAK,MAAM,KAAK;AACtB,WAAO,EAAE,KAAK,IAAG;EACnB;AAQA,WAAS,iBAAiB,GAAW,QAAc;AACjD,aAAS,KAAK,GAAGA,MAAK,CAAC;AACvB,aAAS,UAAU,QAAQ,WAAW,SAAS;AAC/C,UAAM,IAAI;AACV,UAAM,MAAM;AACZ,QAAI,MAAMC;AACV,QAAI,MAAMD;AACV,QAAI,MAAM;AACV,QAAI,MAAMC;AACV,QAAI,OAAOD;AACX,aAAS,IAAI,OAAO,iBAAiB,CAAC,GAAG,KAAKA,MAAK,KAAK;AACtD,YAAM,MAAO,KAAK,IAAKC;AACvB,cAAQ;AACR,OAAC,EAAE,KAAK,IAAG,IAAK,MAAM,MAAM,KAAK,GAAG;AACpC,OAAC,EAAE,KAAK,KAAK,KAAK,IAAG,IAAK,MAAM,MAAM,KAAK,GAAG;AAC9C,aAAO;AAEP,YAAM,IAAI,MAAM;AAChB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,IAAI,MAAM;AAChB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,IAAI,KAAK;AACf,YAAM,IAAI,MAAM;AAChB,YAAM,IAAI,MAAM;AAChB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,KAAK,KAAK,IAAI,CAAC;AACrB,YAAM,OAAO,KAAK;AAClB,YAAM,QAAQ,KAAK;AACnB,YAAM,KAAK,OAAO,IAAI;AACtB,YAAM,KAAK,MAAM,KAAK,QAAQ,KAAK,CAAC;AACpC,YAAM,KAAK,KAAK,EAAE;AAClB,YAAM,KAAK,KAAK,KAAK,KAAK,MAAM,CAAC,EAAE;IACrC;AACA,KAAC,EAAE,KAAK,IAAG,IAAK,MAAM,MAAM,KAAK,GAAG;AACpC,KAAC,EAAE,KAAK,KAAK,KAAK,IAAG,IAAK,MAAM,MAAM,KAAK,GAAG;AAC9C,UAAM,KAAK,WAAW,GAAG;AACzB,WAAO,KAAK,MAAM,EAAE;EACtB;AACA,QAAM,UAAU;IACd,WAAW;IACX,WAAW;IACX,MAAM;;AAER,QAAM,kBAAkB,CAAC,OAAO,aAAa,QAAQ,MAAK;AACxD,WAAO,MAAM,QAAQ,IAAI;AACzB,WAAO;EACT;AACA,WAAS,OAAO,MAAiB;AAC/B,UAAM,YAAY,gBAAgB,IAAI;AACtC,WAAO,EAAE,WAAW,WAAW,eAAe,SAAS,EAAC;EAC1D;AACA,QAAM,QAAQ;IACZ;IACA,kBAAkB;;AAEpB,SAAO;IACL;IACA,iBAAiB,CAAC,WAAgB,cAAmB,WAAW,WAAW,SAAS;IACpF,cAAc,CAAC,cAA+B,eAAe,SAAS;IACtE;IACA;IACA;IACA,SAAS,QAAQ,MAAK;IACtB;;AAEJ;;;ACzJA,IAAMG,OAAsB,OAAO,CAAC;AAApC,IAAuCC,OAAM,OAAO,CAAC;AAArD,IAAwDC,OAAM,OAAO,CAAC;AAAtE,IAAyEC,OAAM,OAAO,CAAC;AAEvF,IAAMC,OAAM,OAAO,CAAC;AAApB,IAAuBC,OAAM,OAAO,CAAC;AAGrC,IAAM,kBAAkB,OACtB,oEAAoE;AAMtE,IAAM,iBAA8C,OAAO;EACzD,GAAG;EACH,GAAG,OAAO,oEAAoE;EAC9E,GAAGA;EACH,GAAG,OAAO,oEAAoE;EAC9E,GAAG,OAAO,oEAAoE;EAC9E,IAAI,OAAO,oEAAoE;EAC/E,IAAI,OAAO,oEAAoE;IAC9E;AAEH,SAAS,oBAAoB,GAAS;AAEpC,QAAM,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE,GAAG,OAAO,OAAO,EAAE;AAC/E,QAAM,IAAI;AACV,QAAM,KAAM,IAAI,IAAK;AACrB,QAAM,KAAM,KAAK,IAAK;AACtB,QAAM,KAAM,KAAK,IAAIH,MAAK,CAAC,IAAI,KAAM;AACrC,QAAM,KAAM,KAAK,IAAID,MAAK,CAAC,IAAI,IAAK;AACpC,QAAM,MAAO,KAAK,IAAIG,MAAK,CAAC,IAAI,KAAM;AACtC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,MAAO,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AACzC,QAAM,OAAQ,KAAK,KAAK,MAAM,CAAC,IAAI,MAAO;AAC1C,QAAM,OAAQ,KAAK,MAAM,MAAM,CAAC,IAAI,MAAO;AAC3C,QAAM,OAAQ,KAAK,MAAM,MAAM,CAAC,IAAI,MAAO;AAC3C,QAAM,YAAa,KAAK,MAAMF,MAAK,CAAC,IAAI,IAAK;AAE7C,SAAO,EAAE,WAAW,GAAE;AACxB;AAEA,SAAS,kBAAkBI,QAAiB;AAG1C,EAAAA,OAAM,CAAC,KAAK;AAEZ,EAAAA,OAAM,EAAE,KAAK;AAEb,EAAAA,OAAM,EAAE,KAAK;AACb,SAAOA;AACT;AAIA,IAAM,kBAAkC,OACtC,+EAA+E;AAGjF,SAAS,QAAQ,GAAW,GAAS;AACnC,QAAM,IAAI;AACV,QAAMC,MAAK,IAAI,IAAI,IAAI,GAAG,CAAC;AAC3B,QAAM,KAAK,IAAIA,MAAKA,MAAK,GAAG,CAAC;AAE7B,QAAM,MAAM,oBAAoB,IAAI,EAAE,EAAE;AACxC,MAAI,IAAI,IAAI,IAAIA,MAAK,KAAK,CAAC;AAC3B,QAAM,MAAM,IAAI,IAAI,IAAI,GAAG,CAAC;AAC5B,QAAM,QAAQ;AACd,QAAM,QAAQ,IAAI,IAAI,iBAAiB,CAAC;AACxC,QAAM,WAAW,QAAQ;AACzB,QAAM,WAAW,QAAQ,IAAI,CAAC,GAAG,CAAC;AAClC,QAAM,SAAS,QAAQ,IAAI,CAAC,IAAI,iBAAiB,CAAC;AAClD,MAAI;AAAU,QAAI;AAClB,MAAI,YAAY;AAAQ,QAAI;AAC5B,MAAI,aAAa,GAAG,CAAC;AAAG,QAAI,IAAI,CAAC,GAAG,CAAC;AACrC,SAAO,EAAE,SAAS,YAAY,UAAU,OAAO,EAAC;AAClD;AAEA,IAAM,MAAsB,MAAM,MAAM,cAAc,GAAG,EAAE,MAAM,KAAI,CAAE,GAAE;AACzE,IAAM,MAAsB,MAAM,MAAM,cAAc,GAAG,EAAE,MAAM,KAAI,CAAE,GAAE;AAEzE,IAAM,mBAAmC,OAAO;EAC9C,GAAG;EACH;EACA,MAAM;EACN;;;;EAIA;IACC;AAYI,IAAM,WAAoC,MAAM,eAAe,eAAe,GAAE;AAEvF,SAAS,eAAe,MAAkB,KAAiB,QAAe;AACxE,MAAI,IAAI,SAAS;AAAK,UAAM,IAAI,MAAM,oBAAoB;AAC1D,SAAO,YACL,YAAY,kCAAkC,GAC9C,IAAI,WAAW,CAAC,SAAS,IAAI,GAAG,IAAI,MAAM,CAAC,GAC3C,KACA,IAAI;AAER;AAGO,IAAM,cAAuC,MAClD,eAAe;EACb,GAAG;EACH,QAAQ;CACT,GAAE;AAGE,IAAM,aAAsC,MACjD,eACE,OAAO,OAAO,CAAA,GAAI,iBAAiB;EACjC,QAAQ;EACR,SAAS;CACV,CAAC,GACF;AAYG,IAAM,UAAoC,MAAK;AACpD,QAAM,IAAI,GAAG;AACb,SAAO,WAAW;IAChB;IACA,MAAM;IACN,YAAY,CAAC,MAAqB;AAEhC,YAAM,EAAE,WAAW,GAAE,IAAK,oBAAoB,CAAC;AAC/C,aAAO,IAAI,KAAK,WAAWJ,MAAK,CAAC,IAAI,IAAI,CAAC;IAC5C;IACA;GACD;AACH,GAAE;AAKF,IAAM,WAA2B,OAAO,kBAAkBA,QAAOE,MAAI;AACrE,IAAM,WAA2B,MAAM,GAAG,IAAIH,MAAK,OAAO,GAAE;AAC5D,IAAM,WAA2B,MAAM,GAAG,KAAK,GAAG,IAAI,GAAG,GAAG,CAAC,GAAE;AAG/D,SAAS,mCAAmC,GAAS;AACnD,QAAM,WAAW,kBAAkBE,QAAOC;AAC1C,QAAM,SAAS,OAAO,MAAM;AAE5B,MAAI,MAAM,GAAG,IAAI,CAAC;AAClB,QAAM,GAAG,IAAI,KAAKH,IAAG;AACrB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG,GAAG;AAC3B,MAAI,MAAM,GAAG,IAAI,MAAM;AACvB,MAAI,MAAM,GAAG,IAAI,EAAE;AACnB,MAAI,MAAM,GAAG,IAAI,KAAK,EAAE;AACxB,MAAI,MAAM,GAAG,IAAI,KAAK,MAAM;AAC5B,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,MAAM,GAAG,IAAI,GAAG;AACpB,QAAM,GAAG,IAAI,GAAG;AAChB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,MAAM,GAAG,IAAI,KAAK,OAAO;AAC7B,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,MAAM,GAAG,IAAI,KAAK,OAAO;AAC7B,QAAM,GAAG,IAAI,GAAG;AAChB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,KAAK,GAAG,KAAK,KAAK,KAAK,EAAE;AAC7B,MAAI,MAAM,GAAG,IAAI,KAAK,GAAG;AACzB,MAAI,MAAM,GAAG,IAAI,KAAK,CAAC;AACvB,QAAM,GAAG,IAAI,KAAK,OAAO;AACzB,MAAI,MAAM,GAAG,IAAI,KAAK,OAAO;AAC7B,MAAI,MAAM,GAAG,IAAI,KAAK,GAAG;AACzB,QAAM,GAAG,IAAI,GAAG;AAChB,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,KAAK,GAAG,KAAK,KAAK,KAAK,EAAE;AAC7B,QAAM,GAAG,IAAI,EAAE;AACf,QAAM,GAAG,IAAI,KAAK,GAAG;AACrB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,KAAK,GAAG,KAAK,KAAK,KAAK,EAAE;AAC7B,MAAI,IAAI,GAAG,KAAK,IAAI,IAAI,EAAE;AAC1B,MAAI,KAAK,GAAG,MAAO,CAAC;AACpB,MAAI,GAAG,KAAK,GAAG,GAAG,IAAI,CAAC,GAAG,OAAO,EAAE;AACnC,SAAO,EAAE,KAAK,IAAI,KAAK,IAAI,KAAK,GAAG,KAAKD,KAAG;AAC7C;AAEA,IAAM,mBAAmC,MAAM,WAAW,IAAI,GAAG,IAAI,OAAO,MAAM,CAAC,CAAC,GAAE;AACtF,SAAS,qCAAqC,GAAS;AACrD,QAAM,EAAE,KAAK,KAAK,KAAK,IAAG,IAAK,mCAAmC,CAAC;AAEnE,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,OAAK,GAAG,IAAI,IAAI,eAAe;AAC/B,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,KAAK,GAAG,IAAI,KAAK,GAAG;AACxB,MAAI,MAAM,GAAG,IAAI,IAAI,EAAE;AACvB,MAAI,IAAI,GAAG,IAAI,KAAK,GAAG,IAAI;AAC3B,OAAK,GAAG,KAAK,IAAI,GAAG,MAAM,CAAC;AAC3B,OAAK,GAAG,KAAK,IAAI,GAAG,KAAK,CAAC;AAC1B,OAAK,GAAG,KAAK,IAAI,GAAG,KAAK,CAAC;AAC1B,OAAK,GAAG,KAAK,IAAI,GAAG,KAAK,CAAC;AAC1B,QAAM,CAAC,QAAQ,MAAM,IAAI,cAAc,IAAI,CAAC,IAAI,EAAE,GAAG,IAAI;AACzD,SAAO,EAAE,GAAG,GAAG,IAAI,IAAI,MAAM,GAAG,GAAG,GAAG,IAAI,IAAI,MAAM,EAAC;AACvD;AAGO,IAAM,kBAAqD,MAChEO,cACE,QAAQ,OACR,CAAC,YAAsB,qCAAqC,QAAQ,CAAC,CAAC,GACtE;EACE,KAAK;EACL,WAAW;EACX,GAAG;EACH,GAAG;EACH,GAAG;EACH,QAAQ;EACR,MAAM;CACP,GACD;AAGJ,IAAM,UAAU;AAEhB,IAAM,oBAAoC,OACxC,+EAA+E;AAGjF,IAAM,oBAAoC,OACxC,+EAA+E;AAGjF,IAAM,iBAAiC,OACrC,8EAA8E;AAGhF,IAAM,iBAAiC,OACrC,+EAA+E;AAGjF,IAAM,aAAa,CAACC,YAAmB,QAAQR,MAAKQ,OAAM;AAE1D,IAAM,WAA2B,OAC/B,oEAAoE;AAEtE,IAAM,qBAAqB,CAACH,WAC1B,QAAQ,MAAM,GAAG,OAAO,gBAAgBA,MAAK,IAAI,QAAQ;AAS3D,SAAS,0BAA0B,IAAU;AAC3C,QAAM,EAAE,EAAC,IAAK;AACd,QAAM,IAAI;AACV,QAAMI,OAAM,CAAC,MAAc,GAAG,OAAO,CAAC;AACtC,QAAM,IAAIA,KAAI,UAAU,KAAK,EAAE;AAC/B,QAAM,KAAKA,MAAK,IAAIT,QAAO,cAAc;AACzC,MAAI,IAAI,OAAO,EAAE;AACjB,QAAM,IAAIS,MAAK,IAAI,IAAI,KAAKA,KAAI,IAAI,CAAC,CAAC;AACtC,MAAI,EAAE,SAAS,YAAY,OAAO,EAAC,IAAK,QAAQ,IAAI,CAAC;AACrD,MAAI,KAAKA,KAAI,IAAI,EAAE;AACnB,MAAI,CAAC,aAAa,IAAI,CAAC;AAAG,SAAKA,KAAI,CAAC,EAAE;AACtC,MAAI,CAAC;AAAY,QAAI;AACrB,MAAI,CAAC;AAAY,QAAI;AACrB,QAAM,KAAKA,KAAI,KAAK,IAAIT,QAAO,iBAAiB,CAAC;AACjD,QAAM,KAAK,IAAI;AACf,QAAM,KAAKS,MAAK,IAAI,KAAK,CAAC;AAC1B,QAAM,KAAKA,KAAI,KAAK,iBAAiB;AACrC,QAAM,KAAKA,KAAIT,OAAM,EAAE;AACvB,QAAM,KAAKS,KAAIT,OAAM,EAAE;AACvB,SAAO,IAAI,QAAQ,MAAMS,KAAI,KAAK,EAAE,GAAGA,KAAI,KAAK,EAAE,GAAGA,KAAI,KAAK,EAAE,GAAGA,KAAI,KAAK,EAAE,CAAC;AACjF;AAEA,SAAS,iBAAiBJ,QAAiB;AACzC,SAAOA,QAAO,EAAE;AAChB,QAAM,KAAK,mBAAmBA,OAAM,SAAS,GAAG,EAAE,CAAC;AACnD,QAAM,KAAK,0BAA0B,EAAE;AACvC,QAAM,KAAK,mBAAmBA,OAAM,SAAS,IAAI,EAAE,CAAC;AACpD,QAAM,KAAK,0BAA0B,EAAE;AACvC,SAAO,IAAI,gBAAgB,GAAG,IAAI,EAAE,CAAC;AACvC;AAWA,IAAM,kBAAN,MAAM,yBAAwB,kBAAkC;EAgB9D,YAAY,IAAiB;AAC3B,UAAM,EAAE;EACV;EAEA,OAAO,WAAW,IAAuB;AACvC,WAAO,IAAI,iBAAgB,QAAQ,MAAM,WAAW,EAAE,CAAC;EACzD;EAEU,WAAW,OAAsB;AACzC,QAAI,EAAE,iBAAiB;AAAkB,YAAM,IAAI,MAAM,yBAAyB;EACpF;EAEU,KAAK,IAAgB;AAC7B,WAAO,IAAI,iBAAgB,EAAE;EAC/B;;EAGA,OAAO,YAAY,KAAQ;AACzB,WAAO,iBAAiB,YAAY,iBAAiB,KAAK,EAAE,CAAC;EAC/D;EAEA,OAAO,UAAUA,QAAiB;AAChC,WAAOA,QAAO,EAAE;AAChB,UAAM,EAAE,GAAG,EAAC,IAAK;AACjB,UAAM,IAAI;AACV,UAAMI,OAAM,CAAC,MAAc,GAAG,OAAO,CAAC;AACtC,UAAM,IAAI,mBAAmBJ,MAAK;AAGlC,QAAI,CAAC,WAAW,GAAG,QAAQ,CAAC,GAAGA,MAAK,KAAK,aAAa,GAAG,CAAC;AACxD,YAAM,IAAI,MAAM,iCAAiC;AACnD,UAAM,KAAKI,KAAI,IAAI,CAAC;AACpB,UAAM,KAAKA,KAAIT,OAAM,IAAI,EAAE;AAC3B,UAAM,KAAKS,KAAIT,OAAM,IAAI,EAAE;AAC3B,UAAM,OAAOS,KAAI,KAAK,EAAE;AACxB,UAAM,OAAOA,KAAI,KAAK,EAAE;AACxB,UAAM,IAAIA,KAAI,IAAI,IAAI,OAAO,IAAI;AACjC,UAAM,EAAE,SAAS,OAAO,EAAC,IAAK,WAAWA,KAAI,IAAI,IAAI,CAAC;AACtD,UAAM,KAAKA,KAAI,IAAI,EAAE;AACrB,UAAM,KAAKA,KAAI,IAAI,KAAK,CAAC;AACzB,QAAI,IAAIA,MAAK,IAAI,KAAK,EAAE;AACxB,QAAI,aAAa,GAAG,CAAC;AAAG,UAAIA,KAAI,CAAC,CAAC;AAClC,UAAM,IAAIA,KAAI,KAAK,EAAE;AACrB,UAAM,IAAIA,KAAI,IAAI,CAAC;AACnB,QAAI,CAAC,WAAW,aAAa,GAAG,CAAC,KAAK,MAAMV;AAC1C,YAAM,IAAI,MAAM,iCAAiC;AACnD,WAAO,IAAI,iBAAgB,IAAI,QAAQ,MAAM,GAAG,GAAGC,MAAK,CAAC,CAAC;EAC5D;;;;;;EAOA,OAAO,QAAQ,KAAQ;AACrB,WAAO,iBAAgB,UAAU,YAAY,gBAAgB,KAAK,EAAE,CAAC;EACvE;EAEA,OAAO,IAAI,QAA2B,SAAiB;AACrD,WAAO,UAAU,kBAAiB,QAAQ,MAAM,IAAI,QAAQ,OAAO;EACrE;;;;;EAMA,UAAO;AACL,QAAI,EAAE,GAAG,GAAG,GAAG,EAAC,IAAK,KAAK;AAC1B,UAAM,IAAI;AACV,UAAMS,OAAM,CAAC,MAAc,GAAG,OAAO,CAAC;AACtC,UAAM,KAAKA,KAAIA,KAAI,IAAI,CAAC,IAAIA,KAAI,IAAI,CAAC,CAAC;AACtC,UAAM,KAAKA,KAAI,IAAI,CAAC;AAEpB,UAAM,OAAOA,KAAI,KAAK,EAAE;AACxB,UAAM,EAAE,OAAO,QAAO,IAAK,WAAWA,KAAI,KAAK,IAAI,CAAC;AACpD,UAAM,KAAKA,KAAI,UAAU,EAAE;AAC3B,UAAM,KAAKA,KAAI,UAAU,EAAE;AAC3B,UAAM,OAAOA,KAAI,KAAK,KAAK,CAAC;AAC5B,QAAI;AACJ,QAAI,aAAa,IAAI,MAAM,CAAC,GAAG;AAC7B,UAAI,KAAKA,KAAI,IAAI,OAAO;AACxB,UAAI,KAAKA,KAAI,IAAI,OAAO;AACxB,UAAI;AACJ,UAAI;AACJ,UAAIA,KAAI,KAAK,iBAAiB;IAChC,OAAO;AACL,UAAI;IACN;AACA,QAAI,aAAa,IAAI,MAAM,CAAC;AAAG,UAAIA,KAAI,CAAC,CAAC;AACzC,QAAI,IAAIA,MAAK,IAAI,KAAK,CAAC;AACvB,QAAI,aAAa,GAAG,CAAC;AAAG,UAAIA,KAAI,CAAC,CAAC;AAClC,WAAO,GAAG,QAAQ,CAAC;EACrB;;;;;EAMA,OAAO,OAAsB;AAC3B,SAAK,WAAW,KAAK;AACrB,UAAM,EAAE,GAAG,IAAI,GAAG,GAAE,IAAK,KAAK;AAC9B,UAAM,EAAE,GAAG,IAAI,GAAG,GAAE,IAAK,MAAM;AAC/B,UAAMA,OAAM,CAAC,MAAc,GAAG,OAAO,CAAC;AAEtC,UAAM,MAAMA,KAAI,KAAK,EAAE,MAAMA,KAAI,KAAK,EAAE;AACxC,UAAM,MAAMA,KAAI,KAAK,EAAE,MAAMA,KAAI,KAAK,EAAE;AACxC,WAAO,OAAO;EAChB;EAEA,MAAG;AACD,WAAO,KAAK,OAAO,iBAAgB,IAAI;EACzC;;AA3HO,gBAAA,QACY,MAAM,IAAI,gBAAgB,QAAQ,MAAM,IAAI,GAAE;AAE1D,gBAAA,QACY,MAAM,IAAI,gBAAgB,QAAQ,MAAM,IAAI,GAAE;AAE1D,gBAAA,KACY,uBAAM,IAAG;AAErB,gBAAA,KACY,uBAAM,IAAG;AAyHvB,IAAM,sBAA6C;EACxD,YAAY,KAAiB,SAAsB;AACjD,UAAM,OAAM,mCAAS,QAAO;AAC5B,UAAM,MAAM,mBAAmB,KAAK,KAAK,IAAI,MAAM;AACnD,WAAO,iBAAiB,GAAG;EAC7B;EACA,aAAa,KAAiB,UAAwB,EAAE,KAAK,YAAW,GAAE;AACxE,UAAM,MAAM,mBAAmB,KAAK,QAAQ,KAAK,IAAI,MAAM;AAC3D,WAAO,GAAG,OAAO,gBAAgB,GAAG,CAAC;EACvC;;AA2CK,IAAM,eAAkD,MAAM,eAAe,aAAY;AAEzF,IAAM,iBAAoD,MAC/D,eAAe,eAAc;AAGxB,IAAM,sBAAkD,MAC7D,oBAAoB,aAA0B;AAEzC,IAAM,wBAAoD,MAC/D,oBAAoB,aAA0B;;;A1HnfhD,IAAAC,iBAAkC;;;A2HtDlC,IAAM,qBAAqB;AAAA,EACvB,gBAAgB;AACpB;AAGA,IAAM,wBAAwB,CAAC,SAAS,QAAQC,UAAS,uBAAuB;AAC5E,QAAM,OAAO,OAAO,KAAK,IACnB,EAAE,MAAM,MAAM,OAAO,OAAO,MAAM,IAClC,EAAE,MAAM,OAAO,OAAO,OAAO,MAAM;AACzC,QAAM,aAAaA,QAAO,iBAAiB,IAAI,MAAM,EAAE,QAAQ;AAC/D,SAAO;AAAA,IACH;AAAA,IACA;AAAA,IACA,OAAO;AAAA,EACX;AACJ;AAmBA,SAASC,WAAU,SAAS,YAAY,GAAG,WAAW;AAClD,WAAS,MAAM,OAAO;AAAE,WAAO,iBAAiB,IAAI,QAAQ,IAAI,EAAE,SAAU,SAAS;AAAE,cAAQ,KAAK;AAAA,IAAG,CAAC;AAAA,EAAG;AAC3G,SAAO,KAAK,MAAM,IAAI,UAAU,SAAU,SAAS,QAAQ;AACvD,aAAS,UAAU,OAAO;AAAE,UAAI;AAAE,aAAK,UAAU,KAAK,KAAK,CAAC;AAAA,MAAG,SAAS,GAAG;AAAE,eAAO,CAAC;AAAA,MAAG;AAAA,IAAE;AAC1F,aAAS,SAAS,OAAO;AAAE,UAAI;AAAE,aAAK,UAAU,OAAO,EAAE,KAAK,CAAC;AAAA,MAAG,SAAS,GAAG;AAAE,eAAO,CAAC;AAAA,MAAG;AAAA,IAAE;AAC7F,aAAS,KAAK,QAAQ;AAAE,aAAO,OAAO,QAAQ,OAAO,KAAK,IAAI,MAAM,OAAO,KAAK,EAAE,KAAK,WAAW,QAAQ;AAAA,IAAG;AAC7G,UAAM,YAAY,UAAU,MAAM,SAAS,cAAc,CAAC,CAAC,GAAG,KAAK,CAAC;AAAA,EACxE,CAAC;AACL;AAEA,SAASC,UAAS,GAAG;AACjB,MAAI,IAAI,OAAO,WAAW,cAAc,OAAO,UAAU,IAAI,KAAK,EAAE,CAAC,GAAG,IAAI;AAC5E,MAAI,EAAG,QAAO,EAAE,KAAK,CAAC;AACtB,MAAI,KAAK,OAAO,EAAE,WAAW,SAAU,QAAO;AAAA,IAC1C,MAAM,WAAY;AACd,UAAI,KAAK,KAAK,EAAE,OAAQ,KAAI;AAC5B,aAAO,EAAE,OAAO,KAAK,EAAE,GAAG,GAAG,MAAM,CAAC,EAAE;AAAA,IAC1C;AAAA,EACJ;AACA,QAAM,IAAI,UAAU,IAAI,4BAA4B,iCAAiC;AACzF;AAEA,SAASC,SAAQ,GAAG;AAChB,SAAO,gBAAgBA,YAAW,KAAK,IAAI,GAAG,QAAQ,IAAIA,SAAQ,CAAC;AACvE;AAEA,SAASC,kBAAiB,SAAS,YAAY,WAAW;AACtD,MAAI,CAAC,OAAO,cAAe,OAAM,IAAI,UAAU,sCAAsC;AACrF,MAAI,IAAI,UAAU,MAAM,SAAS,cAAc,CAAC,CAAC,GAAG,GAAG,IAAI,CAAC;AAC5D,SAAO,IAAI,OAAO,QAAQ,OAAO,kBAAkB,aAAa,gBAAgB,QAAQ,SAAS,GAAG,KAAK,MAAM,GAAG,KAAK,OAAO,GAAG,KAAK,UAAU,WAAW,GAAG,EAAE,OAAO,aAAa,IAAI,WAAY;AAAE,WAAO;AAAA,EAAM,GAAG;AACtN,WAAS,YAAYC,IAAG;AAAE,WAAO,SAAU,GAAG;AAAE,aAAO,QAAQ,QAAQ,CAAC,EAAE,KAAKA,IAAG,MAAM;AAAA,IAAG;AAAA,EAAG;AAC9F,WAAS,KAAK,GAAGA,IAAG;AAAE,QAAI,EAAE,CAAC,GAAG;AAAE,QAAE,CAAC,IAAI,SAAU,GAAG;AAAE,eAAO,IAAI,QAAQ,SAAU,GAAG,GAAG;AAAE,YAAE,KAAK,CAAC,GAAG,GAAG,GAAG,CAAC,CAAC,IAAI,KAAK,OAAO,GAAG,CAAC;AAAA,QAAG,CAAC;AAAA,MAAG;AAAG,UAAIA,GAAG,GAAE,CAAC,IAAIA,GAAE,EAAE,CAAC,CAAC;AAAA,IAAG;AAAA,EAAE;AACvK,WAAS,OAAO,GAAG,GAAG;AAAE,QAAI;AAAE,WAAK,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,IAAG,SAAS,GAAG;AAAE,aAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,IAAG;AAAA,EAAE;AACjF,WAAS,KAAK,GAAG;AAAE,MAAE,iBAAiBF,WAAU,QAAQ,QAAQ,EAAE,MAAM,CAAC,EAAE,KAAK,SAAS,MAAM,IAAI,OAAO,EAAE,CAAC,EAAE,CAAC,GAAG,CAAC;AAAA,EAAG;AACvH,WAAS,QAAQ,OAAO;AAAE,WAAO,QAAQ,KAAK;AAAA,EAAG;AACjD,WAAS,OAAO,OAAO;AAAE,WAAO,SAAS,KAAK;AAAA,EAAG;AACjD,WAAS,OAAOE,IAAG,GAAG;AAAE,QAAIA,GAAE,CAAC,GAAG,EAAE,MAAM,GAAG,EAAE,OAAQ,QAAO,EAAE,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,CAAC;AAAA,EAAG;AACrF;AAEA,SAAS,iBAAiB,GAAG;AACzB,MAAI,GAAG;AACP,SAAO,IAAI,CAAC,GAAG,KAAK,MAAM,GAAG,KAAK,SAAS,SAAU,GAAG;AAAE,UAAM;AAAA,EAAG,CAAC,GAAG,KAAK,QAAQ,GAAG,EAAE,OAAO,QAAQ,IAAI,WAAY;AAAE,WAAO;AAAA,EAAM,GAAG;AAC1I,WAAS,KAAK,GAAGA,IAAG;AAAE,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,SAAU,GAAG;AAAE,cAAQ,IAAI,CAAC,KAAK,EAAE,OAAOF,SAAQ,EAAE,CAAC,EAAE,CAAC,CAAC,GAAG,MAAM,MAAM,IAAIE,KAAIA,GAAE,CAAC,IAAI;AAAA,IAAG,IAAIA;AAAA,EAAG;AACzI;AAEA,SAASC,eAAc,GAAG;AACtB,MAAI,CAAC,OAAO,cAAe,OAAM,IAAI,UAAU,sCAAsC;AACrF,MAAI,IAAI,EAAE,OAAO,aAAa,GAAG;AACjC,SAAO,IAAI,EAAE,KAAK,CAAC,KAAK,IAAI,OAAOJ,cAAa,aAAaA,UAAS,CAAC,IAAI,EAAE,OAAO,QAAQ,EAAE,GAAG,IAAI,CAAC,GAAG,KAAK,MAAM,GAAG,KAAK,OAAO,GAAG,KAAK,QAAQ,GAAG,EAAE,OAAO,aAAa,IAAI,WAAY;AAAE,WAAO;AAAA,EAAM,GAAG;AAC9M,WAAS,KAAK,GAAG;AAAE,MAAE,CAAC,IAAI,EAAE,CAAC,KAAK,SAAU,GAAG;AAAE,aAAO,IAAI,QAAQ,SAAU,SAAS,QAAQ;AAAE,YAAI,EAAE,CAAC,EAAE,CAAC,GAAG,OAAO,SAAS,QAAQ,EAAE,MAAM,EAAE,KAAK;AAAA,MAAG,CAAC;AAAA,IAAG;AAAA,EAAG;AAC/J,WAAS,OAAO,SAAS,QAAQ,GAAG,GAAG;AAAE,YAAQ,QAAQ,CAAC,EAAE,KAAK,SAASK,IAAG;AAAE,cAAQ,EAAE,OAAOA,IAAG,MAAM,EAAE,CAAC;AAAA,IAAG,GAAG,MAAM;AAAA,EAAG;AAC/H;AAOA,IAAM,cAAN,MAAM,aAAY;AAAA,EACd,YAAY,KAAK;AACb,SAAK,WAAW;AAAA,EACpB;AAAA,EACA,OAAO,gBAAgB,SAAS;AAC5B,UAAM,aAAa,QAAQ,KAAK,CAAC,UAAU,IAAI,GAAG,KAAK,CAAC;AACxD,WAAO,IAAI,aAAY,UAAU;AAAA,EACrC;AAAA,EACA,OAAO,YAAY,SAAS,SAAS;AACjC,UAAM,aAAa,QACd,KAAK,CAAC,UAAU,IAAI,GAAG,KAAK,CAAC,EAC7B,MAAM,CAAC,MAAM,IAAI,IAAI,QAAQ,CAAC,CAAC,CAAC;AACrC,WAAO,IAAI,aAAY,UAAU;AAAA,EACrC;AAAA;AAAA,EAEA,OAAO,cAAc,IAAI,SAAS;AAC9B,WAAO,IAAI,SAAS;AAChB,aAAO,IAAI,cAAa,MAAMC,WAAU,MAAM,QAAQ,QAAQ,aAAa;AACvE,YAAI;AACA,iBAAO,IAAI,GAAG,MAAM,GAAG,GAAG,IAAI,CAAC;AAAA,QACnC,SACO,OAAO;AACV,iBAAO,IAAI,IAAI,UAAU,QAAQ,KAAK,IAAI,KAAK;AAAA,QACnD;AAAA,MACJ,CAAC,GAAG,CAAC;AAAA,IACT;AAAA,EACJ;AAAA,EACA,OAAO,QAAQ,iBAAiB;AAC5B,WAAO,uBAAuB,eAAe;AAAA,EACjD;AAAA,EACA,OAAO,qBAAqB,iBAAiB;AACzC,WAAO,oCAAoC,eAAe;AAAA,EAC9D;AAAA,EACA,IAAIC,IAAG;AACH,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,MAAM,GAAG;AACb,eAAO,IAAI,IAAI,IAAI,KAAK;AAAA,MAC5B;AACA,aAAO,IAAI,GAAG,MAAMC,GAAE,IAAI,KAAK,CAAC;AAAA,IACpC,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,WAAWA,IAAG;AACV,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,MAAM,GAAG;AACb,eAAO,IAAI,IAAI,IAAI,KAAK;AAAA,MAC5B;AACA,YAAM,SAAS,MAAMC,GAAE,IAAI,KAAK;AAChC,UAAI,OAAO,MAAM,GAAG;AAChB,eAAO,IAAI,IAAI,OAAO,KAAK;AAAA,MAC/B;AACA,aAAO,IAAI,GAAG,IAAI,KAAK;AAAA,IAC3B,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,OAAOA,IAAG;AACN,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,MAAM,GAAG;AACb,eAAO,IAAI,IAAI,IAAI,KAAK;AAAA,MAC5B;AACA,UAAI;AACA,cAAMC,GAAE,IAAI,KAAK;AAAA,MACrB,SACO,GAAG;AAAA,MAEV;AACA,aAAO,IAAI,GAAG,IAAI,KAAK;AAAA,IAC3B,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,MAAMA,IAAG;AACL,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,KAAK,GAAG;AACZ,eAAO,IAAI,GAAG,IAAI,KAAK;AAAA,MAC3B;AACA,UAAI;AACA,cAAMC,GAAE,IAAI,KAAK;AAAA,MACrB,SACO,GAAG;AAAA,MAEV;AACA,aAAO,IAAI,IAAI,IAAI,KAAK;AAAA,IAC5B,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,OAAOA,IAAG;AACN,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,KAAK,GAAG;AACZ,eAAO,IAAI,GAAG,IAAI,KAAK;AAAA,MAC3B;AACA,aAAO,IAAI,IAAI,MAAMC,GAAE,IAAI,KAAK,CAAC;AAAA,IACrC,CAAC,CAAC,CAAC;AAAA,EACP;AAAA;AAAA,EAEA,QAAQA,IAAG;AACP,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQ;AAC/C,UAAI,IAAI,MAAM,GAAG;AACb,eAAO,IAAI,IAAI,IAAI,KAAK;AAAA,MAC5B;AACA,YAAM,WAAWA,GAAE,IAAI,KAAK;AAC5B,aAAO,oBAAoB,eAAc,SAAS,WAAW;AAAA,IACjE,CAAC,CAAC;AAAA,EACN;AAAA;AAAA,EAEA,OAAOA,IAAG;AACN,WAAO,IAAI,aAAY,KAAK,SAAS,KAAK,CAAC,QAAQD,WAAU,MAAM,QAAQ,QAAQ,aAAa;AAC5F,UAAI,IAAI,MAAM,GAAG;AACb,eAAOC,GAAE,IAAI,KAAK;AAAA,MACtB;AACA,aAAO,IAAI,GAAG,IAAI,KAAK;AAAA,IAC3B,CAAC,CAAC,CAAC;AAAA,EACP;AAAA,EACA,MAAMC,KAAI,MAAM;AACZ,WAAO,KAAK,SAAS,KAAK,CAAC,QAAQ,IAAI,MAAMA,KAAI,IAAI,CAAC;AAAA,EAC1D;AAAA,EACA,SAAS,GAAG;AACR,WAAO,KAAK,SAAS,KAAK,CAAC,QAAQ,IAAI,SAAS,CAAC,CAAC;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,aAAa;AACT,WAAOC,kBAAiB,MAAM,WAAW,UAAU,eAAe;AAC9D,aAAO,MAAMC,SAAQ,MAAMA,SAAQ,OAAO,iBAAiBC,eAAc,MAAMD,SAAQ,KAAK,SAAS,KAAK,CAAC,QAAQ,IAAI,WAAW,CAAC,CAAC,CAAC,CAAC,CAAC,CAAC;AAAA,IAC5I,CAAC;AAAA,EACL;AAAA;AAAA,EAEA,KAAK,iBAAiB,iBAAiB;AACnC,WAAO,KAAK,SAAS,KAAK,iBAAiB,eAAe;AAAA,EAC9D;AAAA,EACA,CAAC,OAAO,aAAa,IAAI;AACrB,WAAOD,kBAAiB,MAAM,WAAW,UAAUG,MAAK;AACpD,YAAM,SAAS,MAAMF,SAAQ,KAAK,QAAQ;AAC1C,UAAI,OAAO,MAAM,GAAG;AAEhB,cAAM,MAAMA,SAAQ,SAAS,OAAO,KAAK,CAAC;AAAA,MAC9C;AAEA,aAAO,MAAMA,SAAQ,OAAO,KAAK;AAAA,IACrC,CAAC;AAAA,EACL;AACJ;AACA,SAAS,QAAQ,OAAO;AACpB,SAAO,IAAI,YAAY,QAAQ,QAAQ,IAAI,GAAG,KAAK,CAAC,CAAC;AACzD;AACA,SAAS,SAASG,MAAK;AACnB,SAAO,IAAI,YAAY,QAAQ,QAAQ,IAAI,IAAIA,IAAG,CAAC,CAAC;AACxD;AACA,IAAMC,eAAc,YAAY;AAChC,IAAM,kBAAkB,YAAY;AACpC,IAAM,qBAAqB,YAAY;AAKvC,IAAM,oBAAoB,CAAC,eAAe;AACtC,MAAI,MAAM,GAAG,CAAC,CAAC;AACf,aAAW,UAAU,YAAY;AAC7B,QAAI,OAAO,MAAM,GAAG;AAChB,YAAM,IAAI,OAAO,KAAK;AACtB;AAAA,IACJ,OACK;AACD,UAAI,IAAI,CAAC,SAAS,KAAK,KAAK,OAAO,KAAK,CAAC;AAAA,IAC7C;AAAA,EACJ;AACA,SAAO;AACX;AAMA,IAAM,yBAAyB,CAAC,oBAAoB,YAAY,gBAAgB,QAAQ,IAAI,eAAe,CAAC,EAAE,QAAQ,iBAAiB;AAIvI,IAAM,iCAAiC,CAAC,eAAe;AACnD,MAAI,MAAM,GAAG,CAAC,CAAC;AACf,aAAW,UAAU,YAAY;AAC7B,QAAI,OAAO,MAAM,KAAK,IAAI,MAAM,GAAG;AAC/B,UAAI,MAAM,KAAK,OAAO,KAAK;AAAA,IAC/B,WACS,OAAO,MAAM,KAAK,IAAI,KAAK,GAAG;AACnC,YAAM,IAAI,CAAC,OAAO,KAAK,CAAC;AAAA,IAC5B,WACS,OAAO,KAAK,KAAK,IAAI,KAAK,GAAG;AAClC,UAAI,MAAM,KAAK,OAAO,KAAK;AAAA,IAC/B;AAAA,EAEJ;AACA,SAAO;AACX;AACA,IAAM,sCAAsC,CAAC,oBAAoB,YAAY,gBAAgB,QAAQ,IAAI,eAAe,CAAC,EAAE,QAAQ,8BAA8B;AAGjK,IAAI;AAAA,CACH,SAAUC,SAAQ;AASf,WAASC,eAAc,IAAI,SAAS;AAChC,WAAO,IAAI,SAAS;AAChB,UAAI;AACA,cAAM,SAAS,GAAG,GAAG,IAAI;AACzB,eAAO,GAAG,MAAM;AAAA,MACpB,SACO,GAAG;AACN,eAAO,IAAI,UAAU,QAAQ,CAAC,IAAI,CAAC;AAAA,MACvC;AAAA,IACJ;AAAA,EACJ;AACA,EAAAD,QAAO,gBAAgBC;AACvB,WAAS,QAAQ,YAAY;AACzB,WAAO,kBAAkB,UAAU;AAAA,EACvC;AACA,EAAAD,QAAO,UAAU;AACjB,WAAS,qBAAqB,YAAY;AACtC,WAAO,+BAA+B,UAAU;AAAA,EACpD;AACA,EAAAA,QAAO,uBAAuB;AAClC,GAAG,WAAW,SAAS,CAAC,EAAE;AAC1B,SAAS,GAAG,OAAO;AACf,SAAO,IAAI,GAAG,KAAK;AACvB;AACA,SAAS,IAAIF,MAAK;AACd,SAAO,IAAI,IAAIA,IAAG;AACtB;AAQA,IAAM,KAAN,MAAS;AAAA,EACL,YAAY,OAAO;AACf,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,OAAO;AACH,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,WAAO,CAAC,KAAK,KAAK;AAAA,EACtB;AAAA,EACA,IAAII,IAAG;AACH,WAAO,GAAGA,GAAE,KAAK,KAAK,CAAC;AAAA,EAC3B;AAAA;AAAA,EAEA,OAAO,IAAI;AACP,WAAO,GAAG,KAAK,KAAK;AAAA,EACxB;AAAA;AAAA,EAEA,QAAQA,IAAG;AACP,WAAOA,GAAE,KAAK,KAAK;AAAA,EACvB;AAAA;AAAA,EAEA,WAAWA,IAAG;AACV,WAAOA,GAAE,KAAK,KAAK,EAAE,IAAI,CAAC,WAAW,KAAK,KAAK;AAAA,EACnD;AAAA,EACA,OAAOA,IAAG;AACN,QAAI;AACA,MAAAA,GAAE,KAAK,KAAK;AAAA,IAChB,SACO,GAAG;AAAA,IAEV;AACA,WAAO,GAAG,KAAK,KAAK;AAAA,EACxB;AAAA,EACA,MAAM,IAAI;AACN,WAAO,GAAG,KAAK,KAAK;AAAA,EACxB;AAAA;AAAA,EAEA,OAAO,IAAI;AACP,WAAO,GAAG,KAAK,KAAK;AAAA,EACxB;AAAA,EACA,aAAaA,IAAG;AACZ,WAAOA,GAAE,KAAK,KAAK;AAAA,EACvB;AAAA;AAAA,EAEA,gBAAgBA,IAAG;AACf,WAAOA,GAAE,KAAK,KAAK,EAAE,IAAI,MAAM,KAAK,KAAK;AAAA,EAC7C;AAAA,EACA,SAASA,IAAG;AACR,WAAO,YAAY,gBAAgBA,GAAE,KAAK,KAAK,CAAC;AAAA,EACpD;AAAA;AAAA,EAEA,SAAS,IAAI;AACT,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA,EAEA,MAAMC,KAAI,MAAM;AACZ,WAAOA,IAAG,KAAK,KAAK;AAAA,EACxB;AAAA,EACA,aAAa;AACT,UAAM,QAAQ,KAAK;AAEnB,WAAQ,aAAa;AACjB,aAAO;AAAA,IACX,EAAG;AAAA,EACP;AAAA,EACA,cAAc,GAAG;AACb,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,iBAAiBC,SAAQ;AACrB,UAAM,sBAAsB,sCAAsC,MAAMA,OAAM;AAAA,EAClF;AAAA;AAAA,EAEA,EAAE,OAAO,QAAQ,IAAI;AACjB,WAAO,KAAK;AAAA,EAChB;AACJ;AACA,IAAM,MAAN,MAAU;AAAA,EACN,YAAY,OAAO;AACf,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,OAAO;AACH,WAAO;AAAA,EACX;AAAA,EACA,QAAQ;AACJ,WAAO,CAAC,KAAK,KAAK;AAAA,EACtB;AAAA;AAAA,EAEA,IAAI,IAAI;AACJ,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA,EACA,OAAOF,IAAG;AACN,WAAO,IAAIA,GAAE,KAAK,KAAK,CAAC;AAAA,EAC5B;AAAA,EACA,WAAW,IAAI;AACX,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA,EACA,OAAO,IAAI;AACP,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA,EACA,MAAMA,IAAG;AACL,QAAI;AACA,MAAAA,GAAE,KAAK,KAAK;AAAA,IAChB,SACO,GAAG;AAAA,IAEV;AACA,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA;AAAA,EAEA,QAAQ,IAAI;AACR,WAAO,IAAI,KAAK,KAAK;AAAA,EACzB;AAAA;AAAA,EAEA,OAAOA,IAAG;AACN,WAAOA,GAAE,KAAK,KAAK;AAAA,EACvB;AAAA;AAAA,EAEA,aAAa,IAAI;AACb,WAAO,SAAS,KAAK,KAAK;AAAA,EAC9B;AAAA,EACA,gBAAgB,IAAI;AAChB,WAAO,SAAS,KAAK,KAAK;AAAA,EAC9B;AAAA;AAAA,EAEA,SAAS,IAAI;AACT,WAAO,SAAS,KAAK,KAAK;AAAA,EAC9B;AAAA,EACA,SAAS,GAAG;AACR,WAAO;AAAA,EACX;AAAA,EACA,MAAM,KAAKG,MAAK;AACZ,WAAOA,KAAI,KAAK,KAAK;AAAA,EACzB;AAAA,EACA,aAAa;AACT,UAAM,QAAQ,KAAK;AACnB,WAAQ,aAAa;AACjB,YAAM,IAAI,KAAK;AACf,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAChE,EAAG;AAAA,EACP;AAAA,EACA,cAAcD,SAAQ;AAClB,UAAM,sBAAsB,oCAAoC,MAAMA,OAAM;AAAA,EAChF;AAAA,EACA,iBAAiB,GAAG;AAChB,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,EAAE,OAAO,QAAQ,IAAI;AAEjB,UAAM,OAAO;AAEb,UAAM;AAEN,WAAO;AAAA,EACX;AACJ;AACA,IAAM,gBAAgB,OAAO;;;A3HsB7B,qBAAkB;AAClB,IAAAE,iBAAkC;;;A4H/f3B,IAAM,UAAyB,OAAO,IAAI,eAAe;AAUzD,IAAM,YAA2B,OAAO,IAAI,iBAAiB;AAE7D,IAAM,cAA6B,OAAO,IAAI,aAAa;ACjB3D,IAAM,SACZ,OACG;;EAEA,SAAS,QAAgB;AACxB,WAAO,mBAAmB,MAAA,mFAAyF,MAAA;EACpH;EACA,SAAS,OAAe;AACvB,WAAO,sJAAsJ,KAAA;EAC9J;EACA;EACA,SAAS,MAAW;AACnB,WACC,yHACA;EAEF;EACA;EACA;EACA;EACA;EACA;EACA;EACA,SAAS,OAAe;AACvB,WAAO,mCAAmC,KAAA;EAC3C;EACA;EACA;EACA;EACA;EACA,SAAS,OAAe;AACvB,WAAO,oCAAoC,KAAA;EAC5C;;;AAGA,IACA,CAAC;AAEE,SAAS,IAAI,UAAkB,MAAoB;AACzD,MAAI,MAAuC;AAC1C,UAAM,IAAI,OAAO,KAAK;AACtB,UAAM,MAAM,OAAO,MAAM,aAAa,EAAE,MAAM,MAAM,IAAW,IAAI;AACnE,UAAM,IAAI,MAAM,WAAW,GAAA,EAAK;EACjC;AACA,QAAM,IAAI;IACT,8BAA8B,KAAA;EAC/B;AACD;ACjCO,IAAM,iBAAiB,OAAO;AAI9B,SAAS,QAAQ,OAAqB;AAC5C,SAAO,CAAC,CAAC,SAAS,CAAC,CAAC,MAAM,WAAW;AACtC;AAIO,SAAS,YAAY,OAAqB;;AAChD,MAAI,CAAC;AAAO,WAAO;AACnB,SACC,cAAc,KAAK,KACnB,MAAM,QAAQ,KAAK,KACnB,CAAC,CAAC,MAAM,SAAS,KACjB,CAAC,GAACC,MAAA,MAAM,gBAAN,gBAAAA,IAAoB,eACtB,MAAM,KAAK,KACX,MAAM,KAAK;AAEb;AAEA,IAAM,mBAAmB,OAAO,UAAU,YAAY,SAAS;AAExD,SAAS,cAAc,OAAqB;AAClD,MAAI,CAAC,SAAS,OAAO,UAAU;AAAU,WAAO;AAChD,QAAM,QAAQ,eAAe,KAAK;AAClC,MAAI,UAAU,MAAM;AACnB,WAAO;EACR;AACA,QAAM,OACL,OAAO,eAAe,KAAK,OAAO,aAAa,KAAK,MAAM;AAE3D,MAAI,SAAS;AAAQ,WAAO;AAE5B,SACC,OAAO,QAAQ,cACf,SAAS,SAAS,KAAK,IAAI,MAAM;AAEnC;AAmBO,SAAS,KAAK,KAAU,MAAW;AACzC,MAAI,YAAY,GAAG,MAAA,GAAuB;AACzC,YAAQ,QAAQ,GAAG,EAAE,QAAQ,CAAA,QAAO;AACnC,WAAK,KAAK,IAAI,GAAG,GAAG,GAAG;IACxB,CAAC;EACF,OAAO;AACN,QAAI,QAAQ,CAAC,OAAY,UAAe,KAAK,OAAO,OAAO,GAAG,CAAC;EAChE;AACD;AAGO,SAAS,YAAY,OAAsB;AACjD,QAAM,QAAgC,MAAM,WAAW;AACvD,SAAO,QACJ,MAAM,QACN,MAAM,QAAQ,KAAK,IAAA,IAEnB,MAAM,KAAK,IAAA,IAEX,MAAM,KAAK,IAAA,IAAA;AAGf;AAGO,SAAS,IAAI,OAAY,MAA4B;AAC3D,SAAO,YAAY,KAAK,MAAA,IACrB,MAAM,IAAI,IAAI,IACd,OAAO,UAAU,eAAe,KAAK,OAAO,IAAI;AACpD;AASO,SAAS,IAAI,OAAY,gBAA6B,OAAY;AACxE,QAAM,IAAI,YAAY,KAAK;AAC3B,MAAI,MAAA;AAAoB,UAAM,IAAI,gBAAgB,KAAK;WAC9C,MAAA,GAAoB;AAC5B,UAAM,IAAI,KAAK;EAChB;AAAO,UAAM,cAAc,IAAI;AAChC;AAGO,SAAS,GAAG,GAAQ,GAAiB;AAE3C,MAAI,MAAM,GAAG;AACZ,WAAO,MAAM,KAAK,IAAI,MAAM,IAAI;EACjC,OAAO;AACN,WAAO,MAAM,KAAK,MAAM;EACzB;AACD;AAGO,SAAS,MAAM,QAA+B;AACpD,SAAO,kBAAkB;AAC1B;AAGO,SAAS,MAAM,QAA+B;AACpD,SAAO,kBAAkB;AAC1B;AAEO,SAAS,OAAO,OAAwB;AAC9C,SAAO,MAAM,SAAS,MAAM;AAC7B;AAGO,SAAS,YAAY,MAAW,QAAoB;AAC1D,MAAI,MAAM,IAAI,GAAG;AAChB,WAAO,IAAI,IAAI,IAAI;EACpB;AACA,MAAI,MAAM,IAAI,GAAG;AAChB,WAAO,IAAI,IAAI,IAAI;EACpB;AACA,MAAI,MAAM,QAAQ,IAAI;AAAG,WAAO,MAAM,UAAU,MAAM,KAAK,IAAI;AAE/D,QAAM,UAAU,cAAc,IAAI;AAElC,MAAI,WAAW,QAAS,WAAW,gBAAgB,CAAC,SAAU;AAE7D,UAAM,cAAc,OAAO,0BAA0B,IAAI;AACzD,WAAO,YAAY,WAAkB;AACrC,QAAI,OAAO,QAAQ,QAAQ,WAAW;AACtC,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,YAAM,MAAW,KAAK,CAAC;AACvB,YAAM,OAAO,YAAY,GAAG;AAC5B,UAAI,KAAK,aAAa,OAAO;AAC5B,aAAK,WAAW;AAChB,aAAK,eAAe;MACrB;AAIA,UAAI,KAAK,OAAO,KAAK;AACpB,oBAAY,GAAG,IAAI;UAClB,cAAc;UACd,UAAU;;UACV,YAAY,KAAK;UACjB,OAAO,KAAK,GAAG;QAChB;IACF;AACA,WAAO,OAAO,OAAO,eAAe,IAAI,GAAG,WAAW;EACvD,OAAO;AAEN,UAAM,QAAQ,eAAe,IAAI;AACjC,QAAI,UAAU,QAAQ,SAAS;AAC9B,aAAO,EAAC,GAAG,KAAI;IAChB;AACA,UAAM,MAAM,OAAO,OAAO,KAAK;AAC/B,WAAO,OAAO,OAAO,KAAK,IAAI;EAC/B;AACD;AAUO,SAAS,OAAU,KAAU,OAAgB,OAAU;AAC7D,MAAI,SAAS,GAAG,KAAK,QAAQ,GAAG,KAAK,CAAC,YAAY,GAAG;AAAG,WAAO;AAC/D,MAAI,YAAY,GAAG,IAAI,GAAoB;AACzC,WAAO,iBAAiB,KAAK;MACR,KAAK,EAAC,OAAO,4BAAkC;MAC/C,KAAK,EAAC,OAAO,4BAAkC;MAC/C,OAAO,EAAC,OAAO,4BAAkC;MACjD,QAAQ,EAAC,OAAO,4BAAkC;IAC1D,CAAC;EAChB;AACA,SAAO,OAAO,GAAG;AACjB,MAAI;AAGH,WAAO,OAAO,GAAG,EAAE,QAAQ,CAAA,UAAS,OAAO,OAAO,IAAI,CAAC;AACxD,SAAO;AACR;AAEA,SAAS,8BAA8B;AACtC,MAAI,CAAC;AACN;AAEO,SAAS,SAAS,KAAmB;AAC3C,SAAO,OAAO,SAAS,GAAG;AAC3B;ACjNA,IAAM,UAoBF,CAAC;AAIE,SAAS,UACf,WACiC;AACjC,QAAM,SAAS,QAAQ,SAAS;AAChC,MAAI,CAAC,QAAQ;AACZ,QAAI,GAAG,SAAS;EACjB;AAEA,SAAO;AACR;ACrBA,IAAI;AAEG,SAAS,kBAAkB;AACjC,SAAO;AACR;AAEA,SAAS,YACR,SACA,QACa;AACb,SAAO;IACN,SAAS,CAAC;IACV;IACA;;;IAGA,gBAAgB;IAChB,oBAAoB;EACrB;AACD;AAEO,SAAS,kBACf,OACA,eACC;AACD,MAAI,eAAe;AAClB,cAAU,SAAS;AACnB,UAAM,WAAW,CAAC;AAClB,UAAM,kBAAkB,CAAC;AACzB,UAAM,iBAAiB;EACxB;AACD;AAEO,SAAS,YAAY,OAAmB;AAC9C,aAAW,KAAK;AAChB,QAAM,QAAQ,QAAQ,WAAW;AAEjC,QAAM,UAAU;AACjB;AAEO,SAAS,WAAW,OAAmB;AAC7C,MAAI,UAAU,cAAc;AAC3B,mBAAe,MAAM;EACtB;AACD;AAEO,SAAS,WAAWC,QAAc;AACxC,SAAQ,eAAe,YAAY,cAAcA,MAAK;AACvD;AAEA,SAAS,YAAY,OAAgB;AACpC,QAAM,QAAoB,MAAM,WAAW;AAC3C,MAAI,MAAM,UAAA,KAA6B,MAAM,UAAA;AAC5C,UAAM,QAAQ;;AACV,UAAM,WAAW;AACvB;AC1DO,SAAS,cAAc,QAAa,OAAmB;AAC7D,QAAM,qBAAqB,MAAM,QAAQ;AACzC,QAAM,YAAY,MAAM,QAAS,CAAC;AAClC,QAAM,aAAa,WAAW,UAAa,WAAW;AACtD,MAAI,YAAY;AACf,QAAI,UAAU,WAAW,EAAE,WAAW;AACrC,kBAAY,KAAK;AACjB,UAAI,CAAC;IACN;AACA,QAAI,YAAY,MAAM,GAAG;AAExB,eAASC,UAAS,OAAO,MAAM;AAC/B,UAAI,CAAC,MAAM;AAAS,oBAAY,OAAO,MAAM;IAC9C;AACA,QAAI,MAAM,UAAU;AACnB,gBAAU,SAAS,EAAE;QACpB,UAAU,WAAW,EAAE;QACvB;QACA,MAAM;QACN,MAAM;MACP;IACD;EACD,OAAO;AAEN,aAASA,UAAS,OAAO,WAAW,CAAC,CAAC;EACvC;AACA,cAAY,KAAK;AACjB,MAAI,MAAM,UAAU;AACnB,UAAM,eAAgB,MAAM,UAAU,MAAM,eAAgB;EAC7D;AACA,SAAO,WAAW,UAAU,SAAS;AACtC;AAEA,SAASA,UAAS,WAAuB,OAAY,MAAkB;AAEtE,MAAI,SAAS,KAAK;AAAG,WAAO;AAE5B,QAAM,QAAoB,MAAM,WAAW;AAE3C,MAAI,CAAC,OAAO;AACX;MAAK;MAAO,CAAC,KAAK,eACjB,iBAAiB,WAAW,OAAO,OAAO,KAAK,YAAY,IAAI;IAChE;AACA,WAAO;EACR;AAEA,MAAI,MAAM,WAAW;AAAW,WAAO;AAEvC,MAAI,CAAC,MAAM,WAAW;AACrB,gBAAY,WAAW,MAAM,OAAO,IAAI;AACxC,WAAO,MAAM;EACd;AAEA,MAAI,CAAC,MAAM,YAAY;AACtB,UAAM,aAAa;AACnB,UAAM,OAAO;AACb,UAAM,SAAS,MAAM;AAKrB,QAAI,aAAa;AACjB,QAAIC,SAAQ;AACZ,QAAI,MAAM,UAAA,GAAwB;AACjC,mBAAa,IAAI,IAAI,MAAM;AAC3B,aAAO,MAAM;AACbA,eAAQ;IACT;AACA;MAAK;MAAY,CAAC,KAAK,eACtB,iBAAiB,WAAW,OAAO,QAAQ,KAAK,YAAY,MAAMA,MAAK;IACxE;AAEA,gBAAY,WAAW,QAAQ,KAAK;AAEpC,QAAI,QAAQ,UAAU,UAAU;AAC/B,gBAAU,SAAS,EAAE;QACpB;QACA;QACA,UAAU;QACV,UAAU;MACX;IACD;EACD;AACA,SAAO,MAAM;AACd;AAEA,SAAS,iBACR,WACA,aACA,cACA,MACA,YACA,UACA,aACC;AACD,MAA6C,eAAe;AAC3D,QAAI,CAAC;AACN,MAAI,QAAQ,UAAU,GAAG;AACxB,UAAM,OACL,YACA,eACA,YAAa,UAAA;IACb,CAAC,IAAK,YAA8C,WAAY,IAAI,IACjE,SAAU,OAAO,IAAI,IACrB;AAEJ,UAAM,MAAMD,UAAS,WAAW,YAAY,IAAI;AAChD,QAAI,cAAc,MAAM,GAAG;AAG3B,QAAI,QAAQ,GAAG,GAAG;AACjB,gBAAU,iBAAiB;IAC5B;AAAO;EACR,WAAW,aAAa;AACvB,iBAAa,IAAI,UAAU;EAC5B;AAEA,MAAI,YAAY,UAAU,KAAK,CAAC,SAAS,UAAU,GAAG;AACrD,QAAI,CAAC,UAAU,OAAO,eAAe,UAAU,qBAAqB,GAAG;AAMtE;IACD;AACA,IAAAA,UAAS,WAAW,UAAU;AAI9B,SACE,CAAC,eAAe,CAAC,YAAY,OAAO,YACrC,OAAO,SAAS,aACf,MAAM,YAAY,IAChB,aAAa,IAAI,IAAI,IACrB,OAAO,UAAU,qBAAqB,KAAK,cAAc,IAAI;AAEhE,kBAAY,WAAW,UAAU;EACnC;AACD;AAEA,SAAS,YAAY,OAAmB,OAAY,OAAO,OAAO;AAEjE,MAAI,CAAC,MAAM,WAAW,MAAM,OAAO,eAAe,MAAM,gBAAgB;AACvE,WAAO,OAAO,IAAI;EACnB;AACD;ACpHO,SAAS,iBACf,MACA,QACyB;AACzB,QAAME,WAAU,MAAM,QAAQ,IAAI;AAClC,QAAM,QAAoB;IACzB,OAAOA,WAAA,IAAA;;IAEP,QAAQ,SAAS,OAAO,SAAS,gBAAgB;;IAEjD,WAAW;;IAEX,YAAY;;IAEZ,WAAW,CAAC;;IAEZ,SAAS;;IAET,OAAO;;IAEP,QAAQ;;;IAER,OAAO;;IAEP,SAAS;IACT,WAAW;EACZ;AAQA,MAAI,SAAY;AAChB,MAAI,QAA2C;AAC/C,MAAIA,UAAS;AACZ,aAAS,CAAC,KAAK;AACf,YAAQ;EACT;AAEA,QAAM,EAAC,QAAQ,MAAK,IAAI,MAAM,UAAU,QAAQ,KAAK;AACrD,QAAM,SAAS;AACf,QAAM,UAAU;AAChB,SAAO;AACR;AAKO,IAAM,cAAwC;EACpD,IAAI,OAAO,MAAM;AAChB,QAAI,SAAS;AAAa,aAAO;AAEjC,UAAM,SAAS,OAAO,KAAK;AAC3B,QAAI,CAAC,IAAI,QAAQ,IAAI,GAAG;AAEvB,aAAO,kBAAkB,OAAO,QAAQ,IAAI;IAC7C;AACA,UAAM,QAAQ,OAAO,IAAI;AACzB,QAAI,MAAM,cAAc,CAAC,YAAY,KAAK,GAAG;AAC5C,aAAO;IACR;AAGA,QAAI,UAAU,KAAK,MAAM,OAAO,IAAI,GAAG;AACtC,kBAAY,KAAK;AACjB,aAAQ,MAAM,MAAO,IAAW,IAAI,YAAY,OAAO,KAAK;IAC7D;AACA,WAAO;EACR;EACA,IAAI,OAAO,MAAM;AAChB,WAAO,QAAQ,OAAO,KAAK;EAC5B;EACA,QAAQ,OAAO;AACd,WAAO,QAAQ,QAAQ,OAAO,KAAK,CAAC;EACrC;EACA,IACC,OACA,MACA,OACC;AACD,UAAM,OAAO,uBAAuB,OAAO,KAAK,GAAG,IAAI;AACvD,QAAI,6BAAM,KAAK;AAGd,WAAK,IAAI,KAAK,MAAM,QAAQ,KAAK;AACjC,aAAO;IACR;AACA,QAAI,CAAC,MAAM,WAAW;AAGrB,YAAMC,WAAU,KAAK,OAAO,KAAK,GAAG,IAAI;AAExC,YAAM,eAAiCA,qCAAU;AACjD,UAAI,gBAAgB,aAAa,UAAU,OAAO;AACjD,cAAM,MAAO,IAAI,IAAI;AACrB,cAAM,UAAU,IAAI,IAAI;AACxB,eAAO;MACR;AACA,UAAI,GAAG,OAAOA,QAAO,MAAM,UAAU,UAAa,IAAI,MAAM,OAAO,IAAI;AACtE,eAAO;AACR,kBAAY,KAAK;AACjB,kBAAY,KAAK;IAClB;AAEA,QACE,MAAM,MAAO,IAAI,MAAM;KAEtB,UAAU,UAAa,QAAQ,MAAM;IAEtC,OAAO,MAAM,KAAK,KAAK,OAAO,MAAM,MAAM,MAAO,IAAI,CAAC;AAEvD,aAAO;AAGR,UAAM,MAAO,IAAI,IAAI;AACrB,UAAM,UAAU,IAAI,IAAI;AACxB,WAAO;EACR;EACA,eAAe,OAAO,MAAc;AAEnC,QAAI,KAAK,MAAM,OAAO,IAAI,MAAM,UAAa,QAAQ,MAAM,OAAO;AACjE,YAAM,UAAU,IAAI,IAAI;AACxB,kBAAY,KAAK;AACjB,kBAAY,KAAK;IAClB,OAAO;AAEN,aAAO,MAAM,UAAU,IAAI;IAC5B;AACA,QAAI,MAAM,OAAO;AAChB,aAAO,MAAM,MAAM,IAAI;IACxB;AACA,WAAO;EACR;;;EAGA,yBAAyB,OAAO,MAAM;AACrC,UAAM,QAAQ,OAAO,KAAK;AAC1B,UAAM,OAAO,QAAQ,yBAAyB,OAAO,IAAI;AACzD,QAAI,CAAC;AAAM,aAAO;AAClB,WAAO;MACN,UAAU;MACV,cAAc,MAAM,UAAA,KAA4B,SAAS;MACzD,YAAY,KAAK;MACjB,OAAO,MAAM,IAAI;IAClB;EACD;EACA,iBAAiB;AAChB,QAAI,EAAE;EACP;EACA,eAAe,OAAO;AACrB,WAAO,eAAe,MAAM,KAAK;EAClC;EACA,iBAAiB;AAChB,QAAI,EAAE;EACP;AACD;AAMA,IAAM,aAA8C,CAAC;AACrD,KAAK,aAAa,CAAC,KAAK,OAAO;AAE9B,aAAW,GAAG,IAAI,WAAW;AAC5B,cAAU,CAAC,IAAI,UAAU,CAAC,EAAE,CAAC;AAC7B,WAAO,GAAG,MAAM,MAAM,SAAS;EAChC;AACD,CAAC;AACD,WAAW,iBAAiB,SAAS,OAAO,MAAM;AACjD,MAA6C,MAAM,SAAS,IAAW,CAAC;AACvE,QAAI,EAAE;AAEP,SAAO,WAAW,IAAK,KAAK,MAAM,OAAO,MAAM,MAAS;AACzD;AACA,WAAW,MAAM,SAAS,OAAO,MAAM,OAAO;AAC7C,MAEC,SAAS,YACT,MAAM,SAAS,IAAW,CAAC;AAE3B,QAAI,EAAE;AACP,SAAO,YAAY,IAAK,KAAK,MAAM,MAAM,CAAC,GAAG,MAAM,OAAO,MAAM,CAAC,CAAC;AACnE;AAGA,SAAS,KAAK,OAAgB,MAAmB;AAChD,QAAM,QAAQ,MAAM,WAAW;AAC/B,QAAM,SAAS,QAAQ,OAAO,KAAK,IAAI;AACvC,SAAO,OAAO,IAAI;AACnB;AAEA,SAAS,kBAAkB,OAAmB,QAAa,MAAmB;;AAC7E,QAAM,OAAO,uBAAuB,QAAQ,IAAI;AAChD,SAAO,OACJ,WAAW,OACV,KAAK;;;KAGLC,MAAA,KAAK,QAAL,gBAAAA,IAAU,KAAK,MAAM;MACtB;AACJ;AAEA,SAAS,uBACR,QACA,MACiC;AAEjC,MAAI,EAAE,QAAQ;AAAS,WAAO;AAC9B,MAAI,QAAQ,eAAe,MAAM;AACjC,SAAO,OAAO;AACb,UAAM,OAAO,OAAO,yBAAyB,OAAO,IAAI;AACxD,QAAI;AAAM,aAAO;AACjB,YAAQ,eAAe,KAAK;EAC7B;AACA,SAAO;AACR;AAEO,SAAS,YAAY,OAAmB;AAC9C,MAAI,CAAC,MAAM,WAAW;AACrB,UAAM,YAAY;AAClB,QAAI,MAAM,SAAS;AAClB,kBAAY,MAAM,OAAO;IAC1B;EACD;AACD;AAEO,SAAS,YAAY,OAIzB;AACF,MAAI,CAAC,MAAM,OAAO;AACjB,UAAM,QAAQ;MACb,MAAM;MACN,MAAM,OAAO,OAAO;IACrB;EACD;AACD;AChQO,IAAMC,SAAN,MAAoC;EAI1C,YAAYC,SAGT;AANH,SAAA,cAAuB;AACvB,SAAA,wBAAoC;AA+BpC,SAAA,UAAoB,CAAC,MAAW,QAAc,kBAAwB;AAErE,UAAI,OAAO,SAAS,cAAc,OAAO,WAAW,YAAY;AAC/D,cAAM,cAAc;AACpB,iBAAS;AAET,cAAM,OAAO;AACb,eAAO,SAAS,eAEfC,QAAO,gBACJ,MACF;AACD,iBAAO,KAAK,QAAQA,OAAM,CAAC,UAAmB,OAAO,KAAK,MAAM,OAAO,GAAG,IAAI,CAAC;QAChF;MACD;AAEA,UAAI,OAAO,WAAW;AAAY,YAAI,CAAC;AACvC,UAAI,kBAAkB,UAAa,OAAO,kBAAkB;AAC3D,YAAI,CAAC;AAEN,UAAI;AAGJ,UAAI,YAAY,IAAI,GAAG;AACtB,cAAM,QAAQ,WAAW,IAAI;AAC7B,cAAM,QAAQ,YAAY,MAAM,MAAS;AACzC,YAAI,WAAW;AACf,YAAI;AACH,mBAAS,OAAO,KAAK;AACrB,qBAAW;QACZ,UAAA;AAEC,cAAI;AAAU,wBAAY,KAAK;;AAC1B,uBAAW,KAAK;QACtB;AACA,0BAAkB,OAAO,aAAa;AACtC,eAAO,cAAc,QAAQ,KAAK;MACnC,WAAW,CAAC,QAAQ,OAAO,SAAS,UAAU;AAC7C,iBAAS,OAAO,IAAI;AACpB,YAAI,WAAW;AAAW,mBAAS;AACnC,YAAI,WAAW;AAAS,mBAAS;AACjC,YAAI,KAAK;AAAa,iBAAO,QAAQ,IAAI;AACzC,YAAI,eAAe;AAClB,gBAAM,IAAa,CAAC;AACpB,gBAAM,KAAc,CAAC;AACrB,oBAAU,SAAS,EAAE,4BAA4B,MAAM,QAAQ,GAAG,EAAE;AACpE,wBAAc,GAAG,EAAE;QACpB;AACA,eAAO;MACR;AAAO,YAAI,GAAG,IAAI;IACnB;AAEA,SAAA,qBAA0C,CAAC,MAAW,WAAsB;AAE3E,UAAI,OAAO,SAAS,YAAY;AAC/B,eAAO,CAAC,UAAe,SACtB,KAAK,mBAAmB,OAAO,CAAC,UAAe,KAAK,OAAO,GAAG,IAAI,CAAC;MACrE;AAEA,UAAI,SAAkB;AACtB,YAAM,SAAS,KAAK,QAAQ,MAAM,QAAQ,CAAC,GAAY,OAAgB;AACtE,kBAAU;AACV,yBAAiB;MAClB,CAAC;AACD,aAAO,CAAC,QAAQ,SAAU,cAAe;IAC1C;AA1FC,QAAI,QAAOD,WAAA,gBAAAA,QAAQ,gBAAe;AACjC,WAAK,cAAcA,QAAQ,UAAU;AACtC,QAAI,QAAOA,WAAA,gBAAAA,QAAQ,0BAAyB;AAC3C,WAAK,wBAAwBA,QAAQ,oBAAoB;EAC3D;EAwFA,YAAiC,MAAmB;AACnD,QAAI,CAAC,YAAY,IAAI;AAAG,UAAI,CAAC;AAC7B,QAAI,QAAQ,IAAI;AAAG,aAAO,QAAQ,IAAI;AACtC,UAAM,QAAQ,WAAW,IAAI;AAC7B,UAAM,QAAQ,YAAY,MAAM,MAAS;AACzC,UAAM,WAAW,EAAE,YAAY;AAC/B,eAAW,KAAK;AAChB,WAAO;EACR;EAEA,YACC,OACA,eACuC;AACvC,UAAM,QAAoB,SAAU,MAAc,WAAW;AAC7D,QAAI,CAAC,SAAS,CAAC,MAAM;AAAW,UAAI,CAAC;AACrC,UAAM,EAAC,QAAQ,MAAK,IAAI;AACxB,sBAAkB,OAAO,aAAa;AACtC,WAAO,cAAc,QAAW,KAAK;EACtC;;;;;;EAOA,cAAc,OAAgB;AAC7B,SAAK,cAAc;EACpB;;;;;;EAOA,wBAAwB,OAAmB;AAC1C,SAAK,wBAAwB;EAC9B;EAEA,aAAkC,MAAS,SAA8B;AAGxE,QAAI;AACJ,SAAK,IAAI,QAAQ,SAAS,GAAG,KAAK,GAAG,KAAK;AACzC,YAAM,QAAQ,QAAQ,CAAC;AACvB,UAAI,MAAM,KAAK,WAAW,KAAK,MAAM,OAAO,WAAW;AACtD,eAAO,MAAM;AACb;MACD;IACD;AAGA,QAAI,IAAI,IAAI;AACX,gBAAU,QAAQ,MAAM,IAAI,CAAC;IAC9B;AAEA,UAAM,mBAAmB,UAAU,SAAS,EAAE;AAC9C,QAAI,QAAQ,IAAI,GAAG;AAElB,aAAO,iBAAiB,MAAM,OAAO;IACtC;AAEA,WAAO,KAAK;MAAQ;MAAM,CAAC,UAC1B,iBAAiB,OAAO,OAAO;IAChC;EACD;AACD;AAEO,SAAS,YACf,OACA,QACyB;AAEzB,QAAM,QAAiB,MAAM,KAAK,IAC/B,UAAU,QAAQ,EAAE,UAAU,OAAO,MAAM,IAC3C,MAAM,KAAK,IACX,UAAU,QAAQ,EAAE,UAAU,OAAO,MAAM,IAC3C,iBAAiB,OAAO,MAAM;AAEjC,QAAM,QAAQ,SAAS,OAAO,SAAS,gBAAgB;AACvD,QAAM,QAAQ,KAAK,KAAK;AACxB,SAAO;AACR;AC3MO,SAAS,QAAQ,OAAiB;AACxC,MAAI,CAAC,QAAQ,KAAK;AAAG,QAAI,IAAI,KAAK;AAClC,SAAO,YAAY,KAAK;AACzB;AAEA,SAAS,YAAY,OAAiB;AACrC,MAAI,CAAC,YAAY,KAAK,KAAK,SAAS,KAAK;AAAG,WAAO;AACnD,QAAM,QAAgC,MAAM,WAAW;AACvD,MAAI;AACJ,MAAI,OAAO;AACV,QAAI,CAAC,MAAM;AAAW,aAAO,MAAM;AAEnC,UAAM,aAAa;AACnB,WAAO,YAAY,OAAO,MAAM,OAAO,OAAO,qBAAqB;EACpE,OAAO;AACN,WAAO,YAAY,OAAO,IAAI;EAC/B;AAEA,OAAK,MAAM,CAAC,KAAK,eAAe;AAC/B,QAAI,MAAM,KAAK,YAAY,UAAU,CAAC;EACvC,CAAC;AACD,MAAI,OAAO;AACV,UAAM,aAAa;EACpB;AACA,SAAO;AACR;AGbA,IAAM,QAAQ,IAAIE,OAAM;AAqBjB,IAAM,UAAoC,MAAM;AAMhD,IAAM,qBAA0D,MAAM,mBAAmB;EAC/F;AACD;AAOO,IAAM,gBAAgC,MAAM,cAAc,KAAK,KAAK;AAOpE,IAAM,0BAA0C,MAAM,wBAAwB;EACpF;AACD;AAOO,IAAM,eAA+B,MAAM,aAAa,KAAK,KAAK;AAMlE,IAAM,cAA8B,MAAM,YAAY,KAAK,KAAK;AAUhE,IAAM,cAA8B,MAAM,YAAY,KAAK,KAAK;;;ACzEvE,IAAI;AAAA;AAAA,EAEF,WAAC,sVAA4T,GAAC;AAAA;AA0BhU,IAAI;AAIJ,SAAS,gBAAgBC,UAAS;AAChC,SAAO;AAAA,IACL,OAAMA,YAAA,gBAAAA,SAAS,UAAQ,+BAAO;AAAA,IAC9B,SAASA,YAAA,gBAAAA,SAAS;AAAA,IAClB,aAAYA,YAAA,gBAAAA,SAAS,gBAAc,+BAAO;AAAA,IAC1C,iBAAgBA,YAAA,gBAAAA,SAAS,oBAAkB,+BAAO;AAAA,EACpD;AACF;AAMA,IAAI;AAKJ,SAAS,iBAAiB,MAAM;AAC9B,SAAO,iCAAQ,IAAI;AACrB;AAMA,IAAI;AAKJ,SAAS,iBAAiB,MAAM;AAC9B,SAAO,iCAAQ,IAAI;AACrB;AAMA,IAAI;AAMJ,SAAS,mBAAmB,WAAW,MAAM;AAlG7C,MAAAC;AAmGE,UAAOA,MAAA,iCAAQ,IAAI,eAAZ,gBAAAA,IAAwB,IAAI;AACrC;AAMA,SAAS,WAAW,OAAO;AA1G3B,MAAAC,KAAA;AA2GE,QAAM,OAAO,OAAO;AACpB,MAAI,SAAS,UAAU;AACrB,WAAO,IAAI,KAAK;AAAA,EAClB;AACA,MAAI,SAAS,YAAY,SAAS,YAAY,SAAS,WAAW;AAChE,WAAO,GAAG,KAAK;AAAA,EACjB;AACA,MAAI,SAAS,YAAY,SAAS,YAAY;AAC5C,YAAQ,WAAS,MAAAA,MAAA,OAAO,eAAe,KAAK,MAA3B,gBAAAA,IAA8B,gBAA9B,mBAA2C,UAAS;AAAA,EACvE;AACA,SAAO;AACT;AAGA,SAAS,UAAUC,UAAS,OAAO,SAASC,UAAS,OAAO;AAC1D,QAAM,QAAQ,SAAS,WAAW,QAAQ,MAAM,QAAQ,QAAQ;AAChE,QAAM,YAAW,+BAAO,aAAYD,SAAQ,WAAW;AACvD,QAAM,YAAW,+BAAO,aAAY,WAAW,KAAK;AACpD,QAAM,QAAQ;AAAA,IACZ,MAAMA,SAAQ;AAAA,IACd,MAAMA,SAAQ;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,WAAW,KAAK,KAAK,WAAW,YAAY,QAAQ,WAAW,GAAG,WAAW,QAAQ;AAAA,IAC9F,aAAaA,SAAQ;AAAA,IACrB,MAAM,+BAAO;AAAA,IACb,QAAQ,+BAAO;AAAA,IACf,MAAMC,SAAQ;AAAA,IACd,YAAYA,SAAQ;AAAA,IACpB,gBAAgBA,SAAQ;AAAA,EAC1B;AACA,QAAM,WAAWD,SAAQ,SAAS;AAClC,QAAM,WAAU,+BAAO,YAAWA,SAAQ,WAAW,mBAAmBA,SAAQ,WAAW,MAAM,IAAI,MAAM,WAAW,iBAAiB,MAAM,IAAI,IAAI,SAASC,SAAQ,WAAW,iBAAiB,MAAM,IAAI;AAC5M,MAAI,SAAS;AACX,UAAM,UAAU,OAAO,YAAY;AAAA;AAAA,MAEjC,QAAQ,KAAK;AAAA,QACX;AAAA,EACN;AACA,MAAI,UAAU;AACZ,YAAQ,QAAQ;AAAA,EAClB;AACA,MAAI,QAAQ,QAAQ;AAClB,YAAQ,OAAO,KAAK,KAAK;AAAA,EAC3B,OAAO;AACL,YAAQ,SAAS,CAAC,KAAK;AAAA,EACzB;AACF;AAuBA,SAAS,aAAa,QAAQ,WAAW;AACvC,QAAM,OAAO,CAAC,GAAG,IAAI,IAAI,MAAM,CAAC;AAChC,MAAI,KAAK,SAAS,GAAG;AACnB,WAAO,IAAI,KAAK,KAAK,IAAI,SAAS,GAAG,CAAC;AAAA,EACxC;AACA,SAAO,KAAK,CAAC,KAAK;AACpB;AA+CA,IAAI,YAAY,cAAc,MAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUlC,YAAY,QAAQ;AAClB,UAAM,OAAO,CAAC,EAAE,OAAO;AAPzB;AAAA;AAAA;AAAA;AAQE,SAAK,OAAO;AACZ,SAAK,SAAS;AAAA,EAChB;AACF;AA+EA,SAAS,MAAM,aAAa,SAAS;AACnC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI,QAAQ,SAAS,CAAC,KAAK,YAAY,QAAQ,KAAK,GAAG;AACrD,kBAAU,MAAM,SAAS,SAASA,QAAO;AAAA,MAC3C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA25BA,SAAS,SAAS,aAAa,SAAS;AACtC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,OAAO;AAAA,IACP,SAAS,KAAK,uBAAuB,OAAO,YAAY,OAAO,IAAI,WAAW,WAAW,CAAC;AAAA,IAC1F;AAAA,IACA;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI,QAAQ,SAAS,QAAQ,QAAQ,KAAK,aAAa;AACrD,kBAAU,MAAM,SAAS,SAASA,UAAS;AAAA,UACzC,UAAU,QAAQ,iBAAiB,OAAO,QAAQ,MAAM,OAAO,IAAI,WAAW,QAAQ,KAAK;AAAA,QAC7F,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAy1BA,SAAS,WAAWC,SAAQ,SAASC,UAAS;AAC5C,SAAO,OAAOD,QAAO,YAAY;AAAA;AAAA,IAE/BA,QAAO,QAAQ,SAASC,QAAO;AAAA;AAAA;AAAA,IAG/BD,QAAO;AAAA;AAEX;AAyFA,SAAS,MAAM,MAAM,SAAS;AAC5B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAASE,UAAS;AArsE3B,UAAAC;AAssEM,YAAM,QAAQ,QAAQ;AACtB,UAAI,MAAM,QAAQ,KAAK,GAAG;AACxB,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,iBAAS,MAAM,GAAG,MAAM,MAAM,QAAQ,OAAO;AAC3C,gBAAM,SAAS,MAAM,GAAG;AACxB,gBAAM,cAAc,KAAK,KAAK,KAAK,EAAE,OAAO,OAAO,OAAO,OAAO,GAAGD,QAAO;AAC3E,cAAI,YAAY,QAAQ;AACtB,kBAAM,WAAW;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,OAAO;AAAA,YACT;AACA,uBAAW,SAAS,YAAY,QAAQ;AACtC,kBAAI,MAAM,MAAM;AACd,sBAAM,KAAK,QAAQ,QAAQ;AAAA,cAC7B,OAAO;AACL,sBAAM,OAAO,CAAC,QAAQ;AAAA,cACxB;AACA,eAAAC,MAAA,QAAQ,WAAR,gBAAAA,IAAgB,KAAK;AAAA,YACvB;AACA,gBAAI,CAAC,QAAQ,QAAQ;AACnB,sBAAQ,SAAS,YAAY;AAAA,YAC/B;AACA,gBAAID,SAAQ,YAAY;AACtB,sBAAQ,QAAQ;AAChB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,YAAY,OAAO;AACtB,oBAAQ,QAAQ;AAAA,UAClB;AACA,kBAAQ,MAAM,KAAK,YAAY,KAAK;AAAA,QACtC;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAoGA,SAAS,QAAQ,SAAS;AACxB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAASE,UAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,WAAW;AACtC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAkWA,SAAS,QAAQ,UAAU,SAAS;AAClC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,WAAW,QAAQ;AAAA,IAC5B,OAAO;AAAA,IACP,SAAS;AAAA,IACT;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI,QAAQ,UAAU,KAAK,SAAS;AAClC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAovBA,SAAS,OAAO,SAAS;AACvB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC9D,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAGA,SAAS,OAAO,SAAS,SAAS;AAChC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAASA,UAAS;AA1+G3B,UAAAC;AA2+GM,YAAM,QAAQ,QAAQ;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,gBAAQ,QAAQ;AAChB,gBAAQ,QAAQ,CAAC;AACjB,mBAAW,OAAO,KAAK,SAAS;AAC9B,gBAAM,SAAS,MAAM,GAAG;AACxB,gBAAM,eAAe,KAAK,QAAQ,GAAG,EAAE;AAAA,YACrC,EAAE,OAAO,OAAO,OAAO,OAAO;AAAA,YAC9BD;AAAA,UACF;AACA,cAAI,aAAa,QAAQ;AACvB,kBAAM,WAAW;AAAA,cACf,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA;AAAA,cACA,OAAO;AAAA,YACT;AACA,uBAAW,SAAS,aAAa,QAAQ;AACvC,kBAAI,MAAM,MAAM;AACd,sBAAM,KAAK,QAAQ,QAAQ;AAAA,cAC7B,OAAO;AACL,sBAAM,OAAO,CAAC,QAAQ;AAAA,cACxB;AACA,eAAAC,MAAA,QAAQ,WAAR,gBAAAA,IAAgB,KAAK;AAAA,YACvB;AACA,gBAAI,CAAC,QAAQ,QAAQ;AACnB,sBAAQ,SAAS,aAAa;AAAA,YAChC;AACA,gBAAID,SAAQ,YAAY;AACtB,sBAAQ,QAAQ;AAChB;AAAA,YACF;AAAA,UACF;AACA,cAAI,CAAC,aAAa,OAAO;AACvB,oBAAQ,QAAQ;AAAA,UAClB;AACA,cAAI,aAAa,UAAU,UAAU,OAAO,OAAO;AACjD,oBAAQ,MAAM,GAAG,IAAI,aAAa;AAAA,UACpC;AAAA,QACF;AAAA,MACF,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA6RA,SAAS,SAAS,YAAY,MAAM;AAClC,QAAME,UAAS;AAAA,IACb,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS,IAAI,QAAQ,OAAO;AAAA,IAC5B,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI,QAAQ,UAAU,QAAQ;AAC5B,YAAI,aAAa,MAAM;AACrB,kBAAQ,QAAQ;AAAA,YACd;AAAA,YACA;AAAA,YACAA;AAAA,UACF;AAAA,QACF;AACA,YAAI,QAAQ,UAAU,QAAQ;AAC5B,kBAAQ,QAAQ;AAChB,iBAAO;AAAA,QACT;AAAA,MACF;AACA,aAAO,KAAK,QAAQ,KAAK,SAASA,QAAO;AAAA,IAC3C;AAAA,EACF;AACA,MAAI,KAAK,MAAM;AACb,IAAAD,QAAO,UAAU,KAAK,CAAC;AAAA,EACzB;AACA,SAAOA;AACT;AAurBA,SAAS,OAAO,SAAS;AACvB,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA,KAAK,SAASE,UAAS;AACrB,UAAI,OAAO,QAAQ,UAAU,UAAU;AACrC,gBAAQ,QAAQ;AAAA,MAClB,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA8aA,SAAS,WAAW,UAAU;AAC5B,MAAI;AACJ,MAAI,UAAU;AACZ,eAAW,WAAW,UAAU;AAC9B,UAAI,QAAQ;AACV,eAAO,KAAK,GAAG,QAAQ,MAAM;AAAA,MAC/B,OAAO;AACL,iBAAS,QAAQ;AAAA,MACnB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AAGA,SAAS,MAAM,SAAS,SAAS;AAC/B,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,MACP,QAAQ,IAAI,CAAC,WAAW,OAAO,OAAO;AAAA,MACtC;AAAA,IACF;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA,KAAK,SAASC,UAAS;AACrB,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,iBAAWC,WAAU,KAAK,SAAS;AACjC,cAAM,gBAAgBA,QAAO;AAAA,UAC3B,EAAE,OAAO,OAAO,OAAO,QAAQ,MAAM;AAAA,UACrCD;AAAA,QACF;AACA,YAAI,cAAc,OAAO;AACvB,cAAI,cAAc,QAAQ;AACxB,gBAAI,eAAe;AACjB,4BAAc,KAAK,aAAa;AAAA,YAClC,OAAO;AACL,8BAAgB,CAAC,aAAa;AAAA,YAChC;AAAA,UACF,OAAO;AACL,2BAAe;AACf;AAAA,UACF;AAAA,QACF,OAAO;AACL,cAAI,iBAAiB;AACnB,4BAAgB,KAAK,aAAa;AAAA,UACpC,OAAO;AACL,8BAAkB,CAAC,aAAa;AAAA,UAClC;AAAA,QACF;AAAA,MACF;AACA,UAAI,cAAc;AAChB,eAAO;AAAA,MACT;AACA,UAAI,eAAe;AACjB,YAAI,cAAc,WAAW,GAAG;AAC9B,iBAAO,cAAc,CAAC;AAAA,QACxB;AACA,kBAAU,MAAM,QAAQ,SAASA,UAAS;AAAA,UACxC,QAAQ,WAAW,aAAa;AAAA,QAClC,CAAC;AACD,gBAAQ,QAAQ;AAAA,MAClB,YAAW,mDAAiB,YAAW,GAAG;AACxC,eAAO,gBAAgB,CAAC;AAAA,MAC1B,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,UAAS;AAAA,UACxC,QAAQ,WAAW,eAAe;AAAA,QACpC,CAAC;AAAA,MACH;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAkFA,SAAS,QAAQ,KAAK,SAAS,SAAS;AACtC,SAAO;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,WAAW;AAAA,IACX,SAAS;AAAA,IACT,OAAO;AAAA,IACP;AAAA,IACA;AAAA,IACA;AAAA,IACA,KAAK,SAASE,UAAS;AACrB,YAAM,QAAQ,QAAQ;AACtB,UAAI,SAAS,OAAO,UAAU,UAAU;AACtC,YAAI;AACJ,YAAI,2BAA2B;AAC/B,YAAI,0BAA0B,KAAK;AACnC,YAAI,yBAAyB,CAAC;AAC9B,cAAM,eAAe,CAAC,UAAU,YAAY;AAC1C,qBAAWC,WAAU,SAAS,SAAS;AACrC,gBAAIA,QAAO,SAAS,WAAW;AAC7B,2BAAaA,SAAQ,IAAI,IAAI,OAAO,EAAE,IAAIA,QAAO,GAAG,CAAC;AAAA,YACvD,OAAO;AACL,kBAAI,eAAe;AACnB,kBAAI,kBAAkB;AACtB,yBAAW,cAAc,SAAS;AAChC,oBAAIA,QAAO,QAAQ,UAAU,EAAE;AAAA;AAAA,kBAE7B,EAAE,OAAO,OAAO,OAAO,MAAM,UAAU,EAAE;AAAA,kBACzCD;AAAA,gBACF,EAAE,QAAQ;AACR,iCAAe;AACf,sBAAI,4BAA4B,eAAe,2BAA2B,mBAAmB,6BAA6B,mBAAmB,cAAc,SAAS,EAAE,2BAA2B,SAAS;AACxM,+CAA2B;AAC3B,8CAA0B;AAC1B,6CAAyB,CAAC;AAAA,kBAC5B;AACA,sBAAI,4BAA4B,YAAY;AAC1C,2CAAuB;AAAA,sBACrBC,QAAO,QAAQ,UAAU,EAAE;AAAA,oBAC7B;AAAA,kBACF;AACA;AAAA,gBACF;AACA;AAAA,cACF;AACA,kBAAI,cAAc;AAChB,sBAAM,gBAAgBA,QAAO;AAAA,kBAC3B,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,kBAC7BD;AAAA,gBACF;AACA,oBAAI,CAAC,iBAAiB,CAAC,cAAc,SAAS,cAAc,OAAO;AACjE,kCAAgB;AAAA,gBAClB;AAAA,cACF;AAAA,YACF;AACA,gBAAI,iBAAiB,CAAC,cAAc,QAAQ;AAC1C;AAAA,YACF;AAAA,UACF;AAAA,QACF;AACA,qBAAa,MAAsB,oBAAI,IAAI,CAAC,KAAK,GAAG,CAAC,CAAC;AACtD,YAAI,eAAe;AACjB,iBAAO;AAAA,QACT;AACA,kBAAU,MAAM,QAAQ,SAASA,UAAS;AAAA;AAAA,UAExC,OAAO,MAAM,uBAAuB;AAAA,UACpC,UAAU,aAAa,wBAAwB,GAAG;AAAA,UAClD,MAAM;AAAA,YACJ;AAAA,cACE,MAAM;AAAA,cACN,QAAQ;AAAA,cACR;AAAA,cACA,KAAK;AAAA;AAAA,cAEL,OAAO,MAAM,uBAAuB;AAAA,YACtC;AAAA,UACF;AAAA,QACF,CAAC;AAAA,MACH,OAAO;AACL,kBAAU,MAAM,QAAQ,SAASA,QAAO;AAAA,MAC1C;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AA+HA,SAAS,MAAME,SAAQ,OAAOC,UAAS;AACrC,QAAM,UAAUD,QAAO;AAAA,IACrB,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,IAC7B,gBAAgBC,QAAO;AAAA,EACzB;AACA,MAAI,QAAQ,QAAQ;AAClB,UAAM,IAAI,UAAU,QAAQ,MAAM;AAAA,EACpC;AACA,SAAO,QAAQ;AACjB;AA+BA,SAAS,QAAQC,SAAQ,MAAM;AAC7B,QAAM,UAAU,CAAC;AACjB,aAAW,OAAOA,QAAO,SAAS;AAChC,YAAQ,GAAG,IAAI,CAAC,QAAQ,KAAK,SAAS,GAAG,IAAI,SAASA,QAAO,QAAQ,GAAG,CAAC,IAAIA,QAAO,QAAQ,GAAG;AAAA,EACjG;AACA,SAAO,EAAE,GAAGA,SAAQ,QAAQ;AAC9B;AAqBA,SAASC,SAAQC,QAAO;AACtB,SAAO;AAAA,IACL,GAAGA,OAAM,CAAC;AAAA,IACV,MAAMA;AAAA,IACN,KAAK,SAASC,UAAS;AACrB,iBAAW,QAAQD,QAAO;AACxB,YAAI,KAAK,SAAS,YAAY;AAC5B,cAAI,QAAQ,WAAW,KAAK,SAAS,YAAY,KAAK,SAAS,mBAAmB;AAChF,oBAAQ,QAAQ;AAChB;AAAA,UACF;AACA,cAAI,CAAC,QAAQ,UAAU,CAACC,SAAQ,cAAc,CAACA,SAAQ,gBAAgB;AACrE,sBAAU,KAAK,KAAK,SAASA,QAAO;AAAA,UACtC;AAAA,QACF;AAAA,MACF;AACA,aAAO;AAAA,IACT;AAAA,EACF;AACF;AAgDA,SAAS,UAAUC,SAAQ,OAAOC,UAAS;AACzC,QAAM,UAAUD,QAAO;AAAA,IACrB,EAAE,OAAO,OAAO,OAAO,MAAM;AAAA,IAC7B,gBAAgBC,QAAO;AAAA,EACzB;AACA,SAAO;AAAA,IACL,OAAO,QAAQ;AAAA,IACf,SAAS,CAAC,QAAQ;AAAA,IAClB,QAAQ,QAAQ;AAAA,IAChB,QAAQ,QAAQ;AAAA,EAClB;AACF;;;AxI3vHA,IAAAC,iBAAkC;;;AyIltDlC,IAAO,gBAAQ;;;ACCf,SAAS,SAAS,MAAM;AACtB,SAAO,OAAO,SAAS,YAAY,cAAM,KAAK,IAAI;AACpD;AACA,IAAO,mBAAQ;;;ACHf,SAASC,OAAM,MAAM;AACnB,MAAI,CAAC,iBAAS,IAAI,GAAG;AACnB,UAAM,UAAU,cAAc;AAAA,EAChC;AACA,MAAI;AACJ,MAAI,MAAM,IAAI,WAAW,EAAE;AAG3B,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,GAAG,CAAC,GAAG,EAAE,OAAO;AAClD,MAAI,CAAC,IAAI,MAAM,KAAK;AACpB,MAAI,CAAC,IAAI,MAAM,IAAI;AACnB,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,GAAG,EAAE,GAAG,EAAE,OAAO;AACnD,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,OAAO;AACpD,MAAI,CAAC,IAAI,IAAI;AAGb,MAAI,CAAC,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,OAAO;AACpD,MAAI,CAAC,IAAI,IAAI;AAIb,MAAI,EAAE,KAAK,IAAI,SAAS,KAAK,MAAM,IAAI,EAAE,GAAG,EAAE,KAAK,gBAAgB;AACnE,MAAI,EAAE,IAAI,IAAI,aAAc;AAC5B,MAAI,EAAE,IAAI,MAAM,KAAK;AACrB,MAAI,EAAE,IAAI,MAAM,KAAK;AACrB,MAAI,EAAE,IAAI,MAAM,IAAI;AACpB,MAAI,EAAE,IAAI,IAAI;AACd,SAAO;AACT;AACA,IAAO,gBAAQA;;;AC9Bf,IAAI,YAAY,CAAC;AACjB,KAAS,IAAI,GAAG,IAAI,KAAK,EAAE,GAAG;AAC5B,YAAU,MAAM,IAAI,KAAO,SAAS,EAAE,EAAE,MAAM,CAAC,CAAC;AAClD;AAFS;AAGF,SAAS,gBAAgB,KAAK,SAAS,GAAG;AAM/C,UAAQ,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,UAAU,IAAI,SAAS,CAAC,CAAC,IAAI,MAAM,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,IAAI,UAAU,IAAI,SAAS,EAAE,CAAC,GAAG,YAAY;AACngB;;;ACbA,IAAI;AACJ,IAAI,QAAQ,IAAI,WAAW,EAAE;AACd,SAAR,MAAuB;AAE5B,MAAI,CAAC,iBAAiB;AAEpB,sBAAkB,OAAO,WAAW,eAAe,OAAO,mBAAmB,OAAO,gBAAgB,KAAK,MAAM;AAC/G,QAAI,CAAC,iBAAiB;AACpB,YAAM,IAAI,MAAM,0GAA0G;AAAA,IAC5H;AAAA,EACF;AACA,SAAO,gBAAgB,KAAK;AAC9B;;;ACdA,SAAS,cAAc,KAAK;AAC1B,QAAM,SAAS,mBAAmB,GAAG,CAAC;AAEtC,MAAIC,SAAQ,CAAC;AACb,WAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACnC,IAAAA,OAAM,KAAK,IAAI,WAAW,CAAC,CAAC;AAAA,EAC9B;AACA,SAAOA;AACT;AACO,IAAI,MAAM;AACV,IAAIC,OAAM;AACF,SAAR,IAAqB,MAAM,SAAS,UAAU;AACnD,WAAS,aAAa,OAAO,WAAW,KAAK,QAAQ;AACnD,QAAI;AACJ,QAAI,OAAO,UAAU,UAAU;AAC7B,cAAQ,cAAc,KAAK;AAAA,IAC7B;AACA,QAAI,OAAO,cAAc,UAAU;AACjC,kBAAY,cAAM,SAAS;AAAA,IAC7B;AACA,UAAM,aAAa,eAAe,QAAQ,eAAe,SAAS,SAAS,WAAW,YAAY,IAAI;AACpG,YAAM,UAAU,kEAAkE;AAAA,IACpF;AAKA,QAAID,SAAQ,IAAI,WAAW,KAAK,MAAM,MAAM;AAC5C,IAAAA,OAAM,IAAI,SAAS;AACnB,IAAAA,OAAM,IAAI,OAAO,UAAU,MAAM;AACjC,IAAAA,SAAQ,SAASA,MAAK;AACtB,IAAAA,OAAM,CAAC,IAAIA,OAAM,CAAC,IAAI,KAAO;AAC7B,IAAAA,OAAM,CAAC,IAAIA,OAAM,CAAC,IAAI,KAAO;AAC7B,QAAI,KAAK;AACP,eAAS,UAAU;AACnB,eAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,YAAI,SAAS,CAAC,IAAIA,OAAM,CAAC;AAAA,MAC3B;AACA,aAAO;AAAA,IACT;AACA,WAAO,gBAAgBA,MAAK;AAAA,EAC9B;AAGA,MAAI;AACF,iBAAa,OAAO;AAAA,EACtB,SAASE,MAAK;AAAA,EAAC;AAGf,eAAa,MAAM;AACnB,eAAa,MAAMD;AACnB,SAAO;AACT;;;AClCA,SAAS,IAAIE,QAAO;AAClB,MAAI,OAAOA,WAAU,UAAU;AAC7B,QAAI,MAAM,SAAS,mBAAmBA,MAAK,CAAC;AAE5C,IAAAA,SAAQ,IAAI,WAAW,IAAI,MAAM;AACjC,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACnC,MAAAA,OAAM,CAAC,IAAI,IAAI,WAAW,CAAC;AAAA,IAC7B;AAAA,EACF;AACA,SAAO,qBAAqB,WAAW,aAAaA,MAAK,GAAGA,OAAM,SAAS,CAAC,CAAC;AAC/E;AAKA,SAAS,qBAAqB,OAAO;AACnC,MAAIC,UAAS,CAAC;AACd,MAAI,WAAW,MAAM,SAAS;AAC9B,MAAI,SAAS;AACb,WAAS,IAAI,GAAG,IAAI,UAAU,KAAK,GAAG;AACpC,QAAI,IAAI,MAAM,KAAK,CAAC,MAAM,IAAI,KAAK;AACnC,QAAI,MAAM,SAAS,OAAO,OAAO,MAAM,IAAI,EAAI,IAAI,OAAO,OAAO,IAAI,EAAI,GAAG,EAAE;AAC9E,IAAAA,QAAO,KAAK,GAAG;AAAA,EACjB;AACA,SAAOA;AACT;AAKA,SAAS,gBAAgB,cAAc;AACrC,UAAQ,eAAe,OAAO,KAAK,KAAK,KAAK;AAC/C;AAKA,SAAS,WAAW,GAAG,KAAK;AAE1B,IAAE,OAAO,CAAC,KAAK,OAAQ,MAAM;AAC7B,IAAE,gBAAgB,GAAG,IAAI,CAAC,IAAI;AAC9B,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,IAAI;AACR,MAAI,IAAI;AACR,WAAS,IAAI,GAAG,IAAI,EAAE,QAAQ,KAAK,IAAI;AACrC,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,OAAO;AACX,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,UAAU;AACzC,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,MAAM;AAC3C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,WAAW;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,UAAU;AAC1C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,QAAQ;AAC5C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,SAAS;AAC5C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,SAAS;AAC5C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,OAAO;AAC1C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,WAAW;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,SAAS;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,IAAI,UAAU;AAC1C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,QAAQ;AAC5C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,CAAC,GAAG,GAAG,UAAU;AACzC,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,GAAG,UAAU;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,QAAQ;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,SAAS;AAC9C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,WAAW;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,UAAU;AAC/C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,GAAG,UAAU;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,EAAE,GAAG,IAAI,WAAW;AAChD,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,SAAS;AAC7C,QAAI,MAAM,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI,CAAC,GAAG,IAAI,UAAU;AAC9C,QAAI,QAAQ,GAAG,IAAI;AACnB,QAAI,QAAQ,GAAG,IAAI;AACnB,QAAI,QAAQ,GAAG,IAAI;AACnB,QAAI,QAAQ,GAAG,IAAI;AAAA,EACrB;AACA,SAAO,CAAC,GAAG,GAAG,GAAG,CAAC;AACpB;AAMA,SAAS,aAAa,OAAO;AAC3B,MAAI,MAAM,WAAW,GAAG;AACtB,WAAO,CAAC;AAAA,EACV;AACA,MAAI,UAAU,MAAM,SAAS;AAC7B,MAAIA,UAAS,IAAI,YAAY,gBAAgB,OAAO,CAAC;AACrD,WAAS,IAAI,GAAG,IAAI,SAAS,KAAK,GAAG;AACnC,IAAAA,QAAO,KAAK,CAAC,MAAM,MAAM,IAAI,CAAC,IAAI,QAAS,IAAI;AAAA,EACjD;AACA,SAAOA;AACT;AAMA,SAAS,QAAQ,GAAG,GAAG;AACrB,MAAI,OAAO,IAAI,UAAW,IAAI;AAC9B,MAAI,OAAO,KAAK,OAAO,KAAK,OAAO,OAAO;AAC1C,SAAO,OAAO,KAAK,MAAM;AAC3B;AAKA,SAAS,cAAc,KAAK,KAAK;AAC/B,SAAO,OAAO,MAAM,QAAQ,KAAK;AACnC;AAKA,SAAS,OAAO,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAChC,SAAO,QAAQ,cAAc,QAAQ,QAAQ,GAAG,CAAC,GAAG,QAAQ,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,CAAC;AAC3E;AACA,SAAS,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAClC,SAAO,OAAO,IAAI,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC7C;AACA,SAAS,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAClC,SAAO,OAAO,IAAI,IAAI,IAAI,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC7C;AACA,SAAS,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAClC,SAAO,OAAO,IAAI,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AACxC;AACA,SAAS,MAAM,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAClC,SAAO,OAAO,KAAK,IAAI,CAAC,IAAI,GAAG,GAAG,GAAG,GAAG,CAAC;AAC3C;AACA,IAAO,cAAQ;;;AC/Lf,IAAI,KAAK,IAAI,MAAM,IAAM,WAAG;;;ACF5B,IAAI,aAAa,OAAO,WAAW,eAAe,OAAO,cAAc,OAAO,WAAW,KAAK,MAAM;AACpG,IAAO,iBAAQ;AAAA,EACb;AACF;;;ACAA,SAAS,GAAG,SAAS,KAAK,QAAQ;AAChC,MAAI,eAAO,cAAc,CAAC,OAAO,CAAC,SAAS;AACzC,WAAO,eAAO,WAAW;AAAA,EAC3B;AACA,YAAU,WAAW,CAAC;AACtB,MAAI,OAAO,QAAQ,WAAW,QAAQ,OAAO,KAAK;AAGlD,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAC3B,OAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAO;AAG3B,MAAI,KAAK;AACP,aAAS,UAAU;AACnB,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,UAAI,SAAS,CAAC,IAAI,KAAK,CAAC;AAAA,IAC1B;AACA,WAAO;AAAA,EACT;AACA,SAAO,gBAAgB,IAAI;AAC7B;AACA,IAAO,aAAQ;;;ACtBf,SAAS,EAAE,GAAG,GAAG,GAAG,GAAG;AACrB,UAAQ,GAAG;AAAA,IACT,KAAK;AACH,aAAO,IAAI,IAAI,CAAC,IAAI;AAAA,IACtB,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,IACjB,KAAK;AACH,aAAO,IAAI,IAAI,IAAI,IAAI,IAAI;AAAA,IAC7B,KAAK;AACH,aAAO,IAAI,IAAI;AAAA,EACnB;AACF;AACA,SAAS,KAAK,GAAG,GAAG;AAClB,SAAO,KAAK,IAAI,MAAM,KAAK;AAC7B;AACA,SAAS,KAAKC,QAAO;AACnB,MAAI,IAAI,CAAC,YAAY,YAAY,YAAY,UAAU;AACvD,MAAI,IAAI,CAAC,YAAY,YAAY,YAAY,WAAY,UAAU;AACnE,MAAI,OAAOA,WAAU,UAAU;AAC7B,QAAI,MAAM,SAAS,mBAAmBA,MAAK,CAAC;AAE5C,IAAAA,SAAQ,CAAC;AACT,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,EAAE,GAAG;AACnC,MAAAA,OAAM,KAAK,IAAI,WAAW,CAAC,CAAC;AAAA,IAC9B;AAAA,EACF,WAAW,CAAC,MAAM,QAAQA,MAAK,GAAG;AAEhC,IAAAA,SAAQ,MAAM,UAAU,MAAM,KAAKA,MAAK;AAAA,EAC1C;AACA,EAAAA,OAAM,KAAK,GAAI;AACf,MAAI,IAAIA,OAAM,SAAS,IAAI;AAC3B,MAAI,IAAI,KAAK,KAAK,IAAI,EAAE;AACxB,MAAI,IAAI,IAAI,MAAM,CAAC;AACnB,WAAS,KAAK,GAAG,KAAK,GAAG,EAAE,IAAI;AAC7B,QAAI,MAAM,IAAI,YAAY,EAAE;AAC5B,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,UAAI,CAAC,IAAIA,OAAM,KAAK,KAAK,IAAI,CAAC,KAAK,KAAKA,OAAM,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,KAAKA,OAAM,KAAK,KAAK,IAAI,IAAI,CAAC,KAAK,IAAIA,OAAM,KAAK,KAAK,IAAI,IAAI,CAAC;AAAA,IACxI;AACA,MAAE,EAAE,IAAI;AAAA,EACV;AACA,IAAE,IAAI,CAAC,EAAE,EAAE,KAAKA,OAAM,SAAS,KAAK,IAAI,KAAK,IAAI,GAAG,EAAE;AACtD,IAAE,IAAI,CAAC,EAAE,EAAE,IAAI,KAAK,MAAM,EAAE,IAAI,CAAC,EAAE,EAAE,CAAC;AACtC,IAAE,IAAI,CAAC,EAAE,EAAE,KAAKA,OAAM,SAAS,KAAK,IAAI;AACxC,WAAS,MAAM,GAAG,MAAM,GAAG,EAAE,KAAK;AAChC,QAAI,IAAI,IAAI,YAAY,EAAE;AAC1B,aAAS,IAAI,GAAG,IAAI,IAAI,EAAE,GAAG;AAC3B,QAAE,CAAC,IAAI,EAAE,GAAG,EAAE,CAAC;AAAA,IACjB;AACA,aAAS,KAAK,IAAI,KAAK,IAAI,EAAE,IAAI;AAC/B,QAAE,EAAE,IAAI,KAAK,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,CAAC,IAAI,EAAE,KAAK,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,CAAC;AAAA,IACjE;AACA,QAAI,IAAI,EAAE,CAAC;AACX,QAAI,IAAI,EAAE,CAAC;AACX,QAAI,IAAI,EAAE,CAAC;AACX,QAAI,IAAI,EAAE,CAAC;AACX,QAAI,IAAI,EAAE,CAAC;AACX,aAAS,MAAM,GAAG,MAAM,IAAI,EAAE,KAAK;AACjC,UAAI,IAAI,KAAK,MAAM,MAAM,EAAE;AAC3B,UAAI,IAAI,KAAK,GAAG,CAAC,IAAI,EAAE,GAAG,GAAG,GAAG,CAAC,IAAI,IAAI,EAAE,CAAC,IAAI,EAAE,GAAG,MAAM;AAC3D,UAAI;AACJ,UAAI;AACJ,UAAI,KAAK,GAAG,EAAE,MAAM;AACpB,UAAI;AACJ,UAAI;AAAA,IACN;AACA,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM;AACpB,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM;AACpB,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM;AACpB,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM;AACpB,MAAE,CAAC,IAAI,EAAE,CAAC,IAAI,MAAM;AAAA,EACtB;AACA,SAAO,CAAC,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,IAAI,KAAM,EAAE,CAAC,IAAI,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,IAAI,KAAM,EAAE,CAAC,IAAI,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,IAAI,KAAM,EAAE,CAAC,IAAI,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,IAAI,KAAM,EAAE,CAAC,IAAI,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,KAAK,KAAM,EAAE,CAAC,KAAK,IAAI,KAAM,EAAE,CAAC,IAAI,GAAI;AACjW;AACA,IAAO,eAAQ;;;ACzEf,IAAI,KAAK,IAAI,MAAM,IAAM,YAAI;;;ACFtB,IAAM,kBAAkB;AAAA,EAC3B,OAAO,CAAC,GAAG,CAAC;AAAA,EACZ,MAAM,CAAC,GAAG,EAAE;AAAA,EACZ,KAAK,CAAC,GAAG,EAAE;AAAA,EACX,QAAQ,CAAC,GAAG,EAAE;AAAA,EACd,WAAW,CAAC,GAAG,EAAE;AAAA,EACjB,UAAU,CAAC,IAAI,EAAE;AAAA,EACjB,SAAS,CAAC,GAAG,EAAE;AAAA,EACf,QAAQ,CAAC,GAAG,EAAE;AAAA,EACd,eAAe,CAAC,GAAG,EAAE;AAAA,EACrB,OAAO,CAAC,IAAI,EAAE;AAAA,EACd,KAAK,CAAC,IAAI,EAAE;AAAA,EACZ,OAAO,CAAC,IAAI,EAAE;AAAA,EACd,QAAQ,CAAC,IAAI,EAAE;AAAA,EACf,MAAM,CAAC,IAAI,EAAE;AAAA,EACb,SAAS,CAAC,IAAI,EAAE;AAAA,EAChB,MAAM,CAAC,IAAI,EAAE;AAAA,EACb,OAAO,CAAC,IAAI,EAAE;AAAA,EACd,aAAa,CAAC,IAAI,EAAE;AAAA,EACpB,WAAW,CAAC,IAAI,EAAE;AAAA,EAClB,aAAa,CAAC,IAAI,EAAE;AAAA,EACpB,cAAc,CAAC,IAAI,EAAE;AAAA,EACrB,YAAY,CAAC,IAAI,EAAE;AAAA,EACnB,eAAe,CAAC,IAAI,EAAE;AAAA,EACtB,YAAY,CAAC,IAAI,EAAE;AAAA,EACnB,aAAa,CAAC,IAAI,EAAE;AAAA,EACpB,SAAS,CAAC,IAAI,EAAE;AAAA,EAChB,OAAO,CAAC,IAAI,EAAE;AAAA,EACd,SAAS,CAAC,IAAI,EAAE;AAAA,EAChB,UAAU,CAAC,IAAI,EAAE;AAAA,EACjB,QAAQ,CAAC,IAAI,EAAE;AAAA,EACf,WAAW,CAAC,IAAI,EAAE;AAAA,EAClB,QAAQ,CAAC,IAAI,EAAE;AAAA,EACf,SAAS,CAAC,IAAI,EAAE;AAAA,EAChB,eAAe,CAAC,KAAK,EAAE;AAAA,EACvB,aAAa,CAAC,KAAK,EAAE;AAAA,EACrB,eAAe,CAAC,KAAK,EAAE;AAAA,EACvB,gBAAgB,CAAC,KAAK,EAAE;AAAA,EACxB,cAAc,CAAC,KAAK,EAAE;AAAA,EACtB,iBAAiB,CAAC,KAAK,EAAE;AAAA,EACzB,cAAc,CAAC,KAAK,EAAE;AAAA,EACtB,eAAe,CAAC,KAAK,EAAE;AAC3B;;;ACzCO,SAAS,eAAe,UAAU,UAAU,QAAQ,uBAAuB,OAAO;AACrF,QAAM,iBAAiB,OAAO,QAAQ;AACtC,QAAM,gBAAgB,CAAC,kBAAkB,SAAS,QAAU,KAAK,CAAC,CAAC,IAAI,gBAAgB,QAAU,KAAK,CAAC,CAAC;AACxG,QAAM,YAAY,CAAC,OAAO,UAAU;AAChC,QAAI,SAAS,QAAQ,OAAO,UAAU,UAAU;AAC5C,aAAO,cAAc,OAAO,gBAAgB,KAAK,CAAC;AAAA,IACtD,WACS,SAAS,QAAQ,MAAM,QAAQ,KAAK,GAAG;AAC5C,aAAO,MAAM,OAAO,CAAC,WAAW,cAAc,UAAU,WAAW,SAAS,GAAG,KAAK;AAAA,IACxF,OACK;AACD,UAAI,SAAS,QAAQ,MAAM,MAAM,KAAK,CAAC,KAAK,MAAM;AAC9C,eAAO,UAAU,OAAO,MAAM,MAAM,KAAK,CAAC,CAAC;AAAA,MAC/C,WACS,SAAS,QAAQ,MAAM,GAAG,KAAK,MAAM;AAC1C,eAAO,UAAU,OAAO,MAAM,GAAG,CAAC;AAAA,MACtC,OACK;AACD,eAAO;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AACA,QAAM,eAAe;AACrB,SAAO,eAAe,QAAQ,cAAc,CAAC,GAAG,gBAAgB;AAxBpE,QAAAC;AAyBQ,UAAM,QAAQ,OAAO,WAAW,KAAK,OAAO,OAAO,OAAO,WAAW,CAAC,IAAI,uBAAuB,KAAK;AACtG,WAAO,SAAS,kBACV,UAAU,SAAOA,MAAA,qCAAU,oBAAV,gBAAAA,IAA4B,iBAAgB,YAAY,IAAI,cAAc,IAAI,gBAAgB,KAAK,IACpH;AAAA,EACV,CAAC;AACL;;;AC9BO,SAAS,qBAAqB,OAAO,SAAS,GAAG,YAAY,GAAG;AACnE,MAAI,SAAS,QAAQ,MAAM,KAAK,GAAG;AAC/B,WAAO;AAAA,EACX;AACA,UAAQ,SAAS,OAAO,QAAQ,YAAY;AAC5C,SAAO,WAAW,IACZ,SAAS,OACL,OACA,QAAQ,KACJ,MAAM,QACN,MAAM,SAAS,IACvB,SAAS,OACL,QACA,QAAQ,KACJ,OAAO,QACP,QAAQ,MACJ,MAAM,QACN,MAAM,SAAS;AACrC;;;AClBO,SAAS,YAAY,KAAK;AAC7B,SAAO;AAAA,IACH,MAAM,IAAI;AAAA,IACV,UAAU,IAAI;AAAA,IACd,UAAU,IAAI;AAAA,IACd,UAAU,IAAI;AAAA,IACd,MAAM,IAAI;AAAA,IACV,UAAU,IAAI;AAAA,IACd,MAAM,IAAI;AAAA,IACV,UAAU,IAAI;AAAA,IACd,QAAQ,IAAI;AAAA,IACZ,cAAc,CAAC,GAAG,IAAI,YAAY,EAAE,IAAI,CAAC,CAAC,KAAK,KAAK,OAAO,EAAE,KAAK,MAAM,EAAE;AAAA,IAC1E,MAAM,IAAI;AAAA,IACV,QAAQ,IAAI;AAAA,EAChB;AACJ;;;ACfO,SAAS,uBAAuB,KAAK;AACxC,QAAM,QAAQ,oBAAI,IAAI;AACtB,SAAO,KAAK,UAAU,KAAK,CAAC,KAAK,UAAU;AACvC,QAAI,OAAO,UAAU,YAAY,UAAU,MAAM;AAC7C,UAAI,MAAM,IAAI,KAAK,GAAG;AAClB,eAAO;AAAA,MACX;AACA,YAAM,IAAI,KAAK;AAAA,IACnB;AACA,QAAI,OAAO,UAAU,UAAU;AAC3B,aAAO,GAAG,KAAK;AAAA,IACnB;AACA,WAAO;AAAA,EACX,CAAC;AACL;;;ACZO,SAAS,QAAQ,KAAK,MAAM;AAC/B,QAAM,MAAM;AAAA,IACR,MAAM,CAAC;AAAA,IACP,SAAS;AAAA,EACb;AACA,MAAI,QAAQ,MAAM;AACd,YAAQ,KAAK,IAAI;AAAA,EACrB;AACA,MAAI,YAAY,IAAI,UAAU;AAC1B,QAAI,aAAa;AACrB,MAAI,YAAY,IAAI,KAAK;AACrB,QAAI,QAAQ;AAChB,MAAI,YAAY,IAAI,MAAM;AACtB,QAAI,SAAS;AACjB,MAAI,YAAY,IAAI,aAAa;AAC7B,QAAI,gBAAgB;AACxB,MAAI,IAAI;AACJ,QAAI,UAAU;AAClB,SAAO,YAAY,KAAK,KAAK,IAAI,KAAK;AAC1C;AACA,QAAQ,SAAS;AACjB,QAAQ,SAAS;AAAA,EACb,SAAS;AAAA,EACT,QAAQ;AAAA,EACR,SAAS;AAAA,EACT,WAAW;AAAA,EACX,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,MAAM;AAAA,EACN,QAAQ;AACZ;AACA,SAAS,UAAU,KAAK;AACpB,SAAO,OAAO,QAAQ;AAC1B;AACA,SAAS,YAAY,KAAK;AACtB,SAAO,QAAQ;AACnB;AACA,SAAS,eAAe,KAAK;AACzB,SAAO;AACX;AACA,SAAS,iBAAiB,KAAK,WAAW;AA1C1C,MAAAC,KAAA;AA2CI,QAAM,QAAQ,QAAQ,OAAO,SAAS;AACtC,MAAI,SAAS,UAAQ,MAAAA,MAAA,mCAAS,WAAT,gBAAAA,IAAkB,WAAlB,mBAA2B,OAAM,UAAQ,8CAAS,WAAT,mBAAkB,WAAlB,mBAA2B,OAAM,MAAM;AACjG,WAAO,UAAY,QAAQ,OAAO,KAAK,EAAE,CAAC,IAAI,MAAM,MAAM,UAAY,QAAQ,OAAO,KAAK,EAAE,CAAC,IAAI;AAAA,EACrG,OACK;AACD,WAAO;AAAA,EACX;AACJ;AACA,SAASC,YAAW,KAAK;AACrB,SAAO,OAAO,QAAQ;AAC1B;AACA,SAAS,SAAS,KAAK;AACnB,SAAO,OAAO,QAAQ;AAC1B;AACA,SAAS,SAAS,KAAK;AACnB,SAAO,OAAO,QAAQ;AAC1B;AACA,SAAS,OAAO,KAAK;AACjB,SAAO,QAAQ;AACnB;AACA,SAAS,OAAO,KAAK,MAAM;AACvB,SAAO,OAAO,UAAU,eAAe,KAAK,KAAK,IAAI;AACzD;AACA,SAAS,SAAS,IAAI;AAClB,SAAO,SAAS,EAAE,KAAK,eAAe,EAAE,MAAM;AAClD;AACA,SAAS,SAAS,KAAK;AACnB,SAAO,OAAO,QAAQ,YAAY,QAAQ;AAC9C;AACA,SAAS,QAAQ,GAAG;AAChB,SAAO,SAAS,CAAC,MAAM,eAAe,CAAC,MAAM,oBAAoB,aAAa;AAClF;AACA,SAAS,OAAO,GAAG;AACf,SAAO,SAAS,CAAC,KAAK,eAAe,CAAC,MAAM;AAChD;AACA,SAAS,eAAe,GAAG;AACvB,SAAO,OAAO,UAAU,SAAS,KAAK,CAAC;AAC3C;AACA,SAAS,YAAYC,QAAO;AACxB,QAAMC,QAAO,CAAC;AACd,EAAAD,OAAM,QAAQ,CAAC,QAAQ;AACnB,IAAAC,MAAK,GAAG,IAAI;AAAA,EAChB,CAAC;AACD,SAAOA;AACX;AACA,SAAS,YAAY,KAAK,OAAO,cAAc,aAAa,MAAM;AAC9D,QAAMC,UAAS,CAAC;AAChB,WAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,IAAI,GAAG,EAAE,GAAG;AAC1C,QAAI,OAAO,OAAO,OAAO,CAAC,CAAC,GAAG;AAC1B,MAAAA,QAAO,KAAK,eAAe,KAAK,OAAO,cAAc,aAAa,OAAO,CAAC,GAAG,IAAI,CAAC;AAAA,IACtF,OACK;AACD,MAAAA,QAAO,KAAK,EAAE;AAAA,IAClB;AAAA,EACJ;AACA,OAAK,QAAQ,CAAC,QAAQ;AAClB,QAAI,CAAC,IAAI,MAAM,OAAO,GAAG;AACrB,MAAAA,QAAO,KAAK,eAAe,KAAK,OAAO,cAAc,aAAa,KAAK,IAAI,CAAC;AAAA,IAChF;AAAA,EACJ,CAAC;AACD,SAAOA;AACX;AACA,SAAS,YAAY,OAAO;AACxB,SAAO,MAAM,MAAM,UAAU,SAAS,KAAK,KAAK,IAAI;AACxD;AACO,SAAS,YAAY,KAAK,OAAO,eAAe,GAAG;AACtD,MAAI,IAAI,iBACJ,SAAS,QACTH,YAAW,KAAK,MAChB,+BAAO,aAAY,WACnB,GAAE,+BAAO,iBAAe,+BAAO,YAAY,eAAc,QAAQ;AACjE,QAAI,OAAO,MAAM,YAAY,cAAc,MAAM,YAAY,MAAM;AAC/D,aAAO,MAAM,SAAS;AAAA,IAC1B;AACA,QAAI,MAAM,+BAAO,QAAQ,cAAc;AACvC,QAAI,CAAC,SAAS,GAAG,GAAG;AAChB,YAAM,YAAY,KAAK,KAAK,YAAY;AAAA,IAC5C;AACA,WAAO;AAAA,EACX;AACA,QAAM,YAAY,gBAAgB,KAAK,KAAK;AAC5C,MAAI,WAAW;AACX,WAAO;AAAA,EACX;AACA,MAAI,OAAO,OAAO,KAAK,KAAK;AAC5B,QAAM,cAAc,YAAY,IAAI;AACpC,MAAI;AACA,QAAI,IAAI,cAAc,OAAO,qBAAqB;AAC9C,aAAO,OAAO,oBAAoB,KAAK;AAAA,IAC3C;AAAA,EACJ,SACO,GAAG;AAAA,EACV;AACA,MAAI,QAAQ,KAAK,MAAM,KAAK,QAAQ,SAAS,KAAK,KAAK,KAAK,QAAQ,aAAa,KAAK,IAAI;AACtF,WAAO,YAAY,KAAK;AAAA,EAC5B;AACA,MAAI,KAAK,WAAW,GAAG;AACnB,QAAIA,YAAW,IAAI,OAAO,GAAG;AACzB,UAAIA,YAAW,KAAK,GAAG;AACnB,cAAM,OAAO,MAAM,OAAO,OAAO,MAAM,OAAO;AAC9C,eAAO,IAAI,QAAQ,cAAc,OAAO,KAAK,SAAS;AAAA,MAC1D;AACA,UAAI,SAAS,KAAK,GAAG;AACjB,eAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,KAAK,KAAK,GAAG,QAAQ;AAAA,MACtE;AACA,UAAI,OAAO,KAAK,GAAG;AACf,eAAO,IAAI,QAAQ,KAAK,UAAU,YAAY,KAAK,KAAK,GAAG,MAAM;AAAA,MACrE;AACA,UAAI,QAAQ,KAAK,GAAG;AAChB,eAAO,YAAY,KAAK;AAAA,MAC5B;AAAA,IACJ,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AACA,MAAI,OAAO;AACX,MAAIC,SAAQ;AACZ,MAAI,SAAS,CAAC,OAAO,KAAK;AAC1B,MAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,IAAAA,SAAQ;AACR,aAAS,CAAC,OAAO,KAAK;AAAA,EAC1B;AACA,MAAID,YAAW,KAAK,GAAG;AACnB,UAAM,IAAI,MAAM,OAAO,OAAO,MAAM,OAAO;AAC3C,WAAO,eAAe,IAAI;AAAA,EAC9B;AACA,MAAI,SAAS,KAAK,GAAG;AACjB,WAAO,MAAM,OAAO,UAAU,SAAS,KAAK,KAAK;AAAA,EACrD;AACA,MAAI,OAAO,KAAK,GAAG;AACf,WAAO,MAAM,KAAK,UAAU,YAAY,KAAK,KAAK;AAAA,EACtD;AACA,MAAI,QAAQ,KAAK,GAAG;AAChB,WAAO,MAAM,YAAY,KAAK;AAAA,EAClC;AACA,MAAI,KAAK,WAAW,MAAM,CAACC,UAAS,MAAM,UAAU,IAAI;AACpD,WAAO,OAAO,CAAC,IAAI,OAAO,OAAO,CAAC;AAAA,EACtC;AACA,MAAI,eAAe,GAAG;AAClB,QAAI,SAAS,KAAK,GAAG;AACjB,aAAO,IAAI,QAAQ,OAAO,UAAU,SAAS,KAAK,KAAK,GAAG,QAAQ;AAAA,IACtE,OACK;AACD,aAAO,IAAI,QAAQ,YAAY,SAAS;AAAA,IAC5C;AAAA,EACJ;AACA,MAAI,KAAK,KAAK,KAAK;AACnB,MAAIE;AACJ,MAAIF,QAAO;AACP,IAAAE,UAAS,YAAY,KAAK,OAAO,cAAc,aAAa,IAAI;AAAA,EACpE,OACK;AACD,IAAAA,UAAS,KAAK,IAAI,CAAC,QAAQ;AACvB,aAAO,eAAe,KAAK,OAAO,cAAc,aAAa,KAAKF,MAAK;AAAA,IAC3E,CAAC;AAAA,EACL;AACA,MAAI,KAAK,IAAI;AACb,SAAO,qBAAqBE,SAAQ,MAAM,MAAM;AACpD;AACA,SAAS,eAAe,KAAK,OAAO,cAAc,aAAa,KAAKF,QAAO;AACvE,MAAI,MAAM;AACV,MAAI,OAAO,EAAE,OAAO,OAAO;AAC3B,MAAI;AACA,SAAK,QAAQ,MAAM,GAAG;AAAA,EAC1B,SACO,GAAG;AAAA,EACV;AACA,MAAI;AACA,QAAI,OAAO,0BAA0B;AACjC,aAAO,OAAO,yBAAyB,OAAO,GAAG,KAAK;AAAA,IAC1D;AAAA,EACJ,SACO,GAAG;AAAA,EACV;AACA,MAAI,KAAK,KAAK;AACV,QAAI,KAAK,KAAK;AACV,YAAM,IAAI,QAAQ,mBAAmB,SAAS;AAAA,IAClD,OACK;AACD,YAAM,IAAI,QAAQ,YAAY,SAAS;AAAA,IAC3C;AAAA,EACJ,OACK;AACD,QAAI,KAAK,KAAK;AACV,YAAM,IAAI,QAAQ,YAAY,SAAS;AAAA,IAC3C;AAAA,EACJ;AACA,MAAI,CAAC,OAAO,aAAa,GAAG,GAAG;AAC3B,WAAO,MAAM,MAAM;AAAA,EACvB;AACA,MAAI,CAAC,KAAK;AACN,QAAI,IAAI,KAAK,QAAQ,KAAK,KAAK,IAAI,GAAG;AAClC,UAAI,OAAO,YAAY,GAAG;AACtB,cAAM,YAAY,KAAK,KAAK,OAAO,MAAS;AAAA,MAChD,OACK;AACD,cAAM,YAAY,KAAK,KAAK,OAAO,eAAe,CAAC;AAAA,MACvD;AACA,UAAI,IAAI,QAAQ,IAAI,IAAI,IAAI;AACxB,YAAIA,QAAO;AACP,gBAAM,IACD,MAAM,IAAI,EACV,IAAI,CAAC,SAAS;AACf,mBAAO,OAAO;AAAA,UAClB,CAAC,EACI,KAAK,IAAI,EACT,OAAO,CAAC;AAAA,QACjB,OACK;AACD,gBACI,OACI,IACK,MAAM,IAAI,EACV,IAAI,CAAC,SAAS;AACf,mBAAO,QAAQ;AAAA,UACnB,CAAC,EACI,KAAK,IAAI;AAAA,QAC1B;AAAA,MACJ;AAAA,IACJ,OACK;AACD,YAAM,IAAI,QAAQ,cAAc,SAAS;AAAA,IAC7C;AAAA,EACJ;AACA,MAAI,YAAY,IAAI,GAAG;AACnB,QAAIA,UAAS,IAAI,MAAM,OAAO,GAAG;AAC7B,aAAO;AAAA,IACX;AACA,WAAO,KAAK,UAAU,KAAK,GAAG;AAC9B,QAAI,KAAK,MAAM,8BAA8B,GAAG;AAC5C,aAAO,KAAK,OAAO,GAAG,KAAK,SAAS,CAAC;AACrC,aAAO,IAAI,QAAQ,MAAM,MAAM;AAAA,IACnC,OACK;AACD,aAAO,KACF,QAAQ,MAAM,KAAK,EACnB,QAAQ,QAAQ,KAAK,EACrB,QAAQ,YAAY,GAAG;AAC5B,aAAO,IAAI,QAAQ,MAAM,QAAQ;AAAA,IACrC;AAAA,EACJ;AACA,SAAO,OAAO,OAAO;AACzB;AACA,SAAS,gBAAgB,KAAK,OAAO;AACjC,MAAI,YAAY,KAAK;AACjB,WAAO,IAAI,QAAQ,aAAa,WAAW;AAC/C,MAAI,SAAS,KAAK,GAAG;AACjB,UAAM,SAAS,MAAM,KAAK,UAAU,KAAK,EAAE,QAAQ,UAAU,EAAE,EAAE,QAAQ,MAAM,KAAK,EAAE,QAAQ,QAAQ,KAAK,IAAI;AAC/G,WAAO,IAAI,QAAQ,QAAQ,QAAQ;AAAA,EACvC;AACA,MAAI,SAAS,KAAK;AACd,WAAO,IAAI,QAAQ,KAAK,OAAO,QAAQ;AAC3C,MAAI,UAAU,KAAK;AACf,WAAO,IAAI,QAAQ,KAAK,OAAO,SAAS;AAC5C,MAAI,OAAO,KAAK;AACZ,WAAO,IAAI,QAAQ,QAAQ,MAAM;AACzC;AACA,SAAS,qBAAqBE,SAAQ,MAAM,QAAQ;AAChD,SAAO,OAAO,CAAC,KAAK,SAAS,KAAK,KAAK,OAAO,QAAQ,OAAOA,QAAO,KAAK,OAAO,IAAI,MAAM,OAAO,CAAC;AACtG;AACA,SAAS,QAAQ,QAAQC,MAAK;AAC1B,QAAM,cAAc,EAAE,GAAG,OAAO;AAChC,MAAI,CAACA,QAAO,CAAC,SAASA,IAAG;AACrB,WAAO;AACX,QAAM,YAAY,EAAE,GAAGA,KAAI;AAC3B,QAAM,OAAO,OAAO,KAAKA,IAAG;AAC5B,MAAI,IAAI,KAAK;AACb,SAAO,KAAK;AACR,gBAAY,KAAK,CAAC,CAAC,IAAI,UAAU,KAAK,CAAC,CAAC;AAAA,EAC5C;AACA,SAAO;AACX;AACO,SAAS,kBAAkB,mBAAmB,MAAM;AACvD,QAAM,MAAM;AAAA,IACR,MAAM,CAAC;AAAA,IACP,SAAS;AAAA,EACb;AACA,MAAI,kBAAkB,MAAM;AACxB,YAAQ,KAAK,cAAc;AAAA,EAC/B;AACA,QAAMC,SAAQ,KAAK,CAAC;AACpB,MAAI,IAAI;AACR,MAAI,MAAM;AACV,MAAI,OAAO;AACX,MAAI,OAAOA,WAAU,UAAU;AAC3B,QAAI,KAAK,WAAW,GAAG;AACnB,aAAOA;AAAA,IACX;AACA,QAAI;AACJ,QAAI,UAAU;AACd,aAAS,IAAI,GAAG,IAAIA,OAAM,SAAS,GAAG,KAAK;AACvC,UAAIA,OAAM,WAAW,CAAC,MAAM,IAAI;AAC5B,cAAM,WAAWA,OAAM,WAAW,EAAE,CAAC;AACrC,YAAI,IAAI,MAAM,KAAK,QAAQ;AACvB,kBAAQ,UAAU;AAAA,YACd,KAAK,KAAK;AACN,oBAAM,UAAU,KAAK,EAAE,CAAC;AACxB,kBAAI,OAAO,YAAY,UAAU;AAC7B,0BAAU,gBAAgB,KAAK,OAAO;AAAA,cAC1C,WACS,OAAO,YAAY,UAAU;AAClC,0BAAU,gBAAgB,KAAK,OAAO;AAAA,cAC1C,WACS,OAAO,YAAY,YAAY,YAAY,MAAM;AACtD,0BAAU,OAAO,OAAO;AAAA,cAC5B,OACK;AACD,0BAAU,QAAQ,SAAS;AAAA,kBACvB,GAAG;AAAA,kBACH,SAAS;AAAA,kBACT,QAAQ;AAAA,kBACR,OAAO;AAAA,gBACX,CAAC;AAAA,cACL;AACA;AAAA,YACJ;AAAA,YACA,KAAK;AACD,wBAAU,uBAAuB,KAAK,EAAE,CAAC,CAAC;AAC1C;AAAA,YACJ,KAAK,KAAK;AACN,oBAAM,UAAU,KAAK,EAAE,CAAC;AACxB,kBAAI,OAAO,YAAY,UAAU;AAC7B,0BAAU,gBAAgB,KAAK,OAAO;AAAA,cAC1C,WACS,OAAO,YAAY,UAAU;AAClC,0BAAU;AAAA,cACd,OACK;AACD,0BAAU,gBAAgB,KAAK,OAAO;AAAA,cAC1C;AACA;AAAA,YACJ;AAAA,YACA,KAAK;AACD,wBAAU,QAAQ,KAAK,EAAE,CAAC,GAAG,cAAc;AAC3C;AAAA,YACJ,KAAK;AACD,wBAAU,QAAQ,KAAK,EAAE,CAAC,GAAG;AAAA,gBACzB,GAAG;AAAA,gBACH,YAAY;AAAA,gBACZ,WAAW;AAAA,gBACX,OAAO;AAAA,cACX,CAAC;AACD;AAAA,YACJ,KAAK,KAAK;AACN,oBAAM,cAAc,KAAK,EAAE,CAAC;AAC5B,kBAAI,OAAO,gBAAgB,UAAU;AACjC,0BAAU,gBAAgB,KAAK,WAAW;AAAA,cAC9C,WACS,OAAO,gBAAgB,UAAU;AACtC,0BAAU;AAAA,cACd,OACK;AACD,0BAAU,gBAAgB,KAAK,SAAS,OAAO,CAAC;AAAA,cACpD;AACA;AAAA,YACJ;AAAA,YACA,KAAK,KAAK;AACN,oBAAM,YAAY,KAAK,EAAE,CAAC;AAC1B,kBAAI,OAAO,cAAc,UAAU;AAC/B,0BAAU;AAAA,cACd,OACK;AACD,0BAAU,gBAAgB,KAAK,SAAS,SAAS,CAAC;AAAA,cACtD;AACA;AAAA,YACJ;AAAA,YACA,KAAK;AACD,mBAAK;AACL,wBAAU;AACV;AAAA,YACJ,KAAK;AACD,qBAAOA,OAAM,MAAM,SAAS,CAAC;AAC7B,wBAAU,IAAI;AACd;AAAA,YACJ;AACI;AAAA,UACR;AACA,cAAI,YAAY,IAAI,GAAG;AACnB,mBAAOA,OAAM,MAAM,SAAS,IAAI,CAAC;AAAA,UACrC;AACA,iBAAO;AACP,oBAAU,IAAI;AAAA,QAClB,WACS,aAAa,IAAI;AACtB,iBAAOA,OAAM,MAAM,SAAS,CAAC;AAC7B,oBAAU,IAAI;AAAA,QAClB;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,YAAY,GAAG;AACf;AACA,aAAO;AACP,UAAI,UAAUA,OAAM,QAAQ;AACxB,eAAOA,OAAM,MAAM,OAAO;AAAA,MAC9B;AAAA,IACJ;AAAA,EACJ;AACA,SAAO,IAAI,KAAK,QAAQ;AACpB,UAAM,QAAQ,KAAK,CAAC;AACpB,WAAO;AACP,WAAO,OAAO,UAAU,WAAW,QAAQ,OAAO,cAAc,IAAI;AACpE,WAAO;AACP;AAAA,EACJ;AACA,SAAO;AACX;;;AC9bA,IAAO,kBAAQ;AAAA,EACX;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA,SAAAC;AAAA,EACA;AAAA,EACA;AACJ;AAbA;AAcA,IAAM,OAAO;AAAA,EACT,SAAS,CAAC,CAAC,OAAO,QAAQ,OAAO,QAAQ,EAAE,SAAS,WAAW,IAAI,YAAY;AAAA,EAC/E,UAAS,8CAAa,iBAAb,mBAA2B;AACxC;AACA,IAAM,YAAY;AACX,SAAS,QAAQ,YAAY,cAAc,iBAAiB,+BAA+B,MAAM,aAAa;AACjH,SAAO,OAAO,OAAO,CAAC,GAAG,MAAM;AAAA,IAC3B;AAAA,IACA;AAAA,IACA,MAAM,oBAAI,KAAK;AAAA,IACf;AAAA,IACA;AAAA,IACA,MAAM,CAAC,gCAAgC,oBAAoB,eAAe,IAAI;AAAA,EAClF,CAAC;AACL;AACO,SAAS,oBAAoB,iBAAiB,QAAQ,MAAM,GAAG;AA7BtE,MAAAC,KAAA;AA8BI,SAAO,uBAAsB,YAAAA,MAAA,+BAAO,UAAP,gBAAAA,IAAc,MAAM,UAApB,mBAA2B,OAAO,CAAC,SAAS,CAAC,KAAK,SAAS,SAAS,OAApE,mBAAyE,gBAAgB;AAC1H;AACO,SAAS,cAAc,OAAO;AAhCrC,MAAAA,KAAA;AAiCI,UAAQ,aAAAA,MAAA,+BAAO,UAAP,gBAAAA,IAAc,MAAM,UAAS,CAAC,MAA9B,mBACF,OAAO,CAAC,SAAS,CAAC,KAAK,SAAS,SAAS,OADvC,mBAEF,OAAO,CAAC,QAAQ,SAAS;AAC3B,WAAO,KAAK,sBAAsB,IAAI,CAAC;AACvC,WAAO;AAAA,EACX,GAAG,CAAC;AACR;AACA,SAAS,sBAAsB,MAAM;AAxCrC,MAAAA;AAyCI,QAAM,QAAOA,MAAA,yCAAY,aAAZ,gBAAAA,IAAsB;AACnC,QAAM,aAAa;AAAA,IACf,cAAc;AAAA,IACd,UAAU;AAAA,IACV,kBAAkB;AAAA,IAClB,YAAY;AAAA,IACZ,UAAU;AAAA,IACV,UAAU;AAAA,IACV,kBAAkB;AAAA,IAClB,QAAQ;AAAA,EACZ;AACA,MAAI,QAAQ,MAAM;AACd,UAAM,QAAQ,KAAK,MAAM,SAAS;AAClC,QAAI,OAAO;AACP,iBAAW,WAAW,MAAM,CAAC,EAAE,QAAQ,SAAS,EAAE;AAClD,iBAAW,eAAe,GAAG,IAAI,GAAG,WAAW,QAAQ;AACvD,YAAM,YAAY,WAAW,SAAS,MAAM,GAAG;AAC/C,iBAAW,WAAW,UAAU,UAAU,SAAS,CAAC;AACpD,iBAAW,WAAW,MAAM,CAAC;AAC7B,iBAAW,aAAa,MAAM,CAAC;AAC/B,iBAAW,mBAAmB,GAAG,WAAW,QAAQ,IAAI,WAAW,QAAQ;AAC3E,iBAAW,mBAAmB,GAAG,WAAW,QAAQ,IAAI,WAAW,QAAQ;AAAA,IAC/E;AAAA,EACJ;AACA,SAAO;AACX;AACO,SAASD,SAAQ,GAAG;AACvB,SAAO,aAAa;AACxB;AACO,SAAS,mBAAmB,YAAY,UAAU;AACrD,SAAO,WAAW,OAAO,CAAC,QAAQ,QAAQ;AACtC,IAAAA,SAAQ,GAAG,IAAI,OAAO,OAAO,KAAK,qBAAqB,KAAK,QAAQ,CAAC,IAAI,OAAO,KAAK,KAAK,GAAG;AAC7F,WAAO;AAAA,EACX,GAAG,EAAE,MAAM,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC;AAC/B;AACO,SAAS,qBAAqB,OAAO,UAAU;AAClD,QAAM,gBAAgB,cAAc,KAAK,EAAE,IAAI,CAAC,eAAe;AAC3D,WAAO,eAAe,UAAU,SAAS,0BAA0B,EAAE,GAAG,WAAW,GAAG,IAAI;AAAA,EAC9F,CAAC;AACD,QAAM,yBAAyB;AAAA,IAC3B,WAAW,IAAI,MAAM,IAAI;AAAA,IACzB,cAAc,OAAO,oBAAoB,KAAK,EACzC,OAAO,CAAC,QAAQ,QAAQ;AACzB,UAAI,QAAQ,SAAS;AACjB,eAAO,KAAK,MAAM,GAAG,CAAC;AAAA,MAC1B;AACA,aAAO;AAAA,IACX,GAAG,CAAC,CAAC,EACA,KAAK,IAAI;AAAA,IACd,YAAY,cAAc,KAAK,IAAI;AAAA,EACvC;AACA,SAAO,eAAe,UAAU,SAAS,qBAAqB,sBAAsB;AACxF;AACO,SAAS,mBAAmB,eAAe,SAAS,WAAW,UAAU;AAC5E,QAAM,gBAAgB,UAAU,SAAS,KAAK,QAAQ,SAAS,IAAI,OAAO,MAAM,UAAU,KAAK,IAAI;AACnG,WAAS,qBAAqB,SAAS,SAAS;AAChD,UAAQ,IAAI,gBAAgB,kBAAkB,SAAS,sBAAsB,GAAG,OAAO,IAAI,YAAY;AAC3G;AACO,SAAS,cAAc,MAAM;AAChC,UAAQ,IAAI,uBAAuB,IAAI,CAAC;AAC5C;AACO,SAAS,SAAS,KAAK;AAC1B,SAAO,MAAM,QAAQ;AACzB;;;AClGO,IAAM,aAAN,MAAiB;AAAA,EACpB,YAAY,UAAU,QAAQ,kBAAkB,GAAG;AAPvD,QAAAE,KAAA;AAQQ,SAAK,SAAS;AACd,SAAK,kBAAkB;AACvB,SAAK,UAAU;AACf,SAAK,WAAW;AAAA,MACZ,OAAM,qCAAU,SAAQ;AAAA,MACxB,MAAM,qCAAU;AAAA,MAChB,aAAa,qCAAU;AAAA,MACvB,WAAU,qCAAU,aAAY;AAAA,MAChC,oBAAoB,qCAAU;AAAA,MAC9B,+BAA8B,qCAAU,iCAAgC;AAAA,MACxE,oBAAmB,qCAAU,sBACzB;AAAA,MACJ,sBAAqB,qCAAU,wBAAuB;AAAA,MACtD,2BAA0B,qCAAU,6BAA4B;AAAA,MAChE,kCAAiC,qCAAU,oCAAmC;AAAA,MAC9E,iCAAgC,qCAAU,mCAAkC;AAAA,MAC5E,kBAAiB,qCAAU,oBAAmB;AAAA,MAC9C,oBAAmB,qCAAU,sBAAqB;AAAA,MAClD,kBAAiB,qCAAU,oBAAmB;AAAA,QAC1C,cAAc;AAAA,UACV,KAAK,CAAC,QAAQ,SAAS,iBAAiB,KAAK;AAAA,UAC7C,OAAO,CAAC,QAAQ,OAAO;AAAA,UACvB,OAAO,CAAC,QAAQ,aAAa;AAAA,UAC7B,OAAO,CAAC,QAAQ,OAAO;AAAA,UACvB,MAAM,CAAC,QAAQ,MAAM;AAAA,UACrB,MAAM,CAAC,QAAQ,QAAQ;AAAA,UACvB,OAAO,CAAC,QAAQ,KAAK;AAAA,UACrB,OAAO,CAAC,QAAQ,WAAW;AAAA,QAC/B;AAAA,QACA,YAAY;AAAA,QACZ,kBAAkB;AAAA,QAClB,MAAM,CAAC,SAAS,MAAM;AAAA,QACtB,yBAAyB,CAAC,SAAS,MAAM;AAAA,QACzC,yBAAyB,CAAC,SAAS,MAAM;AAAA,QACzC,WAAW,CAAC,QAAQ,eAAe,aAAa;AAAA,QAChD,UAAU,CAAC,QAAQ;AAAA,QACnB,kBAAkB;AAAA,MACtB;AAAA,MACA,uBAAsB,qCAAU,yBAAwB;AAAA,QACpD,QAAQ;AAAA,QACR,SAAS;AAAA,QACT,OAAO;AAAA,MACX;AAAA,MACA,eAAc,qCAAU,iBAAgB;AAAA,MACxC,kBAAiB,qCAAU,oBAAmB;AAAA,MAC9C,mBAAkB,qCAAU,qBAAoB,CAAC,UAAU;AAAA,MAC3D,kCAAiC,qCAAU,oCAAmC;AAAA,MAC9E,iBAAiB,qCAAU;AAAA,MAC3B,QAAQ,CAAC,IAAI,qCAAU,WAAU,CAAC,CAAE;AAAA,MACpC,oBAAoB,CAAC,IAAI,qCAAU,uBAAsB,CAAC,CAAE;AAAA,MAC5D,WAAW;AAAA,QACP,OAAMA,MAAA,qCAAU,cAAV,gBAAAA,IAAqB;AAAA,QAC3B,WAAU,0CAAU,cAAV,mBAAqB;AAAA,QAC/B,UAAS,0CAAU,cAAV,mBAAqB;AAAA,QAC9B,kBAAiB,0CAAU,cAAV,mBAAqB;AAAA,QACtC,aAAY,0CAAU,cAAV,mBAAqB;AAAA,QACjC,eAAc,0CAAU,cAAV,mBAAqB;AAAA,QACnC,qBAAoB,0CAAU,cAAV,mBAAqB;AAAA,QACzC,gBAAe,0CAAU,cAAV,mBAAqB;AAAA,MACxC;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,IAAI,YAAY,iBAAiB,MAAM;AAtE3C,QAAAA,KAAA;AAuEQ,QAAI,aAAa,KAAK,SAAS,UAAU;AACrC;AAAA,IACJ;AACA,UAAM,UAAU,CAAC,GAAG,KAAK,SAAS,QAAQ,GAAG,IAAI;AACjD,UAAM,eAAaA,MAAA,KAAK,SAAS,cAAd,gBAAAA,IAAyB,SAAQ,QAC9C,UAAK,SAAS,cAAd,mBAAyB,KAAK,WAC9B,KAAK,SAAS,oBAAoB,QAAQ,KAAK,SAAS,iBAAiB,SAAS,IAC9E,KAAK,MAAM,OAAO,IAClB;AACV,UAAM,aAAa,KAAK,UAAU,OAAO,KAAK,mCAAmC,KAAK,MAAM,IAAI;AAChG,UAAM,WAAS,UAAK,SAAS,cAAd,mBAAyB,aAAY,QAAO,UAAK,SAAS,cAAd,mBAAyB,SAAS,YAAY,cAAc,KAAK,UAAU,YAAY,UAAU;AAC5J,UAAM,mBAAiB,UAAK,SAAS,cAAd,mBAAyB,YAAW,QACrD,UAAK,SAAS,cAAd,mBAAyB,QAAQ,QAAQ,YAAY,gBACrD,KAAK,iBAAiB,QAAQ,YAAY,YAAY;AAC5D,QAAI;AACJ,QAAI,yBAAyB;AAC7B,UAAI,UAAK,SAAS,cAAd,mBAAyB,eAAc,MAAM;AAC7C,uBAAgB,UAAK,SAAS,cAAd,mBAAyB,WAAW,iDAAiB,KAAK,SAAS;AAAA,IACvF;AACA,UAAI,UAAK,SAAS,cAAd,mBAAyB,iBAAgB,MAAM;AAC/C,gCAAyB,UAAK,SAAS,cAAd,mBAAyB,aAAa,YAAY,KAAK;AAAA,IACpF;AACA,QAAI,KAAK,SAAS,SAAS,UAAU;AACjC,sBAAgB,iBAAiB,KAAK,wBAAwB,iDAAiB,KAAK,SAAS,aAAa;AAC1G,+BAAyB,0BAA0B,KAAK,QAAQ,mBAAmB,YAAY,KAAK,QAAQ;AAAA,IAChH;AACA,QAAI,iBAAiB,QAAQ,0BAA0B,MAAM;AACzD,kBAAK,SAAS,cAAd,mBAAyB,uBAAsB,QACzC,UAAK,SAAS,cAAd,mBAAyB,mBAAmB,eAAe,uBAAuB,MAAM,uBAAuB,QAAQ,KAAK,YAC5H,KAAK,QAAQ,mBAAmB,eAAe,uBAAuB,MAAM,uBAAuB,QAAQ,KAAK,QAAQ;AAAA,IAClI,OACK;AACD,kBAAK,SAAS,cAAd,mBAAyB,kBAAiB,QACpC,UAAK,SAAS,cAAd,mBAAyB,cAAc,kBACvC,KAAK,SAAS,SAAS,WACnB,KAAK,QAAQ,cAAc,cAAc,IACzC;AAAA,IACd;AACA,QAAI,KAAK,SAAS,sBAAsB,QAAQ,KAAK,SAAS,mBAAmB,SAAS,GAAG;AACzF,WAAK,SAAS,mBAAmB,QAAQ,CAAC,oBAAoB;AAC1D,wBAAgB,cAAc;AAAA,MAClC,CAAC;AAAA,IACL;AACA,WAAO;AAAA,EACX;AAAA,EACA,gBAAgB,iBAAiB;AAC7B,SAAK,SAAS,mBAAmB,KAAK,eAAe;AAAA,EACzD;AAAA,EACA,aAAa,UAAU,QAAQ;AAvHnC,QAAAA,KAAA;AAwHQ,UAAM,oBAAoB;AAAA,MACtB,GAAG,KAAK;AAAA,MACR,GAAG;AAAA,MACH,eAAaA,MAAA,KAAK,aAAL,gBAAAA,IAAe,gBAAe,UAAQ,UAAK,aAAL,mBAAe,SAAQ,OACpE,CAAC,GAAG,KAAK,SAAS,aAAa,KAAK,SAAS,IAAI,MACjD,UAAK,aAAL,mBAAe,SAAQ,OACnB,CAAC,KAAK,SAAS,IAAI,IACnB;AAAA,MACV,QAAQ,CAAC,GAAG,KAAK,SAAS,QAAQ,IAAI,qCAAU,WAAU,CAAC,CAAE;AAAA,IACjE;AACA,UAAM,YAAY,IAAI,KAAK,YAAY,mBAAmB,UAAU,KAAK,QAAQ,KAAK,eAAe;AACrG,WAAO;AAAA,EACX;AAAA,EACA,MAAM,MAAM;AACR,UAAM,mBAAmB,KAAK,SAAS,oCAAoC,OAAO,KAAK,SAAS,mBAAmB,KAAK,SAAS,iBAAiB,IAAI,CAAC,QAAQ,IAAI,YAAY,CAAC;AAChL,WAAO,6BAAM,IAAI,CAAC,QAAQ;AACtB,aAAO,KAAK,mCAAmC,KAAK,gBAAgB;AAAA,IACxE;AAAA,EACJ;AAAA,EACA,mCAAmC,QAAQ,MAAM,OAAO,CAAC,GAAG;AA3IhE,QAAAA,KAAA;AA4IQ,QAAI,KAAK,SAAS,MAAM,GAAG;AACvB,aAAO,EAAE,GAAG,OAAO;AAAA,IACvB;AACA,QAAI,OAAO,WAAW,YAAY,WAAW,MAAM;AAC/C,WAAK,KAAK,MAAM;AAAA,IACpB;AACA,QAAI,KAAK,QAAQ,QAAQ,MAAM,KAAK,KAAK,QAAQ,SAAS,MAAM,GAAG;AAC/D,aAAO;AAAA,IACX,WACS,kBAAkB,KAAK;AAC5B,aAAO,IAAI,IAAI,MAAM;AAAA,IACzB,WACS,kBAAkB,KAAK;AAC5B,aAAO,IAAI,IAAI,MAAM;AAAA,IACzB,WACS,MAAM,QAAQ,MAAM,GAAG;AAC5B,aAAO,OAAO,IAAI,CAAC,SAAS,KAAK,mCAAmC,MAAM,MAAM,IAAI,CAAC;AAAA,IACzF,WACS,kBAAkB,MAAM;AAC7B,aAAO,IAAI,KAAK,OAAO,QAAQ,CAAC;AAAA,IACpC,WACS,kBAAkB,KAAK;AAC5B,aAAO,YAAY,MAAM;AAAA,IAC7B,WACS,WAAW,QAAQ,OAAO,WAAW,UAAU;AACpD,YAAM,aAAa,KAAK,QAAQ,QAAQ,MAAM,IAAI,KAAK,YAAY,MAAM,IAAI,OAAO,OAAO,OAAO,eAAe,MAAM,CAAC;AACxH,aAAO,OAAO,oBAAoB,MAAM,EAAE,OAAO,CAAC,GAAG,SAAS;AAtK1E,YAAAA;AAuKgB,UAAE,IAAI,IAAI,KAAK,WAASA,MAAA,KAAK,aAAL,gBAAAA,IAAe,qCAAoC,OAAO,OAAO,KAAK,YAAY,CAAC,IACrG,KAAK,SAAS,mBACb,MAAM;AACL,cAAI;AACA,mBAAO,KAAK,mCAAmC,OAAO,IAAI,GAAG,MAAM,IAAI;AAAA,UAC3E,SACO,GAAG;AACN,mBAAO;AAAA,UACX;AAAA,QACJ,GAAG;AACP,eAAO;AAAA,MACX,GAAG,UAAU;AAAA,IACjB,OACK;AACD,UAAI,OAAO,WAAW,UAAU;AAC5B,YAAI,iBAAiB;AACrB,mBAAW,WAASA,MAAA,KAAK,aAAL,gBAAAA,IAAe,oBAAmB,CAAC,GAAG;AACtD,2BAAiB,eAAe,QAAQ,SAAO,UAAK,aAAL,mBAAe,oBAAmB,EAAE;AAAA,QACvF;AACA,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,mCAAmC,QAAQ,OAAO,CAAC,GAAG;AAClD,QAAI,KAAK,gBAAgB,MAAM,KAAK,KAAK,SAAS,MAAM,GAAG;AACvD,aAAO,KAAK,YAAY,MAAM;AAAA,IAClC;AACA,QAAI,KAAK,gBAAgB,MAAM,GAAG;AAC9B,WAAK,KAAK,MAAM;AAAA,IACpB;AACA,QAAI,MAAM,QAAQ,MAAM,GAAG;AACvB,aAAO,OAAO,IAAI,CAAC,SAAS,KAAK,mCAAmC,MAAM,IAAI,CAAC;AAAA,IACnF,WACS,kBAAkB,MAAM;AAC7B,aAAO,IAAI,KAAK,OAAO,QAAQ,CAAC;AAAA,IACpC,WACS,KAAK,SAAS,MAAM,GAAG;AAC5B,aAAO,OAAO,oBAAoB,MAAM,EAAE,OAAO,CAAC,GAAG,SAAS;AAC1D,cAAM,aAAa,OAAO,yBAAyB,QAAQ,IAAI;AAC/D,YAAI,YAAY;AACZ,iBAAO,eAAe,GAAG,MAAM,UAAU;AACzC,gBAAM,QAAQ,OAAO,IAAI;AACzB,YAAE,IAAI,IAAI,OAAO,UAAU,aAAa,MAAM,IAAI,KAAK,mCAAmC,OAAO,IAAI;AAAA,QACzG;AACA,eAAO;AAAA,MACX,GAAG,OAAO,OAAO,OAAO,eAAe,MAAM,CAAC,CAAC;AAAA,IACnD,OACK;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,gBAAgB,OAAO;AACnB,WAAO,OAAO,UAAU,YAAY,UAAU;AAAA,EAClD;AAAA,EACA,SAAS,OAAO;AACZ,WAAO,OAAO,UAAU,YAAY,CAAC,MAAM,QAAQ,KAAK,KAAK,UAAU;AAAA,EAC3E;AAAA,EACA,YAAY,QAAQ;AAChB,QAAI,MAAM,QAAQ,MAAM,GAAG;AACvB,aAAO,CAAC,GAAG,MAAM;AAAA,IACrB,OACK;AACD,aAAO,EAAE,GAAG,OAAO;AAAA,IACvB;AAAA,EACJ;AAAA,EACA,UAAU,MAAM,eAAe,CAAC,GAAG;AAC/B,WAAO,6BAAM,IAAI,CAAC,QAAS,KAAK,QAAQ,QAAQ,GAAG,IAAI,KAAK,eAAe,GAAG,IAAI;AAClF,QAAI,KAAK,SAAS,sBAAsB,MAAM;AAC1C,UAAI,KAAK,WAAW,KAAK,CAAC,MAAM,QAAQ,KAAK,CAAC,CAAC,KAAK,KAAK,QAAQ,SAAS,KAAK,CAAC,CAAC,MAAM,QAAQ,EAAE,KAAK,CAAC,aAAa,OAAO;AACvH,uBAAe,OAAO,KAAK,CAAC,MAAM,YAAY,KAAK,CAAC,KAAK,OAAO,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,aAAa,IAAI,EAAE,GAAG,KAAK,CAAC,GAAG,GAAG,aAAa;AAAA,MACpI,OACK;AACD,uBAAe,EAAE,GAAG,cAAc,GAAG,KAAK;AAAA,MAC9C;AAAA,IACJ,OACK;AACD,qBAAe;AAAA,QACX,GAAG;AAAA,QACH,CAAC,KAAK,SAAS,kBAAkB,GAAG;AAAA,MACxC;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY,OAAO;AACf,UAAM,SAAS,IAAI,MAAM,YAAY;AACrC,WAAO,oBAAoB,KAAK,EAAE,QAAQ,CAAC,QAAQ;AAC/C,aAAO,GAAG,IAAI,MAAM,GAAG;AAAA,IAC3B,CAAC;AACD,WAAO;AAAA,EACX;AAAA,EACA,eAAe,OAAO;AAClB,WAAO;AAAA,MACH,aAAa;AAAA,MACb,MAAM,MAAM,QAAQ;AAAA,MACpB,SAAS,MAAM;AAAA,MACf,OAAO,KAAK,QAAQ,cAAc,KAAK;AAAA,IAC3C;AAAA,EACJ;AAAA,EACA,iBAAiB,QAAQ,YAAY,cAAc;AAC/C,WAAO;AAAA,MACH,GAAG;AAAA,MACH,CAAC,KAAK,SAAS,YAAY,GAAG,KAAK,QAAQ,QAAQ,YAAY,cAAc,KAAK,iBAAiB,KAAK,SAAS,8BAA8B,KAAK,SAAS,MAAM,KAAK,SAAS,WAAW;AAAA,IAChM;AAAA,EACJ;AAAA,EACA,wBAAwB,YAAY;AAhRxC,QAAAA,KAAA;AAiRQ,QAAI,cAAc,MAAM;AACpB,aAAO;AAAA,IACX;AACA,QAAI,WAAW,KAAK,SAAS;AAC7B,UAAM,oBAAoB,CAAC;AAC3B,QAAI,SAAS,SAAS,oDAAoD,GAAG;AACzE,iBAAW,SAAS,QAAQ,sDAAsD,gBAAgB;AAAA,IACtG,OACK;AACD,UAAI,KAAK,SAAS,sBAAsB,OAAO;AAC3C,0BAAkB,MAAM,MAAIA,MAAA,yCAAY,SAAZ,gBAAAA,IAAkB,qBAAoB;AAClE,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,eAAe,GAAG,CAAC;AACpF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,cAAc,CAAC;AAChF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,eAAe,CAAC;AACjF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,iBAAiB,CAAC;AACnF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,iBAAiB,CAAC;AACnF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,sBAAsB,CAAC;AAAA,MAC5F,OACK;AACD,0BAAkB,MAAM,MAAI,8CAAY,SAAZ,mBAAkB,kBAAiB;AAC/D,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,YAAY,GAAG,CAAC;AACjF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,WAAW,CAAC;AAC7E,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,YAAY,CAAC;AAC9E,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,cAAc,CAAC;AAChF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,cAAc,CAAC;AAChF,0BAAkB,IAAI,IAAI,sBAAqB,8CAAY,SAAZ,mBAAkB,mBAAmB,CAAC;AAAA,MACzF;AAAA,IACJ;AACA,UAAM,yBAAyB,KAAK,SAAS,sBAAsB,QAAQ,yCAAY,OAAO,IAAI,OAAK,8CAAY,SAAZ,mBAAkB,eAAY,8CAAY,SAAZ,mBAAkB,uBAAsB,GAAK;AAClL,sBAAkB,WAAW,IAAI,iEAAwB;AACzD,sBAAkB,YAAY,IAAI,iEAAwB,cAAc,QAAQ,KAAK,KAAK,QAAQ,KAAK;AACvG,sBAAkB,cAAc,IAAI,yCAAY;AAChD,sBAAkB,kBAAkB,MAAI,8CAAY,SAAZ,mBAAkB,qBAAoB;AAC9E,sBAAkB,kBAAkB,MAAI,8CAAY,SAAZ,mBAAkB,qBAAoB;AAC9E,sBAAkB,cAAc,MAAI,8CAAY,SAAZ,mBAAkB,iBAAgB;AACtE,QAAI,qBAAoB,UAAK,SAAS,gBAAd,mBAA2B,KAAK,KAAK,SAAS;AACtE,wBAAoB,qBAAqB,SAAQ,yCAAY,SAAQ,OAAO,oBAAoB,KAAK,SAAS,kCAAkC;AAChJ,sBAAkB,MAAM,KAAI,yCAAY,SAAQ,QAAQ,qBAAqB,QAAQ,qBAAqB,OAAM,yCAAY,QAAa;AACzI,sBAAkB,yBAAyB,IACvC,kBAAkB,MAAM,EAAE,SAAS,IAAI,KAAK,SAAS,iCAAiC,kBAAkB,MAAM,IAAI;AACtH,sBAAkB,yBAAyB,IACvC,kBAAkB,MAAM,EAAE,SAAS,IAAI,kBAAkB,MAAM,IAAI,KAAK,SAAS,iCAAiC;AACtH,UAAI,UAAK,SAAS,cAAd,mBAAyB,oBAAmB,MAAM;AAClD,iBAAK,SAAS,cAAd,mBAAyB,gBAAgB,YAAY;AAAA,IACzD;AACA,WAAO,eAAe,KAAK,UAAU,UAAU,iBAAiB;AAAA,EACpE;AACJ;;;AC7TO,IAAM,SAAN,cAAqB,WAAW;AAAA,EACnC,YAAY,UAAU,QAAQ;AAC1B,UAAM,YAAY,OAAO,WAAW,eAAe,OAAO,aAAa;AACvE,UAAM,uBAAuB,YAAY,OAAO,WAAW,UAAa,OAAO,QAAQ,UAAa,OAAO,IAAI,SAAS,SAAS,OAAO,IAAI;AAC5I,UAAM,WAAW,YAAY,iCAAiC,KAAK,UAAU,SAAS,IAAI;AAC1F,eAAW,YAAY,CAAC;AACxB,aAAS,kBAAkB,SAAS,mBAAmB,aAAa,CAAC,uBAAuB,QAAQ,SAAS;AAC7G,UAAM,UAAU,QAAQ,WAAW,IAAI,CAAC;AAAA,EAC5C;AAAA,EACA,IAAI,YAAY,iBAAiB,MAAM;AACnC,WAAO,MAAM,IAAI,YAAY,cAAc,GAAG,IAAI;AAAA,EACtD;AAAA,EACA,SAAS,MAAM;AACX,WAAO,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI;AAAA,EACxC;AAAA,EACA,SAAS,MAAM;AACX,WAAO,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI;AAAA,EACxC;AAAA,EACA,SAAS,MAAM;AACX,WAAO,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI;AAAA,EACxC;AAAA,EACA,QAAQ,MAAM;AACV,WAAO,MAAM,IAAI,GAAG,QAAQ,GAAG,IAAI;AAAA,EACvC;AAAA,EACA,QAAQ,MAAM;AACV,WAAO,MAAM,IAAI,GAAG,QAAQ,GAAG,IAAI;AAAA,EACvC;AAAA,EACA,SAAS,MAAM;AACX,WAAO,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI;AAAA,EACxC;AAAA,EACA,SAAS,MAAM;AACX,WAAO,MAAM,IAAI,GAAG,SAAS,GAAG,IAAI;AAAA,EACxC;AAAA,EACA,aAAa,UAAU,QAAQ;AAC3B,WAAO,MAAM,aAAa,UAAU,MAAM;AAAA,EAC9C;AACJ;;;A7J44EA,IAAAC,iBAAkC;AAwClC,IAAAA,iBAAkC;AAqBlC,IAAAC,iBAAkC;AAgFlC,uBAAsB;AA9jFtB,IAAI,oBAAoB,MAAM;AAC5B,MAAI,CAAC,WAAW,OAAQ,YAAW,SAAS,eAAAC;AAC9C;AAqBA,IAAI,wBAAwB,CAAC,WAAW;AAAA,EACtC,WAAW,IAAI,QAAQ;AAAA,EACvB,cAAc,IAAI,QAAQ;AAAA,EAC1B,wBAAwB,IAAI,QAAQ;AAAA,EACpC,WAAW,IAAI,cAAc,CAAC;AAAA,EAC9B,cAAc,IAAI,gBAAgB,CAAC,CAAC;AAAA,EACpC,qBAAqB,IAAI,QAAQ;AAAA,EACjC,yBAAyB,IAAI,QAAQ;AAAA,EACrC,UAAU,IAAI,gBAAgB,CAAC,CAAC;AAAA,EAChC,eAAe,IAAI,QAAQ;AAAA,EAC3B,QAAQ,IAAI,gBAAgB,SAAS;AAAA,EACrC,mBAAmB,IAAI,gBAAgB,EAAE;AAAA,EACzC,UAAU,IAAI,gBAAgB,MAAM,UAAU,kBAAkB,SAAS,CAAC;AAAA,EAC1E,gBAAgB,IAAI,gBAAgB,KAAK;AAAA,EACzC,iBAAiB,IAAI,gBAAgB,KAAK;AAAA,EAC1C,sBAAsB,IAAI,gBAAgB,KAAK;AAAA,EAC/C,WAAW,IAAI,gBAAgB,KAAK;AAAA,EACpC,WAAW,IAAI,gBAAgB,SAAS;AAAA,EACxC,MAAM,IAAI,gBAAgB,OAAO;AAAA,EACjC,OAAO,IAAI,gBAAgB,YAAY;AAAA,EACvC,WAAW,IAAI,gBAAgB,EAAE;AAAA,EACjC,cAAc,IAAI,gBAAgB,EAAE;AAAA,EACpC,aAAa,IAAI,gBAAgB,CAAC,CAAC;AAAA,EACnC,UAAU,IAAI,gBAAgB,EAAE;AAAA,EAChC,aAAa,IAAI,QAAQ;AAC3B;AAQA,SAASC,QAAO,GAAG;AACjB,MAAI,CAAC,OAAO,cAAc,CAAC,KAAK,IAAI;AAClC,UAAM,IAAI,MAAM,kCAAkC,CAAC,EAAE;AACzD;AACA,SAASC,SAAQ,GAAG;AAClB,SAAO,aAAa,cAAc,KAAK,QAAQ,OAAO,MAAM,YAAY,EAAE,YAAY,SAAS;AACjG;AACA,SAAS,MAAM,MAAM,SAAS;AAC5B,MAAI,CAACA,SAAQ,CAAC;AACZ,UAAM,IAAI,MAAM,qBAAqB;AACvC,MAAI,QAAQ,SAAS,KAAK,CAAC,QAAQ,SAAS,EAAE,MAAM;AAClD,UAAM,IAAI,MAAM,iCAAiC,OAAO,mBAAmB,EAAE,MAAM,EAAE;AACzF;AACA,SAAS,KAAK,GAAG;AACf,MAAI,OAAO,MAAM,cAAc,OAAO,EAAE,WAAW;AACjD,UAAM,IAAI,MAAM,iDAAiD;AACnE,EAAAD,QAAO,EAAE,SAAS;AAClB,EAAAA,QAAO,EAAE,QAAQ;AACnB;AACA,SAAS,OAAO,UAAU,gBAAgB,MAAM;AAC9C,MAAI,SAAS;AACX,UAAM,IAAI,MAAM,kCAAkC;AACpD,MAAI,iBAAiB,SAAS;AAC5B,UAAM,IAAI,MAAM,uCAAuC;AAC3D;AACA,SAAS,OAAO,KAAK,UAAU;AAC7B,QAAM,GAAG;AACT,QAAME,OAAM,SAAS;AACrB,MAAI,IAAI,SAASA,MAAK;AACpB,UAAM,IAAI,MAAM,yDAAyDA,IAAG,EAAE;AAAA,EAChF;AACF;AAGA,IAAIC,cAAa,CAAC,QAAQ,IAAI,SAAS,IAAI,QAAQ,IAAI,YAAY,IAAI,UAAU;AACjF,IAAIC,QAAO,CAAC,MAAM,UAAU,QAAQ,KAAK,QAAQ,SAAS;AAC1D,IAAIC,QAAO,IAAI,WAAW,IAAI,YAAY,CAAC,SAAS,CAAC,EAAE,MAAM,EAAE,CAAC,MAAM;AACtE,SAASC,aAAY,KAAK;AACxB,MAAI,OAAO,QAAQ;AACjB,UAAM,IAAI,MAAM,oCAAoC,OAAO,GAAG,EAAE;AAClE,SAAO,IAAI,WAAW,IAAI,YAAY,EAAE,OAAO,GAAG,CAAC;AACrD;AACA,SAASC,SAAQ,MAAM;AACrB,MAAI,OAAO,SAAS;AAClB,WAAOD,aAAY,IAAI;AACzB,QAAM,IAAI;AACV,SAAO;AACT;AACA,IAAIE,QAAO,MAAM;AAAA;AAAA,EAEf,QAAQ;AACN,WAAO,KAAK,WAAW;AAAA,EACzB;AACF;AACA,IAAI,QAAQ,CAAC,EAAE;AACf,SAAS,gBAAgB,UAAU;AACjC,QAAM,QAAQ,CAAC,QAAQ,SAAS,EAAE,OAAOD,SAAQ,GAAG,CAAC,EAAE,OAAO;AAC9D,QAAM,MAAM,SAAS;AACrB,QAAM,YAAY,IAAI;AACtB,QAAM,WAAW,IAAI;AACrB,QAAM,SAAS,MAAM,SAAS;AAC9B,SAAO;AACT;AAGA,IAAI,OAAO,cAAcC,MAAK;AAAA,EAC5B,YAAY,OAAO,MAAM;AACvB,UAAM;AACN,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,KAAK;AACV,UAAM,MAAMD,SAAQ,IAAI;AACxB,SAAK,QAAQ,MAAM,OAAO;AAC1B,QAAI,OAAO,KAAK,MAAM,WAAW;AAC/B,YAAM,IAAI,MAAM,qDAAqD;AACvE,SAAK,WAAW,KAAK,MAAM;AAC3B,SAAK,YAAY,KAAK,MAAM;AAC5B,UAAM,WAAW,KAAK;AACtB,UAAM,MAAM,IAAI,WAAW,QAAQ;AACnC,QAAI,IAAI,IAAI,SAAS,WAAW,MAAM,OAAO,EAAE,OAAO,GAAG,EAAE,OAAO,IAAI,GAAG;AACzE,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ;AAC9B,UAAI,CAAC,KAAK;AACZ,SAAK,MAAM,OAAO,GAAG;AACrB,SAAK,QAAQ,MAAM,OAAO;AAC1B,aAAS,IAAI,GAAG,IAAI,IAAI,QAAQ;AAC9B,UAAI,CAAC,KAAK,KAAK;AACjB,SAAK,MAAM,OAAO,GAAG;AACrB,QAAI,KAAK,CAAC;AAAA,EACZ;AAAA,EACA,OAAO,KAAK;AACV,WAAO,IAAI;AACX,SAAK,MAAM,OAAO,GAAG;AACrB,WAAO;AAAA,EACT;AAAA,EACA,WAAW,KAAK;AACd,WAAO,IAAI;AACX,UAAM,KAAK,KAAK,SAAS;AACzB,SAAK,WAAW;AAChB,SAAK,MAAM,WAAW,GAAG;AACzB,SAAK,MAAM,OAAO,GAAG;AACrB,SAAK,MAAM,WAAW,GAAG;AACzB,SAAK,QAAQ;AAAA,EACf;AAAA,EACA,SAAS;AACP,UAAM,MAAM,IAAI,WAAW,KAAK,MAAM,SAAS;AAC/C,SAAK,WAAW,GAAG;AACnB,WAAO;AAAA,EACT;AAAA,EACA,WAAW,IAAI;AACb,WAAO,KAAK,OAAO,OAAO,OAAO,eAAe,IAAI,GAAG,CAAC,CAAC;AACzD,UAAM,EAAE,OAAO,OAAO,UAAU,WAAW,UAAU,UAAU,IAAI;AACnE,SAAK;AACL,OAAG,WAAW;AACd,OAAG,YAAY;AACf,OAAG,WAAW;AACd,OAAG,YAAY;AACf,OAAG,QAAQ,MAAM,WAAW,GAAG,KAAK;AACpC,OAAG,QAAQ,MAAM,WAAW,GAAG,KAAK;AACpC,WAAO;AAAA,EACT;AAAA,EACA,UAAU;AACR,SAAK,YAAY;AACjB,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,QAAQ;AAAA,EACrB;AACF;AACA,IAAI,OAAO,CAAC,OAAO,KAAK,YAAY,IAAI,KAAK,OAAO,GAAG,EAAE,OAAO,OAAO,EAAE,OAAO;AAChF,KAAK,SAAS,CAAC,OAAO,QAAQ,IAAI,KAAK,OAAO,GAAG;AAGjD,SAAS,QAAQ,OAAO,KAAK,MAAM;AACjC,OAAK,KAAK;AACV,MAAI,SAAS;AACX,WAAO,IAAI,WAAW,MAAM,SAAS;AACvC,SAAO,KAAK,OAAOA,SAAQ,IAAI,GAAGA,SAAQ,GAAG,CAAC;AAChD;AACA,IAAI,eAA+B,IAAI,WAAW,CAAC,CAAC,CAAC;AACrD,IAAI,eAA+B,IAAI,WAAW;AAClD,SAASE,QAAO,OAAO,KAAK,MAAM,SAAS,IAAI;AAC7C,OAAK,KAAK;AACV,EAAAT,QAAO,MAAM;AACb,MAAI,SAAS,MAAM,MAAM;AACvB,UAAM,IAAI,MAAM,iCAAiC;AACnD,QAAM,SAAS,KAAK,KAAK,SAAS,MAAM,SAAS;AACjD,MAAI,SAAS;AACX,WAAO;AACT,QAAM,MAAM,IAAI,WAAW,SAAS,MAAM,SAAS;AACnD,QAAM,QAAQ,KAAK,OAAO,OAAO,GAAG;AACpC,QAAM,UAAU,MAAM,WAAW;AACjC,QAAM,IAAI,IAAI,WAAW,MAAM,SAAS;AACxC,WAAS,UAAU,GAAG,UAAU,QAAQ,WAAW;AACjD,iBAAa,CAAC,IAAI,UAAU;AAC5B,YAAQ,OAAO,YAAY,IAAI,eAAe,CAAC,EAAE,OAAO,IAAI,EAAE,OAAO,YAAY,EAAE,WAAW,CAAC;AAC/F,QAAI,IAAI,GAAG,MAAM,YAAY,OAAO;AACpC,UAAM,WAAW,OAAO;AAAA,EAC1B;AACA,QAAM,QAAQ;AACd,UAAQ,QAAQ;AAChB,IAAE,KAAK,CAAC;AACR,eAAa,KAAK,CAAC;AACnB,SAAO,IAAI,MAAM,GAAG,MAAM;AAC5B;AACA,IAAI,OAAO,CAAC,OAAO,KAAK,MAAM,MAAM,WAAWS,QAAO,OAAO,QAAQ,OAAO,KAAK,IAAI,GAAG,MAAM,MAAM;AAGpG,SAASC,cAAa,MAAM,YAAY,OAAOC,QAAO;AACpD,MAAI,OAAO,KAAK,iBAAiB;AAC/B,WAAO,KAAK,aAAa,YAAY,OAAOA,MAAK;AACnD,QAAMC,QAAO,OAAO,EAAE;AACtB,QAAM,WAAW,OAAO,UAAU;AAClC,QAAM,KAAK,OAAO,SAASA,QAAO,QAAQ;AAC1C,QAAM,KAAK,OAAO,QAAQ,QAAQ;AAClC,QAAM,IAAID,SAAQ,IAAI;AACtB,QAAM,IAAIA,SAAQ,IAAI;AACtB,OAAK,UAAU,aAAa,GAAG,IAAIA,MAAK;AACxC,OAAK,UAAU,aAAa,GAAG,IAAIA,MAAK;AAC1C;AACA,IAAIE,OAAM,CAAC,GAAG,GAAG,MAAM,IAAI,IAAI,CAAC,IAAI;AACpC,IAAIC,OAAM,CAAC,GAAG,GAAG,MAAM,IAAI,IAAI,IAAI,IAAI,IAAI;AAC3C,IAAIC,UAAS,cAAcP,MAAK;AAAA,EAC9B,YAAY,UAAU,WAAW,WAAWG,QAAO;AACjD,UAAM;AACN,SAAK,WAAW;AAChB,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,OAAOA;AACZ,SAAK,WAAW;AAChB,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,YAAY;AACjB,SAAK,SAAS,IAAI,WAAW,QAAQ;AACrC,SAAK,OAAOR,YAAW,KAAK,MAAM;AAAA,EACpC;AAAA,EACA,OAAO,MAAM;AACX,WAAO,IAAI;AACX,UAAM,EAAE,MAAM,QAAAa,SAAQ,SAAS,IAAI;AACnC,WAAOT,SAAQ,IAAI;AACnB,UAAM,MAAM,KAAK;AACjB,aAAS,MAAM,GAAG,MAAM,OAAO;AAC7B,YAAMU,QAAO,KAAK,IAAI,WAAW,KAAK,KAAK,MAAM,GAAG;AACpD,UAAIA,UAAS,UAAU;AACrB,cAAM,WAAWd,YAAW,IAAI;AAChC,eAAO,YAAY,MAAM,KAAK,OAAO;AACnC,eAAK,QAAQ,UAAU,GAAG;AAC5B;AAAA,MACF;AACA,MAAAa,QAAO,IAAI,KAAK,SAAS,KAAK,MAAMC,KAAI,GAAG,KAAK,GAAG;AACnD,WAAK,OAAOA;AACZ,aAAOA;AACP,UAAI,KAAK,QAAQ,UAAU;AACzB,aAAK,QAAQ,MAAM,CAAC;AACpB,aAAK,MAAM;AAAA,MACb;AAAA,IACF;AACA,SAAK,UAAU,KAAK;AACpB,SAAK,WAAW;AAChB,WAAO;AAAA,EACT;AAAA,EACA,WAAW,KAAK;AACd,WAAO,IAAI;AACX,WAAO,KAAK,IAAI;AAChB,SAAK,WAAW;AAChB,UAAM,EAAE,QAAAD,SAAQ,MAAM,UAAU,MAAML,OAAM,IAAI;AAChD,QAAI,EAAE,IAAI,IAAI;AACd,IAAAK,QAAO,KAAK,IAAI;AAChB,SAAK,OAAO,SAAS,GAAG,EAAE,KAAK,CAAC;AAChC,QAAI,KAAK,YAAY,WAAW,KAAK;AACnC,WAAK,QAAQ,MAAM,CAAC;AACpB,YAAM;AAAA,IACR;AACA,aAAS,IAAI,KAAK,IAAI,UAAU;AAC9B,MAAAA,QAAO,CAAC,IAAI;AACd,IAAAN,cAAa,MAAM,WAAW,GAAG,OAAO,KAAK,SAAS,CAAC,GAAGC,MAAK;AAC/D,SAAK,QAAQ,MAAM,CAAC;AACpB,UAAM,QAAQR,YAAW,GAAG;AAC5B,UAAM,MAAM,KAAK;AACjB,QAAI,MAAM;AACR,YAAM,IAAI,MAAM,6CAA6C;AAC/D,UAAM,SAAS,MAAM;AACrB,UAAM,QAAQ,KAAK,IAAI;AACvB,QAAI,SAAS,MAAM;AACjB,YAAM,IAAI,MAAM,oCAAoC;AACtD,aAAS,IAAI,GAAG,IAAI,QAAQ;AAC1B,YAAM,UAAU,IAAI,GAAG,MAAM,CAAC,GAAGQ,MAAK;AAAA,EAC1C;AAAA,EACA,SAAS;AACP,UAAM,EAAE,QAAAK,SAAQ,UAAU,IAAI;AAC9B,SAAK,WAAWA,OAAM;AACtB,UAAM,MAAMA,QAAO,MAAM,GAAG,SAAS;AACrC,SAAK,QAAQ;AACb,WAAO;AAAA,EACT;AAAA,EACA,WAAW,IAAI;AACb,WAAO,KAAK,IAAI,KAAK,YAAY;AACjC,OAAG,IAAI,GAAG,KAAK,IAAI,CAAC;AACpB,UAAM,EAAE,UAAU,QAAAA,SAAQ,QAAQ,UAAU,WAAW,IAAI,IAAI;AAC/D,OAAG,SAAS;AACZ,OAAG,MAAM;AACT,OAAG,WAAW;AACd,OAAG,YAAY;AACf,QAAI,SAAS;AACX,SAAG,OAAO,IAAIA,OAAM;AACtB,WAAO;AAAA,EACT;AACF;AAGA,IAAIE,YAA2B,IAAI,YAAY;AAAA,EAC7C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAIC,aAA4B,IAAI,YAAY;AAAA,EAC9C;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAIC,YAA2B,IAAI,YAAY,EAAE;AACjD,IAAIC,UAAS,cAAcN,QAAO;AAAA,EAChC,cAAc;AACZ,UAAM,IAAI,IAAI,GAAG,KAAK;AACtB,SAAK,IAAII,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AACxB,SAAK,IAAIA,WAAU,CAAC,IAAI;AAAA,EAC1B;AAAA,EACA,MAAM;AACJ,UAAM,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI;AACnC,WAAO,CAAC,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,EAChC;AAAA;AAAA,EAEA,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG;AAC1B,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AACb,SAAK,IAAI,IAAI;AAAA,EACf;AAAA,EACA,QAAQ,MAAM,QAAQ;AACpB,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK,UAAU;AACrC,MAAAC,UAAS,CAAC,IAAI,KAAK,UAAU,QAAQ,KAAK;AAC5C,aAAS,IAAI,IAAI,IAAI,IAAI,KAAK;AAC5B,YAAM,MAAMA,UAAS,IAAI,EAAE;AAC3B,YAAM,KAAKA,UAAS,IAAI,CAAC;AACzB,YAAM,KAAKhB,MAAK,KAAK,CAAC,IAAIA,MAAK,KAAK,EAAE,IAAI,QAAQ;AAClD,YAAM,KAAKA,MAAK,IAAI,EAAE,IAAIA,MAAK,IAAI,EAAE,IAAI,OAAO;AAChD,MAAAgB,UAAS,CAAC,IAAI,KAAKA,UAAS,IAAI,CAAC,IAAI,KAAKA,UAAS,IAAI,EAAE,IAAI;AAAA,IAC/D;AACA,QAAI,EAAE,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,EAAE,IAAI;AACjC,aAAS,IAAI,GAAG,IAAI,IAAI,KAAK;AAC3B,YAAM,SAAShB,MAAK,GAAG,CAAC,IAAIA,MAAK,GAAG,EAAE,IAAIA,MAAK,GAAG,EAAE;AACpD,YAAM,KAAK,IAAI,SAASS,KAAI,GAAG,GAAG,CAAC,IAAIK,UAAS,CAAC,IAAIE,UAAS,CAAC,IAAI;AACnE,YAAM,SAAShB,MAAK,GAAG,CAAC,IAAIA,MAAK,GAAG,EAAE,IAAIA,MAAK,GAAG,EAAE;AACpD,YAAM,KAAK,SAASU,KAAI,GAAG,GAAG,CAAC,IAAI;AACnC,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,IAAI,KAAK;AACb,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,UAAI,KAAK,KAAK;AAAA,IAChB;AACA,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,QAAI,IAAI,KAAK,IAAI;AACjB,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAAA,EACjC;AAAA,EACA,aAAa;AACX,IAAAM,UAAS,KAAK,CAAC;AAAA,EACjB;AAAA,EACA,UAAU;AACR,SAAK,IAAI,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,GAAG,CAAC;AAC/B,SAAK,OAAO,KAAK,CAAC;AAAA,EACpB;AACF;AACA,IAAIE,UAAyB,gBAAgB,MAAM,IAAID,QAAO,CAAC;AAG/D,IAAI,QAAQ,CAAC,UAAU,eAAAE,OAAQ,KAAK,KAAK,EAAE,SAAS,KAAK;AACzD,IAAI,aAAa,CAAC,gBAAgB,MAAM,OAAO,MAAM,iBAAiB,CAAC,MAAM;AAC3E,QAAM,gBAAgB,MAAM;AAC5B,QAAM,YAAY;AAAA,IAChB,cAAc,MAAM,MAAM,OAAO,aAAa,aAAa,CAAC;AAAA,IAC5D,uBAAuB,CAAC,cAAc,0BAA0B;AAC9D,UAAI;AACF,cAAM,eAAe,OAAO,gBAAgB,eAAe,YAAY;AACvE,cAAM,UAAU;AAAA,UACdD;AAAA,UACA;AAAA,UACA,eAAAC,OAAQ,KAAK,uBAAuB,OAAO;AAAA,UAC3C;AAAA,UACA;AAAA,QACF;AACA,eAAO,GAAG,MAAM,OAAO,CAAC;AAAA,MAC1B,SAAS,OAAO;AACd,eAAO,IAAI,KAAK;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACA,QAAM,aAAa;AAAA,IACjB,cAAc,MAAM,MAAM,QAAQ,aAAa,aAAa,CAAC;AAAA,IAC7D,MAAM,CAAC,eAAe;AACpB,UAAI;AACF,eAAO,GAAG,MAAM,QAAQ,KAAK,YAAY,aAAa,CAAC,CAAC;AAAA,MAC1D,SAAS,OAAO;AACd,eAAO,IAAI,KAAK;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA,QAAQ;AAAA,IACR,SAAS;AAAA,EACX;AACF;AAMA,IAAI,sBAAsB,CAACP,YAAW;AACpC,QAAM,cAAc,IAAI,YAAYA,QAAO,MAAM;AACjD,QAAM,OAAO,IAAI,WAAW,WAAW;AACvC,WAAS,IAAI,GAAG,IAAIA,QAAO,QAAQ,EAAE,GAAG;AACtC,SAAK,CAAC,IAAIA,QAAO,CAAC;AAAA,EACpB;AACA,SAAO;AACT;AACA,IAAI,qBAAqB,CAACA,YAAW,IAAI,WAAW,oBAAoBA,OAAM,CAAC;AAC/E,IAAI,UAAU,CAAC,UAAU;AACvB,MAAI;AACF,WAAO,GAAI,eAAAQ,QAAM,WAAW,mBAAmB,KAAK,GAAG,QAAQ,EAAE,CAAC,EAAE;AAAA,MAClE,CAAC,QAAQ,eAAAC,OAAQ,KAAK,KAAK,KAAK;AAAA,IAClC;AAAA,EACF,SAAS,OAAO;AACd,WAAO,IAAK,KAAK;AAAA,EACnB;AACF;AAoBA,IAAI,UAAU,OAAO;AAAA,EACnB,SAAS,OAAO;AAAA,EAChB,OAAO,OAAO;AAAA,EACd,cAAc,OAAQ;AACxB,CAAC;AACD,IAAI,QAAQ,OAAO;AAAA,EACjB,WAAW,OAAO;AAAA,EAClB,WAAW,OAAO;AAAA,EAClB,OAAO,MAAM,CAAC,QAAQ,YAAY,GAAG,QAAQ,WAAW,CAAC,CAAC;AAC5D,CAAC;AACD,IAAI,eAAe,OAAO;AAAA,EACxB,gBAAgB,OAAO;AAAA,EACvB,OAAO;AACT,CAAC;AACD,IAAI,eAAe,OAAO;AAAA,EACxB,iBAAiB,OAAO;AAAA,EACxB,OAAO;AACT,CAAC;AACD,IAAI,8BAA8B,OAAO;AAAA,EACvC,WAAW,OAAO;AAAA,EAClB,iBAAiB,SAAS,OAAO,CAAC;AAAA,EAClC,kBAAkB,SAAS,MAAM,OAAO,CAAC,CAAC;AAC5C,CAAC;AACD,IAAI,+BAA+B,OAAO;AAAA,EACxC,WAAW,OAAO;AAAA,EAClB,QAAQ,MAAM,MAAM,CAAC,cAAc,YAAY,CAAC,CAAC;AACnD,CAAC;AACD,IAAI,UAAU,OAAO,EAAE,iBAAiB,OAAO,GAAG,OAAO,OAAO,EAAE,CAAC;AACnE,IAAI,6BAA6B;AAAA,EAC/B,SAAS;AAAA,EACT,SAAS;AACX;AACA,IAAI,yBAAyB,MAAM;AAAA,EACjC,QAAQ,2BAA2B,OAAO;AAAA,EAC1C,QAAQ,2BAA2B,OAAO;AAC5C,CAAC;AACD,IAAI,kBAAkB,OAAO;AAAA,EAC3B,SAAS;AAAA,EACT,YAAY,OAAO;AAAA,EACnB,UAAU,OAAO;AAAA,EACjB,YAAY,OAAO;AACrB,CAAC;AACD,IAAI,iBAAiB,OAAO;AAAA,EAC1B,YAAY,MAAM,CAAC,QAAQ,SAAS,GAAG,QAAQ,SAAS,CAAC,CAAC;AAAA,EAC1D,UAAUC,MAAK,OAAQ,GAAG,SAAS,GAAG,gCAAgC,CAAC;AACzE,CAAC;AACD,IAAI,sBAAsB,OAAO;AAAA,EAC/B,WAAW,SAAS,OAAO,CAAC;AAAA,EAC5B,kBAAkB;AACpB,CAAC;AACD,IAAI,8BAA8BA;AAAA,EAChC,OAAO;AAAA,IACL,UAAU,MAAM,OAAO;AAAA,IACvB,WAAW,SAAS,OAAO,CAAC;AAAA,IAC5B,QAAQ,SAAS,MAAM,YAAY,CAAC;AAAA,EACtC,CAAC;AAAA,EACD,MAAM,CAAC,SAAS;AAlmBlB,QAAAC;AAmmBI,QAAI,KAAK,cAAa,6BAAM,SAAQ;AAClC,aAAO,CAAC,EAAE,KAAK,eAAaA,MAAA,6BAAM,WAAN,gBAAAA,IAAc;AAAA,IAC5C;AACA,WAAO;AAAA,EACT,GAAG,6BAA6B;AAClC;AACA,IAAI,yBAAyB,OAAO;AAAA,EAClC,kBAAkB,SAAS,QAAQ,CAAC;AAAA,EACpC,iCAAiC,SAAS,cAAc;AAAA,EACxD,+BAA+B,SAAS,cAAc;AACxD,CAAC;AACD,IAAI,iCAAiC,OAAO;AAAA,EAC1C,MAAM,SAAS,eAAe;AAAA,EAC9B,gBAAgB,SAAS,MAAM,OAAO,CAAC,CAAC;AAAA,EACxC,cAAc,SAAS,MAAM,OAAO,CAAC,CAAC;AACxC,CAAC;AACD,IAAI,mBAAmB,OAAO;AAAA,EAC5B,UAAU,QAAQ;AAAA,EAClB,aAAa,QAAQ;AACvB,CAAC;AACD,IAAI,2BAA2BD;AAAA,EAC7B,OAAO;AAAA,IACL,SAAS;AAAA,IACT,WAAW,SAAS,OAAO,CAAC;AAAA,IAC5B,OAAO,SAAS,KAAK;AAAA,EACvB,CAAC;AAAA,EACD,MAAM,CAAC,SAAS;AACd,QAAI,KAAK,aAAa,KAAK,OAAO;AAChC,aAAO,CAAC,EAAE,KAAK,aAAa,KAAK;AAAA,IACnC;AACA,WAAO;AAAA,EACT,GAAG,4BAA4B;AACjC;AACA,IAAI,iCAAiC,OAAO;AAAA,EAC1C,eAAe,QAAQ,qBAAqB;AAAA,EAC5C,iBAAiB,SAAS,mBAAmB;AAAA,EAC7C,oBAAoB,SAAS,sBAAsB;AACrD,CAAC;AACD,IAAI,4BAA4B,OAAO;AAAA,EACrC,eAAe,QAAQ,YAAY;AAAA,EACnC,iBAAiB,OAAO;AAC1B,CAAC;AACD,IAAI,uCAAuC,OAAO;AAAA,EAChD,eAAe,QAAQ,uBAAuB;AAChD,CAAC;AACD,IAAI,oCAAoC,OAAO;AAAA,EAC7C,eAAe,QAAQ,oBAAoB;AAAA,EAC3C,WAAW,OAAO;AACpB,CAAC;AACD,IAAI,uBAAuB,MAAM;AAAA,EAC/B;AAAA,EACA;AACF,CAAC;AACD,IAAI,kBAAkB,MAAM;AAAA,EAC1B;AAAA,EACA;AACF,CAAC;AACD,IAAI,+BAA+B,OAAO;AAAA,EACxC,eAAe,QAAQ,mBAAmB;AAAA,EAC1C,MAAM;AAAA,EACN,OAAO,SAAS,gBAAgB;AAAA,EAChC,kBAAkB,SAAS,2BAA2B;AAAA,EACtD,iBAAiB,SAAS,mBAAmB;AAAA,EAC7C,iBAAiB,SAAS,mBAAmB;AAAA,EAC7C,oBAAoB,SAAS,sBAAsB;AAAA,EACnD,oBAAoB,SAAS,sBAAsB;AACrD,CAAC;AACD,IAAI,qBAAqB,MAAM;AAAA,EAC7B;AAAA,EACA;AACF,CAAC;AACD,IAAI,sBAAsB,OAAO;AAAA,EAC/B,qBAAqB,OAAO;AAAA,EAC5B,SAAS,OAAQ;AAAA,EACjB,OAAO,SAAS,MAAM,OAAO,CAAC,CAAC;AAAA,EAC/B,SAAS,SAAS,OAAO,CAAC;AAC5B,CAAC;AACD,IAAI,yBAAyB,OAAO;AAAA,EAClC,eAAe,QAAQ,aAAa;AAAA,EACpC,MAAM;AACR,CAAC;AACD,IAAI,8BAA8B,OAAO;AAAA,EACvC,uBAAuB,OAAO;AAChC,CAAC;AACD,IAAI,iCAAiC,OAAO;AAAA,EAC1C,eAAe,QAAQ,aAAa;AAAA,EACpC,MAAM;AACR,CAAC;AACD,IAAI,gBAAgB,OAAO;AAAA,EACzB,eAAe,QAAQ,eAAe;AACxC,CAAC;AACD,IAAI,eAAe,OAAO;AAAA,EACxB,eAAe,QAAQ,cAAc;AAAA,EACrC,sBAAsB,OAAQ;AAChC,CAAC;AACD,IAAI,mBAAmB,OAAO;AAAA,EAC5B,eAAe,QAAQ,kBAAkB;AAAA,EACzC,oBAAoB,OAAQ;AAC9B,CAAC;AACD,IAAI,uBAAuB,OAAO;AAAA,EAChC,eAAe,QAAQ,WAAW;AAAA;AAAA;AAAA;AAAA,EAIlC,SAAS,OAAQ;AAAA;AAAA;AAAA;AAAA,EAIjB,iBAAiB,OAAQ;AAAA,EACzB,mBAAmB,OAAO;AAAA,EAC1B,OAAO,SAAS,MAAM,OAAO,CAAC,CAAC;AAAA,EAC/B,SAAS,SAAS,OAAO,CAAC;AAAA,EAC1B,YAAY,MAAM,CAAC,cAAc,gBAAgB,CAAC;AACpD,CAAC;AACD,IAAI,wBAAwB,OAAO;AAAA,EACjC,qBAAqB,OAAQ;AAAA,EAC7B,eAAe,OAAO;AAAA,EACtB,0BAA0B,OAAO;AACnC,CAAC;AACD,IAAI,8BAA8B,OAAO;AAAA,EACvC,eAAe,QAAQ,yBAAyB;AAAA,EAChD,SAAS,SAAS,oBAAoB;AACxC,CAAC;AACD,IAAI,yBAAyB,MAAM;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAI,WAAW,OAAO;AAAA,EACpB,SAAS,QAAQ,CAAC;AAAA,EAClB,WAAW,OAAQ;AAAA,EACnB,uBAAuB,OAAO;AAAA,EAC9B,QAAQ,OAAO;AACjB,CAAC;AACD,IAAI,oBAAoB,OAAO;AAAA,EAC7B,eAAe,OAAO;AAAA,EACtB,UAAU;AAAA,EACV,OAAO;AACT,CAAC;AACD,IAAI,yCAAyC,OAAO;AAAA,EAClD,eAAe,QAAQ,qBAAqB;AAAA,EAC5C,iBAAiB,SAAS,2BAA2B;AAAA,EACrD,oBAAoB,SAAS,8BAA8B;AAC7D,CAAC;AACD,IAAI,+CAA+C,OAAO;AAAA,EACxD,eAAe,QAAQ,uBAAuB;AAAA,EAC9C,SAAS;AACX,CAAC;AACD,IAAI,4CAA4C,OAAO;AAAA,EACrD,eAAe,QAAQ,oBAAoB;AAAA,EAC3C,SAAS;AAAA,EACT,WAAW,OAAO;AAAA,EAClB,OAAO;AACT,CAAC;AACD,IAAI,sCAAsC,OAAO;AAAA,EAC/C,eAAe,QAAQ,0BAA0B;AAAA,EACjD,UAAU,SAAS,qBAAqB;AAC1C,CAAC;AACD,IAAI,+BAA+B,MAAM;AAAA,EACvC;AAAA,EACA;AACF,CAAC;AACD,IAAI,oCAAoC,OAAO;AAAA,EAC7C,eAAe,QAAQ,YAAY;AAAA,EACnC,SAAS;AACX,CAAC;AACD,IAAI,0BAA0B,MAAM;AAAA,EAClC;AAAA,EACA;AACF,CAAC;AACD,IAAI,uCAAuC,OAAO;AAAA,EAChD,eAAe,QAAQ,mBAAmB;AAAA,EAC1C,MAAM;AAAA,EACN,kBAAkB,SAAS,4BAA4B;AAAA,EACvD,iBAAiB,SAAS,2BAA2B;AAAA,EACrD,iBAAiB,SAAS,2BAA2B;AAAA,EACrD,oBAAoB,SAAS,8BAA8B;AAAA,EAC3D,oBAAoB,SAAS,8BAA8B;AAC7D,CAAC;AACD,IAAI,6BAA6B,MAAM;AAAA,EACrC;AAAA,EACA;AACF,CAAC;AACD,IAAI,iCAAiC,MAAM;AAAA,EACzC;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAI,mCAAmC,OAAO;AAAA,EAC5C,eAAe,QAAQ,SAAS;AAAA,EAChC,eAAe,OAAO;AAAA,EACtB,OAAO;AACT,CAAC;AACD,IAAI,mCAAmC,OAAO;AAAA,EAC5C,eAAe,QAAQ,SAAS;AAAA,EAChC,eAAe,OAAO;AAAA,EACtB,OAAO,OAAO;AAAA,EACd,SAAS,SAAS,OAAO,CAAC;AAC5B,CAAC;AACD,IAAI,4BAA4B,MAAM;AAAA,EACpC;AAAA,EACA;AACF,CAAC;AACD,IAAI,oCAAoC;AAAA,EACtC,iBAAiB;AAAA,EACjB,WAAW;AAAA,EACX,yBAAyB;AAAA,EACzB,mBAAmB;AACrB;AACA,IAAI,6BAA6B,OAAO;AAAA,EACtC,eAAe,OAAO;AAAA,EACtB,eAAe,QAAQ,kCAAkC,eAAe;AAC1E,CAAC;AACD,IAAI,gCAAgC,OAAO;AAAA,EACzC,eAAe,OAAO;AAAA,EACtB,eAAe,QAAQ,kCAAkC,SAAS;AACpE,CAAC;AACD,IAAI,wCAAwC,OAAO;AAAA,EACjD,eAAe,OAAO;AAAA,EACtB,eAAe,QAAQ,kCAAkC,iBAAiB;AAAA,EAC1E,aAAa;AAAA,EACb,WAAW,SAAS,OAAO,CAAC;AAC9B,CAAC;AACD,IAAI,8CAA8C,OAAO;AAAA,EACvD,eAAe,OAAO;AAAA,EACtB,eAAe;AAAA,IACb,kCAAkC;AAAA,EACpC;AAAA,EACA,UAAU;AACZ,CAAC;AACD,IAAI,uBAAuB,MAAM;AAAA,EAC/B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAI,4BAA4B;AAAA,EAC9B,iBAAiB;AAAA,EACjB,qBAAqB;AAAA,EACrB,kBAAkB;AAAA,EAClB,sBAAsB;AAAA,EACtB,mBAAmB;AACrB;AACA,IAAI,uCAAuC,OAAO;AAAA,EAChD,WAAW,QAAQ,0BAA0B,eAAe;AAAA,EAC5D,eAAe,OAAO;AAAA,EACtB,gBAAgB,QAAQ;AAAA,EACxB,sBAAsB,QAAQ;AAAA,EAC9B,mBAAmB,SAAS,QAAQ,CAAC;AACvC,CAAC;AACD,IAAI,wBAAwB,OAAO;AAAA,EACjC,WAAW,MAAM;AAAA,IACf,QAAQ,0BAA0B,eAAe;AAAA,IACjD,QAAQ,0BAA0B,mBAAmB;AAAA,IACrD,QAAQ,0BAA0B,gBAAgB;AAAA,IAClD,QAAQ,0BAA0B,oBAAoB;AAAA,IACtD,QAAQ,0BAA0B,iBAAiB;AAAA,EACrD,CAAC;AAAA,EACD,eAAe,OAAO;AACxB,CAAC;AACD,IAAI,kBAAkB,MAAM;AAAA,EAC1B;AAAA,EACA;AACF,CAAC;AACD,IAAI,YAAY;AAAA,EACd,iBAAiB;AAAA,EACjB,iBAAiB;AACnB;AACA,IAAI,QAAQ,QAAQ,OAAO;AAC3B,IAAI,SAAS,QAAQ,QAAQ;AAC7B,IAAI,eAAe,QAAQ,cAAc;AACzC,IAAI,gBAAgB,QAAQ,eAAe;AAC3C,IAAI,QAAQ,MAAM,CAAC,OAAO,QAAQ,cAAc,aAAa,CAAC;AAC9D,IAAI,UAAU,MAAM,CAAC,QAAQ,QAAQ,GAAG,QAAQ,WAAW,CAAC,CAAC;AAC7D,IAAI,yBAAyB,OAAO;AAAA,EAClC,WAAW,OAAO;AAAA,EAClB,gBAAgB,OAAO;AAAA,EACvB,kBAAkB,OAAO;AAAA,EACzB,QAAQ,SAAS,OAAO;AAAA;AAAA,EAExB,cAAc,SAAS,OAAO,CAAC;AAAA;AAEjC,CAAC;AACD,IAAI,WAAW,OAAO;AAAA,EACpB,GAAG,uBAAuB;AAAA,EAC1B,QAAQ;AAAA,EACR,SAAS,OAAO;AAAA,IACd,KAAK,OAAO;AAAA,EACd,CAAC;AACH,CAAC;AACD,IAAI,UAAU,OAAO;AAAA,EACnB,GAAG,uBAAuB;AAAA,EAC1B,QAAQ;AAAA,EACR,SAAS,OAAO;AAAA,IACd,KAAK,OAAO;AAAA,EACd,CAAC;AACH,CAAC;AACD,IAAI,wBAAwB,OAAO;AAAA,EACjC,WAAW,OAAO;AAAA,EAClB,QAAQ,OAAO;AAAA,EACf,eAAe,OAAQ;AACzB,CAAC;AACD,IAAI,iBAAiB,OAAO;AAAA,EAC1B,GAAG,uBAAuB;AAAA,EAC1B,QAAQ;AAAA,EACR,SAAS;AACX,CAAC;AACD,IAAI,kBAAkB,OAAO;AAAA,EAC3B,GAAG,uBAAuB;AAAA,EAC1B,QAAQ;AAAA,EACR,SAAS,MAAM,qBAAqB;AACtC,CAAC;AAGD,IAAI,4BAA4B,OAAQ;AAAA,EACtC,kBAAkB;AAAA,EAClB,WAAW,SAAU,QAAS,CAAC;AAAA,EAC/B,OAAO,SAAU,QAAS,CAAC;AAC7B,CAAC;AACD,IAAI,WAAW,MAAM;AACnB,QAAM,eAAe;AAAA,IACnB,kBAAkB,EAAE,YAAY,WAAW,UAAU,EAAE;AAAA,EACzD;AACA,MAAI,OAAO,QAAQ,cAAc,MAAM;AAAA,EACvC,CAAC;AACD,QAAM,UAAU,CAAC,MAAM;AACrB,WAAO,QAAQ,MAAM,CAAC,UAAU;AAC9B,YAAM,iBAAiB,aAAa;AACpC,YAAM,iBAAiB,WAAW;AAAA,IACpC,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,UAAU,CAAC,MAAM;AACrB,WAAO,QAAQ,MAAM,CAAC,UAAU;AAC9B,YAAM,iBAAiB,aAAa;AACpC,YAAM,iBAAiB,WAAW;AAAA,IACpC,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,CAAC,QAAQ,SAAS;AAC9B,WAAO,QAAQ,MAAM,CAAC,UAAU;AAC9B,YAAM,QAAQ;AAAA,IAChB,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,CAAC,QAAQ,SAAS;AAClC,WAAO,QAAQ,MAAM,CAAC,UAAU;AAC9B,YAAM,YAAY;AAAA,IACpB,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,OAAO;AAAA,IACvB,UAAU;AAAA,EACZ;AACA,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO;AACT;AAKA,IAAI,SAAS,OAAQ;AAAA,EACnB,WAAW,SAAU,QAAS,CAAC;AACjC,CAAC;AACD,IAAI,UAAU,CAAC,cAAc;AAAA,EAC3B,WAAW;AACb,MAAM;AACJ,MAAI,OAAO,QAAS,aAAa,MAAM;AAAA,EACvC,CAAC;AACD,QAAM,YAAY,CAAC,QAAQ,SAAS;AAClC,WAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,YAAM,YAAY;AAAA,IACpB,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,OAAO;AAAA,IACvB,SAAS;AAAA,EACX;AACA,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,EACF;AACA,SAAO;AACT;AAKA,IAAI,2BAA2B;AAAA,EAC7B,OAAQ;AAAA,IACN,UAAU,QAAS;AAAA,IACnB,gBAAgB;AAAA,IAChB,cAAc;AAAA,IACd,OAAO,QAAS;AAAA,EAClB,CAAC;AACH;AACA,IAAI,cAAc,CAAC,cAAc,CAAC,MAAM;AACtC,MAAI,OAAO,QAAS,aAAa,MAAM;AAAA,EACvC,CAAC;AACD,QAAM,WAAW,CAAC,QAAQ,SAAS;AACjC,WAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,YAAM,WAAW;AAAA,IACnB,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,8BAA8B,CAAC,SAAS;AAAA,IAC5C,SAAS,CAAC,MAAM;AACd,aAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,cAAM,GAAG,IAAI,EAAE,YAAY,WAAW,UAAU,EAAE;AAAA,MACpD,CAAC;AACD,aAAO;AAAA,IACT;AAAA,IACA,SAAS,CAAC,MAAM;AACd,aAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,cAAM,GAAG,IAAI,EAAE,YAAY,WAAW,UAAU,EAAE;AAAA,MACpD,CAAC;AACD,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,iBAAiB,CAAC,QAAQ,SAAS;AACvC,UAAM,UAAU,4BAA4B,gBAAgB;AAC5D,YAAQ,QAAQ,QAAQ,IAAI,CAAC;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,eAAe,CAAC,QAAQ,SAAS;AACrC,UAAM,UAAU,4BAA4B,cAAc;AAC1D,YAAQ,QAAQ,QAAQ,IAAI,CAAC;AAC7B,WAAO;AAAA,EACT;AACA,QAAM,QAAQ,CAAC,QAAQ,SAAS;AAC9B,WAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,YAAM,QAAQ;AAAA,IAChB,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,OAAO;AAAA,IACvB,aAAa;AAAA,EACf;AACA,QAAM,UAAU;AAAA,IACd;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,SAAO;AACT;AAKA,IAAI,UAAU,OAAQ;AAAA,EACpB,kBAAkB,SAAU,MAAO,OAAQ,CAAC,CAAC;AAAA,EAC7C,iBAAiB,SAAU,OAAQ,CAAC;AACtC,CAAC;AACD,IAAI,mBAAmB,CAAC,cAAc,CAAC,MAAM;AAC3C,MAAI,OAAO,QAAS,aAAa,MAAM;AAAA,EACvC,CAAC;AACD,QAAM,YAAY,CAAC,UAAU;AAC3B,WAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,YAAM,mBAAmB;AAAA,IAC3B,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAME,YAAW,CAAC,UAAU;AAC1B,WAAO,QAAS,MAAM,CAAC,UAAU;AAC/B,YAAM,kBAAkB;AAAA,IAC1B,CAAC;AACD,WAAO;AAAA,EACT;AACA,QAAM,YAAY,OAAO;AAAA,IACvB,kBAAkB;AAAA,EACpB;AACA,QAAM,UAAU;AAAA,IACd,UAAU;AAAA,IACV,UAAAA;AAAA,IACA;AAAA,EACF;AACA,SAAO;AACT;AAGA,IAAIC,UAAS,CAAC,SAAS;AACrB,QAAM,YAAY,OAAO,EAAE,GAAG,KAAK;AACnC,QAAM,UAAU;AAAA,IACd;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,qBAAqB;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA,QAAAA;AACF;AACA,IAAI,4BAA4B;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AACF;AAGA,IAAI,cAAc,CAAC,GAAG,MAAM;AAC1B,QAAM,SAAS,CAAC,MAAM,QAAQ,OAAO,IAAI;AACzC,MAAI,OAAO,SAAS,CAAC,KAAK,OAAO,SAAS,CAAC,KAAK,OAAO,MAAM,YAAY,OAAO,MAAM,UAAU;AAC9F,WAAO,OAAO,GAAG,GAAG,CAAC;AAAA,EACvB;AACA,QAAM,QAAQ,OAAO,KAAK,CAAC;AAC3B,QAAM,QAAQ,OAAO,KAAK,CAAC;AAC3B,MAAI,MAAM,WAAW,MAAM,OAAQ,QAAO;AAC1C,aAAW,OAAO,OAAO;AACvB,UAAM,SAAS,EAAE,GAAG;AACpB,UAAM,SAAS,EAAE,GAAG;AACpB,UAAM,YAAYC,UAAS,MAAM,KAAKA,UAAS,MAAM;AACrD,QAAI,aAAa,CAAC,YAAY,QAAQ,MAAM,KAAK,CAAC,aAAa,WAAW,QAAQ;AAChF,aAAO;AAAA,IACT;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAIA,YAAW,CAAC,MAAM;AACpB,SAAO,KAAK,QAAQ,OAAO,MAAM;AACnC;AAGA,IAAI,qCAAqC,CAAC,aAAa,UAAU;AAvnCjE,MAAAH,KAAA;AAwnCE,MAAI,YAAY,kBAAkB,qBAAqB;AACrD,UAAM,YAAUA,MAAA,YAAY,UAAZ,gBAAAA,IAAmB,eAAY,iBAAY,UAAZ,mBAAmB;AAClE,UAAM,mBAAmB,CAAC,EAAE,YAAY,mBAAmB,YAAY;AACvE,UAAM,qBAAqB,YAAY,KAAK,kBAAkB,wBAAwB,CAAC,GAAC,iBAAY,oBAAZ,mBAA6B,cAAa,CAAC,GAAC,iBAAY,oBAAZ,mBAA6B;AACjK,QAAI,WAAW,oBAAoB,mBAAoB,QAAO;AAC9D,QAAI,2BAA2B;AAC/B,QAAI,YAAY,iBAAiB;AAC/B,YAAM,EAAE,YAAY,SAAS,IAAI,YAAY,gBAAgB;AAC7D,mCAA2B,uBAAM,eAAN,mBAAkB,oBAAlB,mBAAmC,qBAAnC,mBAAqD,gBAAe,gBAAc,uBAAM,eAAN,mBAAkB,oBAAlB,mBAAmC,qBAAnC,mBAAqD,cAAa;AAAA,IACjL;AACA,QAAI,YAAY,oBAAoB;AAClC,iCAA2B;AAAA,QACzB,YAAY;AAAA,SACZ,WAAM,eAAN,mBAAkB;AAAA,MACpB;AAAA,IACF;AACA,WAAO;AAAA,EACT;AACA,SAAO;AACT;AASA,IAAI,8CAA8C,OAAQ;AAAA,EACxD,kBAAkB;AAAA,IAChB,OAAQ;AAAA,MACN,WAAW,SAAU,OAAQ,CAAC;AAAA,MAC9B,kBAAkB,SAAU,MAAO,OAAQ,CAAC,CAAC;AAAA,MAC7C,iBAAiB,SAAU,OAAQ,CAAC;AAAA,IACtC,CAAC;AAAA,EACH;AAAA,EACA,UAAU;AAAA,IACR,OAAQ;AAAA,MACN,kBAAkB;AAAA,MAClB,OAAO,QAAS;AAAA,MAChB,SAAS,QAAS;AAAA,MAClB,WAAW,SAAU,OAAQ,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AAAA,EACA,aAAa;AAAA,IACX,OAAQ;AAAA,MACN,UAAU,SAAU,QAAS,CAAC;AAAA,MAC9B,cAAc,SAAU,cAAc;AAAA,MACtC,gBAAgB,SAAU,cAAc;AAAA,MACxC,OAAO,QAAS;AAAA,MAChB,SAAS,SAAU,QAAS,CAAC;AAAA,IAC/B,CAAC;AAAA,EACH;AAAA,EACA,SAAS;AAAA,IACP,OAAQ;AAAA,MACN,iBAAiB,SAAU,OAAQ,CAAC;AAAA,MACpC,OAAO,SAAU,OAAQ,CAAC;AAAA,MAC1B,WAAW,SAAU,OAAQ,CAAC;AAAA,IAChC,CAAC;AAAA,EACH;AACF,CAAC;AACD,IAAI,eAAe,CAAC,UAAU;AAC5B,QAAM,EAAE,SAAS,UAAU,UAAU,WAAW,aAAa,cAAc,kBAAkB,kBAAkB,IAAI;AACnH,QAAM,iBAAiB,CAAC,CAAC;AACzB,QAAM,mBAAkB,uCAAW,WAAS,6CAAc;AAC1D,QAAM,2BAA2B,aAAa,EAAC,uCAAW;AAC1D,QAAM,8BAA8B,gBAAgB,EAAC,6CAAc;AACnE,QAAM,sBAAsB,CAAC,EAAE,mBAAmB,4BAA4B,+BAA+B,kBAAkB;AAC/H,SAAO;AACT;AACA,IAAI,yBAAyB,CAAC,UAAU;AA9rCxC,MAAAA,KAAA;AA+rCE,OAAIA,MAAA,MAAM,YAAN,gBAAAA,IAAe,WAAW;AAC5B,WAAO;AAAA,MACL,eAAe;AAAA,MACf,WAAW,MAAM,QAAQ;AAAA,IAC3B;AAAA,EACF;AACA,OAAI,WAAM,YAAN,mBAAe,iBAAiB;AAClC,WAAO;AAAA,MACL,eAAe;AAAA,MACf,kBAAiB,WAAM,YAAN,mBAAe;AAAA,IAClC;AAAA,EACF;AACA,SAAO;AAAA,IACL,eAAe;AAAA,EACjB;AACF;AACA,IAAI,yBAAyB,CAAC,UAAU,CAAC,iBAAiB;AA/sC1D,MAAAA,KAAA;AAgtCE,QAAM,sBAAsB,EAAE,GAAG,aAAa;AAC9C,QAAM,EAAE,UAAU,UAAU,IAAI;AAChC,MAAI,WAAW;AACb,UAAM,OAAO;AAAA,MACX,WAAW,UAAU;AAAA,MACrB,kBAAkB,UAAU;AAAA,IAC9B;AACA,UAAM,mBAAmB,oBAAoB,kBAAkB,uBAAuB,GAACA,MAAA,MAAM,aAAN,gBAAAA,IAAgB;AACvG,UAAM,0BAA0B,oBAAoB,kBAAkB;AACtE,SAAI,WAAM,aAAN,mBAAgB,SAAS;AAC3B,0BAAoB,iBAAiB,IAAI;AAAA,IAC3C,WAAW,oBAAoB,yBAAyB;AACtD,0BAAoB,iBAAiB,IAAI;AAAA,IAC3C;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,kCAAkC,CAAC,UAAU,CAAC,iBAAiB;AACjE,QAAM,sBAAsB,EAAE,GAAG,aAAa;AAC9C,MAAI,MAAM,kBAAkB;AAC1B,UAAM,EAAE,WAAW,kBAAkB,gBAAgB,IAAI,MAAM;AAC/D,QAAI,aAAa,oBAAoB,kBAAkB,qBAAqB;AAC1E,0BAAoB,kBAAkB,IAAI;AAAA,QACxC;AAAA,MACF;AACA,UAAI,kBAAkB;AACpB,4BAAoB,kBAAkB,EAAE,mBAAmB;AAAA,MAC7D;AACA,UAAI,iBAAiB;AACnB,4BAAoB,kBAAkB,EAAE,kBAAkB;AAAA,MAC5D;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,6BAA6B,CAAC,UAAU,CAAC,iBAAiB;AAnvC9D,MAAAA,KAAA;AAovCE,QAAM,sBAAsB,EAAE,GAAG,aAAa;AAC9C,MAAI,MAAM,aAAa;AACrB,UAAM;AAAA,MACJ,UAAU;AAAA,MACV,cAAc;AAAA,MACd,gBAAgB;AAAA,IAClB,IAAI,MAAM;AACV,SAAIA,MAAA,MAAM,gBAAN,gBAAAA,IAAmB,SAAS;AAC9B,0BAAoB,oBAAoB,IAAI;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AACA,UAAM,mBAAmB,oBAAoB,kBAAkB,uBAAuB,GAAC,WAAM,gBAAN,mBAAmB;AAC1G,UAAM,0BAA0B,oBAAoB,kBAAkB;AACtE,QAAI,oBAAoB,yBAAyB;AAC/C,0BAAoB,oBAAoB,IAAI;AAAA,QAC1C;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AACT;AACA,IAAI,uBAAuB,CAAC,UAAU,CAAC,iBAAiB;AACtD,QAAM,EAAE,UAAU,WAAW,aAAa,aAAa,IAAI;AAC3D,SAAO;AAAA,IACL,GAAG;AAAA,IACH,OAAO,EAAE,UAAU,CAAC,EAAC,uCAAW,QAAO,aAAa,CAAC,EAAC,6CAAc,OAAM;AAAA,EAC5E;AACF;AACA,IAAI,iCAAiC,CAAC,UAAU,GAAI;AAAA,EAClD,eAAe;AACjB,CAAC,EAAE,IAAI,uBAAuB,KAAK,CAAC,EAAE,IAAI,2BAA2B,KAAK,CAAC,EAAE,IAAI,gCAAgC,KAAK,CAAC;AACvH,IAAI,+BAA+B,CAAC,UAAU,GAAI;AAAA,EAChD,eAAe;AAAA,EACf,MAAM,uBAAuB,KAAK;AACpC,CAAC,EAAE,IAAI,uBAAuB,KAAK,CAAC,EAAE,IAAI,2BAA2B,KAAK,CAAC,EAAE,IAAI,qBAAqB,KAAK,CAAC,EAAE,IAAI,gCAAgC,KAAK,CAAC;AACxJ,IAAI,0BAA0B,CAAC,WAAW,UAAU;AAAA,EAClD,YAAY,QAAS,OAAO,CAAC,UAAU;AACrC,QAAI,MAAM,UAAU;AAClB,YAAM,SAAS,UAAU;AACzB,YAAM,SAAS,QAAQ;AAAA,IACzB;AACA,QAAI,MAAM,aAAa;AACrB,YAAM,YAAY,UAAU;AAC5B,YAAM,YAAY,QAAQ;AAAA,IAC5B;AAAA,EACF,CAAC,IAAI;AACP;AACA,IAAI,yCAAyC,CAAC,WAAW,UAAU,wBAAwB,WAAW,KAAK,EAAE;AAAA,EAC3G,CAAC,gBAAgB,aAAa,WAAW,IAAI,6BAA6B,WAAW,IAAI,+BAA+B,WAAW;AACrI;AAGA,IAAI,kBAAkB,CAAC;AAAA,EACrB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AAAA,EACJ;AAAA,EACA,QAAS,CAAC,GAAG,CAAC,UAAU;AArzC1B,QAAAA;AAszCI,QAAI,iBAAiB,kBAAkB;AACrC,YAAM,mBAAmB;AAAA,QACvB,GAAG,iBAAiB;AAAA,QACpB;AAAA,MACF;AAAA,IACF;AACA,QAAI,iBAAiB,UAAU;AAC7B,YAAM,WAAW;AAAA,QACf,kBAAkB,iBAAiB,SAAS,oBAAoB;AAAA,UAC9D,YAAY;AAAA,UACZ,UAAU;AAAA,QACZ;AAAA,QACA;AAAA,QACA,OAAO,CAAC,CAAC,iBAAiB,SAAS;AAAA,QACnC,WAAW,iBAAiB,SAAS,YAAY,YAAY;AAAA,MAC/D;AAAA,IACF;AACA,QAAI,iBAAiB;AACnB,YAAM,cAAc;AAAA,QAClB,GAAG,iBAAiB;AAAA,QACpB,OAAO,CAAC,CAAC,iBAAiB,YAAY;AAAA,QACtC;AAAA,MACF;AACF,QAAI,CAAC,WAAW,iBAAiB,kBAAkB;AACjD,YAAM,WAAW,WAAW;AAC5B,UAAI,WAAW,QAAS,OAAM,UAAU;AACxC,WAAIA,MAAA,iBAAiB,YAAjB,gBAAAA,IAA0B;AAC5B,cAAM,UAAU,EAAE,GAAG,MAAM,WAAW,CAAC,GAAG,UAAU;AACtD,UAAI,OAAO,OAAO,gBAAgB,EAAE,WAAW;AAC7C,cAAM,UAAU,EAAE,WAAW,OAAO;AAAA,IACxC;AAAA,EACF,CAAC;AACH;AAIA,IAAI,qCAAqC,CAAC,mBAAmB,eAAe;AAC1E,QAAM,EAAE,OAAO,kBAAkB,IAAI;AACrC,MAAI,kBAAkB,kBAAkB;AACtC,WAAO,QAAS,CAAC,GAAG,CAAC,UAAU;AAC7B,YAAM,UAAU,EAAE,OAAO,MAAM;AAC/B,UAAI,kBAAkB,KAAK,kBAAkB;AAC3C,cAAM,QAAQ,QAAQ,CAAC,CAAC,kBAAkB,KAAK;AACjD,UAAI,kBAAkB,iBAAiB;AACrC,cAAM,kBAAkB;AAAA,UACtB,OAAO,CAAC,CAAC,kBAAkB,gBAAgB;AAAA,UAC3C,kBAAkB,kBAAkB,gBAAgB;AAAA,QACtD;AAAA,MACF;AACA,UAAI,kBAAkB,oBAAoB;AACxC,cAAM,qBAAqB,kBAAkB;AAAA,MAC/C;AAAA,IACF,CAAC;AACH,SAAO;AACT;AACA,IAAI,wCAAwC,CAAC,eAAe,QAAS,CAAC,GAAG,CAAC,UAAU;AAClF,MAAI,WAAW,iBAAiB;AAC9B,UAAM,WAAW;AAAA,MACf,kBAAkB,WAAW,gBAAgB;AAAA,MAC7C,WAAW,WAAW,gBAAgB;AAAA,MACtC,OAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,WAAW,oBAAoB;AACjC,UAAM,cAAc;AAAA,MAClB,UAAU,WAAW,mBAAmB;AAAA,MACxC,cAAc,WAAW,mBAAmB;AAAA,MAC5C,gBAAgB,WAAW,mBAAmB;AAAA,MAC9C,OAAO;AAAA,IACT;AAAA,EACF;AACA,MAAI,WAAW,SAAS;AACtB,UAAM,UAAU;AAAA,MACd,WAAW;AAAA,IACb;AAAA,EACF;AACF,CAAC;AAmBD,IAAI,YAAY;AAAA,EACd,SAAS;AAAA,EACT,SAAS;AACX;AACA,IAAI,yBAAyB,OAAQ;AAAA,EACnC,WAAW,OAAQ;AAAA,EACnB,OAAO;AAAA,EACP,SAAS,OAAQ;AAAA,EACjB,MAAM,QAAS,UAAU,OAAO;AAClC,CAAC;AACD,IAAI,yBAAyB,OAAQ;AAAA,EACnC,WAAW,OAAQ;AAAA,EACnB,OAAO;AAAA,EACP,SAAS,OAAQ;AAAA,EACjB,MAAM,QAAS,UAAU,OAAO;AAClC,CAAC;AACD,IAAI,kBAAkB,QAAQ,QAAQ;AAAA,EACpC;AAAA,EACA;AACF,CAAC;AACD,IAAI,gCAAgC,OAAQ;AAAA,EAC1C,OAAO,QAAS,UAAU;AAAA,EAC1B,QAAQ;AACV,CAAC;AACD,IAAI,sCAAsC,OAAQ;AAAA,EAChD,OAAO,QAAS,gBAAgB;AAAA,EAChC,QAAQ,MAAO,OAAQ,CAAC;AAC1B,CAAC;AACD,IAAI,6CAA6C,OAAQ;AAAA,EACvD,OAAO,QAAS,cAAc;AAAA,EAC9B,QAAQ,MAAO,OAAQ,CAAC;AAC1B,CAAC;AACD,IAAI,wBAAwB,QAAQ,SAAS;AAAA,EAC3C;AAAA,EACA;AAAA,EACA;AACF,CAAC;AACD,IAAI,aAAa,OAAQ;AAAA,EACvB,UAAU,MAAO,OAAO;AAAA,EACxB,aAAa,MAAO,qBAAqB;AAAA,EACzC,SAAS,SAAU,OAAO;AAAA,EAC1B,QAAQ,MAAO,eAAe;AAChC,CAAC;AACD,IAAI,aAAa,OAAQ;AAAA,EACvB,SAAS,SAAU,OAAQ,EAAE,OAAO,QAAS,EAAE,CAAC,CAAC;AAAA,EACjD,iBAAiB;AAAA,IACf,OAAQ;AAAA,MACN,kBAAkB,SAAU,cAAc;AAAA,MAC1C,OAAO,QAAS;AAAA,IAClB,CAAC;AAAA,EACH;AAAA,EACA,oBAAoB,SAAU,sBAAsB;AACtD,CAAC;AACD,IAAI,WAAW,OAAQ;AAAA,EACrB,mBAAmB,OAAQ;AAAA,EAC3B,YAAY;AAAA,EACZ,YAAY;AACd,CAAC;AACD,IAAI,oBAAoB;AAAA,EACtB,UAAU,CAAC;AAAA,EACX,aAAa,CAAC;AAAA,EACd,QAAQ,CAAC;AAAA,EACT,SAAS;AACX;AAIA,IAAI,cAAc,CAAC,UAAU;AAx9C7B,MAAAA;AAy9CE,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa,EAAE,MAAM,cAAc;AACjE,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,gBAAgB,IAAI,aAAa;AACvC,QAAM,WAAW,CAAC,UAAU,cAAc,SAAS,KAAK;AACxD,QAAM,WAAW,MAAM,cAAc,SAAS,EAAE,OAAO,MAAM,QAAQ,YAAY,CAAC,EAAE,QAAQ,CAAC,UAAU,QAAQ,GAAI,KAAK,IAAI,GAAI,YAAY,CAAC;AAC7I,QAAM,aAAa,CAAC,UAAU,SAAS,EAAE;AAAA,IACvC,CAAC,aAAa,SAAS,EAAE,GAAG,UAAU,GAAG,MAAM,CAAC;AAAA,EAClD;AACA,QAAM,eAAe;AAAA,IACnB,YAAY;AAAA,IACZ,mBAAmB;AAAA,IACnB,YAAY,CAAC;AAAA,EACf;AACA,QAAM,aAAa,MAAM,cAAc,SAAS,YAAY,EAAE,IAAI,MAAM;AACtE,mBAAe;AAAA,EACjB,CAAC;AACD,QAAM,kBAAkB,MAAM,SAAS,EAAE,IAAI,MAAM,eAAe,CAAC,EAAE,OAAO,MAAM,WAAW,CAAC;AAC9F,kBAAgB;AAChB,QAAM,oBAAoB,IAAI;AAAA,IAC5B;AAAA,EACF;AACA,QAAM,iBAAiB,MAAM;AAC3B,kBAAc,SAAS,EAAE,IAAI,CAAC,UAAU;AACtC,wBAAkB,KAAK,+BAAO,UAAU;AAAA,IAC1C,CAAC;AAAA,EACH;AACA,QAAM,cAAc,kBAAkB,aAAa,EAAE,KAAK,OAAO,CAAC,eAAe,CAAC,CAAC,UAAU,CAAC;AAC9F,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAe,MAAM,kBAAkB;AAAA,IACvC,OAAO;AAAA,IACP,UAAU,cAAc;AAAA,IACxB,SAAS,MAAM;AACb,oBAAc,YAAY;AAAA,IAC5B;AAAA,EACF;AACF;AAGA,IAAI,eAAe,CAAC,UAAU,CAAC,eAAe;AApgD9C,MAAAA,KAAA;AAqgDE,MAAI,YAAY,CAAC;AACjB,MAAI,MAAM,kBAAkB,qBAAqB;AAC/C,UAAM,oBAAkBA,MAAA,MAAM,oBAAN,gBAAAA,IAAuB,aAAY,CAAC;AAC5D,UAAM,oBAAkB,WAAM,oBAAN,mBAAuB,aAAY,CAAC;AAC5D,gBAAY,CAAC,GAAG,iBAAiB,GAAG,eAAe;AAAA,EACrD,WAAW,MAAM,kBAAkB,uBAAuB;AACxD,UAAM,oBAAkB,WAAM,oBAAN,mBAAuB,aAAY,CAAC;AAC5D,gBAAY;AAAA,EACd;AACA,SAAO,QAAS,YAAY,CAAC,UAAU;AACrC,UAAM,WAAW;AAAA,EACnB,CAAC;AACH;AACA,IAAI,yBAAyB,CAAC,UAAU;AACtC,QAAM,UAAU,CAAC;AACjB,MAAI,MAAM,MAAM;AACd,YAAQ,KAAK;AAAA,MACX,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,IAChB,CAAC;AAAA,EACH;AACA,MAAI,MAAM;AACR,YAAQ,KAAK;AAAA,MACX,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,IAChB,CAAC;AACH,MAAI,MAAM;AACR,YAAQ,KAAK;AAAA,MACX,OAAO;AAAA,MACP,QAAQ,MAAM;AAAA,IAChB,CAAC;AACH,SAAO;AACT;AACA,IAAI,0CAA0C,CAAC,WAAW,WAAW;AACnE,SAAO,OAAO,IAAI,CAAC,UAAU;AAC3B,UAAM,OAAO,qBAAqB,QAAQ,UAAU,UAAU,UAAU;AACxE,UAAM,UAAU,qBAAqB,QAAQ,MAAM,kBAAkB,MAAM;AAC3E,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,MAAM;AAAA,IACf;AAAA,EACF,CAAC;AACH;AACA,IAAI,kBAAkB,CAAC,UAAU,CAAC,eAAe,QAAS,YAAY,CAAC,UAAU;AAC/E,MAAI,MAAM,kBAAkB,qBAAqB;AAC/C,QAAI,MAAM;AACR,YAAM,cAAc,uBAAuB,MAAM,kBAAkB;AACrE,QAAI,MAAM;AACR,YAAM,cAAc,uBAAuB,MAAM,kBAAkB;AAAA,EACvE,WAAW,MAAM,kBAAkB,yBAAyB,MAAM;AAChE,UAAM,cAAc,uBAAuB,MAAM,kBAAkB;AACvE,CAAC;AACD,IAAI,cAAc,CAAC,UAAU,CAAC,eAAe,QAAS,YAAY,CAAC,UAAU;AA3jD7E,MAAAA;AA4jDE,MAAI,MAAM,kBAAkB;AAC1B,UAAM,WAAUA,MAAA,MAAM,SAAN,gBAAAA,IAAY;AAChC,CAAC;AACD,IAAI,aAAa,CAAC,UAAU,CAAC,eAAe,QAAS,YAAY,CAAC,UAAU;AA/jD5E,MAAAA,KAAA;AAgkDE,QAAM,SAAS,CAAC;AAChB,MAAI,MAAM,kBAAkB,qBAAqB;AAC/C,QAAI,MAAM,KAAK,kBAAkB;AAC/B,YAAM,OAAO,KAAK;AAAA,QAChB,WAAW,MAAM,KAAK;AAAA,QACtB,OAAO,MAAM,KAAK;AAAA,QAClB,SAAS,MAAM,KAAK,QAAQ;AAAA,QAC5B,MAAM,UAAU;AAAA,MAClB,CAAC;AACH,UAAIA,MAAA,MAAM,oBAAN,gBAAAA,IAAuB,gBAAa,WAAM,gBAAgB,WAAtB,mBAA8B,SAAQ;AAC5E,YAAM,YAAY,MAAM,gBAAgB;AACxC,YAAM,gBAAgB,MAAM,gBAAgB,OAAO;AAAA,QACjD,CAAC,EAAE,gBAAgB,MAAM,OAAO;AAAA,UAC9B;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,MAAM,UAAU;AAAA,QAClB;AAAA,MACF;AACA,YAAM,OAAO,KAAK,GAAG,aAAa;AAAA,IACpC;AACA,UAAI,WAAM,oBAAN,mBAAuB,gBAAa,WAAM,gBAAgB,WAAtB,mBAA8B,SAAQ;AAC5E,YAAM,YAAY,MAAM,gBAAgB;AACxC,YAAM,gBAAgB,MAAM,gBAAgB,OAAO;AAAA,QACjD,CAAC,EAAE,gBAAgB,MAAM,OAAO;AAAA,UAC9B;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,MAAM,UAAU;AAAA,QAClB;AAAA,MACF;AACA,YAAM,OAAO,KAAK,GAAG,aAAa;AAAA,IACpC;AACA,QAAI,MAAM,kBAAkB;AAC1B,YAAM,OAAO;AAAA,QACX,GAAG;AAAA,UACD,MAAM,iBAAiB;AAAA,UACvB,MAAM,iBAAiB;AAAA,QACzB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,MAAM,kBAAkB,uBAAuB;AACjD,UAAI,WAAM,oBAAN,mBAAuB,gBAAa,WAAM,gBAAgB,WAAtB,mBAA8B,SAAQ;AAC5E,YAAM,YAAY,MAAM,gBAAgB;AACxC,YAAM,gBAAgB,MAAM,gBAAgB,OAAO;AAAA,QACjD,CAAC,EAAE,gBAAgB,MAAM,OAAO;AAAA,UAC9B;AAAA,UACA,SAAS;AAAA,UACT;AAAA,UACA,MAAM,UAAU;AAAA,QAClB;AAAA,MACF;AACA,YAAM,OAAO,KAAK,GAAG,aAAa;AAAA,IACpC;AAAA,EACF;AACF,CAAC;AACD,IAAI,yCAAyC,CAAC,aAAa,QAAS;AAAA,EAClE,UAAU,CAAC;AAAA,EACX,aAAa,CAAC;AAAA,EACd,QAAQ,CAAC;AAAA,EACT,SAAS;AACX,CAAC,EAAE,IAAI,aAAa,QAAQ,CAAC,EAAE,IAAI,gBAAgB,QAAQ,CAAC,EAAE,IAAI,YAAY,QAAQ,CAAC,EAAE,IAAI,WAAW,QAAQ,CAAC;AAGjH,IAAI,qCAAqC,CAAC,eAAe;AAjoDzD,MAAAA,KAAA;AAkoDE,QAAM,YAAY,WAAW,YAAY,CAAC;AAC1C,QAAM,iBAAeA,MAAA,yCAAY,YAAZ,gBAAAA,IAAqB,UAAS;AACnD,QAAM,YAAY,CAAC,EAAC,yCAAY;AAChC,QAAM,gBAAe,8CAAY,gBAAZ,mBAAyB,IAAI,CAAC,SAAS;AAC1D,QAAI,KAAK,UAAU,YAAY;AAC7B,YAAM,EAAE,SAAS,UAAU,YAAY,YAAY,SAAS,IAAI,KAAK;AACrE,YAAM,QAAQ,aAAa,YAAY,GAAG,UAAU,GAAG,WAAW,KAAK,QAAQ,OAAO,GAAG,GAAG,UAAU,KAAK,GAAG,UAAU,GAAG,WAAW,KAAK,QAAQ,OAAO,GAAG,GAAG,UAAU;AAC1K,aAAO;AAAA,QACL;AAAA,QACA,OAAO;AAAA,MACT;AAAA,IACF,WAAW,KAAK,UAAU,kBAAkB;AAC1C,aAAO;AAAA;AAAA,QAEL,OAAO,KAAK,OAAO,CAAC;AAAA,QACpB,OAAO;AAAA,MACT;AAAA,IACF,WAAW,KAAK,UAAU,gBAAgB;AACxC,aAAO;AAAA;AAAA,QAEL,OAAO,KAAK,OAAO,CAAC;AAAA,QACpB,OAAO;AAAA,MACT;AAAA,IACF;AACA;AAAA,EACF,GAAG;AAAA,IACD,CAAC,SAAM;AA5pDX,UAAAA;AA4pDc,cAAC,CAAC,QAAQ,CAAC,GAACA,MAAA,KAAK,UAAL,gBAAAA,IAAY;AAAA;AAAA;AAEpC,SAAO,EAAE,UAAU,WAAW,cAAc,WAAW,aAAa,aAAa;AACnF;AAKA,IAAI,yBAAyB,CAAC,iBAAiB;AAC7C,QAAM,QAAQ,IAAI,gBAAiB,YAAY;AAC/C,QAAM,QAAQ,MAAM,MAAM,KAAK,YAAY;AAC3C,QAAM,SAAS,CAAC,UAAU,MAAM,KAAK,KAAK;AAC1C,QAAM,WAAW,MAAM,MAAM,SAAS;AACtC,QAAM,qBAAqB,IAAI,UAAU,MAAM,OAAO,CAAC,SAAS,OAAO,KAAK,cAAc,UAAU,EAAE;AAAA,IACpG,CAAC,KAAK,UAAU;AAAA,MACd,GAAG;AAAA,MACH,GAAG,KAAK,UAAU;AAAA,IACpB;AAAA,IACA,CAAC;AAAA,EACH;AACA,QAAM,WAAW,IAAI,UAAU;AAC7B,QAAI,MAAM,WAAW,EAAG,OAAM;AAAA,SACzB;AACH,aAAO,mBAAmB,GAAG,KAAK,CAAC;AAAA,IACrC;AAAA,EACF;AACA,QAAM,aAAa,IAAI,UAAU;AAC/B,QAAI,MAAM,WAAW,EAAG;AACxB,WAAO,EAAE,GAAG,SAAS,GAAG,GAAG,mBAAmB,GAAG,KAAK,EAAE,CAAC;AAAA,EAC3D;AACA,QAAM,cAAc,IAAI,SAAS;AAC/B;AAAA,MACE,QAAS,SAAS,GAAG,CAAC,UAAU;AAC9B,aAAK,QAAQ,CAAC,QAAQ;AACpB,iBAAO,MAAM,GAAG;AAAA,QAClB,CAAC;AAAA,MACH,CAAC;AAAA,IACH;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,QAAQ,MAAM,aAAa;AAAA,EAC7B;AACF;AAOA,IAAI,yBAAyB,CAAC;AAAA,EAC5B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,SAAS;AACf,QAAM,eAAe,eAAAI,OAAQ,KAAK,KAAK,OAAO;AAC9C,QAAM,yBAAyB,sBAAsB;AACrD,QAAM,+BAA+B,eAAAA,OAAQ;AAAA,IAC3C,uBAAuB,SAAS,EAAE;AAAA,IAClC;AAAA,EACF;AACA,QAAM,uBAAuB,eAAAA,OAAQ,KAAK,uBAAuB,OAAO;AACxE,QAAM,eAAe,eAAAA,OAAQ,KAAK,QAAQ,OAAO;AACjD,QAAM,sBAAsB,eAAAA,OAAQ,KAAK,eAAe,OAAO;AAC/D,QAAM,gBAAgB,eAAAA,OAAQ,OAAO;AAAA,IACnC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC;AACD,QAAM,cAAc,QAAQ,aAAa,EAAE,IAAI,CAAC,UAAU;AACxD,qCAAQ,MAAM;AAAA,MACZ,QAAQ;AAAA,MACR,iBAAiB;AAAA,QACf;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAAA,MACA,cAAc;AAAA,QACZ,aAAa,SAAS,KAAK;AAAA,QAC3B,oBAAoB,SAAS,KAAK;AAAA,QAClC,6BAA6B,SAAS,KAAK;AAAA,QAC3C,qBAAqB,SAAS,KAAK;AAAA,QACnC,aAAa,SAAS,KAAK;AAAA,MAC7B;AAAA,MACA,SAAS,cAAc,SAAS,KAAK;AAAA,MACrC,aAAa,MAAM,SAAS,KAAK;AAAA,IACnC;AACA,WAAO,eAAAA,OAAQ,KAAK,KAAK,EAAE,SAAS,KAAK;AAAA,EAC3C,CAAC,EAAE,OAAO,CAAC,aAAa,EAAE,QAAQ,uBAAuB,QAAQ,EAAE;AACnE,SAAO;AACT;AAGA,IAAI,eAAe;AAAA,EACjB,MAAM;AACR;AACA,IAAI,iBAAiB,CAAC,UAAU;AAC9B,QAAM,EAAE,eAAe,cAAc,IAAI,MAAM;AAC/C,QAAM,oBAAoB,CAAC,WAAW,GAAI,cAAc,MAAM,CAAC;AAC/D,QAAM,cAAc,CAAC,SAAS,cAAc,YAAY,IAAI,EAAE;AAAA,IAC5D,CAACH,cAAaA,YAAW,kBAAkBA,UAAS,MAAM,IAAI,QAAS,MAAM;AAAA,EAC/E;AACA,QAAM,iBAAiB,CAAC,SAAS,GAAI,cAAc,CAAC,EAAE;AAAA,IACpD,CAAC,YAAY,cAAc,SAAS;AAAA,MAClC,CAAC,IAAI,GAAG;AAAA,QACN,QAAQ,QAAQ,cAAc;AAAA,QAC9B,WAAW,KAAK,IAAI;AAAA,MACtB;AAAA,IACF,CAAC,EAAE,IAAI,MAAM,OAAO;AAAA,EACtB;AACA,QAAM,sBAAsB,CAAC,SAAS,YAAY,IAAI,EAAE,QAAQ,CAAC,YAAY,UAAU,QAAS,OAAO,IAAI,eAAe,IAAI,CAAC,EAAE,OAAO,CAAC,WAAW;AAAA,IAClJ,QAAQ;AAAA,IACR,SAAS;AAAA,EACX,EAAE;AACF,QAAM,qBAAqB,CAAC,MAAM,cAAc,YAAY,IAAI,EAAE,OAAO,OAAO,EAAE,QAAQ,6BAA6B,EAAE,EAAE;AAAA,IACzH,CAACA,cAAaA,YAAWA,UAAS,OAAO,sBAAsB,WAAW,MAAM,qBAAqB,EAAE,OAAO,OAAO;AAAA,MACnH,QAAQ;AAAA,IACV,EAAE,IAAI,IAAK,EAAE,QAAQ,uBAAuB,CAAC;AAAA,EAC/C;AACA,QAAM,kBAAkB,CAAC;AAAA,IACvB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAM,oBAAoB,IAAI,EAAE;AAAA,IAC9B,CAACA,cAAa,uBAAuB;AAAA,MACnC;AAAA,MACA;AAAA,MACA;AAAA,MACA,QAAQ,MAAM;AAAA,IAChB,CAAC,EAAE;AAAA,MACD,CAAC,YAAYA,UAAS,QAAQ,KAAK,OAAO,EAAE,IAAI,CAAC,eAAe;AAAA,QAC9D;AAAA,QACA,WAAWA,UAAS,OAAO,aAAa;AAAA,QACxC,UAAUA,UAAS,QAAQ,aAAa;AAAA,MAC1C,EAAE,EAAE,OAAO,CAAC,WAAW;AAAA,QACrB,QAAQ;AAAA,QACR,SAAS;AAAA,MACX,EAAE;AAAA,IACJ;AAAA,EACF;AACA,SAAO;AAAA,IACL,KAAK,CAAC,SAAS,oBAAoB,IAAI;AAAA,IACvC;AAAA,IACA;AAAA,EACF;AACF;AAGA,IAAI,gBAAgB;AAAA,EAClB,MAAM;AAAA,EACN,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,UAAU;AAAA,EACV,WAAW;AAAA;AAAA;AAAA;AAAA,EAIX,eAAe;AACjB;AAMA,IAAI,YAAY;AAAA,EACd,gBAAgB;AAAA,EAChB,kBAAkB;AAAA,EAClB,gBAAgB;AAAA,EAChB,yBAAyB;AAAA,EACzB,0BAA0B;AAAA,EAC1B,cAAc;AAAA,EACd,4BAA4B;AAAA,EAC5B,4BAA4B;AAAA,EAC5B,yBAAyB;AAAA,EACzB,2BAA2B;AAAA,EAC3B,kCAAkC;AAAA,EAClC,kCAAkC;AAAA,EAClC,gDAAgD;AAAA,EAChD,kDAAkD;AAAA,EAClD,6CAA6C;AAAA,EAC7C,kBAAkB;AAAA,EAClB,gBAAgB;AAAA,EAChB,mBAAmB;AAAA,EACnB,8BAA8B;AAAA,EAC9B,gBAAgB;AAClB;AACA,IAAI,uBAAuC,oBAAI,IAAI,GAAG,IAAI,UAAU,kBAAkB,8BAA8B,EAAE,IAAI,UAAU,gBAAgB,uBAAuB,EAAE,IAAI,UAAU,gBAAgB,+BAA+B;AAC1O,IAAI,WAAW,CAAC,OAAO,eAAe,SAAS,aAAa;AAAA,EAC1D;AAAA,EACA;AAAA,EACA,SAAS,WAAW,oBAAoB,IAAI,KAAK,KAAK;AAAA,EACtD;AACF;AAIA,IAAI,oBAAoB,CAAC,UAAU;AA72DnC,MAAAD;AA82DE,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa,EAAE,MAAM,oBAAoB;AACvE,QAAM,gBAAgB,IAAI,aAAc;AACxC,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,UAA0B,oBAAI,IAAI;AACxC,QAAM,aAAa,CAAC;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,EACF,OAAO;AAAA,IACL;AAAA,IACA,QAAQ;AAAA,IACR,WAAW,KAAK,IAAI;AAAA,IACpB,eAAe,kBAAkB;AAAA,IACjC,YAAY;AAAA,IACZ;AAAA,IACA;AAAA,EACF;AACA,QAAMK,OAAM,CAAC,OAAO,aAAa;AAC/B,UAAM,OAAO,WAAW,KAAK;AAC7B,qCAAQ,MAAM;AAAA,MACZ,QAAQ;AAAA,MACR;AAAA,IACF;AACA,QAAI,UAAU;AACZ,cAAQ,IAAI,KAAK,eAAe,QAAQ;AAAA,IAC1C;AACA,WAAO,cAAc,SAAS,EAAE,CAAC,KAAK,aAAa,GAAG,KAAK,CAAC,EAAE,IAAI,MAAM,IAAI;AAAA,EAC9E;AACA,QAAM,qBAAqB,CAAC,kBAAkB;AAC5C,QAAI,QAAQ,IAAI,aAAa,GAAG;AAC9B,YAAM,SAAS,QAAQ,IAAI,aAAa;AACxC,cAAQ,OAAO,aAAa;AAC5B,aAAO;AAAA,IACT;AAAA,EACF;AACA,QAAM,QAAQ,CAAC,IAAI,iBAAiB;AAClC,qCAAQ,MAAM;AAAA,MACZ,QAAQ;AAAA,MACR,MAAM,EAAE,IAAI,GAAG,aAAa;AAAA,IAC9B;AACA,WAAO,cAAc,UAAU,IAAI,YAAY;AAAA,EACjD;AACA,QAAM,SAAS,CAAC,OAAO;AACrB,qCAAQ,MAAM,EAAE,QAAQ,qBAAqB,GAAG;AAChD,WAAO,MAAM,IAAI,EAAE,QAAQ,QAAQ,OAAO,UAAU,eAAe,CAAC;AAAA,EACtE;AACA,QAAM,8BAA8B,CAAC,WAAW,CAAC,cAAc,SAAS,cAAc,aAAa,EAAE;AAAA,IACnG;AAAA,EACF;AACA,QAAM,eAAe,CAAC;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW,CAAC;AAAA,IACZ;AAAA,IACA;AAAA,EACF,MAAM;AACJ,WAAO,cAAc,YAAY,EAAE,EAAE,OAAO,OAAO,EAAE,QAAQ,wBAAwB,EAAE,EAAE,QAAQ,CAAC,SAAS;AACzG,UAAI,MAAM;AACR,YAAI,WAAW,cAAc,WAAW,QAAQ,IAAI,EAAE,GAAG;AACvD,kBAAQ,OAAO,EAAE;AAAA,QACnB;AACA,YAAI,WAAW,cAAc,SAAS;AACpC,gBAAM,SAAS,mBAAmB,EAAE;AACpC,2CAAS,qCAAU;AAAA,QACrB;AACA,cAAM,UAAU;AAAA,UACd,GAAG;AAAA,UACH;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA,QAAQ,KAAK,WAAW,cAAc,UAAU,KAAK,SAAS;AAAA,UAC9D,UAAU,KAAK,WAAW,EAAE,GAAG,KAAK,UAAU,GAAG,SAAS,IAAI;AAAA,QAChE;AACA,YAAI,CAAC,4BAA4B,QAAQ,MAAM,GAAG;AAChD,iBAAO,QAAQ;AAAA,QACjB;AACA,yCAAQ,MAAM,EAAE,QAAQ,2BAA2B,QAAQ;AAC3D,eAAO,cAAc,SAAS,EAAE,CAAC,EAAE,GAAG,QAAQ,CAAC,EAAE,OAAO,OAAO,EAAE,QAAQ,uBAAuB,EAAE;AAAA,MACpG;AACA,aAAO,SAAS,EAAE,QAAQ,eAAe,CAAC;AAAA,IAC5C,CAAC;AAAA,EACH;AACA,QAAM,mBAAmB,MAAM,cAAc,YAAY,EAAE;AAAA,IACzD,CAAC,UAAU,MAAM,OAAO,CAAC,SAAS,KAAK,WAAW,cAAc,aAAa;AAAA,EAC/E;AACA,QAAM,aAAa,MAAM,cAAc,YAAY,EAAE,IAAI,CAAC,UAAU,MAAM,OAAO,CAAC,SAAS,KAAK,WAAW,SAAS,CAAC;AACrH,QAAM,YAAY,cAAc,SAAS;AAAA,IACvC,UAAU,MAAM,cAAc,YAAY,CAAC;AAAA,IAC3C,IAAI,CAAC,WAAW;AACd,UAAI,OAAO,KAAK,EAAG,QAAO,OAAO;AAAA,IACnC,CAAC;AAAA,IACD,OAAQ,CAAC,UAAU,CAAC,CAAC,KAAK;AAAA,EAC5B;AACA,SAAO;AAAA,IACL,KAAAA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,CAAC,OAAO,cAAc,YAAY,EAAE;AAAA,IAC7C;AAAA,IACA;AAAA,IACA;AAAA,IACA,OAAO,cAAc;AAAA,IACrB,SAAS,MAAM;AACb,oBAAc,YAAY;AAAA,IAC5B;AAAA,EACF;AACF;AAKA,IAAI,gBAAgB,CAAC,UAAU;AAC7B,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,aAAa,MAAM,cAAc,YAAY,EAAE,OAAO,CAAC,WAAW;AAAA,IACtE,QAAQ;AAAA,IACR,SAAS;AAAA,EACX,EAAE,EAAE,IAAI,CAAC,aAAa,SAAS,CAAC,CAAC;AACjC,QAAM,iBAAiB,CAAC,cAAc,cAAc,YAAY,SAAS,EAAE,OAAO,CAAC,WAAW,EAAE,QAAQ,0BAA0B,SAAS,MAAM,EAAE;AACnJ,QAAM,gBAAgB,MAAM;AAC1B,UAAM,YAAY,WAAO;AACzB,UAAM,aAAa;AAAA,MACjB;AAAA,MACA,WAAW,KAAK,IAAI;AAAA,IACtB;AACA,WAAO,cAAc,SAAS,EAAE,CAAC,SAAS,GAAG,WAAW,CAAC,EAAE,IAAI,MAAM,UAAU,EAAE,OAAO,CAAC,WAAW,EAAE,QAAQ,yBAAyB,SAAS,MAAM,EAAE;AAAA,EAC1J;AACA,QAAM,eAAe,CAAC,WAAW,UAAU,cAAc,UAAU,WAAW,KAAK,EAAE,OAAO,CAAC,WAAW,EAAE,QAAQ,wBAAwB,SAAS,MAAM,EAAE;AAC3J,QAAM,oBAAoB,MAAM,WAAW,EAAE;AAAA,IAC3C,CAAC,YAAY,UAAU,QAAS,OAAO,IAAI,cAAc;AAAA,EAC3D;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,OAAO;AAAA,IACP;AAAA,IACA;AAAA,EACF;AACF;AAIA,IAAI,6BAA6B,OAAO;AAAA,EACtC,wBAAwB,IAAI,QAAS;AAAA,EACrC,wBAAwB,IAAI,QAAS;AAAA,EACrC,iBAAiB,IAAI,QAAS;AAAA,EAC9B,8BAA8B,IAAI,QAAS;AAC7C;AA2BA,IAAI,qBAAqB,CAAC;AAAA,EACxB,eAAe;AAAA,EACf,aAAa;AAAA,EACb,SAAAC;AAAA,EACA,UAAAC,YAAW;AACb,IAAI,CAAC,MAAM;AACT,QAAM,UAAU,IAAI,QAAS;AAC7B,QAAM,OAAO,IAAI,QAAS;AAC1B,MAAI,kBAAkB;AACtB,QAAM,WAAW;AAAA,IACf,GAAG,CAAC;AAAA,IACJ,QAAQ;AAAA,MACN,IAAK,MAAM;AACT,0BAAkB,kBAAkB;AACpC,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AAAA,EACF,EAAE;AAAA,IACA,UAAW,CAAC,qBAAqB;AAC/B,YAAM,YAAY,mBAAmBA,YAAW;AAChD,YAAM,SAAS,YAAY,eAAe,eAAe;AACzD,aAAO,MAAM,MAAM,EAAE,KAAK,IAAK,MAAM,GAAI,gBAAgB,CAAC,CAAC;AAAA,IAC7D,CAAC;AAAA,EACH;AACA,QAAM,yBAAyB;AAAA,IAC7B,KAAK,aAAa,EAAE,KAAK,IAAK,MAAM,IAAK,EAAE,OAAO,UAAU,CAAC,CAAC,CAAC;AAAA,IAC/DD,WAAU;AAAA,MACR;AAAA,MACA,MAAMA,QAAO,EAAE,KAAK,IAAK,MAAM,IAAK,EAAE,OAAO,UAAU,CAAC,CAAC,CAAC;AAAA,IAC5D,IAAI;AAAA,EACN;AACA,SAAO;AAAA,IACL;AAAA,IACA,cAAc;AAAA,IACd,MAAM,MAAM,KAAK,KAAK;AAAA,EACxB;AACF;AAOA,IAAI,YAAY,CAAC,SAAS;AACxB,MAAI;AACF,WAAO,GAAI,KAAK,MAAM,IAAI,CAAC;AAAA,EAC7B,SAAS,OAAO;AACd,WAAO,IAAK,KAAK;AAAA,EACnB;AACF;AAGA,IAAI,aAAa,CAAC,UAAU;AAC5B,IAAI,eAAe,CAAC,cAAc,YAAa,YAAY,WAAW,UAAU,EAAE,OAAO,CAAC,WAAW;AAAA,EACnG,QAAQ;AAAA,EACR;AAAA,EACA,QAAQ;AACV,EAAE;AACF,IAAI,eAAe,CAAC,cAAc,aAAa,SAAS,EAAE;AAAA,EACxD,CAAC,aAAa,YAAa,YAAY,SAAS,KAAK,GAAG,UAAU,EAAE,QAAQ,CAAC,SAAS,OAAO,UAAU,IAAI,IAAI,QAAS,IAAI,CAAC,EAAE,OAAO,CAAC,WAAW;AAAA,IAChJ,QAAQ,SAAS;AAAA,IACjB,QAAQ;AAAA,IACR;AAAA,EACF,EAAE,EAAE;AAAA,IACF,CAAC,SAAS,SAAS,KAAK,QAAS;AAAA,MAC/B,QAAQ,SAAS;AAAA,MACjB;AAAA,IACF,CAAC,IAAI,SAAU;AAAA,MACb,QAAQ,SAAS;AAAA,MACjB,QAAQ;AAAA,MACR;AAAA,IACF,CAAC;AAAA,EACH;AACF;AAIA,IAAIE,UAAS,CAAC,aAAa,IAAI,OAAS;AAAA,EACtC,UAAU,YAAY;AAAA,EACtB,mBAAmB;AACrB,CAAC;AAID,IAAI,YAAY,CAAC,UAAU;AACzB,MAAI;AACF,WAAO,GAAI,KAAK,UAAU,KAAK,CAAC;AAAA,EAClC,SAAS,OAAO;AACd,WAAO,IAAK,KAAK;AAAA,EACnB;AACF;AAGA,IAAI,kBAAkB,CAAC,UAAU,UAAU,KAAK,EAAE,QAAQ,SAAS;AAGnE,IAAI,cAAc,CAAC,UAAU;AAK7B,IAAI,mBAAmB,CAAC,UAAU,YAAa;AAAA,EAC7C,eAAe,KAAK;AAAA,EACpB,CAAC,UAAU;AACb,EAAE,QAAQ,CAAC,WAAW,MAAM;AAK5B,IAAI,yBAAyB,CAAC,mBAAmB;AAC/C,QAAM,KAAK,OAAQ;AAAA,IACjB,CAAC,MAAM,MAAM,2BAA2B,CAAC;AAAA,IACzC,CAAC,UAAU;AAAA,EACb;AACA,SAAO,GAAG,cAAc,EAAE;AAAA,IACxB,CAAC,aAAa;AAAA,MACZ;AAAA,MACA,iDAAgB;AAAA,MAChB;AAAA,MACA;AAAA,IACF;AAAA,EACF;AACF;AAGA,IAAI,wBAAwB,MAAM,CAAC,GAAG,WAAW,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,CAAC,EAAE,IAAI,CAAC,MAAM,EAAE,SAAS,EAAE,EAAE,SAAS,GAAG,GAAG,CAAC,EAAE,KAAK,EAAE;AAGhJ,IAAI,wBAAwB,CAAC,cAAc,OAAO,cAAc,YAAY,kBAAkB,KAAK,SAAS;AAI5G,IAAI,uBAAuB,CAAC,UAAU,UAAU,iBAAiB,KAAK;AAItE,IAAI,2BAA2B,CAAC,UAAU;AAxqE1C,MAAAR;AAyqEE,MAAI,8BAA8B;AAClC,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa;AAAA,IACzC,MAAM;AAAA,EACR;AACA,QAAM,YAAW,+BAAO,aAAY,2BAA2B;AAC/D,QAAM,eAAe,IAAI,aAAc;AACvC,QAAM,0BAAyB,+BAAO,2BAA0B;AAChE,QAAM,wBAAwB,MAAM,UAAU;AAC9C,QAAM,UAAU,MAAM,UAAU,cAAc,aAAa,oBAAoB;AAC/E,eAAa;AAAA,IACX,SAAS,uBAAuB;AAAA,MAC9B,IAAI,CAAC,YAAY;AACf,yCAAQ,MAAM;AAAA,UACZ,QAAQ;AAAA,UACR;AAAA,QACF;AACA,YAAI,eAAe,SAAS;AAC1B,mBAAS,6BAA6B,KAAK,OAAO;AAAA,QACpD,OAAO;AACL,mBAAS,gBAAgB,KAAK,OAAO;AAAA,QACvC;AAAA,MACF,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,eAAa;AAAA,IACX,SAAS,gBAAgB;AAAA,MACvB;AAAA,QACE,CAAC,mBAAmB,KAAK,sBAAsB,mBAAmB,CAAC,cAAc,CAAC,CAAC;AAAA,MACrF;AAAA,IACF,EAAE,UAAU;AAAA,EACd;AACA,eAAa;AAAA,IACX,SAAS,uBAAuB;AAAA,MAC9B,IAAI,CAAC,YAAY;AACf,yCAAQ,MAAM;AAAA,UACZ,QAAQ;AAAA,UACR;AAAA,QACF;AACA,cAAM,UAAU,kBAAkB,WAAW;AAAA,UAC3C,IAAI,YAAY,UAAU,iBAAiB;AAAA,YACzC,QAAQ;AAAA,UACV,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,QAAM,0BAA0B,CAAC,gBAAgB;AAC/C,QAAI,CAAC,6BAA6B;AAChC,aAAO,QAAS,WAAW;AAAA,IAC7B;AACA,WAAO,QAAQ,SAAS,EAAE,QAAQ,CAAC,UAAU;AAC3C,YAAM,sBAAsB,YAAY,MAAM,kBAAkB;AAChE,YAAM,YAAY,uBAAsB,+BAAO,cAAa,WAAQ,IAAI,+BAAO;AAC/E,YAAM,iBAAiB;AAAA,QACrB,eAAe,YAAY;AAAA,QAC3B;AAAA,QACA;AAAA,QACA,eAAe;AAAA,MACjB;AACA,aAAO,sBAAsB,QAAQ,SAAS,EAAE,UAAU,CAAC,EAAE,IAAI,MAAM,cAAc,IAAI,QAAS,cAAc;AAAA,IAClH,CAAC;AAAA,EACH;AACA,QAAM,wBAAwB,CAAC,UAAU;AACvC,UAAM,UAAU,MAAM;AACtB,aAAS,uBAAuB,KAAK,OAAO;AAAA,EAC9C;AACA,mBAAiB,UAAU,iBAAiB,qBAAqB;AACjE,QAAM,wBAAwB,CAAC,mBAAmB,gBAAgB;AAChE,UAAM,uBAAuB,IAAI,QAAS;AAC1C,UAAM,iBAAiB;AAAA,MACrB,sBAAsB;AAAA,QACpB,kBAAkB;AAAA,MACpB;AAAA,IACF,EAAE,KAAK,OAAQ,CAAC,WAAW,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO,KAAK,CAAC;AAC3D,UAAM,kBAAkB,SAAS,gBAAgB;AAAA,MAC/C;AAAA,QACE,CAAC,aAAa,SAAS,kBAAkB,kBAAkB;AAAA,MAC7D;AAAA,MACA,IAAK,CAAC,mBAAmB,GAAI,cAAc,CAAC;AAAA,IAC9C;AACA,UAAM,kBAAkB,SAAS,6BAA6B;AAAA,MAC5D;AAAA,QACE,CAAC,EAAE,eAAe,WAAW,WAAW,MAAM,kBAAkB,kBAAkB,iBAAiB,CAAC,wBAAwB,mBAAmB,EAAE,SAAS,UAAU;AAAA,MACtK;AAAA,MACA,IAAK,CAAC,YAAY;AAChB,cAAM,QAAQ,SAAS,kBAAkB,QAAQ,aAAa;AAC9D,yCAAQ,MAAM,+BAAqD;AACnE,eAAO;AAAA,MACT,CAAC;AAAA,IACH;AACA,UAAM,oBAAoB,MAAM;AAC9B,eAAS,uBAAuB,KAAK;AAAA,QACnC,eAAe,kBAAkB;AAAA,QACjC,UAAU,kBAAkB;AAAA,QAC5B,GAAG,8BAA8B,EAAE,eAAe,0BAA0B,IAAI,EAAE,OAAO,EAAE,eAAe,gBAAgB,EAAE;AAAA,MAC9H,CAAC;AACD,iBAAW,MAAM;AACf,6BAAqB;AAAA,UACnB,IAAK,SAAS,kBAAkB,kBAAkB,aAAa,CAAC;AAAA,QAClE;AAAA,MACF,CAAC;AACD,aAAO,YAAa;AAAA,QAClB;AAAA,UACE;AAAA,YACE,gBAAgB,KAAK,IAAK,MAAM,mBAAmB,CAAC;AAAA,YACpD,gBAAgB,KAAK,IAAK,CAAC,EAAE,WAAW,WAAW,MAAM,UAAU,CAAC;AAAA,UACtE;AAAA,QACF;AAAA,MACF;AAAA,IACF;AACA,QAAI,YAAY;AACd,kBAAY,eAAe;AAAA,QACzB,eAAe,MAAM,kBAAkB,EAAE;AAAA,UACvC,CAAC,eAAe,eAAe,yBAAyB,GAAI,sBAAsB,IAAI,IAAK,mBAAmB;AAAA,QAChH;AAAA,QACA,YAAY,MAAM;AAAA,MACpB,CAAC;AACH,UAAM,iCAAiC;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,IACF,EAAE,KAAK,MAAM,CAAC;AACd,UAAM,yBAAyB,SAAS,6BAA6B;AAAA,MACnE;AAAA,QACE,CAAC,EAAE,cAAc,MAAM,kBAAkB,kBAAkB;AAAA,MAC7D;AAAA,MACA,IAAI,CAAC,UAAU;AACb,YAAI,YAAY;AACd,sBAAY,cAAc,MAAM,SAAS;AAAA,MAC7C,CAAC;AAAA,MACD,UAAU,eAAe;AAAA,MACzB,MAAM;AAAA,IACR;AACA,UAAM,2BAA2B,uBAAuB,UAAU;AAClE,UAAM,yBAAyB,MAAO,sBAAsB,EAAE;AAAA,MAC5D;AAAA,QACE,MAAM,IAAK,SAAS,oBAAoB,kBAAkB,aAAa,CAAC;AAAA,MAC1E;AAAA,IACF;AACA,UAAM,yBAAyB;AAAA,MAC7B;AAAA,MACA;AAAA,IACF,EAAE;AAAA,MACA,MAAM;AAAA,MACN,OAAQ,CAAC,UAAU,EAAE,eAAe,MAAM;AAAA,IAC5C;AACA,UAAM,qBAAqB,iBAAiB;AAAA,MAC1C,OAAQ,CAAC,WAAW,OAAO,oBAAoB;AAAA,MAC/C,UAAW,MAAM,GAAI,wBAAwB,iBAAiB,CAAC,CAAC;AAAA,MAChE,IAAI,CAAC,WAAW;AACd,eAAO,IAAI,CAAC,YAAY;AACtB,mBAAS,uBAAuB,KAAK,OAAO;AAAA,QAC9C,CAAC;AAAA,MACH,CAAC;AAAA,MACD,OAAQ,CAAC,MAAM,KAAK;AAAA,IACtB;AACA,WAAO;AAAA,MACL;AAAA,QACE;AAAA,QACA;AAAA,QACA;AAAA,MACF,EAAE;AAAA,QACA,IAAI,MAAM;AACR,mCAAyB,YAAY;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF;AACA,QAAM,wBAAwB,SAAS,6BAA6B;AAAA,IAClE;AAAA,MACE,CAAC,UAAU,MAAM,cAAc;AAAA,IACjC;AAAA,EACF;AACA,QAAM,mBAAmB,GAAI,IAAI,EAAE;AAAA,IACjC,IAAI,MAAM;AACR,eAAS,uBAAuB,KAAK;AAAA,QACnC,eAAe,WAAQ;AAAA,QACvB,eAAe;AAAA,MACjB,CAAC;AAAA,IACH,CAAC;AAAA,IACD;AAAA,MACE,MAAM;AAAA,QACJ;AAAA,QACA;AAAA,UACE;AAAA,UACA,MAAO,sBAAsB,EAAE;AAAA,YAC7B;AAAA,cACE,OAAO;AAAA,gBACL,WAAW;AAAA,gBACX,gBAAgB;AAAA,gBAChB,sBAAsB;AAAA,gBACtB,mBAAmB;AAAA,cACrB;AAAA,YACF;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,IACA,IAAI,CAAC,UAAU;AACb,oCAA8B,MAAM,qBAAqB;AAAA,IAC3D,CAAC;AAAA,IACD,YAAY,CAAC;AAAA,EACf;AACA,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,aAAa,MAAM,CAAC,MAAM,UAAU,kBAAkB,SAAS;AAAA,IAC/D,MAAM;AAAA,IACN,cAAc,iBAAiB;AAAA,MAC7B,IAAK,CAAC,EAAE,qBAAqB,MAAM,oBAAoB;AAAA,IACzD;AAAA,IACA,WAAW,iBAAiB;AAAA,MAC1B,IAAK,CAAC,EAAE,eAAe,MAAM,cAAc;AAAA,IAC7C;AAAA,IACA,YAAY,MAAM;AAChB,YAAM,UAAU,kBAAkB,WAAW;AAAA,QAC3C,IAAI,YAAY,UAAU,iBAAiB;AAAA,UACzC,QAAQ,EAAE,eAAe,YAAY;AAAA,QACvC,CAAC;AAAA,MACH;AAAA,IACF;AAAA,IACA,YAAY,MAAM;AAChB,cAAQ,MAAM;AAAA,IAChB;AAAA,IACA,SAAS,MAAM;AACb,mBAAa,YAAY;AACzB,0BAAoB,UAAU,iBAAiB,qBAAqB;AAAA,IACtE;AAAA,EACF;AACF;AAIA,IAAI,iBAAiB,CAAC,UAAU;AAj5EhC,MAAAA;AAk5EE,QAAM,EAAE,UAAU,IAAI;AACtB,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa,EAAE,MAAM,iBAAiB;AACpE,QAAM,oBAAoB,MAAM,UAAU,kBAAkB,MAAM;AAClE,QAAM,mBAAmB,CAAC,WAAW;AAr5EvC,QAAAA;AAs5EI,UAAM,cAAc,IAAI,IAAI,SAAS;AACrC,WAAO,QAAQ,MAAM,EAAE,QAAQ,CAAC,CAAC,KAAK,KAAK,MAAM;AAC/C,kBAAY,aAAa,OAAO,KAAK,KAAK;AAAA,IAC5C,CAAC;AACD,qCAAQ,MAAM;AAAA,MACZ,QAAQ;AAAA,MACR,MAAM,EAAE,GAAG,OAAO;AAAA,IACpB;AACA,QAAI,MAAM,UAAU,kBAAkB,SAAS,GAAG;AAChD,YAAM,WAAW,YAAY,SAAS;AACtC,UAAI;AACF,cAAM,UAAU,kBAAkB,WAAW,KAAK,UAAU,QAAQ;AAAA,gBAC7DA,MAAA,MAAM,UAAU,kBAAkB,WAAW,aAA7C,gBAAAA,IAAuD;AAC9D,cAAM,UAAU,kBAAkB,WAAW,SAAS,OAAO;AAC/D,aAAO,QAAS,MAAM;AAAA,IACxB;AACA,WAAO,SAAU,SAAS,wBAAwB,EAAE,CAAC;AAAA,EACvD;AACA,SAAO;AAAA,IACL;AAAA,EACF;AACF;AASA,IAAI,qBAAqB,CAACX,YAAW;AACnC,MAAI,SAAS;AACb,MAAI,kBAAkBA,QAAO;AAC7B,QAAM,iBAAiB,CAAC,cAAc;AACpC,QAAI,YAAY,EAAG,QAAO,IAAK,MAAM,kCAAkC,CAAC;AACxE,QAAI,cAAc,GAAG;AACnB,aAAO,GAAK,eAAAoB,OAAQ,MAAM,CAAC,CAAC;AAAA,IAC9B;AACA,QAAI,SAAS,YAAYpB,QAAO;AAC9B,aAAO,IAAK,MAAM,0BAA0B,CAAC;AAC/C,UAAM,cAAc,eAAAoB,OAAQ,MAAM,SAAS;AAC3C,IAAApB,QAAO,KAAK,aAAa,GAAG,QAAQ,SAAS,SAAS;AACtD,QAAI,YAAY,WAAW,WAAW;AACpC,aAAO,IAAK,MAAM,0CAA0C,CAAC;AAAA,IAC/D;AACA,cAAU;AACV,uBAAmB;AACnB,WAAO,GAAK,WAAW;AAAA,EACzB;AACA,QAAM,kBAAkB,MAAM;AAC5B,QAAI,kBAAkB,GAAG;AACvB,aAAO,IAAK,MAAM,gDAAgD,CAAC;AAAA,IACrE;AACA,WAAO,GAAK,oBAAoB,CAAC;AAAA,EACnC;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,gBAAgB,MAAM,gBAAgB,EAAE,QAAQ,CAAC,aAAa;AAC5D,UAAI,SAAU,QAAO,GAAK,eAAAoB,OAAQ,MAAM,CAAC,CAAC;AAC1C,YAAM,UAAU,eAAAA,OAAQ,MAAM,eAAe;AAC7C,MAAApB,QAAO,KAAK,SAAS,GAAG,MAAM;AAC9B,aAAO,GAAK,OAAO;AAAA,IACrB,CAAC;AAAA,EACH;AACF;AACA,IAAI,aAAa,CAACA,YAAW,mBAAmBA,OAAM,EAAE;AAKxD,IAAI,2BAA2B,CAACA,YAAW;AACzC,QAAM,iBAAiB,WAAWA,OAAM;AACxC,QAAM,cAAc;AACpB,QAAM,gBAAgB;AACtB,SAAO,OAAQ,QAAQ;AAAA,IACrB,eAAe,WAAW;AAAA,IAC1B,eAAeA,QAAO,SAAS,cAAc,aAAa;AAAA,IAC1D,eAAe,aAAa;AAAA,EAC9B,CAAC,EAAE,IAAI,CAAC,CAAC,IAAI,YAAY,OAAO,OAAO;AAAA,IACrC;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAU,eAAAqB,OAAQ,OAAO,CAAC,IAAI,YAAY,OAAO,CAAC;AAAA,IAClD,sBAAsB,eAAAA,OAAQ,OAAO,CAAC,YAAY,OAAO,CAAC;AAAA,EAC5D,EAAE;AACJ;AAKA,IAAI,mBAAmB,MAAM;AAC3B,QAAM,gBAAgB,CAAC,MAAM,eAAe,OAAO,YAAa;AAAA,IAC9D,OAAO,OAAO,QAAQ,EAAE,MAAM,WAAW,GAAG,GAAG,eAAe,IAAI;AAAA,IAClE;AAAA,EACF,EAAE,IAAI,eAAAC,OAAQ,IAAI;AAClB,QAAM,gBAAgB,CAAC,MAAM,eAAe,OAAO,YAAa;AAAA,IAC9D,OAAO,OAAO;AAAA,MACZ;AAAA,QACE,MAAM;AAAA,QACN;AAAA,MACF;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF,EAAE,IAAI,eAAAA,OAAQ,IAAI;AAClB,QAAM,SAAS,CAAC,kBAAkB,YAAa;AAAA,IAC7C,OAAO,OAAO;AAAA,MACZ;AAAA,MACA;AAAA,MACA;AAAA,QACE,MAAM;AAAA,QACN,QAAQ;AAAA,MACV;AAAA,MACA;AAAA,MACA,CAAC,WAAW,SAAS;AAAA,IACvB;AAAA,IACA;AAAA,EACF;AACA,QAAM,UAAU,CAAC,MAAM,eAAe,OAAO,OAAO,aAAa,EAAE;AAAA,IACjE,CAAC,cAAc,cAAc,MAAM,WAAW,EAAE;AAAA,EAClD;AACA,QAAM,UAAU,CAAC,MAAM,eAAe,KAAK,SAAS,MAAM,OAAO,aAAa,EAAE,QAAQ,CAAC,cAAc,cAAc,MAAM,WAAW,EAAE,CAAC,EAAE,IAAI,CAAC,gBAAgB;AAAA,IAC9J,UAAU,eAAAA,OAAQ,OAAO,CAAC,IAAI,UAAU,CAAC;AAAA,IACzC;AAAA,IACA;AAAA,EACF,EAAE;AACF,QAAM,WAAW,MAAM,eAAAA,OAAQ,KAAK,OAAO,gBAAgB,IAAI,WAAW,EAAE,CAAC,CAAC;AAC9E,SAAO,EAAE,SAAS,SAAS,SAAS;AACtC;AAGA,IAAI,8BAA8B,CAAC,UAAU;AA3hF7C,MAAAX;AA4hFE,QAAM,UAAU,MAAM;AACtB,QAAM,UAASA,MAAA,MAAM,WAAN,gBAAAA,IAAc,aAAa,EAAE,MAAM,uBAAuB;AACzE,QAAM,UAAU,CAAC,SAAS;AACxB,qCAAQ,MAAM,EAAE,QAAQ,WAAW,KAAK,MAAM,IAAI,KAAK;AACvD,WAAO;AAAA,MACL,MAAM,SAAS;AAAA,QACb,QAAQ;AAAA,QACR,MAAM,KAAK,UAAU,IAAI;AAAA,MAC3B,CAAC;AAAA,IACH,EAAE,IAAI,CAAC,aAAa;AAClB,uCAAQ,MAAM;AAAA,QACZ,QAAQ,WAAW,KAAK,MAAM;AAAA,QAC9B;AAAA,MACF;AACA,aAAO;AAAA,IACT,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,uCAAQ,MAAM;AAAA,QACZ,QAAQ,WAAW,KAAK,MAAM;AAAA,QAC9B;AAAA,MACF;AACA,aAAO;AAAA,QACL;AAAA,QACA,KAAK,iBAAiB;AAAA,MACxB;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,eAAe,CAAC,cAAc,QAAQ;AAAA,IAC1C,QAAQ;AAAA,IACR;AAAA,EACF,CAAC,EAAE,IAAI,CAAC,UAAU,MAAM,IAAI;AAC5B,SAAO;AAAA,IACL;AAAA,EACF;AACF;AAIA,IAAI,kBAAkB,CAAC,UAAU,iBAAAY,QAAU,OAAO,OAAO,KAAK,KAAK,UAAU,KAAK,CAAC,CAAC;AAGpF,IAAI,0BAA0B,CAAC,UAAU;AApkFzC,MAAAZ;AAqkFE,QAAM,UAASA,MAAA,MAAM,WAAN,gBAAAA,IAAc,aAAa,EAAE,MAAM,0BAA0B;AAC5E,QAAM,EAAE,SAAS,WAAW,UAAU,IAAI;AAC1C,QAAM,EAAE,eAAe,sBAAsB,IAAI;AACjD,QAAM,oBAAmB,uCAAW,qBAAoB,iBAAiB;AACzE,QAAM,kBAAiB,uCAAW,mBAAkB,eAAe;AAAA,IACjE;AAAA,IACA;AAAA,IACA,WAAW;AAAA,MACT,mBAAmB,MAAM,UAAU;AAAA,IACrC;AAAA,EACF,CAAC;AACD,QAAM,kBAAiB,uCAAW,mBAAkB,eAAe;AAAA,IACjE;AAAA,IACA,uBAAuB,MAAM;AAAA,IAC7B,WAAW;AAAA,MACT,eAAe,cAAc,aAAa,YAAY;AAAA,MACtD,eAAe;AAAA,IACjB;AAAA,EACF,CAAC;AACD,QAAM,iBAAgB,uCAAW,kBAAiB,cAAc;AAAA,IAC9D,WAAW;AAAA,MACT,eAAe,cAAc,aAAa,UAAU;AAAA,IACtD;AAAA,EACF,CAAC;AACD,QAAM,8BAA8B,4BAA4B;AAAA,IAC9D,SAAS,GAAG,OAAO;AAAA,IACnB;AAAA,EACF,CAAC;AACD,QAAM,gBAAgB,IAAI,aAAc;AACxC,QAAM,OAAO,CAAC,SAAS,SAAS,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,MAAM,CAAC;AACpF,QAAM,wBAAwB,CAAC,mBAAmB;AAChD,QAAI,WAAW,gBAAgB;AAC7B,aAAO,SAAU,EAAE,QAAQ,eAAe,MAAM,CAAC;AAAA,IACnD;AACA,WAAO,eAAe,IAAI,MAAM,EAAE;AAAA,MAChC,CAAC,iBAAiB,aAAa,OAAO;AAAA,QACpC,eAAe;AAAA,QACf,MAAM;AAAA,MACR,EAAE,OAAO,OAAO,EAAE,QAAQ,6BAA6B,EAAE,EAAE;AAAA,QACzD,CAAC,iBAAiB,0BAA0B,cAAc,eAAe,IAAI;AAAA,MAC/E;AAAA,IACF;AAAA,EACF;AACA,QAAM,iBAAiB,YAAY;AACjC,UAAM,sBAAsB,qBAAqB,EAAE;AAAA,MACjD,MAAM,cAAc,kBAAkB,EAAE,IAAI,CAAC,YAAY,QAAQ,SAAS,EAAE,QAAQ,4BAA4B,YAAY,EAAE;AAAA,QAC5H,CAAC,cAAc,YAAa,QAAQ,UAAU,IAAI,qBAAqB,CAAC;AAAA,MAC1E,EAAE,QAAQ,sBAAsB,kBAAkB;AAAA,IACpD;AACA,UAAM,KAAK;AACX,mBAAe;AAAA,EACjB;AACA,MAAI,MAAM,UAAU,kBAAkB,SAAS,GAAG;AAChD,mBAAe;AAAA,EACjB;AACA,QAAM,+BAA+B,CAAC;AAAA,IACpC;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,UAAAC;AAAA,EACF,MAAM,sBAAsB,sBAAsB,kBAAkB,aAAa,EAAE;AAAA,IACjF,MAAM,sBAAsB;AAAA,MAC1B,kBAAkB;AAAA,IACpB;AAAA,EACF,EAAE;AAAA,IACA,MAAM,eAAe,iBAAiB;AAAA,MACpC,WAAW,QAAQ;AAAA,MACnB,SAAS,gBAAgB,iBAAiB;AAAA,MAC1C;AAAA,MACA;AAAA,MACA,UAAAA;AAAA,MACA,QAAQ,kBAAkB,SAAS;AAAA,MACnC,uBAAuB,kBAAkB,SAAS;AAAA,IACpD,CAAC;AAAA,EACH,EAAE;AAAA,IACA,MAAM,SAAS,2BAA2B,kBAAkB,aAAa;AAAA,EAC3E;AACA,QAAM,eAAe,CAAC,mBAAmB,gBAAgB,YAAa,QAAQ;AAAA,IAC5E,cAAc,kBAAkB,EAAE;AAAA,MAChC,CAAC,UAAU,SAAS,MAAM,QAAQ,kBAAkB,aAAa;AAAA,IACnE;AAAA,IACA,eAAe,IAAI,MAAM,EAAE;AAAA,MACzB,CAAC,UAAU,SAAS,MAAM,QAAQ,kBAAkB,aAAa;AAAA,IACnE;AAAA,EACF,CAAC,EAAE;AAAA,IACD,CAAC,CAAC,SAAS,YAAY,MAAM,eAAe,gBAAgB;AAAA,MAC1D,uBAAuB,kBAAkB,SAAS;AAAA,MAClD,eAAe,kBAAkB;AAAA,MACjC,QAAQ,kBAAkB,SAAS;AAAA,MACnC,MAAM;AAAA,IACR,CAAC,EAAE;AAAA,MACD,CAAC,UAAU,SAAS,MAAM,QAAQ,kBAAkB,aAAa;AAAA,IACnE,EAAE;AAAA,MACA,CAAC,EAAE,UAAU,MAAM,6BAA6B;AAAA,QAC9C;AAAA,QACA;AAAA,QACA;AAAA,QACA,UAAU,aAAa,QAAQ,aAAa;AAAA,QAC5C,WAAW,aAAa,OAAO,aAAa;AAAA,MAC9C,CAAC;AAAA,IACH,EAAE;AAAA,MACA,MAAM,sBAAsB;AAAA,QAC1B,kBAAkB;AAAA,MACpB;AAAA,IACF,EAAE,IAAI,CAAC,gBAAgB,YAAY,cAAc;AAAA,EACnD;AACA,QAAM,4BAA4B,CAAC,iBAAiB,UAAU,yBAAyB,OAAO,KAAK,OAAO,KAAK,CAAC,EAAE;AAAA,IAChH,CAAC,EAAE,sBAAsB,GAAG,MAAM,iBAAiB;AAAA,MACjD;AAAA,MACA,OAAO,KAAK,iBAAiB,KAAK;AAAA,MAClC;AAAA,IACF;AAAA,EACF,EAAE;AAAA,IACA,CAAC,cAAc,UAAU,UAAU,SAAS,OAAO,CAAC;AAAA,EACtD,EAAE,OAAO,CAAC,WAAW;AAAA,IACnB,QAAQ;AAAA,IACR,SAAS;AAAA,EACX,EAAE;AACF,SAAO;AAAA,IACL,IAAI;AAAA,IACJ,aAAa,MAAM,MAAM,UAAU,kBAAkB,SAAS;AAAA,IAC9D,MAAM;AAAA,IACN,YAAY,MAAM;AAAA,IAClB;AAAA,IACA,SAAS,MAAM;AACb,oBAAc,YAAY;AAAA,IAC5B;AAAA,EACF;AACF;AAMA,IAAI,mBAAmB,CAAC,UAAU;AA5sFlC,MAAAD,KAAA;AA6sFE,QAAM,WAAW;AAAA,IACf,SAAS;AAAA,IACT,uBAAuB,MAAM;AAAA,IAC7B,WAAW,MAAM;AAAA,IACjB,QAAQ,MAAM,YAAU,MAAAA,MAAA,MAAM,UAAU,kBAAkB,eAAlC,gBAAAA,IAA8C,aAA9C,mBAAwD,WAAU;AAAA,EAC5F;AACA,QAAM,uBAAuB,MAAM,UAAU,wBAAwB;AACrE,QAAO,UAAU,QAAQ;AACzB,QAAM,UAAS,oCAAO,WAAP,mBAAe,aAAa,EAAE,MAAM,YAAY;AAC/D,QAAM,sBAAsB,MAAM,UAAU;AAC5C,QAAM,4BAA4B,OAAO,sBAAsB;AAC/D,QAAM,qBAAqB,MAAM,sBAAsB;AACvD,mCAAQ,MAAM,EAAE,SAAS;AACzB,QAAM,0BAA0B,CAAC,OAAO,gBAAgB,qBAAqB,OAAO;AAAA,IAClF;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACA,QAAM,kBAAkB,CAAC,YAAY,YAAa;AAAA,IAChD,mBAAmB,OAAO;AAAA,IAC1B,CAAC,UAAU,SAAS,2BAA2B,QAAQ,eAAe,MAAM,OAAO;AAAA,EACrF;AACA,QAAM,eAAe,CAAC,kBAAkB;AACtC,UAAM,YAAY,oBAAoB;AAAA,MACpC,CAAC,eAAe,WAAW,YAAY;AAAA,IACzC;AACA,WAAO,YAAY,GAAK,SAAS,IAAI,IAAK;AAAA,MACxC,OAAO;AAAA,MACP;AAAA,MACA,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACA,QAAM,kBAAkB,CAAC;AAAA,IACvB,gBAAgB,WAAQ;AAAA,IACxB;AAAA,EACF,GAAG,cAAc,CAAC,MAAM,gBAAgB;AAAA,IACtC;AAAA,IACA;AAAA,IACA;AAAA,EACF,CAAC,EAAE;AAAA,IACD,CAAC,sBAAsB,aAAa,kBAAkB,aAAa,EAAE;AAAA,MACnE,CAAC,cAAc,UAAU,KAAK,mBAAmB,WAAW;AAAA,IAC9D,EAAE;AAAA,MACA,CAAC,aAAa,SAAS,kBAAkB,YAAY,SAAU,QAAQ,IAAI,QAAS,QAAQ;AAAA,IAC9F;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAiBA,IAAI,wBAAwB,CAAC,UAAU;AAjxFvC,MAAAA;AAkxFE,QAAM,YAAY;AAClB,QAAM,EAAE,UAAU,IAAI;AACtB,QAAM,EAAE,mBAAmB,eAAe,UAAU,IAAI;AACxD,QAAM,UAASA,MAAA,MAAM,WAAN,gBAAAA,IAAc,aAAa,EAAE,MAAM,wBAAwB;AAC1E,MAAI,YAAY;AAChB,QAAM,kBAAkB,cAAc,aAAa,iBAAiB;AACpE,QAAM,qBAAqB,MAAM,kBAAkB,WAAW,EAAE,OAAO,CAAC,UAAU;AAChF,qCAAQ,MAAM,EAAE,QAAQ,sBAAsB,MAAM;AACpD,WAAO,GAAK,CAAC,CAAC;AAAA,EAChB,CAAC,EAAE;AAAA,IACD,CAAC,iBAAiB,aAAa,WAAW,IAAI,IAAM,sBAAsB,IAAI,GAAK,YAAY;AAAA,EACjG;AACA,QAAM,wBAAwB,CAAC,kBAAkB,kBAAkB,QAAQ,aAAa,EAAE,OAAO,MAAM,SAAS,2BAA2B,aAAa,CAAC,EAAE;AAAA,IACzJ,CAAC,iBAAgB,2CAAa,YAAW,YAAY,GAAK,WAAW,IAAI,IAAM,SAAS,uBAAuB,aAAa,CAAC;AAAA,EAC/H;AACA,QAAM,wBAAwB,CAAC,kBAAkB,kBAAkB,QAAQ,aAAa,EAAE,OAAO,MAAM,SAAS,6BAA6B,aAAa,CAAC,EAAE,IAAI,CAAC,SAAS,6BAAM,cAAc;AAC/L,QAAM,oBAAoB,CAAC,kBAAkB,kBAAkB,MAAM,eAAe,EAAE,cAAc,KAAK,CAAC;AAC1G,QAAM,qBAAqB,CAAC,cAAc,OAAQ,QAAQ,UAAU,IAAI,sBAAsB,CAAC,EAAE;AAAA,IAC/F,MAAM,gBAAgB;AAAA,MACpB,UAAU;AAAA,QACR,CAAC,KAAK,aAAa;AACjB,cAAI,SAAS,aAAa,IAAI;AAC9B,iBAAO;AAAA,QACT;AAAA,QACA,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,EAAE,OAAO,CAAC,UAAU,iCAAQ,MAAM,EAAE,QAAQ,sBAAsB,MAAM,EAAE;AAC1E,QAAM,mBAAmB,CAAC,UAAU,MAAM;AAAA,IACxC,CAAC,KAAK,UAAU,EAAE,GAAG,KAAK,CAAC,KAAK,aAAa,GAAG,KAAK;AAAA,IACrD,CAAC;AAAA,EACH;AACA,QAAM,8BAA8B,CAAC,iBAAiB;AACpD,UAAM,MAAM,OAAO,KAAK,YAAY;AACpC,WAAO,gBAAgB,YAAY,EAAE;AAAA,MACnC,CAAC,cAAc,UAAU,OAAO,CAAC,aAAa,IAAI,SAAS,SAAS,aAAa,CAAC;AAAA,IACpF,EAAE;AAAA,MACA,CAAC,cAAc,UAAU,SAAS,GAAK,SAAS,IAAI,IAAM,yBAAyB;AAAA,IACrF,EAAE;AAAA,MACA,CAAC,cAAc,UAAU,IAAI,CAAC,cAAc;AAAA,QAC1C,2BAA2B;AAAA,QAC3B,aAAa,aAAa,SAAS,aAAa;AAAA,MAClD,EAAE;AAAA,IACJ;AAAA,EACF;AACA,QAAM,kBAAkB,CAAC,uBAAuB,YAAc,QAAQ,mBAAmB,IAAI,cAAc,CAAC,EAAE;AAAA,IAC5G,MAAM;AAAA,EACR;AACA,QAAM,UAAU,CAAC,iBAAiB;AAChC,WAAO,QAAS,MAAM;AAAA,EACxB;AACA,QAAM,iBAAiB,CAAC;AAAA,IACtB;AAAA,IACA;AAAA,EACF,MAAM;AACJ,UAAM,EAAE,kBAAkB,IAAI;AAC9B,WAAO,YAAc;AAAA,MACnB,UAAU;AAAA,QACR,CAAC,aAAa,SAAS,EAAE,mBAAmB,2BAA2B,YAAY,CAAC;AAAA,MACtF;AAAA,IACF;AAAA,EACF;AACA,QAAM,wBAAwB,CAAC,kBAAkB,YAAc;AAAA,IAC7D;AAAA,MACE,kBAAkB,UAAU;AAAA,QAC1B;AAAA,UACE,CAAC,UAAU,MAAM;AAAA,YACf,CAAC,SAAS,KAAK,kBAAkB,iBAAiB,KAAK,WAAW;AAAA,UACpE;AAAA,QACF;AAAA,QACA;AAAA,UACE,CAAC,UAAU,MAAM,KAAK,CAAC,SAAS,KAAK,kBAAkB,aAAa;AAAA,QACtE;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,QAAM,sBAAsB,YAAY;AACtC,UAAM,mBAAmB,EAAE,IAAI,gBAAgB,EAAE,QAAQ,2BAA2B,EAAE,QAAQ,eAAe,EAAE;AAAA,MAC7G,CAAC,uBAAuB,mBAAmB,IAAI,CAAC,SAAS,KAAK,WAAW;AAAA,IAC3E,EAAE,QAAQ,OAAO;AACjB,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,SAAS,CAAC;AAC7D,QAAI,UAAW,qBAAoB;AAAA,EACrC;AACA,sBAAoB;AACpB,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA,sBAAsB,MAAM,mBAAmB,EAAE;AAAA,MAC/C,CAAC,UAAU,MAAM,IAAI,CAAC,SAAS,KAAK,aAAa;AAAA,IACnD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,SAAS,MAAM;AACb,kBAAY;AAAA,IACd;AAAA,EACF;AACF;AAIA,IAAI,gBAAgB,CAAC,UAAU;AAC7B,MAAI,MAAM,kBAAkB,WAAW;AACrC,QAAI,MAAM,MAAM,kBAAkB,uBAAuB,MAAM,MAAM,kBAAkB,uBAAuB;AAC5G,aAAO,MAAM;AAAA,IACf;AAAA,EACF;AACF;AACA,IAAI,2BAA2B,CAAC,0BAA0B,kBAAkB,CAAC,eAAe;AAC1F,QAAM,6BAA6B,yBAAyB;AAC5D,MAAI,CAAC,2BAA4B,QAAO,QAAU,UAAU;AAC5D,SAAO,2BAA2B,UAAU,EAAE,IAAI,MAAM,UAAU,EAAE,OAAO,CAAC,UAAU,SAAS,MAAM,OAAO,eAAe,MAAM,OAAO,CAAC;AAC3I;AACA,IAAI,kCAAkC,CAAC;AAAA,EACrC;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM,YAAY,SAAS,EAAE;AAAA,EAC3B,CAAC,UAAU,YAAY,SAAS;AAAA,IAC9B,mBAAmB,YAAY,SAAS,iBAAiB,KAAK,IAAI,EAAE,SAAS,IAAI,MAAM;AAAA,IACvF;AAAA,IACA,YAAY;AAAA,MACV;AAAA,MACA,MAAM;AAAA,IACR;AAAA,EACF,CAAC,EAAE,OAAO,MAAM,YAAY,eAAe,CAAC;AAC9C,EAAE;AAAA,EACA,MAAM,IAAM,SAAS,0BAA0B,kBAAkB,aAAa,CAAC;AACjF;AACA,IAAI,uBAAuB,CAAC,iBAAiB,CAAC,EAAE,mBAAmB,2BAA2B,YAAY,MAAM;AAC9G,QAAM,eAAe,cAAc,yBAAyB;AAC5D,MAAI,CAAC,aAAc,QAAO,QAAU,MAAM;AAC1C,QAAM,EAAE,mBAAmB,0BAA0B,YAAY,IAAI;AACrE,QAAM,EAAE,cAAc,IAAI;AAC1B,SAAO,uCAAuC,YAAY,EAAE;AAAA,IAC1D,yBAAyB,0BAA0B,aAAa;AAAA,EAClE,EAAE;AAAA,IACA,CAAC,eAAe,aAAa,kBAAkB,sBAAsB,gCAAgC;AAAA,MACnG;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC,EAAE,IAAI,MAAM,UAAU,IAAI,QAAU,UAAU;AAAA,EACjD,EAAE;AAAA,IACA,CAAC,eAAe,kBAAkB,aAAa;AAAA,MAC7C,IAAI,kBAAkB;AAAA,MACtB,QAAQ;AAAA,MACR;AAAA,MACA,gBAAgB;AAAA,IAClB,CAAC,EAAE;AAAA,MACD,CAAC,UAAU,SAAS,MAAM,QAAQ,kBAAkB,aAAa;AAAA,IACnE;AAAA,EACF,EAAE,OAAO,MAAM,aAAa,0BAA0B,SAAS,CAAC,EAAE,OAAO,CAAC,UAAU;AAClF,iBAAa,0BAA0B,MAAM;AAC7C,WAAO,IAAM,KAAK;AAAA,EACpB,CAAC,EAAE,IAAI,MAAM,MAAM;AACrB;AAIA,IAAI,iBAAiB,CAAC,UAAU;AAC9B,MAAI,MAAM,kBAAkB,WAAW;AACrC,WAAO;AAAA,EACT;AACF;AACA,IAAI,yBAAyB,CAAC,iBAAiB,CAAC,EAAE,mBAAmB,0BAA0B,MAAM;AACnG,QAAM,iBAAiB,eAAe,yBAAyB;AAC/D,MAAI,CAAC,eAAgB,QAAO,QAAU,MAAM;AAC5C,QAAM,EAAE,cAAc,IAAI;AAC1B,QAAM,EAAE,kBAAkB,IAAI;AAC9B,SAAO,kBAAkB,aAAa;AAAA,IACpC,IAAI;AAAA,IACJ,QAAQ;AAAA,IACR,gBAAgB;AAAA,EAClB,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,iBAAa,0BAA0B,MAAM;AAC7C,WAAO,IAAM,SAAS,MAAM,QAAQ,aAAa,CAAC;AAAA,EACpD,CAAC,EAAE,OAAO,MAAM,aAAa,0BAA0B,MAAM,CAAC,EAAE,IAAI,MAAM,MAAM;AAClF;AAMA,IAAI,oBAAoB;AAAA,EACtB,SAAS;AAAA,EACT,kBAAkB;AAAA,EAClB,kBAAkB;AAAA,EAClB,SAAS;AAAA,EACT,UAAU;AACZ;AACA,IAAI,eAAe;AAAA,EACjB,SAAS;AAAA,EACT,UAAU;AAAA,EACV,UAAU;AAAA,EACV,SAAS;AAAA,EACT,UAAU;AAAA,EACV,WAAW;AAAA,EACX,UAAU;AAAA,EACV,SAAS;AACX;AACA,IAAI,qBAAqB;AAAA,EACvB,SAAS;AAAA,IACP,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,UAAU;AAAA,IACR,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,UAAU;AAAA,IACR,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,UAAU;AAAA,IACR,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,SAAS;AAAA,IACP,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,UAAU;AAAA,IACR,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AAAA,EACA,SAAS;AAAA,IACP,aAAa;AAAA,IACb,WAAW,aAAa;AAAA,IACxB,YAAY;AAAA,IACZ,cAAc;AAAA,EAChB;AACF;AACA,IAAI,yBAAyB,OAAO,OAAO,kBAAkB,EAAE;AAAA,EAC7D,CAAC,MAAMa,aAAY;AACjB,SAAKA,SAAQ,SAAS,IAAIA;AAC1B,WAAO;AAAA,EACT;AAAA,EACA,CAAC;AACH;AAGA,IAAI,2BAA2B,CAAC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,OAAO;AAAA,EACL,UAAU,kBAAkB,uBAAuB,SAAS,EAAE;AAAA,EAC9D,iBAAiB,mBAAmB;AAAA,EACpC,oBAAoB,sBAAsB;AAAA,EAC1C,kCAAkC;AACpC;AAGA,IAAI,cAAc;AAGlB,IAAI,oBAAoB,CAAC;AAAA,EACvB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,MAAM;AACJ,QAAM,mBAAmB,CAAC,KAAK,SAAS;AAAA,IACtC,MAAM,GAAG,QAAQ,GAAG,GAAG,IAAI;AAAA,MACzB,QAAQ;AAAA,MACR,MAAM,KAAK,UAAU,IAAI;AAAA,MACzB,SAAS;AAAA,QACP,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,QACnB,sBAAsB;AAAA,QACtB,gBAAgB;AAAA,QAChB,mBAAmB;AAAA,QACnB,2BAA2B;AAAA,MAC7B;AAAA,IACF,CAAC;AAAA,EACH,EAAE,IAAI,CAAC,aAAa,SAAS,IAAI;AACjC,QAAM,uBAAuB,CAAC,0BAA0B,iBAAiB,uBAAuB;AAAA,IAC9F,aAAa;AAAA,EACf,CAAC;AACD,QAAM,qBAAqB,CAAC,kBAAkB,iBAAiB,iCAAiC;AAAA,IAC9F,gBAAgB;AAAA,EAClB,CAAC;AACD,QAAM,wBAAwB,CAAC,YAAY,iBAAiB,+BAA+B,EAAE,QAAQ,CAAC;AACtG,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAKA,IAAI,gBAAgB,CAAC,UAAU;AAvkG/B,MAAAb,KAAA;AAwkGE,QAAM,UAASA,MAAA,MAAM,WAAN,gBAAAA,IAAc,aAAa,EAAE,MAAM,gBAAgB;AAClE,QAAM,eAAa,oCAAO,cAAP,mBAAkB,sBAAqB,kBAAkB,MAAM,YAAY;AAC9F,QAAM,OAAO,CAAC,OAAO,SAAS,uBAAuB;AACnD,WAAO,YAAc;AAAA,MACnB;AAAA,QACE,mBAAmB,aAAa;AAAA,UAC9B,UAAW,CAAC,WAAW;AACrB,gBAAI,OAAO,MAAM;AACf,qBAAO;AAAA,gBACL;AAAA,kBACE,SAAS,gBAAgB,IAAI,QAAQ;AAAA,oBACnC,OAAO,OAAO;AAAA,oBACd,SAAS;AAAA,oBACT,MAAM;AAAA,kBACR,CAAC;AAAA,gBACH;AAAA,cACF;AACF,6CAAQ,MAAM,WAAW,KAAK,WAAW,OAAO,QAAQ,CAAC;AACzD,mBAAO,QAAQ,EAAE,OAAO,CAAC,aAAa;AACpC,kBAAI,SAAS,WAAW,iBAAiB;AACvC,iDAAQ,MAAM;AAAA,kBACZ,OAAO;AAAA,kBACP,SAAS;AAAA,gBACX;AACA,mCAAmB,QAAQ,KAAK;AAChC,uBAAO,GAAK,MAAM;AAAA,cACpB;AACA,+CAAQ,MAAM;AACd,qBAAO;AAAA,gBACL,SAAS,gBAAgB,IAAI,QAAQ;AAAA,kBACnC,OAAO;AAAA,kBACP,MAAM;AAAA,kBACN,SAAS;AAAA,gBACX,CAAC;AAAA,cACH;AAAA,YACF,CAAC;AAAA,UACH,CAAC;AAAA,UACD;AAAA,YACE,CAAC,WAAW,OAAO,KAAK,KAAK,CAAC,CAAC,OAAO,SAAS,OAAO,MAAM;AAAA,UAC9D;AAAA,UACA,MAAO;AAAA,QACT;AAAA,MACF;AAAA,MACA,CAAC,UAAU;AAAA,IACb,EAAE,QAAQ,CAAC,WAAW,MAAM;AAAA,EAC9B;AACA,QAAM,wBAAwB,CAAC,0BAA0B;AACvD,UAAM,qBAAqB,mBAAmB,MAAM,WAAW;AAC/D,WAAO;AAAA,MACL;AAAA,MACA,MAAM,WAAW,qBAAqB,qBAAqB,EAAE,IAAI,CAAC,EAAE,OAAO,MAAM;AAC/E,cAAM,kBAAkC,oBAAI,IAAI;AAAA,UAC9C;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AACD,YAAI,gBAAgB,IAAI,MAAM,EAAG,QAAO;AACxC,2BAAmB,QAAQ,KAAK;AAChC;AAAA,MACF,CAAC;AAAA,MACD;AAAA,IACF;AAAA,EACF;AACA,QAAM,sBAAsB,CAAC,eAAe,wBAAwB;AAClE,UAAM,qBAAqB,mBAAmB;AAAA,MAC5C,GAAG,MAAM;AAAA,MACT,cAAc;AAAA,MACd,SAAS,IAAI,KAAK,sBAAsB,GAAG;AAAA,IAC7C,CAAC;AACD,WAAO;AAAA,MACL,MAAM,mBAAmB;AAAA,MACzB,QAAQ;AAAA,QACN;AAAA,QACA,MAAM,WAAW,mBAAmB,aAAa,EAAE;AAAA,UACjD,CAAC,EAAE,kBAAkB,qCAAqC,MAAM;AAC9D,gBAAI,qBAAqB,oBAAoB;AAC3C,qBAAO;AAAA,gBACL,iBAAiB;AAAA,gBACjB,uBAAuB;AAAA,cACzB;AAAA,YACF;AACA,+BAAmB,QAAQ,KAAK;AAChC;AAAA,UACF;AAAA,QACF;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAe,MAAM;AAAA,EACvB;AACF;AAGA,IAAI,iBAAiB,CAAC,UAAU;AAC9B,MAAI,MAAM,kBAAkB,aAAa,MAAM,MAAM,kBAAkB,eAAe;AACpF,WAAO,MAAM;AAAA,EACf;AACF;AACA,IAAI,6BAA6B,CAAC,WAAW;AAC3C,QAAM,0BAA0B;AAAA,IAC9B,kBAAkB;AAAA,IAClB,kBAAkB;AAAA,EACpB;AACA,SAAO,wBAAwB,SAAS,MAAM;AAChD;AACA,IAAI,kCAAkC,CAAC,iBAAiB,CAAC,EAAE,mBAAmB,0BAA0B,MAAM;AAC5G,QAAM,sBAAsB,eAAe,yBAAyB;AACpE,MAAI,CAAC,oBAAqB,QAAO,QAAU,MAAM;AACjD,QAAM,EAAE,eAAe,mBAAmB,0BAA0B,IAAI;AACxE,QAAM,EAAE,cAAc,IAAI;AAC1B,QAAM;AAAA,IACJ,MAAM,EAAE,sBAAsB;AAAA,EAChC,IAAI;AACJ,SAAO,kBAAkB,QAAQ,aAAa,EAAE,OAAO,MAAM,SAAS,oCAAoC,aAAa,CAAC,EAAE;AAAA,IACxH,MAAG;AA/rGP,UAAAA;AA+rGU,cAAAA,MAAA,kBAAkB,mBAAmB,aAAa,MAAlD,gBAAAA;AAAA,QACJ;AAAA;AAAA;AAAA,EAEJ,EAAE,QAAQ,MAAM,cAAc,sBAAsB,qBAAqB,CAAC,EAAE,QAAQ,CAAC,WAAW;AAC9F,UAAM,sBAAsB,2BAA2B,MAAM;AAC7D,UAAM,oBAAoB,sBAAsB,SAAS;AACzD,WAAO,kBAAkB,aAAa;AAAA,MACpC,IAAI;AAAA,MACJ,QAAQ;AAAA,MACR;AAAA,MACA,UAAU,EAAE,mBAAmB,OAAO;AAAA,MACtC,gBAAgB;AAAA,IAClB,CAAC,EAAE,OAAO,CAAC,UAAU,IAAM,SAAS,MAAM,QAAQ,aAAa,CAAC,CAAC,EAAE,QAAQ,MAAM;AAC/E,gCAA0B,iBAAiB;AAC3C,aAAO,QAAU,MAAM;AAAA,IACzB,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,gCAA0B,MAAM;AAChC,aAAO,IAAM,KAAK;AAAA,IACpB,CAAC;AAAA,EACH,CAAC,EAAE,IAAI,MAAM,MAAM;AACrB;AAIA,IAAI,iBAAiB,CAAC,UAAU;AAC9B,MAAI,MAAM,kBAAkB,aAAa,MAAM,MAAM,kBAAkB,4BAA4B;AACjG,WAAO,MAAM,MAAM;AAAA,EACrB;AACF;AACA,IAAI,mCAAmC,CAAC,iBAAiB,CAAC,EAAE,mBAAmB,0BAA0B,MAAM;AAC7G,QAAM,WAAW,eAAe,yBAAyB;AACzD,MAAI,CAAC,SAAU,QAAO,QAAU,MAAM;AACtC,QAAM,EAAE,0BAA0B,qBAAqB,cAAc,IAAI;AACzE,QAAM,EAAE,cAAc,IAAI;AAC1B,QAAM,EAAE,kBAAkB,IAAI;AAC9B,SAAO,kBAAkB,aAAa;AAAA,IACpC,IAAI;AAAA,IACJ,QAAQ,cAAc;AAAA,IACtB,uBAAuB;AAAA,IACvB,gBAAgB;AAAA,IAChB,UAAU;AAAA,MACR;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,iBAAa,0BAA0B,MAAM;AAC7C,WAAO,IAAM,SAAS,MAAM,QAAQ,aAAa,CAAC;AAAA,EACpD,CAAC,EAAE,OAAO,MAAM,aAAa,0BAA0B,SAAS,CAAC,EAAE,IAAI,MAAM,MAAM;AACrF;AAKA,IAAI,gCAAgC,CAAC,UAAU;AArvG/C,MAAAA;AAsvGE,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa;AAAA,IACzC,MAAM;AAAA,EACR;AACA,QAAM;AAAA,IACJ,WAAW,EAAE,mBAAmB,yBAAyB;AAAA,EAC3D,IAAI;AACJ,MAAI,YAAY;AAChB,QAAM,YAAY;AAClB,QAAM,gBAAgC,oBAAI,IAAI;AAC9C,QAAM,gBAAgB,IAAI,aAAc;AACxC,gBAAc;AAAA,IACZ,yBAAyB;AAAA,MACvB,IAAK,CAAC,OAAO;AAlwGnB,YAAAA;AAmwGQ,YAAI,cAAc,IAAI,EAAE,GAAG;AACzB,WAAAA,MAAA,cAAc,IAAI,EAAE,MAApB,gBAAAA,IAAuB;AACvB,wBAAc,OAAO,EAAE;AAAA,QACzB;AAAA,MACF,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,QAAM,8BAA8B,YAAY;AAC9C,UAAM,kBAAkB,iBAAiB,EAAE,QAAQ,CAAC,kBAAkB;AACpE,YAAM,gBAAgB,CAAC;AACvB,YAAM,cAAc,CAAC;AACrB,oBAAc,QAAQ,CAAC,SAAS;AA9wGtC,YAAAA;AA+wGQ,YAAI,QAAOA,MAAA,KAAK,aAAL,gBAAAA,IAAe,mBAAmB,IAAI,MAAM,KAAK,IAAI,GAAG;AACjE,wBAAc,KAAK,IAAI;AAAA,QACzB,OAAO;AACL,sBAAY,KAAK,IAAI;AAAA,QACvB;AAAA,MACF,CAAC;AACD,kBAAY,QAAQ,CAAC,SAAS;AArxGpC,YAAAA;AAsxGQ,YAAI,CAAC,cAAc,IAAI,KAAK,aAAa,GAAG;AAC1C,gBAAM,UAAU,MAAM,UAAU,cAAc;AAAA,YAC5C,KAAK;AAAA,aACLA,MAAA,KAAK,aAAL,gBAAAA,IAAe;AAAA,UACjB;AACA,wBAAc,IAAI,KAAK,eAAe,OAAO;AAC7C,kBAAQ,OAAO;AAAA,YACb,CAAC,WAAW,kBAAkB,aAAa;AAAA,cACzC,IAAI,KAAK;AAAA,cACT,QAAQ,cAAc;AAAA,cACtB,UAAU;AAAA,gBACR,6BAA6B,OAAO;AAAA,cACtC;AAAA,YACF,CAAC;AAAA,UACH,EAAE,OAAO,MAAM;AACb,0BAAc,OAAO,KAAK,aAAa;AAAA,UACzC,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,aAAO,YAAc;AAAA,QACnB,cAAc,IAAI,CAAC,SAAS;AA1yGpC,cAAAA;AA2yGU,cAAI,cAAc,IAAI,KAAK,aAAa,GAAG;AACzC,aAAAA,MAAA,cAAc,IAAI,KAAK,aAAa,MAApC,gBAAAA,IAAuC;AACvC,0BAAc,OAAO,KAAK,aAAa;AAAA,UACzC;AACA,iBAAO,kBAAkB,aAAa;AAAA,YACpC,IAAI,KAAK;AAAA,YACT,QAAQ,cAAc;AAAA,UACxB,CAAC;AAAA,QACH,CAAC;AAAA,MACH;AAAA,IACF,CAAC;AACD,UAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,SAAS,CAAC;AAC7D,QAAI,UAAW,6BAA4B;AAAA,EAC7C;AACA,8BAA4B;AAC5B,SAAO;AAAA,IACL,SAAS,MAAM;AACb,kBAAY;AACZ,oBAAc,YAAY;AAAA,IAC5B;AAAA,EACF;AACF;AAGA,IAAI,sBAAsB,CAAC,UAAU;AAn0GrC,MAAAA;AAo0GE,QAAM,UAASA,MAAA,MAAM,WAAN,gBAAAA,IAAc,aAAa,EAAE,MAAM,sBAAsB;AACxE,QAAM,WAAW,MAAM;AACvB,QAAM,YAAY,MAAM;AACxB,QAAM,uBAAuB,IAAI,QAAS;AAC1C,QAAM,2BAA2B,IAAI,QAAS;AAC9C,QAAM,iCAAiC,IAAI,QAAS;AACpD,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,wBAAwB,MAAM;AACpC,QAAM,cAAc,MAAM,UAAU;AACpC,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,yBAAyB,MAAM,UAAU,0BAA0B,uBAAuB,CAAC,CAAC;AAClG,QAAM,oBAAoB,MAAM,UAAU,qBAAqB,kBAAkB;AAAA,IAC/E;AAAA,IACA,WAAW;AAAA,MACT;AAAA,MACA,eAAe,cAAc,aAAa,UAAU;AAAA,IACtD;AAAA,EACF,CAAC;AACD,QAAM,gCAAgC,MAAM,UAAU,iCAAiC,8BAA8B;AAAA,IACnH;AAAA,IACA,WAAW;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACD,QAAM,4BAA4B,CAAC,WAAW;AAC5C,mCAA+B,KAAK,MAAM;AAAA,EAC5C;AACA,QAAM,wBAAwB,MAAM,UAAU,yBAAyB,sBAAsB;AAAA,IAC3F;AAAA,IACA,WAAW;AAAA,MACT;AAAA,MACA;AAAA,MACA,WAAW;AAAA,QACT,gCAAgC;AAAA,UAC9B;AAAA,UACA;AAAA,UACA;AAAA,QACF,CAAC;AAAA,QACD,iCAAiC;AAAA,UAC/B;AAAA,UACA;AAAA,QACF,CAAC;AAAA,QACD,uBAAuB;AAAA,UACrB;AAAA,UACA;AAAA,QACF,CAAC;AAAA,QACD,qBAAqB;AAAA,UACnB;AAAA,UACA,0BAA0B,MAAM;AAAA,UAChC;AAAA,UACA;AAAA,QACF,CAAC;AAAA,MACH;AAAA,IACF;AAAA,EACF,CAAC;AACD,QAAM,aAAa,MAAM,UAAU,cAAc;AAAA,IAC/C,yBAAyB;AAAA,MACvB;AAAA,MACA,WAAW;AAAA,QACT;AAAA,QACA;AAAA,QACA,mBAAmB,MAAM,UAAU;AAAA,MACrC;AAAA,IACF,CAAC;AAAA,IACD,wBAAwB;AAAA,MACtB;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,MACT,uBAAuB,MAAM;AAAA,MAC7B,WAAW;AAAA,QACT;AAAA,QACA;AAAA,QACA,mBAAmB,MAAM,UAAU;AAAA,MACrC;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,mBAAmB,MAAM,UAAU,oBAAoB,iBAAiB;AAAA,IAC5E;AAAA,IACA;AAAA,IACA,QAAQ,MAAM;AAAA,IACd;AAAA,IACA,oBAAoB,MAAM;AAAA,IAC1B,WAAW;AAAA,MACT;AAAA,MACA,mBAAmB,MAAM,UAAU;AAAA,IACrC;AAAA,EACF,CAAC;AACD,QAAM,uBAAuB,CAAC,OAAO;AACnC,UAAM,wBAAwB,IAAI,QAAS;AAC3C,WAAO;AAAA,MACL,eAAe,CAAC,UAAU;AACxB,8BAAsB,KAAK,KAAK;AAAA,MAClC;AAAA,MACA,gBAAgB,CAAC,EAAE,eAAe,gBAAgB,WAAW,MAAM;AACjE;AAAA,UACE,sBAAsB;AAAA,YACpB,OAAQ,CAAC,UAAU,UAAU,kBAAkB;AAAA,YAC/C,IAAK,MAAM,WAAW,CAAC;AAAA,YACvB,IAAK,CAAC,YAAY;AAChB,kBAAI,CAAC,eAAe,yBAAyB,EAAE;AAAA,gBAC7C,QAAQ,MAAM;AAAA,cAChB;AACE,kCAAkB,MAAM,IAAI,EAAE,YAAY,MAAM,CAAC;AAAA,YACrD,CAAC;AAAA,UACH;AAAA,QACF;AACA;AAAA,UACE,qBAAqB;AAAA,YACnB,OAAQ,CAAC,kBAAkB,kBAAkB,EAAE;AAAA,YAC/C;AAAA,cACE,MAAM,kBAAkB,OAAO,EAAE,EAAE,QAAQ,MAAM,eAAe,CAAC;AAAA,YACnE;AAAA,UACF;AAAA,QACF;AACA;AAAA,UACE,yBAAyB;AAAA,YACvB,OAAQ,CAAC,kBAAkB,kBAAkB,EAAE;AAAA,YAC/C;AAAA,cACE,MAAM,kBAAkB,aAAa;AAAA,gBACnC;AAAA,gBACA,QAAQ;AAAA,cACV,CAAC,EAAE,QAAQ,MAAM,eAAe,CAAC;AAAA,YACnC;AAAA,UACF;AAAA,QACF;AAAA,MACF;AAAA,IACF;AAAA,EACF;AACA,MAAI,uBAAuB,MAAM,QAAQ,QAAQ,EAAE;AACnD,MAAI;AACJ,MAAI;AACJ,QAAM,oBAAoB,CAAC,qBAAkB;AAz8G/C,QAAAA,KAAA;AAy8GkD,aAAAA,MAAA,iBAAiB,aAAjB,gBAAAA,IAA2B,gBAAa,sBAAiB,YAAjB,mBAA0B,cAAa,iBAAiB;AAAA;AAChJ,QAAM,eAAe,CAAC,qBAAqB;AACzC,QAAI,CAAC,kBAAkB,gBAAgB,EAAG,QAAO,QAAU,MAAM;AACjE,WAAO,YAAc;AAAA,MACnB,qBAAqB;AAAA,MACrB,MAAM,SAAS,2BAA2B,IAAI,8BAA8B;AAAA,IAC9E,EAAE;AAAA,MACA,CAAC,cAAc,sBAAsB,SAAS,IAAI,GAAK,SAAS,IAAI,IAAM,SAAS,4BAA4B,IAAI,sBAAsB,CAAC;AAAA,IAC5I;AAAA,EACF;AACA,QAAM,iCAAiC,CAAC,OAAO;AAC7C,8BAA0B,CAAC,WAAW,GAAG,MAAM;AAAA,EACjD;AACA,QAAM,4BAA4B,CAAC,OAAO;AACxC,yBAAqB,CAAC,eAAe,YAAc,YAAY,GAAG,UAAU,GAAG,OAAO;AAAA,MACpF,OAAO;AAAA,MACP,SAAS;AAAA,IACX,EAAE;AAAA,EACJ;AACA,QAAM,8BAA8B,CAAC,sBAAsB;AACzD,8BAA0B,SAAS;AACnC,WAAO,YAAc,QAAQ;AAAA,MAC3B,iBAAiB;AAAA,QACf;AAAA,QACA,qBAAqB,kBAAkB,aAAa;AAAA,MACtD;AAAA,MACA,sBAAsB;AAAA,QACpB,kBAAkB;AAAA,MACpB;AAAA,IACF,CAAC,EAAE,IAAI,CAAC,CAAC,GAAG,QAAQ,MAAM,QAAQ;AAAA,EACpC;AACA,QAAM,qBAAqB,IAAI,UAAU,YAAY;AAAA,IACnD,kBAAkB,uBAAuB,mBAAmB,GAAG,KAAK;AAAA,IACpE,WAAW;AAAA,IACX,SAAS;AAAA,EACX,CAAC;AACD,QAAM,kBAAkB,CAAC,sBAAsB,4BAA4B,iBAAiB,EAAE,QAAQ,CAAC,aAAa;AAClH,qCAAQ,MAAM,EAAE,QAAQ,mCAAmC,SAAS;AACpE,WAAO,GAAK,SAAS,UAAU;AAAA,EACjC,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,qCAAQ,MAAM,EAAE,QAAQ,iCAAiC,MAAM;AAC/D,WAAO;AAAA,EACT,CAAC;AACD,QAAM,cAAc,MAAM,YAAY,SAAS,EAAE,OAAO,MAAM,SAAS,wBAAwB,EAAE,CAAC;AAClG,QAAM,gBAAgB,CAAC,MAAM,mBAAmB,kBAAkB,WAAW,kBAAkB;AAAA,IAC7F;AAAA,MACE;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,IACA;AAAA,EACF,EAAE;AAAA,IACA,CAAC,EAAE,QAAQ,MAAM;AAAA,MACf;AAAA,MACA,kBAAkB;AAAA,MAClB;AAAA,IACF;AAAA,EACF;AACA,QAAM,8BAA8B,CAAC,UAAU;AAngHjD,QAAAA;AAogHI,UAAM,oBAAoB,iBAAiB,wBAAwB;AAAA,MACjE,eAAe;AAAA,MACf,SAAS,MAAM,cAAc;AAAA,IAC/B,CAAC;AACD,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,OACAA,MAAA,MAAM,4BAAN,gBAAAA,IAAA;AAAA,IACF,EAAE,QAAQ,MAAM,4BAA4B,iBAAiB,CAAC,EAAE;AAAA,MAC9D,CAAC,iBAAiB;AAAA,QAChB,GAAG,YAAY;AAAA,MACjB;AAAA,IACF;AAAA,EACF;AACA,QAAM,cAAc,CAAC;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,EACF,MAAM,YAAc,QAAQ;AAAA,IAC1B,aAAa,gBAAgB;AAAA,IAC7B,YAAY;AAAA,EACd,CAAC,EAAE;AAAA,IACD,CAAC,CAAC,WAAW,KAAK,MAAM,gBAAgB;AAAA,MACtC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,YAAY,MAAM;AAAA,IACpB,CAAC,EAAE,OAAO,MAAM,SAAS,kCAAkC,EAAE,CAAC,EAAE,aAAa,CAAC,sBAAsB;AAClG,YAAM,oBAAoB,iBAAiB,wBAAwB,iBAAiB;AACpF,UAAI,mCAAmC,mBAAmB,KAAK,KAAK;AAClE,eAAO,QAAU,MAAM,UAAU;AACnC,YAAM,iBAAiB,CAAC,MAAM,WAAW,WAAW,kBAAkB,kBAAkB;AACxF,YAAM,4BAA4B,kBAAkB,kBAAkB,uBAAuB,CAAC,CAAC,kBAAkB;AACjH,YAAM,cAAc,iBAAiB,iBAAiB,4BAA4B,iBAAiB;AACnG,aAAO,cAAc,aAAa,mBAAmB,OAAO,EAAE;AAAA,QAC5D,MAAM,gBAAgB,iBAAiB;AAAA,MACzC;AAAA,IACF,CAAC;AAAA,EACH;AACA,QAAM,sBAAsB,IAAI,UAAU;AACxC,2BAAuB,SAAS,GAAG,KAAK;AACxC,WAAO;AAAA,MACL,aAAa,MAAM,YAAY;AAAA,QAC7B,kBAAkB,uBAAuB,SAAS;AAAA,QAClD,WAAW;AAAA,QACX,SAAS;AAAA,MACX,CAAC;AAAA,IACH;AAAA,EACF;AACA,QAAM,uBAAuB,MAAM,YAAY,SAAS,EAAE,OAAO,CAAC,UAAU;AAC1E,qCAAQ,MAAM;AACd,WAAO;AAAA,MACL,OAAO;AAAA,MACP,SAAS;AAAA,MACT,SAAS;AAAA,IACX;AAAA,EACF,CAAC,EAAE;AAAA,IACD,CAAC,UAAU,YAAY;AAAA,MACrB,kBAAkB;AAAA,QAChB,MAAM;AAAA,MACR;AAAA,MACA,WAAW;AAAA,MACX,SAAS;AAAA,IACX,CAAC;AAAA,EACH;AACA,QAAM,gBAAgB,IAAI,aAAc;AACxC,QAAM,kBAAkB,CAAC,UAAU;AACjC,UAAM,2BAA2B,MAAM;AACrC,YAAM,oBAAoB,iBAAiB,wBAAwB;AAAA,QACjE,eAAe;AAAA,QACf,MAAM;AAAA,UACJ,OAAO,MAAM;AAAA,UACb,qBAAqB,MAAM;AAAA,UAC3B,SAAS,MAAM;AAAA,UACf,SAAS,MAAM,WAAW;AAAA,QAC5B;AAAA,MACF,CAAC;AACD,aAAO,kBAAkB;AAAA,QACvB;AAAA,UACE,MAAM;AAAA,UACN;AAAA,UACA,kBAAkB;AAAA,QACpB;AAAA,QACA,MAAM;AAAA,MACR,EAAE;AAAA,QACA,MAAM,SAAS,0BAA0B,kBAAkB,aAAa;AAAA,MAC1E,EAAE,IAAI,MAAM,iBAAiB;AAAA,IAC/B;AACA,WAAO,yBAAyB,EAAE;AAAA,MAChC,CAAC,sBAAsB,4BAA4B,iBAAiB;AAAA,IACtE,EAAE,QAAQ,CAAC,EAAE,QAAQ,uBAAuB,UAAU,cAAc,MAAM;AACxE,YAAM,UAAU;AAAA,QACd;AAAA,QACA,QAAQ,SAAS;AAAA,MACnB;AACA,aAAO,WAAW,YAAY,GAAK,OAAO,IAAI,IAAM,SAAS,QAAQ,QAAQ,aAAa,CAAC;AAAA,IAC7F,CAAC;AAAA,EACH;AACA,QAAM,eAAe,MAAM,WAAW,KAAK,CAAC,cAAc,UAAU,YAAY,CAAC;AACjF,QAAM,qBAAqB,MAAM,kBAAkB,WAAW;AAC9D,QAAM,gBAAgB,CAAC,OAAO;AAC5B,yBAAqB,KAAK,EAAE;AAC5B,sBAAkB,OAAO,EAAE;AAC3B,mCAA+B,KAAK,MAAM;AAC1C,8BAA0B,MAAM;AAAA,EAClC;AACA,QAAM,oBAAoB,CAAC,OAAO;AAChC,6BAAyB,KAAK,EAAE;AAChC,sBAAkB,aAAa;AAAA,MAC7B;AAAA,MACA,QAAQ;AAAA,IACV,CAAC;AACD,mCAA+B,KAAK,MAAM;AAAA,EAC5C;AACA,QAAM,4BAA4B,CAAC,OAAO;AACxC,2BAAuB;AAAA,EACzB;AACA,QAAM,aAAa,MAAM;AACvB,sBAAkB,WAAW,EAAE,IAAI,CAAC,UAAU;AAC5C,YAAM,QAAQ,CAAC,SAAS;AACtB,YAAI,KAAK,WAAY,sBAAqB,KAAK,KAAK,aAAa;AAAA,MACnE,CAAC;AAAA,IACH,CAAC;AACD,gBAAY,MAAM;AAClB,sBAAkB,MAAM;AACxB,eAAW,QAAQ,CAAC,cAAc,uCAAW,YAAY;AAAA,EAC3D;AACA,QAAM,UAAU,MAAM;AAroHxB,QAAAA;AAsoHI,gBAAY,QAAQ;AACpB,sBAAkB,QAAQ;AAC1B,0BAAsB,QAAQ;AAC9B,kCAA8B,QAAQ;AACtC,KAAAA,MAAA,MAAM,UAAU,eAAhB,gBAAAA,IAA4B,QAAQ,CAAC,cAAc,UAAU,QAAQ;AACrE,kBAAc,YAAY;AAAA,EAC5B;AACA,SAAO;AAAA,IACL,aAAa,CAAC,WAAW,YAAY;AAAA,MACnC,WAAW,OAAO;AAAA,MAClB,SAAS,OAAO;AAAA,MAChB,kBAAkB,uBAAuB,SAAS;AAAA,IACpD,CAAC,EAAE,QAAQ,CAAC,aAAa;AACvB,UAAI,wBAAyB,yBAAwB,GAAK,QAAQ,CAAC;AACnE,aAAO,GAAK,QAAQ;AAAA,IACtB,CAAC,EAAE,OAAO,CAAC,UAAU;AACnB,UAAI,wBAAyB,yBAAwB,IAAM,KAAK,CAAC;AACjE,aAAO,IAAM,KAAK;AAAA,IACpB,CAAC;AAAA,IACD;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,0BAA0B,+BAA+B,aAAa;AAAA,IACtE,eAAe,kBAAkB;AAAA,IACjC;AAAA,IACA;AAAA,EACF;AACF;AAGA,IAAI,0BAA0B,MAAM;AAClC,MAAI,QAAQ;AAAA,IACV,eAAe;AAAA,IACf,SAAS;AAAA,IACT,iBAAiB;AAAA,EACnB;AACA,MAAI;AACJ,QAAM,qBAAqB,CAAC,aAAa;AACvC,2BAAuB;AACvB,WAAO;AAAA,EACT;AACA,QAAM,gBAAgB,CAAC,MAAM,UAAU;AACrC,UAAM,aAAa,SAAS,WAAW;AAAA,MACrC,eAAe;AAAA,MACf,sBAAsB;AAAA,IACxB,IAAI;AAAA,MACF,eAAe;AAAA,MACf,oBAAoB;AAAA,IACtB;AACA,WAAO;AAAA,EACT;AACA,QAAM,WAAW,IAAI,UAAU;AAC7B,UAAM,QAAQ;AACd,WAAO;AAAA,EACT;AACA,QAAM,UAAU,CAAC,aAAa;AAC5B,UAAM,UAAU;AAChB,WAAO;AAAA,EACT;AACA,QAAM,WAAW,CAAC,UAAU;AAC1B,UAAM,oBAAoB;AAC1B,WAAO,EAAE,cAAc;AAAA,EACzB;AACA,QAAM,gBAAgB,MAAM;AAC5B,QAAM,YAAY,CAAC,eAAe;AAChC,YAAQ,EAAE,GAAG,YAAY,eAAe,YAAY;AACpD,WAAO,EAAE,cAAc;AAAA,EACzB;AACA,QAAM,MAAM;AAAA,IACV;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,yBAAyB,MAAM;AAAA,EACjC;AACA,SAAO,EAAE,UAAU,UAAU;AAC/B;AAIA,IAAI,0BAA0B,MAAM;AAClC,SAAO;AAAA,IACL,SAAS;AAAA,IACT,YAAY;AAAA,IACZ,eAAe;AAAA,IACf,yBAAyB;AAAA,IACzB,gBAAgB;AAAA,IAChB,sBAAsB;AAAA,IACtB,cAAc;AAAA,IACd,WAAW,MAAM;AAAA,IACjB;AAAA,IACA,SAAS,MAAM;AAAA,IACf;AAAA,IACA,UAAU,MAAM;AAAA,IAChB;AAAA,IACA,cAAc,MAAM;AAAA,IACpB;AAAA,IACA,aAAa,MAAM;AAAA,IACnB;AAAA,IACA,mBAAmB,MAAM;AAAA,IACzB;AAAA,IACA,yBAAyB,MAAM;AAAA,IAC/B;AAAA,IACA,cAAc,MAAM;AAAA,IACpB;AAAA,IACA,sBAAsB,MAAM;AAAA,IAC5B;AAAA,IACA,iBAAiB,MAAM;AAAA,IACvB;AAAA,IACA,aAAa,MAAM;AAAA,IACnB;AAAA,IACA,gBAAgB,MAAM;AAAA,IACtB;AAAA,IACA,iBAAiB,MAAM;AAAA,IACvB;AAAA,IACA,aAAa,MAAM;AAAA,IACnB;AAAA,IACA,SAAS,MAAM;AAAA,IACf;AAAA,IACA,YAAY,MAAM;AAAA,IAClB;AAAA,EACF;AACF;AAGA,IAAI,sBAAsB,CAAC,UAAU;AA9wHrC,MAAAA;AA+wHE,MAAI,CAAC,MAAM,UAAU,kBAAkB,UAAU,GAAG;AAClD,WAAO,wBAAwB;AAAA,EACjC;AACA,SAAO,uCAA8B;AACrC,QAAM,UAASA,MAAA,+BAAO,WAAP,gBAAAA,IAAe,aAAa,EAAE,MAAM,sBAAsB;AACzE,QAAM,WAAW,MAAM,YAAY,sBAAsB;AAAA,IACvD,WAAW,EAAE,mBAAmB,MAAM,UAAU,kBAAkB;AAAA,EACpE,CAAC;AACD,QAAM,wBAAwB,MAAM;AACpC,QAAM,EAAE,SAAS,cAAc,iBAAiB,cAAc,IAAI,MAAM,YAAY;AAAA,IAClF,SAAS,uBAAuB,MAAM,SAAS,EAAE;AAAA,IACjD,iBAAiB;AAAA,IACjB,eAAe;AAAA,IACf,cAAc;AAAA,EAChB;AACA,QAAM,cAAc,MAAM,UAAU;AACpC,QAAM,gBAAgB,MAAM,UAAU;AACtC,QAAM,sBAAsB,MAAM,UAAU;AAC5C,QAAM,mBAAmB,CAAC,SAAS;AACjC,SAAK;AAAA,EACP;AACA,QAAM,YAAY,MAAM,aAAa;AACrC,QAAM,YAAY,oBAAoB,aAAa;AACnD,QAAM,0BAA0B,MAAM,SAAS,cAAc,sBAAsB;AACnF,QAAM,gBAAgB,IAAI,aAAc;AACxC,QAAM,yBAAyB,UAAU,MAAM,UAAU,kBAAkB,YAAY,uBAAuB;AAC9G,gBAAc;AAAA,IACZ,uBAAuB;AAAA,MACrB,IAAK,MAAM,wBAAwB,CAAC;AAAA,MACpC,OAAQ,CAAC,YAAY,CAAC,CAAC,OAAO;AAAA,MAC9B,UAAW,CAAC,yBAAyB;AACnC,yCAAQ,MAAM,EAAE,YAAY,yBAAyB;AACrD,cAAM,aAAa,UAAU,sBAAsB,WAAW,EAAE;AAAA,UAC9D,IAAK,MAAM;AACT,sBAAU,CAAC,UAAU,SAAS,UAAU,KAAK,KAAK,CAAC;AAAA,UACrD,CAAC;AAAA,QACH;AACA,cAAM,gBAAgB;AAAA,UACpB;AAAA,UACA;AAAA,QACF,EAAE,KAAK,IAAK,MAAM,SAAS,aAAa,KAAK,CAAC,CAAC;AAC/C,cAAM,eAAe,UAAU,sBAAsB,aAAa,EAAE;AAAA,UAClE,IAAK,CAAC,OAAO;AACX,qBAAS,YAAY,KAAK,GAAG,MAAM;AAAA,UACrC,CAAC;AAAA,QACH;AACA,cAAM,aAAa,UAAU,sBAAsB,WAAW,EAAE;AAAA,UAC9D,IAAK,MAAM;AACT,6CAAQ,MAAM,EAAE,YAAY,aAAa;AACzC,mBAAO;AAAA,UACT,CAAC;AAAA,QACH;AACA,cAAM,uBAAuB;AAAA,UAC3B;AAAA,UACA;AAAA,QACF,EAAE;AAAA,UACA,IAAK,CAAC,UAAU;AACd,kBAAM,KAAK,MAAM,OAAO;AACxB,6CAAQ,MAAM,EAAE,QAAQ,uBAAuB,GAAG;AAClD,qBAAS,oBAAoB,KAAK,EAAE;AAAA,UACtC,CAAC;AAAA,QACH;AACA,cAAM,2BAA2B;AAAA,UAC/B;AAAA,UACA;AAAA,QACF,EAAE;AAAA,UACA,IAAK,CAAC,UAAU;AACd,kBAAM,KAAK,MAAM,OAAO;AACxB,6CAAQ,MAAM;AAAA,cACZ,QAAQ;AAAA,cACR;AAAA,YACF;AACA,qBAAS,wBAAwB,KAAK,EAAE;AAAA,UAC1C,CAAC;AAAA,QACH;AACA,cAAM,0BAA0B;AAAA,UAC9B;AAAA,UACA;AAAA,QACF,EAAE;AAAA,UACA,IAAK,MAAM;AACT,6CAAQ,MAAM;AACd,qBAAS,uBAAuB,KAAK;AAAA,UACvC,CAAC;AAAA,QACH;AACA,cAAM,iBAAiB;AAAA,UACrB;AAAA,UACA;AAAA,QACF,EAAE,KAAK,IAAK,MAAM,SAAS,cAAc,KAAK,CAAC,CAAC;AAChD,cAAM,kBAAkB,SAAS,eAAe;AAAA,UAC9C,IAAK,CAAC,UAAU,qBAAqB,iBAAiB,KAAK;AAAA,QAC7D;AACA,cAAM,wBAAwB,SAAS,qBAAqB;AAAA,UAC1D,IAAK,CAAC,UAAU,qBAAqB,uBAAuB,KAAK;AAAA,QACnE;AACA,cAAM,UAAU,SAAS,OAAO;AAAA,UAC9B,IAAK,CAAC,UAAU,qBAAqB,SAAS,KAAK;AAAA,QACrD;AACA,cAAM,QAAQ,SAAS,KAAK;AAAA,UAC1B,IAAK,CAAC,UAAU,qBAAqB,OAAO,KAAK;AAAA,QACnD;AACA,cAAM,aAAa,SAAS,UAAU;AAAA,UACpC,IAAK,CAAC,UAAU,qBAAqB,YAAY,KAAK;AAAA,QACxD;AACA,cAAM,YAAY,SAAS,SAAS;AAAA,UAClC,IAAK,CAAC,UAAU,qBAAqB,WAAW,KAAK;AAAA,QACvD;AACA,cAAM,qBAAqB,SAAS,kBAAkB;AAAA,UACpD,IAAK,CAAC,UAAU,qBAAqB,oBAAoB,KAAK;AAAA,QAChE;AACA,cAAM,aAAa,SAAS,UAAU;AAAA,UACpC,IAAK,CAAC,UAAU,qBAAqB,YAAY,KAAK;AAAA,QACxD;AACA,cAAM,gBAAgB,SAAS,aAAa;AAAA,UAC1C,IAAK,CAAC,UAAU,qBAAqB,eAAe,KAAK;AAAA,QAC3D;AACA,cAAM,mBAAmB,SAAS,gBAAgB;AAAA,UAChD,IAAK,CAAC,UAAU;AACd,oBAAQ,qBAAqB,aAAa,mBAAmB,MAAM,IAAI,qBAAqB,gBAAgB,iBAAiB;AAAA,UAC/H,CAAC;AAAA,QACH;AACA,cAAM,YAAY,SAAS,SAAS;AAAA,UAClC,IAAK,CAAC,UAAU,qBAAqB,WAAW,KAAK;AAAA,QACvD;AACA,cAAM,eAAe,SAAS,YAAY;AAAA,UACxC,IAAK,CAAC,UAAU,qBAAqB,cAAc,KAAK;AAAA,QAC1D;AACA,cAAM,gBAAgB,SAAS,aAAa;AAAA,UAC1C,IAAK,CAAC,UAAU,qBAAqB,eAAe,KAAK;AAAA,QAC3D;AACA,cAAM,YAAY,SAAS,SAAS;AAAA,UAClC,IAAK,CAAC,UAAU,qBAAqB,WAAW,KAAK;AAAA,QACvD;AACA,cAAM,SAAS,SAAS,MAAM;AAAA,UAC5B,IAAK,CAAC,UAAU,qBAAqB,QAAQ,KAAK;AAAA,QACpD;AACA,cAAM,uBAAuB;AAAA,UAC3B;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,UACA;AAAA,QACF,EAAE,KAAK,IAAK,MAAM,KAAK,CAAC;AACxB,eAAO,MAAO,sBAAsB,UAAU,EAAE;AAAA,UAC9C,OAAQ,CAAC,kBAAkB,CAAC,CAAC,aAAa;AAAA,UAC1C,MAAO;AAAA,UACP,SAAS,MAAM;AACb,6CAAQ,MAAM,EAAE,YAAY,kCAAkC;AAAA,UAChE,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,KACX,aAAa,UAAU,gBAAgB,GAAI,IAAI,GAAG,KAAK,IAAK,CAAC,UAAU,SAAS,qBAAqB,KAAK,KAAK,CAAC,CAAC,EAAE,UAAU;AAAA,EAChI;AACA,gBAAc;AAAA,KACX,aAAa,UAAU,aAAa,GAAI,IAAI,GAAG,KAAK,IAAK,CAAC,UAAU,SAAS,eAAe,KAAK,KAAK,CAAC,CAAC,EAAE,UAAU;AAAA,EACvH;AACA,gBAAc;AAAA,IACZ,SAAS,YAAY;AAAA,MACnB,IAAK,CAAC,EAAE,MAAM,KAAK,MAAM;AACvB,YAAI,CAAC,WAAW,eAAe,WAAW,EAAE,SAAS,IAAI,GAAG;AAC1D,cAAI,CAAC,WAAW,CAAC,OAAQ;AACzB,gBAAM,MAAM,GAAG,OAAO,GAAG,SAAS,gBAAgB,kBAAkB,SAAS,cAAc,gBAAgB,YAAY,GAAG,IAAI;AAC9H,iBAAO,KAAK,GAAG;AAAA,QACjB,WAAW,SAAS;AAClB,iBAAO,KAAK,6BAA6B;AAAA,iBAClC,SAAS,aAAa;AAC7B,iBAAO,KAAK,kCAAkC;AAAA,QAChD,WAAW,SAAS,iBAAgB,uCAAW;AAC7C,oBAAU,WAAW;AAAA,MACzB,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,QAAM,mBAAmB;AAAA,IACvB,SAAS,SAAS,OAAO,aAAa;AAAA,IACtC,YAAY,SAAS,UAAU,aAAa;AAAA,IAC5C,eAAe,SAAS,aAAa,aAAa;AAAA,IAClD,gBAAgB,SAAS,cAAc,aAAa;AAAA,IACpD,yBAAyB,SAAS,uBAAuB,aAAa;AAAA,IACtE,sBAAsB,SAAS,oBAAoB,aAAa;AAAA,IAChE,0BAA0B,SAAS,wBAAwB,aAAa;AAAA,IACxE,cAAc,SAAS,YAAY,aAAa;AAAA,IAChD,UAAU,CAAC,UAAU,SAAS,MAAM,KAAK,KAAK;AAAA,IAC9C,SAAS,CAAC,UAAU,SAAS,KAAK,KAAK,KAAK;AAAA,IAC5C,cAAc,CAAC,UAAU,SAAS,UAAU,KAAK,KAAK;AAAA,IACtD,aAAa,CAAC,UAAU,SAAS,SAAS,KAAK,KAAK;AAAA,IACpD,mBAAmB,CAAC,UAAU,SAAS,eAAe,KAAK,KAAK;AAAA,IAChE,yBAAyB,CAAC,UAAU,SAAS,qBAAqB,KAAK,KAAK;AAAA,IAC5E,sBAAsB,CAAC,UAAU,SAAS,kBAAkB,KAAK,KAAK;AAAA,IACtE,cAAc,CAAC,UAAU,SAAS,UAAU,KAAK,KAAK;AAAA,IACtD,oBAAoB,CAAC,UAAU,SAAS,gBAAgB,KAAK,KAAK;AAAA,IAClE,iBAAiB,CAAC,UAAU,SAAS,aAAa,KAAK,KAAK;AAAA,IAC5D,aAAa,CAAC,cAAc,SAAS,SAAS,KAAK,SAAS;AAAA,IAC5D,gBAAgB,CAAC,iBAAiB,SAAS,YAAY,KAAK,YAAY;AAAA,IACxE,iBAAiB,CAAC,iBAAiB,SAAS,aAAa,KAAK,YAAY;AAAA,IAC1E,aAAa,CAAC,aAAa,SAAS,SAAS,KAAK,QAAQ;AAAA,IAC1D,YAAY,MAAM;AAChB,eAAS,UAAU,KAAK,KAAK;AAC7B,eAAS,OAAO,KAAK,SAAS;AAAA,IAChC;AAAA,IACA,SAAS,MAAM;AACb,oBAAc,YAAY;AAAA,IAC5B;AAAA,EACF;AACA,QAAM,oBAAoB,MAAM,YAAY,SAAS,EAAE,IAAI,CAAC,UAAU;AACpE,UAAM,EAAE,aAAa,cAAc,UAAU,WAAW,cAAc,UAAU,IAAI,mCAAmC,MAAM,UAAU;AACvI,qBAAiB,qBAAqB,MAAM,iBAAiB;AAC7D,qBAAiB,YAAY,SAAS;AACtC,qBAAiB,eAAe,YAAY;AAC5C,qBAAiB,gBAAgB,YAAY;AAC7C,qBAAiB,aAAa,SAAS;AAAA,EACzC,CAAC;AACD,gBAAc;AAAA,IACZ,YAAY,SAAS,KAAK,UAAW,MAAM,kBAAkB,CAAC,CAAC,EAAE,UAAU;AAAA,EAC7E;AACA,gBAAc;AAAA,IACZ,SAAS,oBAAoB;AAAA,MAC3B,IAAK,CAAC,UAAU;AACd,4BAAoB,cAAc,KAAK;AAAA,MACzC,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,IACZ,SAAS,wBAAwB;AAAA,MAC/B,IAAK,CAAC,UAAU;AACd,4BAAoB,kBAAkB,KAAK;AAAA,MAC7C,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,IACZ,oBAAoB,cAAc;AAAA,MAChC,IAAK,CAAC,UAAU;AACd,yBAAiB,gBAAgB,CAAC,GAAG,KAAK,EAAE,QAAQ,CAAC;AAAA,MACvD,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,IACZ,SAAS,cAAc;AAAA,MACrB,IAAK,MAAM;AACT,4BAAoB,mBAAmB,EAAE,IAAI,CAAC,oBAAoB;AAChE,cAAI,gBAAgB,SAAS,GAAG;AAC9B,qBAAS,UAAU,KAAK,UAAU;AAAA,UACpC;AAAA,QACF,CAAC;AAAA,MACH,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,IACZ,SAAS,UAAU;AAAA,MACjB;AAAA,QACE,MAAM,YAAY,MAAM,EAAE;AAAA,UACxB,MAAM,oBAAoB,YAAY;AAAA,YACpC,WAAW;AAAA,YACX,SAAS;AAAA,UACX,CAAC;AAAA,QACH,EAAE;AAAA,UACA,MAAM,MAAM,UAAU,kBAAkB,SAAS,KAAK,SAAS,gBAAgB,KAAK,KAAK;AAAA,QAC3F;AAAA,MACF;AAAA,IACF,EAAE,UAAU;AAAA,EACd;AACA,gBAAc;AAAA,IACZ,SAAS,uBAAuB,KAAK,UAAW,MAAM,oBAAoB,qBAAqB,CAAC,CAAC,EAAE,UAAU;AAAA,EAC/G;AACA,gBAAc;AAAA,IACZ,SAAS,aAAa;AAAA,MACpB,IAAK,MAAM;AACT,iBAAS,UAAU,KAAK,KAAK;AAC7B,iBAAS,OAAO,KAAK,SAAS;AAC9B,4BAAoB,WAAW;AAC/B,YAAI,MAAM,aAAc,OAAM,aAAa;AAAA,MAC7C,CAAC;AAAA,IACH,EAAE,UAAU;AAAA,EACd;AACA,QAAM,sBAAsB,MAAM,oBAAoB,mBAAmB,EAAE;AAAA,IACzE,CAAC,UAAU,SAAS,OAAO,KAAK,MAAM,SAAS,YAAY,SAAS;AAAA,EACtE;AACA,gBAAc;AAAA,IACZ,oBAAoB,yBAAyB;AAAA,MAC3C;AAAA,QACE,CAAC,cAAc;AAAA,UACb,SAAS,OAAO;AAAA,YACd,cAAc,YAAY,YAAY,cAAc,SAAS,UAAU;AAAA,UACzE;AAAA,QACF,EAAE;AAAA,UACA,MAAM,GAAG;AAAA,UACT,UAAU,MAAM,oBAAoB,CAAC;AAAA,QACvC;AAAA,MACF;AAAA,IACF,EAAE,UAAU;AAAA,EACd;AACA,sBAAoB;AACpB,MAAI,uBAAuB;AACzB,kBAAc,WAAW,sBAAsB,qBAAqB,EAAE;AAAA,MACpE,CAAC,YAAS;AAvkIhB,YAAAA,KAAA;AAukImB,4BAAAA,MAAA,mCAAS,MAAM,KAAK,CAAC,SAAS,KAAK,QAAQ,YAA3C,gBAAAA,IAAoD,UAApD,mBAA2D,UAA3D,mBAAkE;AAAA;AAAA,IACjF,EAAE,IAAI,CAAC,aAAa;AAClB,eAAS,SAAS,KAAK,YAAY,cAAc;AAAA,IACnD,CAAC;AAAA,EACH;AACA,SAAO;AACT;AAGA,IAAI,sBAAsB;AAAA,EACxB,SAAS;AAAA,EACT,SAAS;AAAA,EACT,SAAS;AAAA,EACT,OAAO;AACT;AAGA,IAAI,oBAAoB,MAAM;AAC5B,QAAM,WAAW,CAAC,cAAc;AAC9B,UAAM,KAAK,UAAU,YAAY;AACjC,WAAO,yQAAyQ;AAAA,MAC9Q;AAAA,IACF;AAAA,EACF;AACA,QAAM,eAAe,MAAM;AACzB,WAAO,OAAO,cAAc,cAAc,YAAY;AAAA,EACxD;AACA,QAAM,QAAQ,MAAG;AAlmInB,QAAAA,KAAA;AAkmIsB,kBAAO,OAAK,MAAAA,MAAA,yCAAY,aAAZ,gBAAAA,IAAsB,YAAtB,mBAA+B,eAAc,CAAC,CAAC,EAAE,SAAS;AAAA;AAC1F,SAAO;AAAA,IACL,IAAI,aAAa;AACf,aAAO;AAAA,IACT;AAAA,IACA,UAAU,CAAC,cAAc;AAvmI7B,UAAAA;AAwmIM,aAAO,SAAS,eAAaA,MAAA,aAAa,MAAb,gBAAAA,IAAgB,cAAa,EAAE;AAAA,IAC9D;AAAA,IACA;AAAA,IACA,WAAW,MAAM,CAAC,CAAC,OAAO,QAAQ,OAAO,QAAQ,EAAE,SAAS,WAAW;AAAA,EACzE;AACF;AAKA,IAAI,qBAAqB,CAAC,YAAY;AAAA,EACpC;AACF,MAAM;AACJ,QAAM,UAAU,UAAU,kBAAkB;AAC5C,QAAM,eAAe,MAAM,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC1D,QAAI;AACF,cAAQ,aAAa,QAAQ,UAAU,CAAC;AAAA,IAC1C,SAAS,OAAO;AACd,aAAO,KAAK;AAAA,IACd;AAAA,EACF,CAAC;AACD,QAAM,eAAe,CAAC,UAAU,IAAI,QAAQ,CAAC,SAAS,WAAW;AAC/D,QAAI;AACF,mBAAa,QAAQ,YAAY,KAAK;AACtC,cAAQ;AAAA,IACV,SAAS,OAAO;AACd,aAAO,KAAK;AAAA,IACd;AAAA,EACF,CAAC;AACD,QAAM,WAAW,MAAM,YAAc,YAAY,aAAa,GAAG,WAAW,EAAE;AAAA,IAC5E,CAAC,SAAS,OAAO,UAAU,IAAI,IAAI,GAAK,CAAC,CAAC;AAAA,EAC5C;AACA,QAAM,WAAW,MAAM,YAAc,YAAY,aAAa,GAAG,WAAW,EAAE;AAAA,IAC5E,CAAC,SAAS,OAAO,UAAU,IAAI,IAAI,GAAK,MAAM;AAAA,EAChD;AACA,QAAM,cAAc,CAAC,OAAO,YAAc,YAAY,aAAa,GAAG,WAAW,EAAE,QAAQ,CAAC,SAAS,OAAO,UAAU,IAAI,IAAI,GAAK,MAAM,CAAC,EAAE,IAAI,CAAC,UAAU,QAAQ,MAAM,EAAE,IAAI,MAAM;AACrL,QAAM,iBAAiB,CAAC,OAAO,SAAS,EAAE,QAAQ,CAAC,UAAU;AAC3D,UAAM,EAAE,CAAC,EAAE,GAAG,GAAG,GAAG,SAAS,IAAI;AACjC,WAAO,UAAU,QAAQ,EAAE,aAAa,CAAC,eAAe;AACtD,YAAM,SAAS,YAAc;AAAA,QAC3B,aAAa,UAAU;AAAA,QACvB;AAAA,MACF,EAAE,IAAI,MAAM;AACV,gBAAQ;AAAA,UACN,IAAI,aAAa,WAAW;AAAA,YAC1B,KAAK;AAAA,YACL,UAAU,KAAK,UAAU,KAAK;AAAA,YAC9B,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,CAAC;AAAA,EACH,CAAC;AACD,QAAM,YAAY,CAAC,IAAI,UAAU,YAAY,EAAE,EAAE,QAAQ,CAAC,SAAS;AACjE,WAAO,OAAO,SAAS,EAAE,CAAC,EAAE,GAAG,EAAE,GAAG,MAAM,GAAG,MAAM,EAAE,CAAC,IAAI,IAAM,IAAI,MAAM,gBAAgB,CAAC;AAAA,EAC7F,CAAC;AACD,QAAM,WAAW,CAAC,SAAS,SAAS,EAAE;AAAA,IACpC,CAAC,SAAS,UAAU,EAAE,GAAG,MAAM,GAAG,KAAK,CAAC,EAAE,aAAa,CAAC,eAAe;AACrE,YAAM,SAAS,YAAc;AAAA,QAC3B,aAAa,UAAU;AAAA,QACvB;AAAA,MACF,EAAE,IAAI,MAAM;AACV,gBAAQ;AAAA,UACN,IAAI,aAAa,WAAW;AAAA,YAC1B,KAAK;AAAA,YACL,UAAU,KAAK,UAAU,IAAI;AAAA,YAC7B,UAAU;AAAA,UACZ,CAAC;AAAA,QACH;AAAA,MACF,CAAC;AACD,aAAO;AAAA,IACT,CAAC;AAAA,EACH;AACA,QAAM,cAAc,MAAM,SAAS,EAAE,IAAI,OAAO,MAAM;AACtD,QAAM,WAAW,CAAC,aAAa,SAAS,EAAE;AAAA,IACxC,CAAC,aAAa,UAAU,EAAE,GAAG,YAAY,CAAC,GAAG,GAAG,SAAS,CAAC,EAAE;AAAA,MAC1D,CAAC,eAAe;AACd,cAAM,SAAS,YAAc;AAAA,UAC3B,aAAa,UAAU;AAAA,UACvB;AAAA,QACF,EAAE,IAAI,MAAM;AACV,kBAAQ;AAAA,YACN,IAAI,aAAa,WAAW;AAAA,cAC1B,KAAK;AAAA,cACL,UAAU,KAAK,UAAU,QAAQ;AAAA,cACjC,UAAU;AAAA,YACZ,CAAC;AAAA,UACH;AAAA,QACF,CAAC;AACD,eAAO;AAAA,MACT;AAAA,IACF;AAAA,EACF;AACA,QAAM,aAAa,CAAC,aAAa,SAAS,EAAE,OAAO,OAAO,EAAE,QAAQ,+BAA+B,EAAE,EAAE;AAAA,IACrG,CAAC,aAAa,WAAW,SAAS,EAAE,GAAG,UAAU,GAAG,SAAS,CAAC,EAAE,OAAO,OAAO;AAAA,MAC5E,QAAQ;AAAA,IACV,EAAE,IAAI,IAAM,EAAE,QAAQ,sBAAsB,CAAC;AAAA,EAC/C;AACA,QAAM,eAAe,CAAC,iBAAiB,mBAAmB,GAAG,UAAU,IAAI,YAAY,IAAI,EAAE,UAAU,CAAC;AACxG,QAAM,WAAW;AAAA,IACf,UAAW,UAAU,kBAAkB,YAAY,SAAS;AAAA,IAC5D,GAAI,EAAE,KAAK,YAAY,UAAU,MAAM,UAAU,KAAK,CAAC;AAAA,EACzD,EAAE;AAAA,IACA,OAAQ,CAAC,SAAS,KAAK,QAAQ,UAAU;AAAA,IACzC,SAAU,CAAC,UAAU;AACnB,YAAM,EAAE,KAAK,UAAU,SAAS,IAAI;AACpC,UAAI,CAAC,IAAK,QAAO,CAAC;AAClB,YAAM,CAAC,KAAK,mBAAmB,WAAWc,UAAS,IAAI,IAAI,MAAM,GAAG;AACpE,UAAI,QAAQ,SAAS,qBAAqB,WAAW;AACnD,cAAM,iBAAiB,WAAW,UAAU,QAAQ,IAAI,GAAK,MAAM;AACnE,cAAM,iBAAiB,WAAW,UAAU,QAAQ,IAAI,GAAK,MAAM;AACnE,eAAO;AAAA,UACL,OAAQ,QAAQ,CAAC,gBAAgB,cAAc,CAAC,EAAE;AAAA,YAChD,CAAC,CAAC,WAAW,SAAS,OAAO;AAAA,cAC3B;AAAA,cACA,WAAAA;AAAA,cACA,UAAU;AAAA,cACV,UAAU;AAAA,YACZ;AAAA,UACF;AAAA,QACF;AAAA,MACF;AACA,aAAO,CAAC;AAAA,IACV,CAAC;AAAA,IACD,OAAQ,CAAC,WAAW,OAAO,KAAK,CAAC;AAAA,IACjC,IAAK,CAAC,EAAE,MAAM,MAAM,KAAK;AAAA,EAC3B;AACA,QAAM,QAAQ,MAAM,YAAc;AAAA,IAChC,IAAI,QAAQ,CAAC,YAAY,QAAQ,aAAa,WAAW,UAAU,CAAC,CAAC;AAAA,IACrE;AAAA,EACF;AACA,SAAO;AAAA,IACL;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAGA,kBAAkB;AAClB,IAAI,mBAAmB,CAAC,YAAY;AAClC,QAAM,wBAAwB,QAAQ,yBAAyB,QAAQ;AACvE,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,WAAW;AAAA,EACb,IAAI,WAAW,CAAC;AAChB,QAAM,qBAAoB,uCAAW,sBAAqB,kBAAkB;AAC5E,QAAM,iBAAgB,uCAAW,kBAAiB,mBAAmB,OAAO,qBAAqB,IAAI,SAAS,IAAI;AAAA,IAChH,WAAW;AAAA,MACT;AAAA,IACF;AAAA,EACF,CAAC;AACD,QAAM,eAAc,uCAAW,gBAAe,YAAY;AAAA,IACxD;AAAA,IACA,WAAW;AAAA,MACT,eAAe,cAAc,aAAa,OAAO;AAAA,IACnD;AAAA,EACF,CAAC;AACD,QAAM,iBAAgB,uCAAW,kBAAiB,cAAc;AAAA,IAC9D;AAAA,IACA,cAAc,yBAAyB;AAAA,MACrC;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF,CAAC;AAAA,EACH,CAAC;AACD,QAAM,uBAAsB,uCAAW,wBAAuB,oBAAoB;AAAA,IAChF;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,oBAAoB,QAAQ;AAAA,IAC5B,WAAW;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACD,QAAM,uBAAsB,uCAAW,wBAAuB,oBAAoB;AAAA,IAChF;AAAA,IACA;AAAA,IACA,UAAU,QAAQ;AAAA,IAClB;AAAA,IACA;AAAA,IACA,WAAW;AAAA,MACT;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACF;AAAA,EACF,CAAC;AACD,SAAO;AAAA,IACL,WAAW;AAAA,MACT,gBAAgB,oBAAoB;AAAA,MACpC,aAAa,MAAM,oBAAoB,YAAY;AAAA,QACjD,WAAW;AAAA,QACX,SAAS;AAAA,MACX,CAAC;AAAA,MACD,2BAA2B,CAAC,OAAO,oBAAoB,0BAA0B,EAAE;AAAA,MACnF,oBAAoB,CAAC,OAAO;AAC1B,4BAAoB,0BAA0B,EAAE;AAAA,MAClD;AAAA,MACA,gCAAgC,oBAAoB;AAAA,MACpD,sBAAsB,MAAM,oBAAoB,qBAAqB;AAAA,MACrE,oBAAoB,oBAAoB;AAAA,MACxC,6BAA6B,oBAAoB;AAAA,MACjD,iBAAiB,CAAC,UAAU,oBAAoB,gBAAgB,KAAK;AAAA,MACrE,aAAa,YAAY;AAAA,MACzB,eAAe,YAAY;AAAA,IAC7B;AAAA,IACA,WAAW;AAAA,MACT,UAAU,oBAAoB;AAAA,MAC9B,SAAS,oBAAoB;AAAA,MAC7B,SAAS,oBAAoB;AAAA,IAC/B;AAAA,IACA,YAAY;AAAA,MACV,cAAc,cAAc;AAAA,IAC9B;AAAA,IACA,YAAY,MAAM;AAChB,0BAAoB,WAAW;AAC/B,0BAAoB,WAAW;AAC/B,UAAI,aAAc,cAAa;AAAA,IACjC;AAAA,IACA,SAAS,MAAM;AACb,kBAAY,QAAQ;AACpB,0BAAoB,QAAQ;AAC5B,0BAAoB,QAAQ;AAAA,IAC9B;AAAA,EACF;AACF;",
  "names": ["len", "i", "output", "len2", "buffer", "isLE", "Buffer", "from", "string", "fromArrayLike", "array", "isBuffer", "concat", "buffer", "utf8ToBytes", "inspect", "max", "i", "bytes", "byteLength", "first", "last", "min", "errors", "range", "toHex", "bytes", "v", "last", "blake2b", "output", "v", "last", "output", "buffer", "base64url", "require_base64url", "import_buffer", "errors", "err", "Subscription", "errors", "err", "_a", "empty", "timeout", "err", "_a", "err", "Subscriber", "err", "ConsumerObserver", "err", "SafeSubscriber", "err", "Observable", "observable", "_a", "err", "_a", "err", "OperatorSubscriber", "err", "_a", "ConnectableObservable", "err", "timestamp", "timestamp", "Subject", "err", "_a", "observable", "AnonymousSubject", "_a", "err", "BehaviorSubject", "_a", "ReplaySubject", "_a", "last", "AsyncSubject", "_a", "Action", "delay", "timeout", "AsyncAction", "delay", "_a", "AsapAction", "delay", "_a", "Scheduler", "delay", "AsyncScheduler", "AsapScheduler", "QueueAction", "delay", "QueueScheduler", "AnimationFrameAction", "delay", "_a", "AnimationFrameScheduler", "VirtualTimeScheduler", "_a", "VirtualAction", "delay", "_a", "array", "err", "process", "delay", "repeat", "delay", "err", "delay", "iterator", "_a", "err", "iterator", "NotificationKind", "Notification", "_a", "err", "_a", "config", "isArray", "expand", "buffer", "err", "_a", "add", "isArray", "i", "count", "_a", "refCount", "err", "windowTime", "refCount", "_a", "_a", "err", "crypto", "min", "bytes", "array", "crypto", "isLE", "_32n", "buffer", "take", "bytes", "bytes", "bytes", "min", "max", "object", "current", "map", "_0n", "_1n", "_0n", "number", "_1n", "Fp", "map", "Fp", "_1n", "isLE", "_0n", "f", "_1n", "bytes", "Fp", "_0n", "_1n", "window", "f", "wbits", "isLE", "_0n", "Fp", "Fn", "_0n", "_1n", "_2n", "_8n", "Fp", "Fn", "uvRatio", "min", "bytes", "max", "f", "p", "randomBytes", "adjustScalarBytes", "hash", "context", "eddsa", "count", "hash", "expand", "createHasher", "map", "_0n", "_1n", "_2n", "adjustScalarBytes", "_0n", "_1n", "_2n", "_3n", "_5n", "_8n", "bytes", "v3", "createHasher", "number", "mod", "import_buffer", "config", "__awaiter", "__values", "__await", "__asyncGenerator", "f", "__asyncValues", "v", "__awaiter", "f", "ok", "__asyncGenerator", "__await", "__asyncValues", "_a", "err", "fromPromise", "Result", "fromThrowable", "f", "ok", "config", "err", "import_buffer", "_a", "immer", "finalize", "isSet", "isArray", "current", "_a", "Immer", "config", "base", "Immer", "config2", "_a", "_a", "context", "config2", "config2", "config2", "schema", "config2", "config2", "_a", "config2", "config2", "config2", "_a", "schema", "config2", "config2", "config2", "schema", "config2", "schema", "schema", "config2", "schema", "pipe", "pipe2", "config2", "schema", "config2", "import_buffer", "parse", "bytes", "URL", "err", "bytes", "output", "bytes", "_a", "_a", "isFunction", "array", "hash", "output", "add", "first", "isError", "_a", "_a", "import_buffer", "import_buffer", "Buffer2", "number", "isBytes", "min", "createView", "rotr", "isLE", "utf8ToBytes", "toBytes", "Hash", "expand", "setBigUint64", "isLE2", "_32n", "Chi", "Maj", "HashMD", "buffer", "take", "SHA256_K", "SHA256_IV", "SHA256_W", "SHA256", "sha256", "Buffer3", "blake", "Buffer4", "pipe", "_a", "identity", "config", "isObject", "Buffer5", "add", "timeout", "interval", "Logger", "Buffer6", "Buffer7", "Buffer8", "base64url", "config2", "partition"]
}
